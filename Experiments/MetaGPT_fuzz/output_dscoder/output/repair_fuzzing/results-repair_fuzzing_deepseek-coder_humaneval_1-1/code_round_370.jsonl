{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "completions": ["from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a 2D list `lst` and an integer `x`, and returns a list of tuples\n    containing the coordinates of `x`. The coordinates are sorted first by row index in\n    ascending order and then by column index in descending order.\n    \n    Args:\n        lst (List[List[int]]): A 2D list of integers.\n        x (int): The integer to find in the 2D list.\n        \n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column of `x`.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row in the 2D list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, element in enumerate(row):\n            # If the element matches `x`, append the coordinates to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the list by row index in ascending order and then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list, x: int) -> list:\n    '''\n    Parameters:\n    lst (list): A nested list representing a matrix where each row may have a different number of columns.\n    x (int): The integer to find in the matrix.\n\n    Returns:\n    list: A list of tuples, each containing the row and column indices of the integer x.\n    '''\n    coordinates = []\n    \n    # Iterate through each row in lst\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for column_index, element in enumerate(row):\n            # If element equals x, append (row_index, column_index) to the list\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort the list by row index in ascending order, and by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples, each containing the row and column index of x.\n    \n    Args:\n        lst (List[List[int]]): A 2D list (matrix) of integers.\n        x (int): The integer to search for in the matrix.\n        \n    Returns:\n        List[Tuple[int, int]]: A list of tuples, where each tuple is a pair of indices (row, column) representing the location of x in the matrix.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through the matrix to find the coordinates of the integer x\n    for row_index, row in enumerate(lst):\n        for col_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the list of coordinates first by row index in ascending order\n    # and then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of a given integer `x` in a 2-dimensional list (matrix) and returns their coordinates sorted by rows in ascending order and columns in descending order.\n\n    Args:\n        lst (List[List[int]]): A 2-dimensional list representing a matrix.\n        x (int): The integer to search for in the matrix.\n\n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column indices of the integer `x` in the matrix.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through the matrix to find all occurrences of x\n    for row_index, row in enumerate(lst):\n        for col_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by row index in ascending order and by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a 2-dimensional data (nested list), find the specified integer x and return its coordinates.\n    The coordinates are returned as a list of tuples, where each tuple represents (row, column).\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    \n    Args:\n    lst (List[List[int]]): The 2-dimensional data structure.\n    x (int): The integer to find in the nested list.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates of the integer x.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through the nested list to find the integer x\n    for row_index, row in enumerate(lst):\n        for col_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    Given lst, a nested list, and x, an integer, this function returns a list of tuples\n    containing the coordinates (row, column) of the integer x in the nested list.\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n    \n    Parameters:\n    lst (List[List[int]]): A nested list representing a matrix-like structure.\n    x (int): The integer to search for in the nested list.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples, each containing the row and column indices of x.\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2-dimensional data (nested lists similar to a matrix), find the specified integer `x` and return a list of tuples\n    representing the coordinates (row, column) where `x` is found. The coordinates are sorted first by rows in ascending order\n    and then by columns in descending order.\n\n    Args:\n        lst (List[List[int]]): A 2-dimensional list representing the matrix.\n        x (int): The integer to find in the matrix.\n\n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column indices of `x`.\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst, x):\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    '''\n    Given a 2D list (matrix-like structure) and an integer x, find all occurrences of x and return their coordinates.\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n    '''\n    coordinates = []\n    \n    # Iterate through each row in lst\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element\n        for col_index, element in enumerate(row):\n            # If element equals x, append (row_index, col_index) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the list by row index in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # For rows with the same index, sort by column index in descending order\n    coordinates.sort(key=lambda coord: coord[1], reverse=True)\n    \n    return coordinates\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a 2D list (matrix) and an integer x, and returns a list of tuples\n    containing the coordinates of the integer x in the matrix. The coordinates are sorted\n    by rows in ascending order and columns in descending order within each row.\n    \n    Args:\n        lst (List[List[int]]): A 2D list (matrix) of integers.\n        x (int): The target integer to search for in the matrix.\n        \n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column indices\n        of the target integer x in the matrix.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and each element within the row\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort the coordinates first by row index in ascending order, and then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n"], "plans": ["requirement analysis:\nThe requirement involves finding the coordinates of a specific integer in a 2D list (matrix) where each row may have a different number of columns. The output should be a list of tuples, each representing a coordinate (row, column), sorted first by rows in ascending order and then by columns in descending order. This requirement is crucial for applications where data needs to be accessed and manipulated efficiently.\nrequirement pool:\n- Implement a function to find the coordinates of a given integer in a 2D list.\n- Ensure the function can handle matrices with varying row lengths.\n- Return the coordinates sorted by rows in ascending order and columns in descending order.\n- Optimize the function for performance, especially for large matrices.\n- Include error handling for cases where the integer is not found in the matrix.\nTo implement the function `get_row` efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the 2D list, keeping track of the row and column indices where the target integer is found. We will use a list to store the coordinates and then sort this list based on the specified criteria. This approach ensures scalability and adaptability to different matrix sizes, optimizing performance for large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '2D list': a list of lists where each sublist represents a row in a matrix, and the elements within a sublist represent columns.\n    Explanation: In the requirement, we are dealing with a 2-dimensional data structure where each row can have a different number of columns. The goal is to find all occurrences of a given integer `x` and return their coordinates.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find coordinates where the integer `x` appears.\n    'less than': not applicable in this context as we are not comparing quantities but rather finding specific occurrences.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not comparing sizes but rather finding specific occurrences.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Provide detailed logic to implement the code\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    - The integer 1 is found at (0, 0) in the first row.\n    - The integer 1 is found at (1, 4) in the second row.\n    - The integer 1 is found at (1, 0) in the second row.\n    - The integer 1 is found at (2, 5) in the third row.\n    - The integer 1 is found at (2, 0) in the third row.\n    The coordinates are sorted initially by rows in ascending order and then by columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already handles the case where the list is empty or contains empty sublists.\n\n# [code logic]\n    Here's a detailed logic to implement the function `get_row`:\n\n    1. Initialize an empty list `coordinates` to store the coordinates of the integer `x`.\n    2. Iterate through the 2D list `lst` using a nested loop where the outer loop iterates through the rows and the inner loop iterates through the columns.\n    3. For each element in the 2D list, check if it is equal to `x`.\n    4. If it is, append the current row and column indices as a tuple to the `coordinates` list.\n    5. After collecting all coordinates, sort the list first by the row index in ascending order and then by the column index in descending order.\n    6. Return the sorted list of coordinates.\n", "requirement analysis:\nThe requirement is to find the coordinates of a specific integer in a nested list (matrix) where each row may have a different number of columns. The coordinates should be returned as a list of tuples, sorted first by rows in ascending order and then by columns in descending order. This requirement involves handling nested lists, which can be a challenge for performance and readability.\nrequirement pool:\n- Implement a function to find the coordinates of a specific integer in a nested list\n- Ensure the function can handle matrices with varying numbers of columns\n- Optimize the function for performance, especially for large matrices\n- Implement error handling for non-integer inputs\n- Provide documentation and examples for user guidance\nTo implement the function efficiently, we will utilize Python's built-in data structures and functionalities. The function will iterate through the nested list, keeping track of the row and column indices. For each occurrence of the target integer, a tuple of (row, column) will be stored. After finding all occurrences, the results will be sorted based on the specified criteria.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': a data structure that contains other lists, forming a matrix-like structure.\n    Explanation: In this requirement, the function `get_row` operates on a 2-dimensional list (nested lists) where each row can have a different number of columns. The goal is to find all occurrences of a given integer `x` and return their coordinates.\n\n# [phrase showing quantity relationship]\n    'more than': means that the integer `x` should be present more times than its own value.\n    Explanation: For example, if `x` is 2, then it should appear more than 2 times in the list.\n\n# [degree adverb] \n    'descending order': means that the order should be from the highest to the lowest value.\n    Explanation: In the context of columns, this means sorting the columns in a reverse order.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Iterate through the nested list to find all occurrences of `x`.\n    - Store the coordinates (row, column) for each occurrence.\n    - Sort the coordinates first by rows in ascending order, and then by columns in descending order.\n    - Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The integer 5 appears once in the list at position (1, 1). Since there are no other occurrences, the sorting does not affect the result.\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation: The integer 10 does not appear in the list, so the function returns an empty list.\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3]], 3) = [(0, 0), (0, 2), (3, 0), (3, 2)]\n    Explanation: The integer 3 appears twice, once in each of the first two rows and once in the last row. The coordinates are sorted by rows and then by columns.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle cases where the target integer is not found or the list is empty.\n", "requirement analysis:\nThe requirement is to find all occurrences of a specific integer x in a 2D list (matrix) and return their coordinates. The coordinates should be sorted first by the row index in ascending order, and within the same row, by the column index in descending order. The function should handle cases where the matrix is empty or where x is not found.\nrequirement pool:\n- Implement a function to find all occurrences of x and return their coordinates.\n- Ensure the function can handle matrices with varying row lengths.\n- Sort the coordinates as specified: first by row index in ascending order, then by column index in descending order.\n- Optimize the function for performance, especially for large matrices.\n- Include error handling for cases where x is not found in the matrix.\nTo implement the function efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the matrix, keeping track of the coordinates where the specified integer x is found. After collecting all coordinates, we will sort them first by row index in ascending order and then by column index in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': lists within lists, representing a matrix\n    'coordinates': pairs of indices (row, column) that locate an element in a 2D structure\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the matrix to find the coordinates of the integer x.\n    Store the coordinates in a list.\n    Sort the list of coordinates first by row index in ascending order, and then by column index in descending order.\n    Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The integer 5 is found in the second row and second column. The expected output is a list containing the coordinate (1, 1).\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation: The integer 10 is not found in the matrix. The expected output is an empty list.\n    get_row([[1, 2, 3], [1, 2, 3], [1, 2, 3]], 2) = [(0, 1), (1, 1), (2, 1)]\n    Explanation: The integer 2 is found in the first, second, and third rows and second column. The expected output is a list containing the coordinates (0, 1), (1, 1), and (2, 1).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle cases where the matrix is empty or the integer is not found.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer x in a 2-dimensional list (matrix) and return their coordinates. The coordinates should be sorted first by rows in ascending order and then by columns in descending order. This requires a function that can iterate through the list, identify the positions of x, and then sort these positions according to the specified criteria.\nrequirement pool:\n- Implement a function to find and return coordinates of x in the matrix\n- Ensure coordinates are sorted by rows in ascending order\n- Ensure columns within the same row are sorted in descending order\nTo implement the function `get_row` that finds all occurrences of a given integer `x` in a 2-dimensional list (matrix) and returns their coordinates sorted by rows in ascending order and columns in descending order, we will use Python's built-in capabilities and the `numpy` library for efficient matrix operations. The function will iterate through the matrix, identify the positions of `x`, and then sort these positions according to the specified criteria.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '2-dimensional list'\n    In the requirement, it refers to a list of lists where each sublist can have a different number of elements, representing a matrix.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find all occurrences of the integer `x` in the matrix.\n\n# [degree adverb] \n    'descending order': Indicates that we need to sort the columns within each row in descending order.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5, 6]], 2) = [(0, 1)]\n    Explanation: The integer 2 is found in the first row, second column. The coordinates are sorted by rows in ascending order and columns in descending order.\n    get_row([[1, 2, 3], [2, 2, 2], [4, 5, 6]], 2) = [(1, 2), (1, 1), (0, 1)]\n    Explanation: The integer 2 is found in the second row, second and third columns, and first row, second column. The coordinates are sorted accordingly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where the integer `x` is not found by returning an empty list.\n", "requirement analysis:\nThe requirement is to create a function that can find specific integers in a 2-dimensional list (matrix) and return their coordinates. The function should sort the coordinates by rows in ascending order and by columns in descending order. This requirement is crucial for users who need to locate specific elements in large matrices for analysis or manipulation.\nrequirement pool:\n- The main code should efficiently search for the integer x in the given nested list.\n- The function should return a list of tuples, each representing the coordinates of the integer x.\n- The coordinates should be sorted by rows in ascending order and by columns in descending order.\n- The function should handle matrices with varying numbers of columns in each row.\nTo implement the function efficiently, we will utilize Python's built-in data structures and libraries. The function will iterate through the nested list to find the specified integer, and then store its coordinates. After finding all occurrences, we will sort the coordinates first by rows in ascending order and then by columns in descending order.\nPlease read and understand the following inteperation before coding\n It seems like your last prompt was cut off. However, I'll proceed with the general guidelines you've provided to analyze the given coding plan and requirement.\n\n## Prompt 3 Analysis:\n\n[requirement]\n```python\ndef get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order. Examples:\n        get_row([\n          \n```\n\n[plan]\n```python\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Identify the presence of integer x in the nested list\",\n      \"Store the coordinates of integer x\",\n      \"Sort the coordinates by rows in ascending order and then by columns in descending order\"\n    ],\n    \"steps\": [\n      \"Initialize an empty list to store the coordinates\",\n      \"Iterate through the nested list to find the integer x\",\n      \"For each occurrence, store the row and column index in the coordinates list\",\n      \"Sort the coordinates list first by rows in ascending order and then by columns in descending order\"\n    ]\n  }\n}\n```\n\n### Analysis:\n\n# [core concept]\n    \"2-dimensional data\": This refers to data organized in a matrix-like structure where each row can have a different number of columns.\n    \"coordinates\": In the context of this requirement, coordinates are represented as (row, column) pairs, where both the row and column indices start from 0.\n\n# [phrase showing quantity relationship]\n    No specific phrases showing quantity relationships were identified in the requirement.\n\n# [degree adverb]\n    No degree adverbs were identified in the requirement.\n\n# [code logic]\n    The plan outlines a logical approach to find the integer x in the nested list and store its coordinates. The sorting of coordinates by rows in ascending order and columns in descending order needs to be implemented efficiently.\n\n# [edge case]\n    Edge cases should be considered to ensure the function handles all possible scenarios correctly.\n\n    Edge case 1:\n    ```python\n    get_row([[1, 2], [3, 4]], 3)\n    ```\n    Expected output: `[(1, 0)]`\n    Explanation: The integer 3 is found in the second row (index 1) and the first column (index 0) of the matrix.\n\n    Edge case 2:\n    ```python\n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 7)\n    ```\n    Expected output: `[(2, 1)]`\n    Explanation: The integer 7 is found in the third row (index 2) and the second column (index 1) of the matrix.\n\n    Edge case 3:\n    ```python\n    get_row([[1, 2], [2, 3], [3, 2]], 2)\n    ```\n    Expected output: `[(0, 1), (1, 1), (2, 0)]`\n    Explanation: The integer 2 is found in the first row (index 0) and the second column (index 1), the second row (index 1) and the second column (index 1), and the third row (index 2) and the first column (index 0) of the matrix.\n\n# [extra code for edge case]\n    Based on the provided plan, no extra code is needed to handle the edge cases as the logic for finding and sorting coordinates seems sufficient.\n\nThis analysis provides a structured approach to understanding the requirement, the plan, and potential edge cases.\n", "requirement analysis:\nThe requirement is to create a function that can search for a specific integer within a nested list structure, similar to a matrix. The function should return coordinates of the integer, sorted by rows in ascending order and columns in descending order. This requirement is crucial for applications where data needs to be searched and located precisely within complex structures.\nrequirement pool:\n- Implement a function to search for an integer x in a nested list structure.\n- Return a list of tuples containing coordinates (row, column) of the integer x.\n- Ensure the function is efficient and can handle large datasets.\n- Implement sorting of coordinates by rows in ascending order and columns in descending order.\n- Design a user-friendly interface for easy interaction with the function.\nWe will implement the function using Python, leveraging the power of list comprehensions and built-in sorting functions to efficiently find and return the coordinates of the specified integer in a nested list structure. The function will ensure that the coordinates are sorted by rows in ascending order and columns in descending order.\nPlease read and understand the following inteperation before coding\n Based on the provided prompt and plan, let's analyze the requirement and plan to provide a detailed breakdown for the programmer.\n\n## Prompt 3:\n\n[requirement]\n```python\ndef get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order. Examples:\n        get_row([\n          \n```\n\n[plan]\n```python\nWe will implement the function using Python, leveraging the power of list comprehensions and built-in sorting functions to efficiently find and return the coordinates of the specified integer in a nested list structure. The function will ensure that the coordinates are sorted by rows in ascending order and columns in descending order.\n```\n\n## Analysis and Plan Interpretation:\n\n1. **Core Concept**:\n   - The core concept is to find and return the coordinates of a specific integer `x` in a nested list structure.\n   - The coordinates should be sorted by rows in ascending order and within each row, by columns in descending order.\n\n2. **Phrase Showing Quantity Relationship**:\n   - There are no specific phrases showing quantity relationships in the requirement.\n\n3. **Degree Adverb**:\n   - The degree adverb \"initially\" suggests that the sorting should be done first by rows and then by columns.\n\n4. **Code Logic**:\n   - We need to iterate through the nested list to find the coordinates of `x`.\n   - Collect the coordinates in a list of tuples.\n   - Sort the list of tuples first by the row index in ascending order.\n   - Within each row, sort the column indices in descending order.\n\n5. **Edge Case**:\n   - **Edge Case 1**: What if `x` is not found in the list?\n     - Expected Output: The function should return an empty list `[]` since no coordinates are found.\n   - **Edge Case 2**: What if the list contains multiple occurrences of `x` in different rows?\n     - Expected Output: The function should return all coordinates found, sorted as specified.\n   - **Edge Case 3**: What if the list is empty?\n     - Expected Output: The function should return an empty list `[]` since there are no coordinates to find.\n\n6. **Extra Code for Edge Case**:\n   - For Edge Case 1 and 3, the original logic can handle these cases without additional code since the function will naturally return an empty list if `x` is not found or if the list is empty.\n   - For Edge Case 2, the original logic will collect all coordinates and sort them as required.\n\n## Detailed Plan:\n\n# [core concept]\n    'coordinates': finding and returning the coordinates of a specific integer in a nested list structure, sorted by rows in ascending order and columns in descending order.\n    Explanation: The function needs to locate all occurrences of `x` in the nested list and return their coordinates. The coordinates are then sorted based on the specified criteria.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'initially': sorting should be done first by rows and then by columns.\n\n# [code logic]\n    - Iterate through the nested list to find the coordinates of `x`.\n    - Collect the coordinates in a list of tuples.\n    - Sort the list of tuples by row index in ascending order.\n    - Within each row, sort the column indices in descending order.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n    get_row([[2, 3], [1, 4]], 4) = [(1, 1)]\n    Explanation: The integer 4 is found in the second row, second column. The coordinates are sorted as specified.\n    get_row([[2, 3], [1, 4]], 5) = []\n    Explanation: The integer 5 is not found in the list, so no coordinates are returned.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will naturally return an empty list if `x` is not found or if the list is empty.\n", "requirement analysis:\nThe requirement is to create a function that can find specific integers in a 2-dimensional list (matrix) and return their coordinates. The coordinates should be sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the function is both efficient and user-friendly, providing a clear and organized output.\nrequirement pool:\n- Implement a function to find and return coordinates of a given integer in a matrix\n- Ensure the function sorts the coordinates by rows in ascending order and columns in descending order\n- Optimize the function for performance, especially for large matrices\n- Develop a user-friendly interface for easy interaction with the function\n- Design a visually appealing and organized output for the coordinates\nTo implement the function efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the matrix to find the specified integer, and then it will store and sort the coordinates as required. We will use list comprehensions for clarity and efficiency.\nPlease read and understand the following inteperation before coding\n Based on the provided format and the requirements, here is the analysis for the third prompt:\n\n## Prompt 3:\n[requirement]\n```python\ndef get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order. Examples:\n        get_row([\n          \n\n[plan]\nTo implement the function efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the matrix to find the specified integer, and then it will store and sort the coordinates as required. We will use list comprehensions for clarity and efficiency.\n```\n\n## Answer 3:\n\n# [core concept]\n    '2-dimensional data': means data structured in rows and columns, where each row can have a different number of columns.\n    'nested lists': lists within lists, representing rows within a matrix.\n    'coordinates': a pair of values (row, column) that uniquely identify a position in the matrix.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb]\n    No specific degree adverb.\n\n# [code logic]\n    The function will:\n    1. Iterate through each row of the matrix.\n    2. Within each row, iterate through each element to find the target integer `x`.\n    3. Store the coordinates (row, column) of each occurrence of `x`.\n    4. Sort the coordinates first by rows in ascending order.\n    5. Within each row, sort the coordinates by columns in descending order.\n    6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation:\n    The target integer `x` is 5, which is found in the second row (index 1) and second column (index 1). The coordinates are (1, 1).\n\n# [extra code for edge case]\n    No extra code is needed for this edge case as the logic provided covers the basic functionality. However, for robustness, we could add error handling for cases where the matrix is empty or `x` is not found.\n\n```python\ndef get_row(lst, x):\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n```\n", "requirement analysis:\nThe primary requirement is to create a function that can search through a nested list structure similar to a matrix, where each row may contain a different number of columns. The function should return a list of tuples representing the coordinates of the specified integer, sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement the function to search for a specific integer in a nested list structure.\n- Ensure the function returns a list of tuples with coordinates sorted by rows and columns.\n- Develop a user-friendly interface for easy data access.\n- Optimize the function for performance and scalability.\n- Design a visually appealing interface for better user experience.\nTo implement the function `get_row` that searches for a specific integer in a nested list structure, we will use Python's built-in capabilities and the `numpy` library for efficient matrix operations. The function will iterate through the nested list, find the coordinates of the specified integer, and return them sorted by rows in ascending order and columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list containing other lists as its elements.\n    'matrix': a specific type of nested list where each sublist has the same length.\n    'coordinate': a pair of indices (row, column) that uniquely identifies a position in a nested list or matrix.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    get_row([[1, 2], [3, 4]], 2) = [(0, 1)]\n    explanation: The integer 2 is found in the first row, second column. Since there are no other occurrences, the result is a single tuple representing its position.\n    get_row([[1, 2, 3], [4, 5]], 5) = [(1, 1)]\n    explanation: The integer 5 is found in the second row, second column. There are no other occurrences, so the result is a single tuple representing its position.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The function can directly return the coordinate once the integer is found, ensuring it is sorted as per the requirement.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through the nested list using a nested loop to access each element and its position.\n3. If the current element matches the target integer `x`, append its coordinates (row, column) to the list.\n4. Sort the list of coordinates first by row index in ascending order, and then by column index in descending order.\n5. Return the sorted list of coordinates.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer x in a 2D list (matrix-like structure) and return their coordinates. The coordinates should be sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the user can efficiently locate all instances of a specific value within the data structure.\nrequirement pool:\n- Implement a function to find all occurrences of x in the 2D list.\n- Ensure the coordinates are sorted by rows in ascending order and columns in descending order.\n- Develop a user-friendly interface for easy data search.\n- Optimize the algorithm for performance and scalability.\nTo implement the function `get_row` efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the 2D list, check for the presence of the target integer, and store the coordinates. After collecting all coordinates, we will sort them first by rows in ascending order and then by columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '2D list': a nested list structure where each sublist represents a row and elements within a sublist represent columns.\n    'coordinate': a pair (x, y) where x is the row index and y is the column index, used to locate a specific element in a 2D list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Iterate through the 2D list to find the target integer.\n    - Store the coordinates of the target integer.\n    - Sort the coordinates first by rows in ascending order.\n    - Sort the coordinates of the row by columns in descending order.\n    - Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 5) = [(1, 1)]\n    Explanation:\n    - The target integer 5 is found in the second row (index 1) at the second column (index 1).\n    - The coordinates are sorted by rows in ascending order and then by columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided covers the basic functionality and sorting requirements.\n", "requirement analysis:\nThe requirement is to find the coordinates of a specific integer x in a 2-dimensional list (matrix) where each row may have a different number of columns. The coordinates should be returned as a list of tuples, sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the function is versatile and can handle matrices with varying row lengths efficiently.\nrequirement pool:\n- Implement a function to find the coordinates of a specific integer in a 2-dimensional list.\n- Ensure the function can handle matrices with varying row lengths.\n- Return the coordinates sorted by rows in ascending order and columns in descending order.\n- Optimize the function for performance, especially for large matrices.\n- Include error handling for cases where the integer is not found in the matrix.\nTo implement the function efficiently, we will utilize Python's built-in data structures and libraries. The function will iterate through the matrix, checking each element for the target integer. Upon finding a match, it will store the coordinates in a list of tuples. The coordinates will be sorted based on the specified criteria: rows in ascending order and columns in descending order within each row. This approach ensures that the function is both scalable and adaptable to different matrix sizes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': a data structure that contains other lists, allowing for a two-dimensional representation of data.\n    Explanation: In the requirement, the function `get_row` is designed to work with a 2D data structure, where each row can have a different number of columns. This is crucial for handling matrices with varying row lengths.\n\n# [phrase showing quantity relationship]\n    'as many times': indicates the frequency of an integer within the nested lists.\n    Explanation: The phrase \"appears at least as many times as the integer itself\" means that for each integer found, the count of its occurrences must be at least equal to its value. This is important for determining the return value of the function.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: The degree adverb \"largest\" implies that among all integers meeting the criteria, the function should return the largest one. This is significant for ensuring the correct output in cases where multiple integers satisfy the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The function should:\n    1. Iterate through each row and each element within the row to find the target integer.\n    2. Store the coordinates of the found integers.\n    3. Sort the coordinates first by row index in ascending order, and then by column index in descending order within each row.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    - The integer 1 is found at (0, 0), (1, 4), and (2, 5).\n    - The integer 1 is also found at (1, 0) and (2, 0).\n    - The coordinates are sorted by row index first, then by column index in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the scenario where the matrix is empty or contains empty rows.\n\n# [core concept]\n    'nested lists': a data structure that contains other lists, allowing for a two-dimensional representation of data.\n    Explanation: In the requirement, the function `get_row` is designed to work with a 2D data structure, where each row can have a different number of columns. This is crucial for handling matrices with varying row lengths.\n\n# [phrase showing quantity relationship]\n    'as many times': indicates the frequency of an integer within the nested lists.\n    Explanation: The phrase \"appears at least as many times as the integer itself\" means that for each integer found, the count of its occurrences must be at least equal to its value. This is important for determining the return value of the function.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: The degree adverb \"largest\" implies that among all integers meeting the criteria, the function should return the largest one. This is significant for ensuring the correct output in cases where multiple integers satisfy the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The function should:\n    1. Iterate through each row and each element within the row to find the target integer.\n    2. Store the coordinates of the found integers.\n    3. Sort the coordinates first by row index in ascending order, and then by column index in descending order within each row.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    - The integer 1 is found at (0, 0), (1, 4), and (2, 5).\n    - The integer 1 is also found at (1, 0) and (2, 0).\n    - The coordinates are sorted by row index first, then by column index in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the scenario where the matrix is empty or contains empty rows.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5172, 1.0], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 45, 87], "completion": "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a 2D list (matrix) and an integer x, and returns a list of tuples\n    containing the coordinates of the integer x in the matrix. The coordinates are sorted\n    by rows in ascending order and columns in descending order within each row.\n    \n    Args:\n        lst (List[List[int]]): A 2D list (matrix) of integers.\n        x (int): The target integer to search for in the matrix.\n        \n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column indices\n        of the target integer x in the matrix.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and each element within the row\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort the coordinates first by row index in ascending order, and then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "passed": true, "pass": true, "pass_num": 9, "round": 370, "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", " def get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n         ", " def get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, similar to a matrix where each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0, sorting coordinates initially by rows in ascending order and also sorting coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n         "], "mutate_method": "condense_two2one", "parent_index": 292}
