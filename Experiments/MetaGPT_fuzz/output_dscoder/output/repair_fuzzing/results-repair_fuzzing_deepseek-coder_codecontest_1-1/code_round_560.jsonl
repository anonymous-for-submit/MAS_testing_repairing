{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's describe k as the mathematical average of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array might have duplicate elements or where n is very close to 2. Ensure your solution efficiently handles arrays with large lengths.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's describe k as the mathematical average of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array might have duplicate elements or where n is very close to 2. Ensure your solution efficiently handles arrays with large lengths.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers. The average of these elements, denoted as k, is calculated by dividing the sum of the elements by the number of elements (i.e., sum divided by n).\n\nMonocarp wants to remove exactly two elements from the array a such that the average of the remaining (n - 2) elements is still equal to k.\n\nYour task is to find the number of pairs of positions [i, j] (where i < j) in the array a, where removing the elements at these positions will result in the average of the remaining elements being equal\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the average of these elements. The task is to find the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the average of the remaining (n - 2) elements equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if removing the elements at positions i and j maintains the mean\n            if (sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    # Use a set to store the indices of elements that can be removed\n    possible_deletions = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):  # Ensure i < j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                # Store the indices as a tuple (i, j)\n                possible_deletions.add((i, j))\n    \n    return len(possible_deletions)\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Create a dictionary to count the frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr, avg):\n    \"\"\"\n    This function finds all pairs of indices that, when removed, maintain the average of the array.\n    \n    Args:\n        arr (list): A list of integers representing the array.\n        avg (float): The average of the array.\n    \n    Returns:\n        list: A list of pairs of indices that, when removed, maintain the average of the array.\n    \"\"\"\n    n = len(arr)\n    pairs = []\n    \n    # Calculate the sum of the array\n    total_sum = sum(arr)\n    \n    # Iterate through all possible pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements when removing elements at indices i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            # Check if the remaining sum divided by (n - 2) equals the average\n            if remaining_sum / (n - 2) == avg:\n                pairs.append((i, j))\n    \n    return pairs\n\n# Read input from stdin\nn = int(input())\narr = list(map(int, input().split()))\navg = sum(arr) / n\n\n# Find and print the number of pairs\nresult = find_pairs(arr, avg)\nprint(len(result))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], avg: float) -> int:\n    n = len(arr)\n    sum_a = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = sum_a - arr[i] - arr[j]\n            if new_sum / (n - 2) == avg:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\navg = sum(arr) / n\n\n# Call the function and print the result\nresult = find_pairs(arr, avg)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\nfrom collections import defaultdict\n\ndef find_pairs(arr, avg):\n    \"\"\"\n    This function finds the number of pairs of positions [i, j] (where i < j) in the array such that if the elements on these positions are deleted, the average of the remaining elements is equal to the original average.\n    \n    Args:\n    arr (list): A list of integers representing the array.\n    avg (float): The average of the array.\n    \n    Returns:\n    int: The number of pairs of positions [i, j] such that the average of the remaining elements is equal to the original average.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    total_sum = sum(arr)\n    \n    # Create a hash map to store the counts of the differences\n    diff_count = defaultdict(int)\n    \n    for i in range(n):\n        # Calculate the difference between the current element and the average\n        diff = arr[i] - avg\n        # Increment the count of this difference in the hash map\n        diff_count[diff] += 1\n    \n    # Iterate through the hash map to find pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            # Calculate the average of the remaining elements\n            remaining_avg = remaining_sum / (n - 2)\n            # Check if the average of the remaining elements is equal to the original average\n            if remaining_avg == avg:\n                count += 1\n    \n    return count\n\n# Read input from stdin\nn = int(input())\narr = list(map(int, input().split()))\navg = sum(arr) / n\nresult = find_pairs(arr, avg)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_pairs(n, arr):\n    # Calculate the average of the array\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Use a more efficient approach to check the condition for each pair\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting the elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the average of the remaining elements is still equal to the original average\n            if remaining_sum / remaining_count == average:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    # Read the sequence of integers\n    arr = list(map(int, input().strip().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(n, arr):\n    original_average = sum(arr) / n\n    count = 0\n    sum_freq = {}\n    \n    # Precompute the sum frequency\n    total_sum = 0\n    for num in arr:\n        total_sum += num\n        if num not in sum_freq:\n            sum_freq[num] = 0\n        sum_freq[num] += 1\n    \n    # Iterate through all possible pairs [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the new average of the remaining elements is still equal to the original average\n            if remaining_sum / remaining_count == original_average:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], avg: float) -> int:\n    n = len(arr)\n    count = 0\n    total_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == avg:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of pairs\n    pairs_count = 0\n    \n    # Create a dictionary to count the frequency of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                # Check if the elements to be removed are the same\n                if arr[i] == arr[j]:\n                    # If the element appears at least 3 times, it's a valid pair\n                    if element_count[arr[i]] >= 3:\n                        pairs_count += 1\n                else:\n                    # If the elements are different, it's a valid pair\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean. The solution must be efficient to handle large arrays efficiently. Edge cases such as duplicate elements and arrays close to size 2 must also be considered.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs.\n- Handle edge cases where the array might have duplicate elements or where n is very close to 2.\n- Ensure the solution is accurate in calculating the number of pairs to delete.\n- Optimize the solution for large arrays to ensure it handles large inputs efficiently.\nTo efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements maintains the mean. We will use a brute-force method initially to ensure correctness, and then we can optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': Indicates that the number of times an element appears should be at least equal to the element's value.\n    Explanation: For example, if an element is 3, it should appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets the condition.\n    Explanation: We need to find the largest integer in the array that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with all elements equal.\n    Expected output: 0\n    Explanation: If all elements are the same, removing any two elements will change the mean, so there are no valid pairs.\n\n    Edge case 2: Array with very small values.\n    Expected output: 0\n    Explanation: If the array values are very small, the mean will be very close to zero, and removing any two elements will likely change the mean significantly.\n\n    Edge case 3: Array with duplicate elements.\n    Expected output: The number of pairs that can be removed to maintain the mean.\n    Explanation: If there are duplicates, we need to ensure that removing any two elements does not change the mean.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array might have all elements equal or where n is very close to 2.\n    Example code:\n    if n == 3:\n        return 0  # Special case for small arrays\n    if all(x == a[0] for x in a):\n        return n * (n - 1) // 2  # Special case for arrays with all elements equal\n\n    (other edge cases handling code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must be efficient and handle edge cases, including arrays with duplicate elements and small values of n.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs to delete.\n- The solution should handle edge cases where the array might have duplicate elements.\n- Ensure the solution is accurate in calculating the number of pairs to delete.\n- Implement a simple and clear algorithm for easy understanding and maintenance.\nTo efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to the original mean. We will use a simple and efficient algorithm to ensure that the solution handles large arrays and edge cases effectively.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of elements divided by the number of these elements\n    'pairs of positions': i < j\n\n    Explanation: The core concept here is to find pairs of indices [i, j] such that removing the elements at these indices results in the mean of the remaining elements being equal to the original mean of the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    n = 3, array = [1, 2, 3]\n    expected output: 0\n    Explanation: With only 3 elements, it's impossible to remove any two elements and still have the mean of the remaining elements equal to the original mean.\n\n    n = 4, array = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The original mean is (1+2+3+6)/4 = 3. Removing the elements at indices 1 and 2 (values 2 and 3) results in the remaining elements [1, 6] having a mean of (1+6)/2 = 3.5, which is not equal to 3. No other pairs result in the same mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n is very close to 2, as it's not possible to remove two elements from such a small array and still have a mean.\n        if n < 3:\n            return 0\n\n    (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must handle edge cases and large inputs efficiently. The output should be clear and concise, providing the number of such pairs.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] where deleting elements at these positions maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Add error handling for edge cases such as small arrays or arrays with duplicate elements.\n- Improve the user interface for displaying the results.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical average' (mean)\n    The mean of a set of numbers is the sum of the numbers divided by the count of the numbers. In this context, it refers to the average of all elements in the array.\n\n# [phrase showing quantity relationship]\n    'as many times'\n    This phrase indicates that the number of times a value appears in the array should be considered when determining if removing two elements maintains the mean.\n\n# [degree adverb] \n    'largest'\n    This adverb indicates that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs that result in a mean equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: Array with duplicate elements\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n\n    Edge case 2: Array with no element satisfying the condition\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n    Edge case 3: Array with very few elements\n    search([1, 2]) = 0\n    Explanation: With only two elements, there are no pairs to remove, so the result is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of elements that, when removed, maintain the same average. This involves a two-step process: first, calculate the average of the entire array, and then iterate through all possible pairs of elements to check if their removal maintains the average. The constraints are high, with up to 2 * 10^5 elements, so the solution must be efficient to handle such large inputs.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find all pairs of indices and check if removing them maintains the average.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the code is well-documented and easy to understand for users.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find all pairs of indices that, when removed, maintain the average of the array. We will calculate the average of the array once and then iterate through all possible pairs to check if their removal maintains the average. The solution will be optimized to handle up to 2 * 10^5 elements efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the operation of deleting elements from an array\n    'maintain the average': the condition that the average of the remaining elements is still equal to the original average\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove exactly 2 elements from the array\n\n# [degree adverb] \n    'largest': not applicable in this context\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Explanation: The original average is (1+2+3+4+5)/5 = 3. Removing any two elements will change the average. For example, removing 1 and 5 results in [2, 3, 4] with an average of (2+3+4)/3 = 3, which is equal to the original average.\n    Edge case 2: [10]\n    Explanation: Since there's only one element, removing any two elements is not possible.\n    Edge case 3: [7, 7, 7, 7]\n    Explanation: Any pair of elements can be removed since all elements are the same. For example, removing the first and last elements results in [7, 7] with an average of 7, which is equal to the original average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find pairs can be directly applied to these edge cases.\n\n# [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the operation of deleting elements from an array\n    'maintain the average': the condition that the average of the remaining elements is still equal to the original average\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove exactly 2 elements from the array\n\n# [degree adverb] \n    'largest': not applicable in this context\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Explanation: The original average is (1+2+3+4+5)/5 = 3. Removing any two elements will change the average. For example, removing 1 and 5 results in [2, 3, 4] with an average of (2+3+4)/3 = 3, which is equal to the original average.\n    Edge case 2: [10]\n    Explanation: Since there's only one element, removing any two elements is not possible.\n    Edge case 3: [7, 7, 7, 7]\n    Explanation: Any pair of elements can be removed since all elements are the same. For example, removing the first and last elements results in [7, 7] with an average of 7, which is equal to the original average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find pairs can be directly applied to these edge cases.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of indices that, when removed, result in the average of the remaining elements being the same. This involves a two-step process: first, calculate the average of the entire array, and then iterate through all possible pairs of indices to check if removing them results in the average remaining elements being equal to the original average.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find all pairs of indices.\n- Ensure the function checks if removing the elements at the given pairs results in the average of the remaining elements being equal to the original average.\n- Optimize the algorithm to handle large inputs efficiently.\n- Design a user-friendly interface for input and output.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair checking. We will calculate the sum of the array and the average, then iterate through all possible pairs of indices to check if removing them results in the average of the remaining elements being equal to the original average. The key challenge is to ensure the solution is scalable and can handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the process of deleting specific elements from the array\n    'pairwise combinations': the method of calculating all possible pairs of indices in the array\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of elements after removal should still be greater than 2\n    'at least as many times': implies that the average of the remaining elements should still be equal to the original average\n\n# [degree adverb] \n    'exactly': specifies that the removal should result in the exact original average being maintained\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Calculate the sum of the array elements.\n    - Compute the original average.\n    - Iterate through all possible pairs of indices (i, j) where i < j.\n    - For each pair, calculate the sum of the remaining elements after removal.\n    - Check if the new average of the remaining elements is equal to the original average.\n    - Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    explanation: Possible pairs to remove are [1, 2], [1, 3], [2, 3]. Removing any of these pairs will result in the average of the remaining elements being 3.\n    search([1, 1, 1, 1]) = 6\n    explanation: All pairs are valid since removing any two elements will result in the average of the remaining elements being 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to calculate the number of valid pairs is straightforward and does not require additional complexity for edge cases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array contains zeros or negative numbers, as the average calculation might need adjustments to avoid division by zero or negative results.\n    (code for handling the edge case)\n    if n == 3:\n        return 1  # Special case for small arrays\n    sum_a = sum(a)\n    avg = sum_a / n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            new_sum = sum_a - a[i] - a[j]\n            if new_sum / (n - 2) == avg:\n                count += 1\n    return count\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of indices that, when removed, result in the average of the remaining elements being the same. This involves a two-step process: 1) Calculate the average of the entire array. 2) Iterate through all possible pairs of indices and check if removing them results in the average of the remaining elements being equal to the calculated average.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to iterate through all pairs of indices and check the condition.\n- Ensure the solution is optimized to handle large inputs efficiently.\n- Implement error handling for invalid inputs.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and iteration. We will calculate the average of the array once and then iterate through all possible pairs of indices to check if removing them results in the average of the remaining elements being equal to the calculated average. The key challenge is to ensure that the solution is optimized to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'removal of elements': the process of deleting elements from an array\n    'pair of positions': two specific positions in an array\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs that, when removed, result in the average of the remaining elements being equal to the original average\n\n# [degree adverb] \n    'exactly': means that we need to find pairs that, when removed, result in the average of the remaining elements being exactly equal to the original average\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the average of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at positions i and j.\n    4. Check if the average of the remaining elements is equal to the original average.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    explanation: The original average is (1+2+3+4+5)/5 = 3. Removing the elements at positions 1 and 3 (2 and 4) results in the average of the remaining elements being 3. Similarly, removing the elements at positions 2 and 4 (3 and 5) also results in an average of 3.\n    search([1, 1, 1, 1]) = 6\n    explanation: The original average is (1+1+1+1)/4 = 1. Removing any pair of elements results in the average of the remaining elements being 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where all elements are the same.\n", "requirement analysis:\nThe task requires finding pairs of indices in an array such that deleting the elements at these positions keeps the average of the remaining elements unchanged. This involves calculating the average of the entire array and then checking pairs of elements to ensure their deletion does not alter the average. The challenge lies in efficiently handling large inputs and ensuring the solution is scalable.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to iterate through pairs of indices and check the condition.\n- Ensure the solution is optimized for large inputs and meets performance expectations.\n- Provide clear and accurate results for any input within the specified range.\n- Offer a user-friendly interface for easy interaction and understanding.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The approach involves calculating the average of the array and then iterating through pairs of indices to check if deleting the elements at these positions keeps the average of the remaining elements unchanged. We will use a simple and efficient algorithm to ensure scalability and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: The average (k) of an array is calculated by summing all the elements and dividing by the number of elements. We need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the average of the remaining (n - 2) elements equal to k.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the remaining elements divided by the number of remaining elements equals the original average.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not looking for the largest integer but rather pairs of indices that maintain the average.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the average (k) of the array.\n    2. Iterate through all pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after deleting the elements at positions i and j.\n    4. Check if the average of these remaining elements is still equal to k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7], [1, 2]) = 3\n    Explanation: The original average is (1+2+3+4+5+6+7)/7 = 4. If we delete elements at positions 1 and 2 (0-based index), the remaining elements are [1, 3, 4, 5, 6, 7], and their average is (1+3+4+5+6+7)/6 = 4.25, which is not equal to 4.\n    search([1, 1, 1, 1], [0, 1]) = 1\n    Explanation: The original average is (1+1+1+1)/4 = 1. If we delete elements at positions 0 and 1, the remaining elements are [1, 1], and their average is (1+1)/2 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe primary requirement is to find the number of pairs [i, j] where deleting the elements at these positions keeps the average of the remaining elements equal to the original average. This requires calculating the average of the entire array and then checking each pair to see if deleting them keeps the average unchanged. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find all pairs [i, j] where i < j.\n- Develop a check to verify if deleting the elements at positions i and j keeps the average unchanged.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output for each test case.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair-wise comparisons. We will calculate the average of the array once and then iterate through all possible pairs to check if deleting them keeps the average unchanged. The key challenge is to ensure the solution is optimized for large inputs, which can be achieved by avoiding redundant calculations and using efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that the average of the remaining elements after deleting the elements at these positions is still equal to the original average.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the remaining elements divided by the number of remaining elements is still equal to the original average.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs that maintain the average after deletion.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original average of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the new average of the remaining elements is still equal to the original average.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7], 4) = 3\n    Explanation: The original average is 4. The pairs that can be deleted to keep the average as 4 are [0, 1], [0, 2], and [1, 2].\n    search([1, 1, 1, 1], 1) = 6\n    Explanation: The original average is 1. All pairs can be deleted to keep the average as 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all test cases.\n", "requirement analysis:\nThe primary requirement is to find the number of pairs [i, j] such that deleting the elements at these positions keeps the average of the remaining elements equal to the original average. This requires calculating the average of the entire array and then checking each pair to see if their deletion maintains the average. The challenge lies in ensuring the solution is efficient enough to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to iterate through all pairs [i, j] and check if their deletion maintains the average.\n- Optimize the pair checking function to ensure it runs efficiently within the given constraints.\n- Ensure the solution is scalable and can handle large inputs efficiently.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The primary approach involves calculating the average of the array and then iterating through all possible pairs to check if their deletion maintains the average. We will use a nested loop to iterate through pairs and a simple check to verify the average condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that the average of the remaining elements after deleting the elements at these indices is still equal to the original average of the array.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the deletion of elements does not change the average.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs that maintain the average.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the average of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. Check if the average of the remaining elements after deleting the elements at indices i and j is still equal to the original average.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7], 4) = 3\n    Explanation: The original average is 4. The pairs that maintain this average after deletion are [1, 2], [1, 3], and [2, 3].\n    search([1, 1, 1, 1], 1) = 6\n    Explanation: The original average is 1. All pairs [i, j] where i < j will maintain the average after deletion. There are 6 such pairs: [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], and [3, 4].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean. The solution must be efficient and handle large arrays up to 2 * 10^5 elements. Edge cases such as duplicate elements and n very close to 2 must also be considered.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs to delete.\n- The solution should handle large arrays up to 2 * 10^5 elements.\n- The code should accurately calculate the number of pairs to delete to maintain the original mean.\n- The solution should handle edge cases where the array might have duplicate elements or where n is very close to 2.\n- The code should be optimized for performance to handle large inputs.\nTo efficiently solve this problem, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': Indicates that the number of times an element appears should be at least as much as the element itself.\n    Explanation: For example, if an element is 3, it should appear at least 3 times in the remaining array after removal of two elements.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that appears at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: Array with duplicate elements\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: In this case, the array has duplicate elements, and the function should return 3 as the largest integer that appears at least as many times as itself.\n\n    Edge case 2: Array with very close to two elements\n    search([5, 5]) = -1\n    Explanation: Since the array has only two elements, it's impossible to remove any to maintain the mean, so the function should return -1.\n\n    Edge case 3: Array with large length\n    search([1, 2, 3, ..., 100000]) = 50000\n    Explanation: This edge case represents an array with a large number of elements. The function should efficiently calculate the number of pairs that maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has duplicate elements or is very close to two elements.\n    For example, if the array length is 2, we can immediately return -1 since it's impossible to remove any elements to maintain the mean.\n    If the array has duplicate elements, we need to ensure that the function correctly identifies the largest integer that meets the condition.\n"], "scores": [], "pass_results": [false, false, true, true, false, false, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 560, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 456}
