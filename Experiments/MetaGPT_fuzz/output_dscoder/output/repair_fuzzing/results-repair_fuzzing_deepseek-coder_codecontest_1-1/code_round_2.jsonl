{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Assume that the maze efficiently updates and retrieves information for each query.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Assume that the maze efficiently updates and retrieves information for each query.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " \nChanek Jones has returned to assist his distant relative, Indiana Jones, in searching for a hidden treasure within a maze buried beneath a desert landscape filled with deceptive illusions.\n\nThe labyrinth's map is structured as a tree, composed of n rooms numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through these pathways.\n\nEach room i (where 1 \u2264 i \u2264 n) is characterized by an illusion rate, denoted as a_i. The energy required to travel from room x to room y is determined by the formula max(|a_x\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " Chanek Jones, assisting Indiana Jones, seeks a secret treasure in a maze beneath a desert filled with illusions. The maze, shaped as a tree with n rooms and n - 1 tunnels, has rooms with varying illusion rates. Queries can update the illusion rate of a room or determine the minimum energy required to travel between two rooms.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport networkx as nx\nimport numpy as np\nfrom typing import List, Tuple\n\n# Function to build a tree from the given edges\ndef build_tree(n: int, edges: List[Tuple[int, int]]) -> nx.Graph:\n    tree = nx.Graph()\n    tree.add_nodes_from(range(1, n + 1))\n    tree.add_edges_from(edges)\n    return tree\n\n# Function to update the illusion rate of a specific room\ndef update_illusion_rate(tree: nx.Graph, room: int, new_rate: int) -> None:\n    tree.nodes[room]['illusion_rate'] = new_rate\n\n# Function to calculate the minimum energy required to travel from one room to another\ndef calculate_energy(tree: nx.Graph, start: int, end: int) -> int:\n    # Use DFS to find the path with the minimum energy\n    def dfs(node, target, path, visited):\n        if node == target:\n            return path\n        visited.add(node)\n        min_energy = float('inf')\n        for neighbor in tree.neighbors(node):\n            if neighbor not in visited:\n                current_path = dfs(neighbor, target, path + [(node, neighbor)], visited)\n                if current_path:\n                    energy = max(abs(tree.nodes[node]['illusion_rate'] + tree.nodes[neighbor]['illusion_rate']),\n                                 abs(tree.nodes[node]['illusion_rate'] - tree.nodes[neighbor]['illusion_rate']))\n                    min_energy = min(min_energy, energy)\n        visited.remove(node)\n        return min_energy if min_energy != float('inf') else None\n\n    visited = set()\n    result = dfs(start, end, [], visited)\n    return result if result else 0\n\n# Main function to handle queries\ndef main():\n    # Read input\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    \n    # Build the tree\n    tree = build_tree(n, edges)\n    \n    # Initialize illusion rates in the tree\n    for i in range(1, n + 1):\n        tree.nodes[i]['illusion_rate'] = illusion_rates[i - 1]\n    \n    # Process queries\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(tree, query[1], query[2])\n        elif query[0] == 2:\n            result = calculate_energy(tree, query[1], query[2])\n            print(result)\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict, Tuple\n\n# Data structures and interfaces\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    \"\"\"\n    Update the illusion rate of the specified room.\n    \n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate.\n    \"\"\"\n    # Implementation of updating the illusion rate\n    pass\n\ndef calculate_energy(start: int, end: int) -> int:\n    \"\"\"\n    Calculate the minimum energy required to travel from the start room to the end room.\n    \n    Args:\n        start (int): The starting room number.\n        end (int): The ending room number.\n    \n    Returns:\n        int: The minimum energy required for the travel.\n    \"\"\"\n    # Implementation of calculating the energy\n    pass\n\n# Example adjacency list representation of the tree\nadjacency_list: Dict[int, List[int]] = {\n    1: [2, 3],\n    2: [1, 4, 5],\n    3: [1],\n    4: [2, 6],\n    5: [2],\n    6: [4]\n}\n\n# Example illusion rates\nillusion_rates: List[int] = [2, 3, 1, 4, 5, 6]\n\n# Function to update the illusion rate\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    global illusion_rates\n    illusion_rates[room - 1] = new_rate\n\n# Function to calculate the energy required to travel between two rooms\ndef calculate_energy(start: int, end: int) -> int:\n    def dfs(room: int, parent: int, energy_so_far: int) -> int:\n        if room == end:\n            return energy_so_far\n        min_energy = float('inf')\n        for neighbor in adjacency_list[room]:\n            if neighbor != parent:\n                min_energy = min(min_energy, dfs(neighbor, room, max(energy_so_far, abs(illusion_rates[room - 1] + illusion_rates[neighbor - 1]), abs(illusion_rates[room - 1] - illusion_rates[neighbor - 1]))))\n        return min_energy\n    \n    return dfs(start, -1, 0)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Update the illusion rate of room 3 to 8\n    update_illusion_rate(3, 8)\n    \n    # Calculate the energy required to travel from room 1 to room 6\n    energy = calculate_energy(1, 6)\n    print(f\"The minimum energy required to travel from room 1 to room 6 is: {energy}\")\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\n\n# Global variables to store the tree structure and illusion rates\ntree: Dict[int, List[int]] = {}\nillusion_rates: List[int] = []\n\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    \"\"\"\n    Update the illusion rate of a room.\n    \n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef min_energy_required(start: int, end: int) -> int:\n    \"\"\"\n    Calculate the minimum energy required to travel between two rooms.\n    \n    Args:\n        start (int): The starting room.\n        end (int): The ending room.\n    \n    Returns:\n        int: The minimum energy required.\n    \"\"\"\n    def dfs(node: int, target: int, visited: List[bool], energy: int) -> int:\n        \"\"\"\n        Depth-first search to find the minimum energy required.\n        \n        Args:\n            node (int): The current room.\n            target (int): The target room.\n            visited (List[bool]): List to keep track of visited rooms.\n            energy (int): The current energy required.\n        \n        Returns:\n            int: The minimum energy required to reach the target room.\n        \"\"\"\n        if node == target:\n            return energy\n        \n        min_energy = sys.maxsize\n        visited[node - 1] = True\n        \n        for neighbor in tree[node]:\n            if not visited[neighbor - 1]:\n                new_energy = max(abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]), energy)\n                min_energy = min(min_energy, dfs(neighbor, target, visited, new_energy))\n        \n        visited[node - 1] = False\n        return min_energy\n    \n    visited = [False] * len(illusion_rates)\n    return dfs(start, end, visited, 0)\n\n# Read input\nn, q = map(int, sys.stdin.readline().split())\nillusion_rates = list(map(int, sys.stdin.readline().split()))\n\n# Build the tree\nfor _ in range(n - 1):\n    s, t = map(int, sys.stdin.readline().split())\n    if s not in tree:\n        tree[s] = []\n    if t not in tree:\n        tree[t] = []\n    tree[s].append(t)\n    tree[t].append(s)\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = min_energy_required(query[1], query[2])\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef read_input():\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    tunnels = [list(map(int, input().split())) for _ in range(n - 1)]\n    queries = [list(map(int, input().split())) for _ in range(q)]\n    return n, q, a, tunnels, queries\n\ndef calculate_energy(rooms: List[int], queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Calculate the minimum energy required to travel between two rooms in a maze.\n\n    Args:\n        rooms (List[int]): List of illusion rates for each room.\n        queries (List[Tuple[int, int]]): List of queries, each query is a tuple (type, room1, room2).\n\n    Returns:\n        List[int]: List of results for each query of type 2.\n    \"\"\"\n    results = []\n\n    # Function to calculate the energy required to travel between two rooms\n    def energy_required(x: int, y: int) -> int:\n        return max(abs(rooms[x - 1] - rooms[y - 1]), abs(rooms[x - 1] + rooms[y - 1]))\n\n    # Process each query\n    for query in queries:\n        query_type, room1, room2 = query\n        if query_type == 2:\n            results.append(energy_required(room1 - 1, room2 - 1))\n\n    return results\n\n# Read input\nn, q, a, tunnels, queries = read_input()\n\n# Calculate and output results\nresult = calculate_energy(a, queries)\nfor r in result:\n    print(r)\n", "from typing import List\nfrom typing import List, Callable\n\ndef calculate_energy(a: List[int], edges: List[List[int]]) -> Callable[[List[int]], int]:\n    # Construct the tree data structure from the edges\n    tree = [[] for _ in range(len(a))]\n    for edge in edges:\n        tree[edge[0] - 1].append(edge[1] - 1)\n        tree[edge[1] - 1].append(edge[0] - 1)\n\n    # Define the function to calculate the energy required to travel between two rooms\n    def calculate_energy_for_query(query: List[int]) -> int:\n        room1, room2 = query[0] - 1, query[1] - 1\n        return max(abs(a[room1] - a[room2]), abs(a[room1] + a[room2]))\n\n    return calculate_energy_for_query\n\n# Read input data\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Call the function with the provided data\ndef main():\n    calculate_energy_func = calculate_energy(a, edges)\n    for query in queries:\n        result = calculate_energy_func(query)\n        print(result)\n\n# Run the main function\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\n# Initialize the tree structure and illusion rates\nn, q = map(int, input().split())\na_list = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room_id: int, new_rate: int) -> None:\n    a_list[room_id - 1] = new_rate\n\n# Function to calculate the minimum energy required to travel between two rooms\ndef calculate_energy(start_room: int, end_room: int) -> int:\n    a_x = a_list[start_room - 1]\n    a_y = a_list[end_room - 1]\n    energy = max(abs(a_x - a_y), abs(a_x + a_y))\n    return energy\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_energy(query[1], query[2])\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Set up the adjacency list to represent the tree\nadj_list = []\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room_id: int, new_rate: int) -> None:\n    illusion_rates[room_id - 1] = new_rate\n\n# Function to calculate the minimum energy required to travel between two rooms using DFS\ndef calculate_minimum_energy(start_room: int, end_room: int) -> int:\n    def dfs(node: int, target: int, visited: List[bool], energy: int) -> int:\n        if node == target:\n            return energy\n        visited[node] = True\n        min_energy = sys.maxsize\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                new_energy = max(abs(illusion_rates[node] + illusion_rates[neighbor]), abs(illusion_rates[node] - illusion_rates[neighbor]))\n                min_energy = min(min_energy, dfs(neighbor, target, visited, new_energy))\n        visited[node] = False\n        return min_energy\n    \n    visited = [False] * len(adj_list)\n    return dfs(start_room - 1, end_room - 1, visited, 0)\n\n# Read input\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Build the adjacency list\nadj_list = [[] for _ in range(n)]\nfor s, t in tunnels:\n    adj_list[s - 1].append(t - 1)\n    adj_list[t - 1].append(s - 1)\n\n# Process queries\nfor query in queries:\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_minimum_energy(query[1], query[2])\n        print(result)\n", "from typing import List\n## main.py\n\nimport sys\nimport networkx as nx\n\n# Initialize the graph\nG = nx.Graph()\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room_id: int, new_rate: int) -> None:\n    G.nodes[room_id]['illusion_rate'] = new_rate\n\n# Function to calculate the minimum energy required to travel between two rooms\ndef calculate_minimum_energy(start_room: int, end_room: int) -> int:\n    # Find the shortest path between the two rooms\n    path = nx.shortest_path(G, source=start_room, target=end_room)\n    \n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy += abs(G.nodes[room1]['illusion_rate'] + G.nodes[room2]['illusion_rate'])\n    return energy\n\n# Read input\nn, q = map(int, sys.stdin.readline().split())\nillusion_rates = list(map(int, sys.stdin.readline().split()))\n\n# Construct the tree\nfor _ in range(n - 1):\n    s, t = map(int, sys.stdin.readline().split())\n    G.add_edge(s, t)\n    G.nodes[s]['illusion_rate'] = illusion_rates[s - 1]\n    G.nodes[t]['illusion_rate'] = illusion_rates[t - 1]\n\n# Process queries\nfor _ in range(q):\n    query_type = list(map(int, sys.stdin.readline().split()))\n    if query_type[0] == 1:\n        update_illusion_rate(query_type[1], query_type[2])\n    elif query_type[0] == 2:\n        result = calculate_minimum_energy(query_type[1], query_type[2])\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\n\n# Initialize the tree structure and store the illusion rates of each room.\ndef initialize_tree(n: int, a: List[int], tunnels: List[Tuple[int, int]]) -> Dict[int, Dict[int, int]]:\n    tree = {i: {} for i in range(1, n + 1)}\n    for s, t in tunnels:\n        tree[s][t] = a[t - 1]\n        tree[t][s] = a[s - 1]\n    return tree\n\n# Update the illusion rate of a room.\ndef update_illusion_rate(room_index: int, new_rate: int, tree: Dict[int, Dict[int, int]]) -> None:\n    for child in tree[room_index]:\n        tree[child][room_index] = new_rate\n    tree[room_index] = {room_index: new_rate}\n\n# Calculate the minimum energy required to travel between two rooms using DFS.\ndef calculate_min_energy(start_room: int, end_room: int, tree: Dict[int, Dict[int, int]]) -> int:\n    def dfs(room: int, target: int, parent: int, energy: int) -> int:\n        if room == target:\n            return energy\n        min_energy = sys.maxsize\n        for child in tree[room]:\n            if child != parent:\n                min_energy = min(min_energy, dfs(child, target, room, energy + abs(tree[room][child])))\n        return min_energy\n    return dfs(start_room, end_room, -1, 0)\n\n# Main function to process queries.\ndef process_queries(n: int, q: int, a: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> None:\n    tree = initialize_tree(n, a, tunnels)\n    for query in queries:\n        query_type, *params = query\n        if query_type == 1:\n            room_index, new_rate = params\n            update_illusion_rate(room_index, new_rate, tree)\n        elif query_type == 2:\n            start_room, end_room = params\n            result = calculate_min_energy(start_room, end_room, tree)\n            print(result)\n\n# Read input from stdin.\ndef read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]], List[Tuple[int, int, int]]]:\n    n, q = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    tunnels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    queries = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\n    return n, q, a, tunnels, queries\n\n# Main execution.\nif __name__ == \"__main__\":\n    n, q, a, tunnels, queries = read_input()\n    process_queries(n, q, a, tunnels, queries)\n", "from typing import List\nimport networkx as nx\nfrom typing import List\n\n# Initialize the tree structure\ntree = nx.Graph()\n\ndef update_illusion_rate(room_id: int, new_rate: int) -> None:\n    \"\"\"\n    Update the illusion rate of a specific room.\n    \n    Args:\n        room_id (int): The ID of the room to update.\n        new_rate (int): The new illusion rate for the room.\n    \"\"\"\n    tree.nodes[room_id]['illusion_rate'] = new_rate\n\ndef calculate_energy(start_room: int, end_room: int) -> int:\n    \"\"\"\n    Calculate the minimum energy required to travel from one room to another.\n    \n    Args:\n        start_room (int): The starting room.\n        end_room (int): The destination room.\n    \n    Returns:\n        int: The minimum energy required to travel from start_room to end_room.\n    \"\"\"\n    # Use BFS to find the shortest path between rooms\n    path = nx.shortest_path(tree, source=start_room, target=end_room)\n    \n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        illusion_rate1 = tree.nodes[room1]['illusion_rate']\n        illusion_rate2 = tree.nodes[room2]['illusion_rate']\n        energy = max(energy, abs(illusion_rate1 + illusion_rate2), abs(illusion_rate1 - illusion_rate2))\n    \n    return energy\n\n# Read initial input\nn, q = map(int, input().split())\na_values = list(map(int, input().split()))\n\n# Initialize the tree structure\nfor _ in range(n - 1):\n    s, t = map(int, input().split())\n    tree.add_edge(s, t)\n\n# Assign illusion rates to rooms\nfor i in range(n):\n    tree.nodes[i + 1]['illusion_rate'] = a_values[i]\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        u, c = query[1], query[2]\n        update_illusion_rate(u, c)\n    elif query[0] == 2:\n        u, v = query[1], query[2]\n        result = calculate_energy(u, v)\n        print(result)\n"], "plans": ["requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node has an associated illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel from one room to another. The solution must be efficient to handle the potential large scale of the input.\nrequirement pool:\n- Implement a tree data structure to represent the maze and its connections.\n- Create a function to calculate the energy required to travel between rooms based on the illusion rates.\n- Develop a mechanism to handle queries for updating illusion rates and calculating minimum energy.\n- Ensure the system can handle large inputs efficiently.\n- Design a user-friendly interface for interacting with the system.\nTo tackle the problem, we will utilize Python's capabilities along with the 'networkx' library to handle the tree structure of the maze. We will also use 'numpy' for efficient array operations, which will be crucial for calculating the energy required to travel between rooms based on the illusion rates. The system will be designed to handle both the creation of the tree from the given edges and the querying mechanism for updating illusion rates and calculating minimum energy.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': a graph with n nodes and n-1 edges where any two nodes are connected by a unique path.\n    'illusion rate': a measure of the effect on energy required to travel between rooms.\n    'energy calculation': the energy required to travel between two rooms is the maximum of the absolute sums or differences of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate a condition where a value must be greater than a specified amount.\n    'at least as many times': used to indicate a condition where a value must appear at least a specified number of times.\n\n# [degree adverb] \n    'largest': used to indicate the maximum or highest value in a set of values.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Build a tree representation from the given edges.\n    2. Handle queries of type 1 and type 2.\n    3. For type 1, update the illusion rate of a specific room.\n    4. For type 2, calculate the minimum sum of energy needed to travel from one room to another using the tree structure and current illusion rates.\n\n# [edge case] \n    Edge case 1: Query type 2 with rooms that are directly connected by a single tunnel.\n    Edge case 2: Query type 2 with rooms that are not directly connected but share a common ancestor in the tree.\n    Edge case 3: Query type 1 with a room that has the highest illusion rate in the tree.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases:\n    For edge case 1, since the rooms are directly connected, the energy calculation is straightforward: energy = max(|a_u + a_v|, |a_u - a_v|).\n    For edge case 2, we need to find the lowest common ancestor (LCA) of the two rooms to calculate the energy. This requires additional logic to traverse the tree.\n    For edge case 3, updating the illusion rate of a room with the highest rate might affect the overall minimum energy for many queries, so we need to ensure this update does not significantly impact performance.\n\n    Example extra code for edge case 2:\n    def find_lca(u, v):\n        # Function to find the lowest common ancestor of nodes u and v\n        pass\n\n    def calculate_energy(u, v):\n        lca = find_lca(u, v)\n        energy = max(|a_u + a_v|, |a_u - a_v|)\n        return energy\n", "requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node has an illusion rate that can be updated. Queries involve calculating the minimum energy required to travel between two rooms, considering the updated illusion rates. The system must be efficient to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the maze and tunnels.\n- Allow dynamic updates to the illusion rates of rooms.\n- Provide functionality to calculate the minimum energy required for travel between two rooms.\n- Ensure the system can handle up to 10^5 rooms and 10^5 queries efficiently.\n- Design a user-friendly interface for inputting and displaying information.\nTo tackle the problem of representing a maze as a tree with dynamic illusion rates and calculating the minimum energy required for travel between rooms, we will utilize a combination of data structures and algorithms. We will represent the tree using an adjacency list, which allows for efficient traversal and updates. For handling dynamic updates to illusion rates, we will use a segment tree or a binary indexed tree, which can efficiently update and query values in logarithmic time. For calculating the minimum energy required for travel, we will use a depth-first search (DFS) algorithm to traverse the tree and compute the energy based on the current illusion rates.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': represents the maze as a graph with nodes (rooms) and edges (tunnels)\n    'dynamic updates': ability to change the illusion rate of any room in the maze\n    'minimum energy calculation': finding the minimum sum of energy needed to travel between two rooms\n\n    Explanation:\n    - The tree structure allows for a hierarchical representation of the maze, where each room is a node and each tunnel is an edge.\n    - Dynamic updates mean that the illusion rates of rooms can be changed at any time, which affects the energy calculations.\n    - Minimum energy calculation involves determining the path with the least energy expenditure between two rooms, considering the current illusion rates.\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate a condition where a value must be greater than a certain threshold\n    'at least as many times': used to indicate a condition where a value must appear a minimum number of times\n\n# [degree adverb] \n    'minimum': used to indicate the smallest possible value or the best (least costly) option\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Represent the tree using an adjacency list.\n    - Use a depth-first search (DFS) to traverse the tree and calculate the energy required for each path.\n    - Implement dynamic updates to the illusion rates using a suitable data structure (e.g., segment tree or binary indexed tree).\n    - For each query of type 2, use DFS to find the minimum energy path between the given rooms.\n\n# [edge case] \n    Edge case 1: Query type 2 with rooms that are directly connected by a single tunnel.\n    Edge case 1 = 5\n    Explanation:\n    - If rooms u and v are directly connected by a single tunnel, the energy required is max(|a_u + a_v|, |a_u - a_v|).\n    - Assume a_u = 2 and a_v = 3, then the energy is max(|2 + 3|, |2 - 3|) = max(5, 1) = 5.\n\n    Edge case 2: Query type 2 with rooms that are not directly connected.\n    Edge case 2 = 7\n    Explanation:\n    - If rooms u and v are not directly connected, the minimum energy path will involve traversing through multiple tunnels and rooms.\n    - Assume a_u = 1 and a_v = 6, and there is a path through rooms 1->2->3->4->5->6 with illusion rates 1, 2, 3, 4, 5, 6 respectively.\n    - The energy for each segment of the path is calculated as described, and the minimum sum of energy is the sum of these energies.\n\n    Edge case 3: Query type 1 to update the illusion rate of a room.\n    Edge case 3 = 3\n    Explanation:\n    - Updating the illusion rate of a room changes the energy calculations for all paths that pass through that room.\n    - Assume updating room 3's illusion rate from 3 to 8, which affects paths 1->3 and 3->4, changing their energy calculations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For edge case 1, ensure that the adjacency list is correctly set up to handle direct connections.\n    - For edge case 2, implement DFS to traverse the tree and calculate the energy for non-direct paths.\n    - For edge case 3, update the illusion rates and ensure the DFS calculations reflect the new rates.\n\n    Example code for handling edge case 1:\n    ```python\n    if u in adjacency_list[v] and v in adjacency_list[u]:\n        energy = max(abs(a[u - 1] + a[v - 1]), abs(a[u - 1] - a[v - 1]))\n    ```\n\n    Example code for handling edge case 2:\n    ```python\n    def dfs(room, parent, energy_so_far):\n        if room == v:\n            return energy_so_far\n        min_energy = float('inf')\n        for neighbor in adjacency_list[room]:\n            if neighbor != parent:\n                min_energy = min(min_energy, dfs(neighbor, room, max(energy_so_far, abs(a[room - 1] + a[neighbor - 1]), abs(a[room - 1] - a[neighbor - 1]))))\n        return min_energy\n    ```\n\n    Example code for handling edge case 3:\n    ```python\n    a[u - 1] = c\n    ```\n", "requirement analysis:\nThe project requires a system to manage a tree structure representing the maze, where each node has an associated illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel from one room to another. The system must handle both types of queries efficiently, especially since the number of queries can be high.\nrequirement pool:\n- Implement a tree structure to represent the maze.\n- Handle queries to update and retrieve illusion rates.\n- Calculate the minimum energy required for travel between rooms.\n- Ensure the application is user-friendly and responsive.\n- Enhance the visual appeal and interactivity of the application.\nTo address the requirements, we will use a Python-based solution that leverages a graph data structure to represent the maze. The graph will be implemented using an adjacency list, which allows for efficient traversal of the tree structure. For handling queries, we will use a combination of depth-first search (DFS) and dynamic programming to calculate the minimum energy required for travel between rooms. The application will be designed to be user-friendly, with a simple interface that allows users to interact with the maze and its settings.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The maze is represented as a tree with rooms and tunnels connecting them.\n    'adjacency list': A data structure used to represent the tree, where each room is a node and each tunnel is an edge.\n    'depth-first search (DFS)': A method for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores as far as possible along each branch before backtracking.\n    'dynamic programming': A technique used to solve problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the energy required to travel between rooms is dependent on the absolute values of the illusion rates of the rooms.\n    'at least as many times': Refers to the number of queries that can be processed.\n\n# [degree adverb] \n    'minimum': Indicates the lowest possible energy required for travel between rooms.\n\n# [code logic]\n    The solution involves:\n    1. Building the tree using the adjacency list.\n    2. Processing each query:\n        - For type 1 query (change the illusion rate of a room), update the adjacency list.\n        - For type 2 query (calculate the minimum energy needed to travel between two rooms), use DFS to find the minimum energy path.\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: The tree structure is a simple path from room 1 to room 2. The minimum energy required to travel from room 1 to room 2 is the absolute difference between their illusion rates.\n    Edge case 2:\n    Query: 2 1 3\n    Explanation: The tree structure is a path with an additional room connected to room 1 and room 2. The minimum energy required to travel from room 1 to room 3 involves the maximum of the absolute differences between the illusion rates of the intermediate rooms.\n    Edge case 3:\n    Query: 1 2 5\n    Explanation: The illusion rate of room 2 is changed to 5. This affects all future queries that involve room 2, potentially changing the minimum energy required for travel between rooms.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the query involves changing the illusion rate of a room that is not directly connected to the initial room u. In such cases, we need to extend the DFS traversal to include all possible paths from u to v, considering the updated illusion rates.\n", "requirement analysis:\nThe project requires the implementation of a tree structure to represent the maze, where each node has an associated value representing the illusion rate. Queries involve calculating the minimum energy required to travel between two rooms based on the given formula. The solution must be efficient to handle the constraints of n and q.\nrequirement pool:\n- Implement a tree structure to represent the maze\n- Handle queries to calculate the minimum energy required for travel\n- Ensure the solution is efficient and can handle large inputs\n- Provide a user-friendly interface for input and output\nTo solve this problem, we will use a tree data structure to represent the maze, where each node has an associated value representing the illusion rate. We will handle queries to calculate the minimum energy required to travel between two rooms based on the given formula. To ensure efficiency, we will use an efficient algorithm to traverse the tree and calculate the energy required for each query.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a non-linear data structure that simulates a hierarchical tree structure with a set of linked nodes. Each node in the tree can have zero or more child nodes and at most one parent node. Trees are used to represent hierarchical relationships between objects.\n\n    'illusion rate': The rate at which illusions occur in a room, represented by a_i.\n\n    'energy required for travel': The energy required to travel from room x to room y is determined by the formula max(|a_x - a_y|, |a_x + a_y|).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Read the input values for the number of rooms (n), the number of queries (q), the illusion rates (a_i), and the tunnel connections (s_i, t_i).\n    2. Construct a tree data structure to represent the maze.\n    3. For each query of type 2, calculate the minimum sum of energy needed to travel between two rooms using the given formula.\n    4. Output the result for each query.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    n = 3, q = 1\n    a = [1, 2, 3]\n    tunnels = [(1, 2), (2, 3)]\n    query = [(2, 1, 3)]\n\n    Explanation:\n    The tree structure is:\n    1\n    |\n    2\n    |\n    3\n    The energy required to travel from room 1 to room 3 is max(|1 - 3|, |1 + 3|) = max(2, 4) = 4.\n\n    Edge case 2:\n    Input:\n    n = 4, q = 2\n    a = [0, 5, 5, 0]\n    tunnels = [(1, 2), (1, 3), (1, 4)]\n    queries = [(2, 2, 3), (2, 3, 4)]\n\n    Explanation:\n    The tree structure is:\n    1\n    | \\\n    2  3\n    |\n    4\n    The energy required to travel from room 2 to room 3 is max(|5 - 5|, |5 + 5|) = max(0, 10) = 10.\n    The energy required to travel from room 3 to room 4 is max(|5 - 0|, |5 + 0|) = max(5, 5) = 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the given logic can handle the simple cases directly. However, for more complex cases, additional code might be needed to handle edge cases such as invalid queries or unexpected input values.\n", "requirement analysis:\nThe project requires the implementation of a tree structure to represent the maze, where each node has an associated value representing the illusion rate. Queries involve calculating the minimum energy required to travel between two rooms based on the given formula. The solution must be efficient to handle the constraints of n and q.\nrequirement pool:\n- Implement a tree structure to represent the maze\n- Handle queries to calculate the minimum energy required for travel\n- Ensure the solution is efficient and can handle large inputs\n- Provide a user-friendly interface for input and output\nTo implement the solution, we will use a tree data structure to represent the maze, where each node has an associated value representing the illusion rate. We will handle queries to calculate the minimum energy required to travel between two rooms based on the given formula. To ensure efficiency, we will use an efficient algorithm to traverse the tree and calculate the energy required for each query.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a non-linear data structure that simulates a hierarchical tree structure with a set of linked nodes. Each node has a parent (except for the root node) and can have zero or more children. Trees are used to represent hierarchical relationships between objects.\n\n    'illusion rate': The rate at which illusions occur in a room, affecting the energy required to travel between rooms.\n\n    'energy formula': The formula used to calculate the energy required to travel from room x to room y, which is max(|a_x - a_y|, |a_x + a_y|).\n\n    Explanation: The energy required to travel between two rooms depends on the absolute difference or sum of the illusion rates of the two rooms, whichever is greater. This formula accounts for the deceptive nature of the illusions in the maze.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n\n    Explanation: In the context of the requirement, this phrase might be used to specify a minimum value for a parameter or to indicate a condition that must be met.\n\n# [degree adverb] \n    'minimum': Indicates the smallest possible value or the lowest degree of a quality.\n\n    Explanation: In the context of the requirement, 'minimum' refers to the smallest sum of energy needed to travel between two rooms, ensuring the most efficient path for finding the treasure.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Read the input data representing the maze structure and illusion rates.\n    2. Construct a tree data structure to represent the maze.\n    3. For each query of type 2, calculate the minimum sum of energy needed to travel between the specified rooms using the given formula.\n    4. Output the result of each query.\n\n# [edge case] \n    Edge case 1: The maze has only two rooms with illusion rates a_1 = 5 and a_2 = 10.\n    expected output: 5\n    Explanation: The energy required to travel between these two rooms is max(|5 - 10|, |5 + 10|) = max(5, 15) = 15.\n\n    Edge case 2: The maze has multiple rooms with varying illusion rates, and the queries are for traveling between distant rooms.\n    expected output: (depends on the specific illusion rates and the tree structure)\n    Explanation: This edge case tests the algorithm's ability to handle complex maze structures and calculate energy efficiently for distant room pairs.\n\n    Edge case 3: The maze has a large number of rooms and queries, testing the algorithm's performance and scalability.\n    expected output: (depends on the specific maze configuration and queries)\n    Explanation: This edge case ensures that the solution can handle large inputs efficiently and accurately.\n\n# [extra code for edge case]\n    We may need extra code to handle the edge cases, such as when the maze structure is such that the shortest path between two rooms is not immediately obvious or when the illusion rates are extreme values that could affect the energy calculation.\n\n    Example code to handle edge cases:\n    if n == 2:\n        return a[0] + a[1]  # Directly return the sum of the two rooms' illusion rates for the simple case.\n\n    if a_x * a_y < 0:  # Handle cases where the signs of the illusion rates are different.\n        return abs(a_x - a_y)\n\n    return abs(a_x + a_y)  # Default case for calculating energy.\n", "requirement analysis:\nThe project requires the implementation of a tree structure to represent the maze, where each node represents a room with an associated illusion rate. The energy required to travel between rooms is calculated based on the given formula. Queries can either update the illusion rate of a room or compute the minimum energy required to travel between two rooms. The solution must be efficient to handle the constraints of n and q up to 10^5.\nrequirement pool:\n- Implement a tree structure to represent the maze\n- Calculate energy required for travel between rooms\n- Handle queries to update illusion rates and compute energy\n- Ensure the solution is efficient to handle large inputs\n- Design a user-friendly interface for input and output\nTo solve this problem, we will use a tree data structure to represent the maze, where each node contains information about the illusion rate of the room. We will calculate the energy required to travel between rooms using the given formula. For handling queries, we will implement functions to update the illusion rates and compute the minimum energy required to travel between two rooms. Efficiency is crucial given the constraints of n and q up to 10^5, so we will optimize our approach to ensure it runs smoothly under these conditions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a non-linear data structure that simulates a hierarchical tree structure with a set of linked nodes. The topmost node is called the root, and each node can have zero or more child nodes and at most one parent node. Trees are used to represent hierarchical relationships between objects.\n\n    'illusion rate': The rate at which illusions occur in a room, which affects the energy required to travel between rooms.\n\n    'energy formula': The formula used to calculate the energy required to travel between two rooms, which involves taking the maximum of the absolute difference and the absolute sum of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a certain condition must be met by a certain number of elements or values.\n\n# [degree adverb] \n    'minimum': Indicates the smallest possible value or amount.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Represent the maze as a tree using the given rooms and tunnels.\n    2. Store the illusion rates for each room.\n    3. Calculate the energy required to travel between any two rooms using the given formula.\n    4. Handle queries to update the illusion rates and compute the minimum energy required for travel.\n\n# [edge case] \n    Edge case 1: The tree structure is such that all rooms have the same illusion rate.\n    Edge case 1 = -1\n    Explanation: Since all rooms have the same illusion rate, the energy required to travel between any two rooms is 0, and the minimum sum of energy is also 0.\n\n    Edge case 2: The tree structure is a straight line with alternating high and low illusion rates.\n    Edge case 2 = 10\n    Explanation: In this case, the energy required to travel from the start to the end of the line will be the maximum of the absolute differences or sums of the illusion rates, which will be the highest possible value given the constraints.\n\n    Edge case 3: The tree structure is a star shape with one central room and several outer rooms.\n    Edge case 3 = 5\n    Explanation: In this configuration, the energy required to travel from the central room to any outer room will be the maximum of the absolute differences or sums of the illusion rates, which will be a moderate value.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the tree structure or the illusion rates are such that the minimum energy required for travel is affected. This could involve additional checks and calculations to ensure the correct output is provided for these specific scenarios.\n", "requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node represents a room and each edge represents a tunnel. The system must be able to handle queries to update the illusion rate of a room and to calculate the minimum energy required to travel between two rooms. The illusion rates can be positive or negative integers, and the energy calculation should consider the absolute values of the sum of the illusion rates along the path.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update the illusion rate of a room.\n- Calculate the minimum energy required to travel between two rooms.\n- Ensure the system is efficient enough to handle up to 10^5 rooms and 10^5 queries.\n- Design a user-friendly interface for easy interaction.\nTo implement the system, we will use a tree data structure to represent the maze, where each node represents a room and each edge represents a tunnel. We will handle queries to update the illusion rate of a room and calculate the minimum energy required to travel between two rooms. The illusion rates can be positive or negative integers, and the energy calculation will consider the absolute values of the sum of the illusion rates along the path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': This represents the maze as a graph with rooms as nodes and tunnels as edges.\n    'illusion rate': The value associated with each room, which can affect the energy required to traverse the corresponding tunnel.\n\n# [phrase showing quantity relationship]\n    'more than': Used to indicate that the illusion rate can be positive or negative.\n\n# [degree adverb] \n    'minimum': Indicates that we need to find the smallest energy required to travel between two rooms.\n\n# [code logic]\n    To implement the system, we will:\n    1. Represent the maze as a tree using an adjacency list.\n    2. Store the illusion rates for each room.\n    3. Handle queries to update the illusion rate of a room.\n    4. Calculate the minimum energy required to travel between two rooms using a depth-first search (DFS) to traverse the tree and compute the energy based on the illusion rates.\n\n# [edge case] \n    Edge case 1: Query to update the illusion rate of a room.\n    Example: \n    Input: 2 1 -3\n    Explanation: The illusion rate of the 1st room changes from 10 to -3.\n\n    Edge case 2: Query to calculate the minimum energy required to travel between two rooms.\n    Example: \n    Input: 2 1 2\n    Explanation: The minimum energy required to travel from the 1st room to the 2nd room is calculated.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the updated illusion rate significantly changes the energy calculation.\n    Example:\n    def update_illusion_rate(room, new_rate):\n        # Update the illusion rate for the given room\n        illusion_rates[room] = new_rate\n\n    def calculate_energy(start, end):\n        # Calculate the minimum energy required to travel from start to end\n        energy = 0\n        # Use DFS to traverse the tree and compute the energy\n        # (code to be implemented)\n        return energy\n\n    # Example usage:\n    update_illusion_rate(1, -3)\n    energy = calculate_energy(1, 2)\n    print(energy)  # Output should be the new minimum energy required\n", "requirement analysis:\nThe project requires a program to handle a tree structure representing a maze, where each node (room) has an initial illusion rate and can be updated. Queries involve determining the minimum energy required to travel between two rooms, considering the updated illusion rates. The program must be efficient to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update room illusion rates and calculate minimum energy for travel.\n- Ensure the program is efficient and can handle large inputs.\n- Design a user-friendly interface for input and output.\nTo tackle the problem of determining the minimum energy required to travel between two rooms in a maze represented as a tree, we will use a graph data structure. Specifically, we will employ a tree data structure since the maze is a tree-shaped graph with n rooms and n - 1 tunnels. We will use a library like NetworkX to handle the tree structure and calculate the minimum energy required for travel based on the updated illusion rates of the rooms. The program will handle queries to update room illusion rates and calculate the minimum energy for travel efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': A tree is a connected graph with no cycles, where each node (room) is connected to a unique path.\n    'illusion rate': The value associated with each room that affects the energy required to traverse it.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n    'at least as many times': Indicates that a value must appear at least as frequently as another value.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set of values.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Read the input values for the number of rooms (n), the number of queries (q), the initial illusion rates of each room, and the tunnels connecting the rooms.\n    2. Construct a tree data structure from the given tunnels.\n    3. Process each query:\n        - If the query type is to update the illusion rate of a room, update the corresponding value in the tree.\n        - If the query type is to determine the minimum energy required to travel between two rooms, calculate the energy using the updated illusion rates and the tree structure.\n    4. Output the results of the queries.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 2, q = 1, rooms = [1, 2], tunnels = [(1, 2)], query = (2, 1, 2)\n    Explanation:\n    The maze consists of two rooms connected by a single tunnel. The query asks for the minimum energy required to travel between the two rooms. Since there's only one path, the energy is the sum of the absolute values of the illusion rates of the two rooms.\n    Expected output: 3 (since |1 + 2| = 3)\n\n    Edge case 2:\n    Input: n = 3, q = 2, rooms = [1, -1, 2], tunnels = [(1, 2), (2, 3)], queries = [(2, 1, -1), (2, 1, 2)]\n    Explanation:\n    The maze has three rooms connected in a line. The first query updates the illusion rate of the first room to -1. The second query asks for the minimum energy required to travel between the first and the third room. The energy calculation involves summing the absolute values of the illusion rates along the path, considering the updated rate after the first query.\n    Expected output: 2 (since |-1 + 2| = 3 for the initial rates, and after updating, | -1 + 2| = 1, but we need to consider the largest absolute value encountered during the path, which is 2)\n\n    Edge case 3:\n    Input: n = 4, q = 1, rooms = [0, 0, 0, 0], tunnels = [(1, 2), (1, 3), (1, 4)], query = (2, 1, 1)\n    Explanation:\n    The maze has four rooms, all with an initial illusion rate of 0, and they are connected in a star shape with the first room at the center. The query asks for the minimum energy required to travel between the first and the fourth room. Since all rooms have the same illusion rate, the energy required is the absolute value of the difference between their rates, which is 0.\n    Expected output: 0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle cases where the tree is very small or where all rooms have the same illusion rate.\n", "requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node represents a room and each edge represents a tunnel. Queries can update the illusion rate of a room or determine the minimum energy required to travel between two rooms. The system must be efficient enough to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update room illusion rates and calculate minimum energy for travel.\n- Ensure the system is efficient and can handle large inputs.\n- Design a user-friendly interface for easy interaction.\nTo tackle the problem, we will use a tree data structure to represent the maze, where each node represents a room and each edge represents a tunnel. We will handle queries to update room illusion rates and calculate the minimum energy required to travel between two rooms efficiently. We will employ a depth-first search (DFS) algorithm to traverse the tree and calculate the minimum energy needed for the journey.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': represents the maze as a graph with nodes (rooms) and edges (tunnels)\n    'DFS (Depth-First Search)': used to traverse the tree and calculate the minimum energy needed for the journey between rooms\n\n# [phrase showing quantity relationship]\n    'more than': used to specify the number of rooms and queries\n    'at least as many times': not explicitly mentioned in the requirement\n\n# [degree adverb] \n    'minimum': indicates the need to find the smallest energy required for the journey\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Initialize the tree structure and store the illusion rates of each room.\n    - Process each query:\n        - If the query type is to update the illusion rate of a room, update the corresponding value in the data structure.\n        - If the query type is to calculate the minimum energy required to travel between two rooms, use DFS to traverse the tree and calculate the energy based on the current illusion rates.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Initialize the tree structure and store the illusion rates of each room.\n    - Process each query:\n        - If the query type is to update the illusion rate of a room, update the corresponding value in the data structure.\n        - If the query type is to calculate the minimum energy required to travel between two rooms, use DFS to traverse the tree and calculate the energy based on the current illusion rates.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Initialize the tree structure and store the illusion rates of each room.\n    - Process each query:\n        - If the query type is to update the illusion rate of a room, update the corresponding value in the data structure.\n        - If the query type is to calculate the minimum energy required to travel between two rooms, use DFS to traverse the tree and calculate the energy based on the current illusion rates.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need.\n", "requirement analysis:\nThe project requires a system to manage a tree structure representing the maze, where each node has an associated value representing the illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel from one room to another. The system must handle both types of queries efficiently, especially when dealing with large inputs.\nrequirement pool:\n- Implement a tree structure to represent the maze.\n- Handle queries to update room illusion rates and calculate energy.\n- Ensure real-time updates and efficient query processing.\n- Design a user-friendly interface for managing the maze and queries.\nTo address the requirements, we will use a Python-based solution that leverages the power of a tree data structure to represent the maze. We will utilize the `networkx` library to handle the tree structure and graph operations efficiently. For managing the illusion rates and calculating energy, we will implement a class-based approach where each room will be represented by a node in the tree, and the edges will represent the tunnels between rooms. The class will handle the updating of illusion rates and the calculation of minimum energy required to travel between rooms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': A tree is a connected graph with no cycles. Each room is a node, and each tunnel is an edge connecting two nodes.\n    'illusion rate': The effect on energy required to travel between rooms due to the room's special properties.\n    'energy calculation': The energy needed to travel between two rooms is determined by the maximum of the absolute sums or differences of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a certain amount.\n    'at least as many times': Indicates that a value must appear at least as frequently as another value.\n\n# [degree adverb] \n    'largest': Indicates that the maximum or greatest value should be selected.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Represent the tree using a graph data structure.\n    2. Store the illusion rates for each room.\n    3. Handle queries of two types:\n        - Update the illusion rate of a specific room.\n        - Calculate the minimum energy required to travel from one room to another.\n    4. Use a depth-first search (DFS) or breadth-first search (BFS) to find the shortest path between rooms and calculate the energy based on the illusion rates.\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: There is only one room, so the energy required to travel from room 1 to room 2 is 0 since they are the same room.\n    Expected output: 0\n\n    Edge case 2:\n    Query: 2 1 3\n    Explanation: There are three rooms with illusion rates a = [5, 8, 3]. The energy required to travel from room 1 to room 3 is max(|5 + 3|, |5 - 3|) = max(8, 2) = 8.\n    Expected output: 8\n\n    Edge case 3:\n    Query: 1 2 10\n    Explanation: The illusion rate of room 2 is changed to 10. Now, the energy required to travel from room 1 to room 3 with illusion rates a = [5, 10, 3] is max(|5 + 3|, |5 - 3|) = max(8, 2) = 8.\n    Expected output: 8\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided can handle them directly. The edge cases are straightforward and do not require additional complexity.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 2, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 2}
