{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp's challenge lies in ensuring that the mean remains constant after removing exactly two elements from the array.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp's challenge lies in ensuring that the mean remains constant after removing exactly two elements from the array.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp needs to make sure that the average of the numbers in the array stays the same after he removes two elements from it.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp's challenge is to maintain the mean of the array after removing exactly two elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs_with_same_mean(arr: List[int], target_mean: float) -> int:\n    n = len(arr)\n    pair_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) > 0:\n                new_mean = sum(new_arr) / len(new_arr)\n                if new_mean == target_mean:\n                    pair_count += 1\n    \n    return pair_count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the mean of the entire array\noriginal_mean = sum(arr) / n\n\n# Calculate and print the result\nresult = calculate_pairs_with_same_mean(arr, original_mean)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], k: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a copy of the array excluding the elements at indices i and j\n            remaining_elements = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(remaining_elements) > 0:\n                # Calculate the mean of the remaining elements\n                remaining_mean = sum(remaining_elements) / len(remaining_elements)\n                # Check if the mean of the remaining elements is equal to k\n                if remaining_mean == k:\n                    count += 1\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate the mean of the original array\n    k = sum(arr) / n\n    # Calculate the number of pairs\n    result = calculate_pairs(arr, k)\n    # Output the result\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The input array of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef count_valid_pairs(arr: List[int], k: int) -> int:\n    \"\"\"\n    Count the number of valid pairs of positions in the array that, when removed, result in the mean of the remaining elements being equal to k.\n    \n    Args:\n        arr (List[int]): The input array of integers.\n        k (int): The target mean value.\n        \n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    n = len(arr)\n    if n == 3:\n        return 0\n    if all(x == arr[0] for x in arr):\n        return (n * (n - 1)) // 2\n    \n    count = 0\n    total_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == k:\n                count += 1\n    \n    return count\n\n# Main function to handle input/output\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        k = calculate_mean(arr)\n        result = count_valid_pairs(arr, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef find_pairs(arr, avg):\n    \"\"\"\n    This function calculates the number of pairs [i, j] such that removing the elements at these positions keeps the average of the array unchanged.\n    \n    Args:\n        arr (list): A list of integers representing the array.\n        avg (float): The average of the array.\n    \n    Returns:\n        int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    \n    # Iterate over all possible pairs [i, j]\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at positions i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Check if the new array has the same average\n            if sum(new_arr) / (n - 2) == avg:\n                count += 1\n    \n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    avg = sum(arr) / n\n    result = find_pairs(arr, avg)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_average(n: int, arr: List[int], k: float) -> int:\n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_avg = new_sum / (n - 2)\n            if new_avg == k:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    total_sum = sum(arr)\n    avg = total_sum / n\n    result = count_pairs_to_maintain_average(n, arr, avg)\n    print(result)\n", "from typing import List\n## main.py\n\ndef count_pairs_to_maintain_average(n, arr):\n    \"\"\"\n    This function calculates the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the (n - 2) remaining elements is equal to the mean of the original array.\n    \n    Args:\n    n (int): The number of elements in the array.\n    arr (list): A list of integers representing the array.\n    \n    Returns:\n    int: The number of pairs that maintain the average.\n    \"\"\"\n    # Calculate the average of the entire array\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new count after removing elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            \n            # Calculate the new average\n            new_average = new_sum / new_count\n            \n            # Check if the new average is equal to the original average\n            if new_average == original_average:\n                count += 1\n    \n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_average(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_mean_and_pairs(n, arr, k):\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    mean_of_array = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions [i, j] (i < j) in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the mean of the remaining elements\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to k\n            if new_mean == k:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    # Read the array elements\n    arr = list(map(int, input().strip().split()))\n    # Read the target mean k\n    k = float(input().strip())\n    # Calculate and print the result\n    result = calculate_mean_and_pairs(n, arr, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs_with_mean(n, arr, k):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining (n - 2) elements is equal to k.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers representing the array.\n        k (float): The target mean value.\n\n    Returns:\n        int: The number of pairs of positions that result in the mean of the remaining elements being equal to k.\n    \"\"\"\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at positions i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            \n            # Check if the new array has at least two elements\n            if len(new_arr) < 2:\n                continue\n            \n            # Calculate the mean of the new array\n            mean_new_arr = sum(new_arr) / len(new_arr)\n            \n            # Check if the mean of the new array is equal to k\n            if mean_new_arr == k:\n                count += 1\n    \n    return count\n\n# Read input from stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = float(input())\n    result = calculate_pairs_with_mean(n, arr, k)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_of_positions(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    if 0 in arr:\n        count_zeros = arr.count(0)\n        if count_zeros >= 2:\n            return (count_zeros * (count_zeros - 1)) // 2\n    \n    count = 0\n    seen_sums = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] == 0 and arr[j] == 0:\n                continue\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean and (new_sum, i, j) not in seen_sums:\n                count += 1\n                seen_sums.add((new_sum, i, j))\n    \n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_of_positions(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int], k: float) -> int:\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr:\n                new_mean = sum(new_arr) / (n - 2)\n                if new_mean == k:\n                    result += 1\n    return result\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = calculate_pairs(n, arr, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires iterating through all possible pairs and checking the condition.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all pairs of positions and check the condition.\n- Optimize the solution to handle large inputs efficiently.\n- Ensure the code is readable and maintainable.\nTo solve the problem of finding pairs of positions that, when removed, result in the mean of the remaining elements being equal to the original mean, we can follow these steps: \n1. Calculate the mean of the entire array. \n2. Iterate through all possible pairs of positions in the array. \n3. For each pair, calculate the mean of the remaining elements and check if it equals the original mean. \n4. Count the number of such pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When we remove two elements, the mean of the remaining elements should still be equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the value of the removed elements should be greater than zero.\n    Explanation: Since the elements are positive integers, we need to ensure that the sum of the remaining elements divided by the number of remaining elements equals the original mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest integer that appears more than once in the array.\n    Explanation: The requirement is to find the largest integer that appears at least as many times as itself, which implies finding the largest integer with the highest frequency.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the sum of the remaining elements and check if it equals the product of the mean and the number of remaining elements.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. There are no pairs of elements that, when removed, result in the mean of the remaining elements being 2.5.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The mean of the array is (2+2+4+4)/4 = 3. Removing any pair of elements that are the same will result in the mean of the remaining elements being 3. There are two such pairs: (0, 2) and (1, 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can be used to check for pairs of elements that, when removed, result in the mean of the remaining elements being equal to the original mean.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This involves iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Calculate the mean of the remaining elements after removing each pair\n- Compare the calculated mean with the given value k\n- Count the number of pairs that satisfy the condition\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to iterate through all possible pairs of positions in the array, calculate the mean of the remaining elements, and compare it to the given value k. We will use a brute-force approach to ensure we cover all pairs and calculate the mean efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the mean of the remaining elements should be equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'exactly': means that the condition must be met without any deviation.\n    Explanation: In this problem, we need to find pairs of positions where removing two elements results in the mean of the remaining elements being exactly the same as the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Count the number of pairs where the remaining mean is equal to the original mean.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. The only pair that, when removed, results in the mean of the remaining elements being 2.5 is removing elements 3 and 4.\n    search([5, 5, 5, 5]) = 6\n    Explanation: The original mean is (5+5+5+5)/4 = 5. There are 6 pairs that, when removed, result in the mean of the remaining elements being 5: (5,5), (5,5), (5,5), (5,5), (5,5), and (5,5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute-force approach will work efficiently for the given constraints.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Calculate the mean of the remaining elements after removing each pair\n- Compare the calculated mean with the given value k\n- Count and return the number of pairs that satisfy the condition\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to iterate through all possible pairs of positions in the array, calculate the mean of the remaining elements, and compare it to the given value k. We will use a function to calculate the mean of an array and iterate through all pairs of positions to find the valid ones.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. The goal is to find pairs of positions in the array where removing the elements at those positions results in the mean of the remaining elements being equal to a given value k.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 3, it should appear at least 3 times in the array to satisfy the condition.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears at least as many times as itself.\n    Explanation: If there are multiple integers that meet the condition, we need to return the largest one.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Compare the calculated mean with k and count the pairs that satisfy the condition.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: If the array has only 3 elements, there are no pairs to remove, so the output is 0.\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements in the array are the same, any pair of elements can be removed to maintain the mean. The number of such pairs is given by the combination formula (n choose 2).\n    Edge case 3: Large arrays with varying elements\n    Expected output: A specific count of pairs\n    Explanation: For large arrays with a mix of different elements, we need to count the pairs that, when removed, do not change the mean of the remaining elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 3:\n            return 0\n        if all(x == a[0] for x in a):\n            return (n * (n - 1)) // 2\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. This requires a thorough understanding of array manipulation and mathematical operations. The algorithm must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases, summing up to 2 * 10^5 elements in total.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a function to find pairs of positions [i, j] that, when removed, do not change the average of the array.\n- Ensure the program can handle multiple test cases efficiently.\n- Optimize the code for large inputs to prevent performance issues.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the average of the array and then finding pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. We will use a brute-force method initially to ensure correctness and then optimize it for better performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pair': a combination of two elements from the array\n    'mathematical mean': the sum of elements divided by the number of elements\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the remaining elements divided by the number of remaining elements equals the original average\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears at least as many times as itself\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element, so removing any two elements will change the average. The expected output is 0.\n    search([2, 2, 2, 2]) = 6\n    explanation: There are four elements, and we can remove any two elements in 6 different ways (e.g., removing the first two or the last two). The average remains the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly return the number of pairs for small arrays.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    (provide detailed logic to implement the code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that, when removed, will not change the average of the array. This involves understanding the sum of the array and the average, then checking the sum of the remaining elements after each pair removal. The solution must be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find all possible pairs of positions.\n- Ensure the solution is optimized for large inputs.\n- Add user interface elements for input and output.\n- Include a feature to handle multiple test cases efficiently.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the sum of the array and the average, then iterating through all possible pairs of positions to check if removing them changes the average. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements, representing the central tendency of the data.\n    Explanation: In this problem, we need to ensure that the average of the remaining elements after removing two is the same as the original average. This involves calculating the sum and average of the array and then checking pairs of elements to see if their removal maintains the original average.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where removing them does not change the average significantly.\n    'at least as many times': not directly applicable in this context, as we are looking for pairs that affect the average, not frequencies.\n\n# [degree adverb] \n    'largest': not directly applicable in this context, as we are looking for pairs that affect the average, not the size of the elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we need to:\n    1. Calculate the sum of the array.\n    2. Determine the original average.\n    3. Iterate through all pairs of positions in the array.\n    4. For each pair, calculate the new sum after removal and check if the new average is the same as the original average.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: The original average is (1+2+3+4+5)/5 = 3. Removing the elements at positions 1 and 3 (with values 2 and 4) leaves the sum as 1+3+5 = 9, and the average is 9/3 = 3, which matches the original average. This process is repeated for other pairs.\n    search([1, 1, 1, 1]) = 0\n    Explanation: The original average is (1+1+1+1)/4 = 1. No pair of elements can be removed to maintain the average of 1 since all elements are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where the array has all identical elements.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. This requires iterating through all possible pairs and checking if removing them changes the average. The challenge lies in handling large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Iterate through all pairs of positions and check if removing them changes the average.\n- Optimize the algorithm to handle large inputs within the given constraints.\n- Ensure the output matches the expected result for each test case.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the average of the array and then iterating through all possible pairs of positions to check if removing them changes the average. We will optimize the algorithm to handle large inputs efficiently by using efficient data structures and avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pair': a combination of two elements from a list\n    'removal': the action of removing two elements from a list\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where removing them changes the average\n\n# [degree adverb] \n    'largest': not applicable in this context\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    explanation: Since all elements are the same, removing any two elements will not change the average.\n    search([1, 2, 3, 4]) = 0\n    explanation: The average of the array is 2.5. There are no pairs that, when removed, will result in the average being 2.5 again.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find pairs already accounts for all elements being the same.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal results in the mean of the remaining elements being equal to k.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to k.\n- Ensure the solution is efficient enough to handle the upper limits of the input constraints.\n- Optimize the code for readability and maintainability.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to efficiently calculate the mean of the array and then find all pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to a given value k. We will use a brute-force approach initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the mean of the remaining elements should be calculated and compared to a given value k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'exactly': means that the condition must be met without any deviation.\n    Explanation: In this context, it means that the removal of two specific elements should result in the mean of the remaining elements being exactly equal to k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] (i < j) in the array.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the calculated mean equals k.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] with k = 3\n    Expected output: 2\n    Explanation: The possible pairs to remove are [0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]. The means of the remaining elements for pairs [0, 2] and [1, 3] are both 3.\n\n    Edge case 2: [1, 1, 1] with k = 1\n    Expected output: 1\n    Explanation: The only pair to remove is [0, 1]. The mean of the remaining elements is still 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute-force approach is sufficient for this problem.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Calculate the mean of the remaining elements after removing each pair\n- Compare the calculated mean with the target mean k\n- Count the number of pairs that satisfy the condition\nTo solve this problem, we will use Python due to its simplicity and powerful standard libraries. The main challenge is to efficiently calculate the mean of the remaining elements after removing any two elements from the array and compare it to a given target mean k. We will use a brute-force approach to iterate through all possible pairs of positions in the array, calculate the mean of the remaining elements, and count the pairs that match the target mean k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. When two elements are removed, the mean of the remaining elements should be calculated and compared to a given target mean k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. Calculate the mean of the remaining elements after removing the two specified positions.\n    4. Count the pairs that result in the mean of the remaining elements being equal to k.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3, as it appears 3 times.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3, as it appears 3 times.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        freq = {}\n        for num in lst:\n            freq[num] = freq.get(num, 0) + 1\n        max_num = max(lst)\n        result = -1\n        for num in range(1, max_num + 1):\n            if freq.get(num, 0) >= num:\n                result = num\n        return result\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that, when removed, result in the mean of the remaining elements being unchanged. This involves understanding the properties of means and how removing elements affects the overall average. The solution must be efficient and scalable to handle the upper limits of input size.\nrequirement pool:\n- Implement an algorithm to calculate the mean of the array before and after removing two elements.\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements across multiple test cases.\n- Optimize the algorithm for time complexity to ensure it performs well even with large inputs.\n- Design a user-friendly interface for input and output.\n- Conduct thorough testing to verify the accuracy and reliability of the solution.\nTo solve Monocarp's challenge efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through pairs of elements to check if removing them results in the same mean. We will use a list to store the array elements and a set to track the pairs that meet the criteria.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the mean of the remaining elements should be the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove exactly two elements from the array.\n    Explanation: This phrase indicates that we are specifically looking for pairs of positions [i, j] where i < j, and removing the elements at these positions should not change the mean of the array.\n\n# [degree adverb] \n    'exactly': means that the condition must hold true without any deviation.\n    Explanation: This adverb emphasizes that the mean of the remaining elements after removing two specific elements must be exactly equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array for each test case.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new mean of the remaining elements.\n    4. Count the number of pairs that result in the same mean as the original array.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: If there are exactly three elements in the array, there are no pairs to remove, so the output should be 0.\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements in the array are the same, removing any two elements will not change the mean. The number of such pairs is given by the binomial coefficient (n choose 2).\n    Edge case 3: Array contains zero\n    Expected output: (n choose 2)\n    Explanation: If the array contains zero, removing any two elements that are not zero will not change the mean. The number of such pairs is given by the binomial coefficient (n choose 2).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array contains zero. Specifically, we need to ensure that we do not consider pairs where both elements are zero, as removing them would change the mean.\n    Code for handling the edge case:\n    if 0 in a:\n        count = 0\n        for i in range(n):\n            if a[i] == 0:\n                count += 1\n        return (count * (count - 1)) // 2\n    (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Calculate the mean of the remaining elements after removing each pair\n- Compare the calculated mean with the given value k\n- Count and return the number of pairs that satisfy the condition\nTo solve this problem, we will use Python due to its simplicity and powerful standard libraries. The main challenge is to efficiently calculate the mean of the remaining elements after removing any two elements from the array and compare it with the given value k. We will use a brute-force approach to iterate through all possible pairs of positions and calculate the mean of the remaining elements. This approach is straightforward and ensures correctness but may not be the most efficient for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. After removing two elements, the mean of the remaining elements should be equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that the number of times a value appears in the array is greater than a specified amount.\n    'at least as many times': means that the number of times a value appears in the array is greater than or equal to a specified amount.\n\n# [degree adverb] \n    'largest': means the greatest or highest in value or rank.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Count the number of pairs where the mean of the remaining elements is equal to the original mean.\n\n# [edge case] \n    Edge case 1: [1, 2, 3], k = 2\n    Expected output: 0\n    Explanation: The original mean is (1+2+3)/3 = 2. Removing any two elements will result in an empty array or an array with one element, which cannot have a mean equal to 2.\n    Edge case 2: [4, 4, 4, 4], k = 4\n    Expected output: 6\n    Explanation: The original mean is (4+4+4+4)/4 = 4. There are 6 pairs of positions that can be removed to keep the mean constant: (0,1), (0,2), (0,3), (1,2), (1,3), and (2,3).\n    Edge case 3: [1, 3, 2, 6], k = 3\n    Expected output: 1\n    Explanation: The original mean is (1+3+2+6)/4 = 3. There is only one pair (0,2) that can be removed to keep the mean constant: (3+6)/2 = 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute-force approach is sufficient for these cases as they are straightforward and do not require additional logic beyond the core concept and the provided plan.\n"], "scores": [], "pass_results": [false, false, false, false, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 556, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 11}
