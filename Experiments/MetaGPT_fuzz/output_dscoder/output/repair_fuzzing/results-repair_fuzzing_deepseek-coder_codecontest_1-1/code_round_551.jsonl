{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has an array a composed of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to count the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are removed, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Focus on optimizing your approach for large values of n.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has an array a composed of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to count the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are removed, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Focus on optimizing your approach for large values of n.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array \\( a \\) consisting of \\( n \\) integers. The mean \\( k \\) of these elements is calculated as the sum of the elements divided by the number of elements, i.e., the sum divided by \\( n \\). Monocarp wants to remove exactly two elements from \\( a \\) such that the mean of the remaining \\( n - 2 \\) elements is still equal to \\( k \\). Your task is to find the number of pairs of positions \\([i, j]\\) (where \\( i < j \\)) where if the elements at these positions are removed, the mean of the remaining \\(\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers. The mean k of these elements is the sum of elements divided by the number of elements (i.e., sum divided by n). He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Count the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are removed, the mean of (n - 2) remaining elements is equal to k. Optimize for large values of n.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef count_pairs(n, arr):\n    if n <= 2:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    freq = {}\n    for num in arr:\n        diff = num - mean\n        if diff in freq:\n            count += freq[diff]\n            freq[diff] += 1\n        else:\n            freq[diff] = 1\n    \n    return count\n\n# Read input\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    arr = list(map(int, sys.stdin.readline().split()))\n    result = count_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    \n    # Create a frequency dictionary to count occurrences of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and mean after removing arr[i] and arr[j]\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef count_pairs_to_maintain_mean(n, arr):\n    \"\"\"\n    Counts the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (list of int): The array of integers.\n    \n    Returns:\n        int: The number of pairs [i, j] such that deleting the elements at these positions maintains the original mean.\n    \"\"\"\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == original_mean:\n                    count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    \n    # Create a frequency dictionary to count occurrences of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and mean after removing arr[i] and arr[j]\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The challenge lies in optimizing this for large inputs efficiently. The solution should be able to handle up to 2 * 10^5 elements and provide a result for each test case.\nrequirement pool:\n- Implement an efficient algorithm to count the pairs of positions that can be deleted to maintain the mean.\n- Ensure the solution is optimized for large inputs and performs well within time constraints.\n- Provide clear and accurate output for each test case.\n- Ensure the solution is scalable and can handle up to 2 * 10^5 elements.\nTo efficiently solve the problem of counting pairs of positions that can be deleted to maintain the mean, we will use a combination of mathematical analysis and algorithmic optimization. The key steps include calculating the mean of the array, identifying pairs of elements that, when removed, do not change the mean, and then counting these pairs efficiently. We will leverage Python's built-in functions and libraries to handle large datasets effectively.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    In the requirement, it refers to the sum of all elements in the array divided by the number of elements, which is a measure of central tendency.\n\n# [phrase showing quantity relationship]\n    'divided by the number of these elements': means the sum of elements is divided by the total number of elements in the array.\n\n# [degree adverb] \n    'exactly two': specifies that we need to remove exactly two elements from the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Count the pairs where the new mean is still equal to the original mean.\n    5. Optimize the process to handle large arrays efficiently.\n\n# [edge case] \n    Edge case 1:\n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, removing any two will change the mean, so no pairs can be counted.\n\n    Edge case 2:\n    n = 4, a = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The original mean is (1+2+3+6)/4 = 3. Removing the elements at indices 1 and 2 (values 2 and 3) results in a mean of (1+6)/2 = 3.5, which is not equal to the original mean. However, removing elements at indices 1 and 3 (values 2 and 3) results in a mean of (1+6)/2 = 3.5, which is not equal to the original mean. There is no pair that maintains the original mean after removal.\n\n    Edge case 3:\n    n = 5, a = [1, 2, 3, 4, 5]\n    expected output: 2\n    Explanation: The original mean is (1+2+3+4+5)/5 = 3. Removing the elements at indices 2 and 3 (values 3 and 4) results in a mean of (1+2+5)/3 = 2.67, which is not equal to the original mean. However, removing elements at indices 1 and 4 (values 2 and 4) results in a mean of (1+3+5)/3 = 3, which is equal to the original mean. Similarly, removing elements at indices 1 and 3 (values 2 and 3) results in a mean of (1+4+5)/3 = 3.33, which is not equal to the original mean. There are two pairs that maintain the original mean after removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n    To handle edge cases where n is very small or the array is not suitable for maintaining the mean, additional checks and conditions need to be implemented. This may include returning 0 or a specific number of pairs based on the array's composition and size.\n", "requirement analysis:\nThe primary requirement is to count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. This requires a solution that is both efficient and scalable, capable of handling large inputs efficiently. The solution should also be easy to understand and maintain, ensuring clarity in implementation and documentation.\nrequirement pool:\n- Implement a solution to count pairs of positions that maintain the mean after deletion.\n- Optimize the solution for large inputs to ensure minimal time complexity.\n- Ensure the solution is scalable and can handle increasing array sizes.\n- Provide clear and concise output for user understanding.\n- Compare and contrast with other solutions for performance benchmarks.\nTo efficiently count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array, we will use a mathematical approach to avoid the need for nested loops. We will first calculate the mean of the entire array and then iterate through all possible pairs (i, j) where i < j. For each pair, we will check if removing these elements results in the remaining elements having the same mean. This approach will be optimized by leveraging the properties of arithmetic mean and avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    The mean of a set of numbers is the sum of the numbers divided by the quantity of the numbers. In this problem, we need to find pairs of elements that, when removed, leave the remaining elements with the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'divided by': indicates that we need to perform a division operation to calculate the mean.\n\n# [degree adverb] \n    'exactly': means that we need to find pairs specifically, without over or under counting.\n\n# [code logic]\n    To implement this, we will:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. For each pair, check if removing these elements results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, removing any two will change the mean, so there are no valid pairs.\n\n    n = 4, a = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The mean of the array is (1+2+3+6)/4 = 3. Removing the elements at positions 1 and 3 (0-indexed) leaves [2, 3], which also has a mean of 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n is very large. Given the constraints, we should optimize the iteration through pairs to avoid a brute-force approach that would be too slow. Instead, we can use a more efficient method to count pairs that, when removed, maintain the mean.\n\n    For example, we can use a dictionary to count the frequency of each element and then iterate through possible sums of elements that, when removed, would maintain the mean. This approach significantly reduces the number of comparisons needed, making it feasible to handle large arrays efficiently.\n", "requirement analysis:\nThe primary requirement is to count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. This requires iterating through all possible pairs and checking if deleting them maintains the mean. The challenge lies in optimizing this for large values of n, which is constrained by the sum of n over all test cases not exceeding 2 \u22c5 10^5.\nrequirement pool:\n- Implement a solution to count pairs of positions that maintain the mean after deletion.\n- Optimize the solution for large values of n.\n- Ensure the solution is efficient and handles large inputs correctly.\nTo efficiently count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array, we can follow these steps: \n1. Calculate the mean of the entire array. \n2. For each pair (i, j), check if removing these elements results in the remaining elements having the same mean. \n3. To optimize for large values of n, we can use a hash map to store the frequency of the differences between the elements and the mean, which allows us to quickly determine if removing two elements results in the mean being preserved.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of elements in the array such that when these elements are removed, the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'divided by': Indicates the division operation used to calculate the mean.\n    Explanation: To find the mean, we divide the sum of all elements by the number of elements (n).\n\n# [degree adverb] \n    'exactly': Indicates the specific number of elements to be removed (exactly two in this case).\n    Explanation: We need to remove exactly two elements from the array to check if the mean of the remaining elements is still equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. For each pair, calculate the new sum and new count after removing the elements at positions i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    n = 3, array = [1, 2, 3]\n    expected output = 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have a mean equal to the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n is less than or equal to 2.\n        if n <= 2:\n            return 0\n        (other code)\n\n    This ensures that we do not attempt to count pairs of positions for arrays with fewer than three elements, as the problem requires at least three elements to remove two.\n", "requirement analysis:\nThe problem requires counting pairs of positions in an array where removing two elements results in the mean of the remaining elements being unchanged. This involves calculating the mean of the entire array and then checking each pair of elements to see if their removal maintains the same mean. Given the constraints, the solution must be optimized for large values of n, ensuring it can handle up to 2 * 10^5 elements efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions in the array\n- Check if removing the elements at these positions maintains the original mean\n- Count the number of such pairs\n- Ensure the solution is optimized for large inputs\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through all pairs of positions in the array to check if removing the elements at these positions maintains the original mean. We will optimize for large values of n by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of positions in the array such that removing the elements at these positions does not change the mean of the remaining elements. The mean of the original array is given and remains constant.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where removing the elements at these positions will not change the mean.\n\n# [degree adverb] \n    'exactly': means that we need to find pairs of positions where exactly two elements are removed, and the mean of the remaining elements is still equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at positions i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1], 2) = 6\n    Explanation: In this case, the array has four elements all equal to 1. The mean is 1. Removing any two elements will not change the mean. There are 6 possible pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).\n    search([5, 5, 5, 5], 4) = 0\n    Explanation: In this case, the array has four elements all equal to 5. The mean is 5. There are no pairs that can be removed to maintain the mean of 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases, including when all elements are the same.\n", "requirement analysis:\nThe primary requirement is to count the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being the same as the original mean. The challenge lies in optimizing this for large arrays where n can be as large as 2 * 10^5. The solution must be efficient and handle large inputs without timing out.\nrequirement pool:\n- Implement a solution that can handle large arrays efficiently\n- Ensure the solution is accurate and provides the correct number of pairs\n- Optimize the algorithm for time complexity\n- Implement error handling for invalid inputs\n- Provide detailed documentation and comments for code readability\nTo efficiently solve the problem of counting pairs of positions to delete for maintaining the mean, we will use Python's built-in data structures and algorithms. The key is to calculate the mean of the array once and then iterate through pairs of elements to check if their removal maintains the original mean. Given the constraints, we will optimize for time complexity by avoiding unnecessary computations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of elements in the array such that after their removal, the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of elements whose removal does not significantly affect the mean.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs that maintain the mean rather than the largest individual elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we can follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new mean of the remaining elements.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 6\n    Explanation: In this case, any pair of elements can be removed, and the mean of the remaining elements will still be 1. There are 6 possible pairs: [0,1], [0,2], [0,3], [1,2], [1,3], [2,3].\n    search([2, 2, 2, 2]) = 6\n    Explanation: Similar to the previous edge case, any pair of elements can be removed, and the mean of the remaining elements will still be 2. There are 6 possible pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to count all possible pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to count all possible pairs.\n", "requirement analysis:\nThe problem requires counting pairs of positions in an array where removing the elements at those positions results in the mean of the remaining elements being unchanged. This involves calculating the mean of the entire array and then checking each pair of positions to see if removing them results in the same mean. Given the constraints, the solution must be optimized for large inputs and efficient in terms of time complexity.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to count pairs of positions that can be removed to maintain the same mean\n- Ensure the solution is optimized for large inputs and handles edge cases\n- Provide clear and accurate output for each test case\n- Support for multiple test cases efficiently\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing those elements results in the mean remaining unchanged. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that removing the elements at these indices results in the mean of the remaining elements being equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of indices where removing the elements at these indices does not change the mean.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs of indices rather than a single largest value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The mean of [1, 2, 3] is 2. There are no pairs of indices [i, j] such that removing the elements at these indices results in the mean remaining unchanged.\n    search([2, 2, 2]) = 3\n    Explanation: The mean of [2, 2, 2] is 2. There are three pairs of indices [i, j] where i < j: [0, 1], [0, 2], and [1, 2]. Removing any two elements from this array will result in the mean remaining unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where the array has only three elements.\n", "requirement analysis:\nThe primary requirement is to count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean. This requires a solution that is both efficient and scalable, capable of handling up to 2 * 10^5 elements. The solution should avoid unnecessary computations and focus on optimizing for large input sizes.\nrequirement pool:\n- Implement an efficient algorithm to count pairs of positions that can be deleted to maintain the mean.\n- Ensure the solution is optimized for large input sizes, handling up to 2 * 10^5 elements.\n- Implement error handling to manage edge cases and unexpected inputs.\n- Provide clear and concise output, ensuring the number of pairs is accurately calculated.\nTo efficiently count the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean, we will use a Python script that processes each test case individually. We will calculate the mean of the array and then iterate through all possible pairs of indices (i, j) where i < j, checking if removing the elements at these positions results in the remaining elements having the same mean. This approach will be optimized to handle large values of n by avoiding unnecessary computations and focusing on the mathematical properties of the mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    The mean of a set of numbers is the sum of the numbers divided by the quantity of numbers. In this case, Monocarp wants to find pairs of elements to delete such that the mean of the remaining elements is the same as the original mean.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at positions i and j results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The mean of the array is (1+2+3)/3 = 2. There are no pairs [i, j] such that removing the elements at these positions results in the mean of the remaining elements being 2.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 2, 3]\n    Explanation: The mean of the array is (1+3+2+3)/4 = 2.25. The pairs [i, j] that can be removed to maintain the mean are [0, 2] and [1, 3] since removing 1 and 2 results in the mean being 2.25, and removing 3 and 3 also results in the mean being 2.25.\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3 and the array elements do not allow for any pair to be removed and still maintain the original mean.\n        if n < 3:\n            return 0\n\n    This check ensures that we do not process arrays with fewer than 3 elements, as the problem statement specifies n \u2265 3.\n", "requirement analysis:\nThe problem requires counting pairs of positions in an array where removing the elements at those positions results in the mean of the remaining elements being unchanged. This involves calculating the mean of the entire array and then checking each pair of positions to see if removing them results in the same mean. Given the constraints, the solution must be optimized for large inputs and efficient in terms of time complexity.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to count pairs of positions that can be removed to maintain the same mean\n- Ensure the solution is optimized for large inputs and handles edge cases\n- Provide clear and accurate output for each test case\n- Support for multiple test cases efficiently\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing those elements results in the mean remaining unchanged. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that removing the elements at these indices results in the mean of the remaining elements being equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of indices where removing the elements at these indices does not change the mean.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs of indices rather than a single largest value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The mean of [1, 2, 3] is 2. There are no pairs of indices [i, j] such that removing the elements at these indices results in the mean remaining unchanged.\n    search([2, 2, 2]) = 3\n    Explanation: The mean of [2, 2, 2] is 2. There are three pairs of indices [i, j] where i < j: [0, 1], [0, 2], and [1, 2]. Removing any two elements from this array will result in the mean remaining unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where the array has only three elements.\n", "requirement analysis:\nThe problem requires counting pairs of positions in an array where removing two elements results in the mean of the remaining elements being unchanged. This involves calculating the mean of the entire array and then checking each pair of elements to see if their removal maintains the same mean. Given the constraints, the solution must be optimized for large values of n, ensuring it can handle up to 2 * 10^5 elements efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions in the array\n- Check if removing the elements at these positions maintains the original mean\n- Count the number of such pairs\n- Ensure the solution is optimized for large inputs\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through all pairs of positions in the array to check if removing the elements at these positions maintains the original mean. We will optimize for large values of n by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of positions in the array such that removing the elements at these positions does not change the mean of the remaining elements. The mean of the original array is given and remains constant.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where removing the elements at these positions will not change the mean.\n\n# [degree adverb] \n    'exactly': means that we need to find pairs of positions where exactly two elements are removed, and the mean of the remaining elements is still equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at positions i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1], 2) = 6\n    Explanation: In this case, the array has four elements all equal to 1. The mean is 1. Removing any two elements will not change the mean. There are 6 possible pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).\n    search([5, 5, 5, 5], 4) = 0\n    Explanation: In this case, the array has four elements all equal to 5. The mean is 5. There are no pairs that can be removed to maintain the mean of 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases, including when all elements are the same.\n", "requirement analysis:\nThe problem requires counting pairs of positions in an array where removing two elements results in the mean of the remaining elements being unchanged. This involves calculating the mean of the entire array and then checking each pair of elements to see if their removal maintains the same mean. Given the constraints, the solution must be optimized for large values of n, ensuring it can handle up to 2 * 10^5 elements efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions in the array\n- Check if removing the elements at these positions maintains the original mean\n- Count the number of such pairs\n- Ensure the solution is optimized for large inputs\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through all pairs of positions in the array to check if removing the elements at these positions maintains the original mean. We will optimize for large values of n by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of positions in the array such that removing the elements at these positions does not change the mean of the remaining elements. The mean of the original array is given and remains constant.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where removing the elements at these positions will not change the mean.\n\n# [degree adverb] \n    'exactly': means that we need to find pairs of positions where exactly two elements are removed, and the mean of the remaining elements is still equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at positions i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1], 2) = 6\n    Explanation: In this case, the array has four elements all equal to 1. The mean is 1. Removing any two elements will not change the mean. There are 6 possible pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).\n    search([5, 5, 5, 5], 4) = 0\n    Explanation: In this case, the array has four elements all equal to 5. The mean is 5. There are no pairs that can be removed to maintain the mean of 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases, including when all elements are the same.\n"], "scores": [], "pass_results": [true, true, true, true, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 551, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 455}
