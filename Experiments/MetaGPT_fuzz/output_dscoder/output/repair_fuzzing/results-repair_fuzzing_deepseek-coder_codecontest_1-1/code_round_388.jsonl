{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp possesses an array a made up of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer).\n\nThe mean of a collection with n items is calculated by taking the sum of its elements and dividing by the count of the items (i.e., total divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements remains equal to k.\n\nYour task is to find out the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp possesses an array a made up of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer).\n\nThe mean of a collection with n items is calculated by taking the sum of its elements and dividing by the count of the items (i.e., total divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements remains equal to k.\n\nYour task is to find out the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers. The mean, k, of these elements is calculated by summing them up and dividing by the number of elements (n). Monocarp wants to remove two elements from this array a such that the mean of the remaining (n - 2) elements is still equal to k. Your task is to determine the number of pairs of positions [i, j] (where i is less than j) in the array a where if the elements at these positions are removed, the mean of the remaining (n - 2) elements will still be equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Find the number of pairs of positions [i, j] (i < j) where deleting the elements at these positions keeps the mean of the remaining elements equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_mean_and_pairs(n: int, arr: List[int]) -> int:\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining elements is equal to the mean of the original array.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (List[int]): The list of integers representing the array.\n        \n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting the pair [i, j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of the remaining elements is equal to the mean of the original array\n            if remaining_sum / remaining_count == mean:\n                count += 1\n    \n    return count\n\n# Read input from the user\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_mean_and_pairs(n, arr)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    if mean * 2 % 1 != 0:  # Check if the mean is not an integer\n        return 0\n    \n    target_mean = mean * 2\n    count = 0\n    freq = {}\n    \n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_sum = total_sum - arr[i] - arr[j]\n            if temp_sum / (n - 2) == target_mean:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    if all(x == arr[0] for x in arr):\n        # If all elements are the same, any two elements can be removed\n        return n * (n - 1) // 2\n    \n    pairs_counter = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                pairs_counter += 1\n    \n    return pairs_counter\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n, arr):\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If the mean is not an integer, no pairs can be removed to maintain the mean\n    if mean != int(mean):\n        return 0\n    \n    # Convert mean to integer for easier comparison\n    mean_int = int(mean)\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Use a set to keep track of the sums of the remaining elements after removing each pair\n    sum_set = set()\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_sum / (n - 2) == mean_int:\n                count += 1\n        # Add the sum of the current pair to the set\n        sum_set.add(total_sum - arr[i])\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nimport sys\n\ndef calculate_pairs(n, arr):\n    mean_value = sum(arr) / n\n    count = 0\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            remaining_sum = sum(arr) - arr[i] - arr[j]\n            remaining_count = n - 2\n            if remaining_sum / remaining_count == mean_value:\n                count += freq.get(arr[i], 0) * freq.get(arr[j], 0)\n    return count\n\n# Read input\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    arr = list(map(int, sys.stdin.readline().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\ninput = sys.stdin.readline\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) such that removing the elements at these positions\n    maintains the mean of the remaining elements unchanged.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] that maintain the mean.\n    \"\"\"\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n\n    # Initialize the count of valid pairs\n    count = 0\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate through all possible pairs (i, j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n\n            # Check if the mean of the remaining elements is still equal to the original mean\n            if remaining_sum / remaining_count == mean:\n                # Check if the remaining elements are still integers in the array\n                if remaining_sum / mean in element_count and element_count[remaining_sum / mean] > 0:\n                    count += 1\n\n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean_of_array = total_sum / n\n    count = 0\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate through all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new count after deleting arr[i] and arr[j]\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            if new_sum / new_count == mean_of_array:\n                count += 1\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_delete(n: int, arr: List[int]) -> int:\n    mean_value = sum(arr) / n\n    count = 0\n    sum_arr = sum(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_sum = sum_arr - arr[i] - arr[j]\n            if temp_sum / (n - 2) == mean_value:\n                count += 1\n\n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\nfrom itertools import combinations\n\ndef calculate_pairs_to_delete(n: int, arr: list) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    count = 0\n\n    for i, j in combinations(range(n), 2):\n        new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n        if len(new_arr) > 0:\n            new_mean = sum(new_arr) / len(new_arr)\n            if new_mean == original_mean:\n                count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    # Read the array elements\n    arr = list(map(int, input().strip().split()))\n    # Calculate and print the result\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the mean of the array and determine the number of pairs of positions that, when deleted, maintain the mean. The challenge lies in handling large datasets efficiently and ensuring the application is user-friendly.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a method to find pairs of positions to delete for maintaining the mean.\n- Ensure the application can handle large datasets efficiently.\n- Design a user-friendly interface for easy interaction.\n- Optimize performance for large datasets and ensure reliability.\nTo address the requirements, we will use Python due to its simplicity and efficiency for handling mathematical operations and data structures. We will calculate the mean of the array and then iterate through pairs of positions to check if deleting them maintains the mean. We will use a list to store the array elements and a nested loop to find pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements in a collection.\n    Explanation: The mean (average) of a set of numbers is calculated by dividing the sum of those numbers by the quantity of items in the set. In this case, Monocarp wants to find pairs of positions in an array such that the mean of the remaining elements is equal to the mean of the entire array after removing those elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to its value.\n    Explanation: In the requirement, we need to find pairs of positions [i, j] such that the mean of the remaining elements is equal to the mean of the original array. This involves checking if the sum of the remaining elements divided by the number of remaining elements equals the mean of the original array.\n\n# [degree adverb] \n    'equal to': means that the mathematical mean of the remaining elements should match the mathematical mean of the original array.\n    Explanation: The 'equal to' adverb is used to specify that the mean of the remaining elements after deleting two elements should be the same as the mean of the original array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements and check if their mean is equal to the calculated mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: The mean of the array is 3, but there are no pairs that can be removed to keep the mean unchanged since all elements are distinct and cannot be removed without changing the mean.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The mean of the array is 3, and we can remove two elements to keep the mean unchanged. There are two pairs that can be removed: [0, 1] and [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where no pairs can be removed to maintain the mean.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires a thorough understanding of mean calculations and efficient iteration through the array to find the pairs.\nrequirement pool:\n- Implement the mean calculation and pair finding logic\n- Ensure the solution is optimized for large inputs\n- Provide clear and concise output\n- Handle edge cases and ensure robustness\n- Test the solution with various inputs to validate accuracy\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of indices whose deletion does not change the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements in a collection.\n    Explanation: The mean (average) of a set of numbers is calculated by dividing the sum of those numbers by the quantity of items in the set. In this problem, Monocarp wants to find pairs of elements to delete such that the mean of the remaining elements remains the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to its value.\n    Explanation: For example, if we have an element with value 3, it must appear at least 3 times in the array for us to consider it.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that appears at least as many times as itself.\n    Explanation: In the context of the problem, we need to find the largest integer in the array that meets the condition of appearing at least as many times as its value.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through the array to count the frequency of each element.\n    3. Find the largest integer that appears at least as many times as itself.\n    4. Return the count of such integers or -1 if no such integer exists.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = -1\n    Explanation: In this case, no integer appears as many times as itself, so the function should return -1.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The integer 3 appears three times, which is more than its value, so the function should return 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to return -1 when no integer meets the condition.\n\n# [code logic]\n    Here's a Python function that implements the above logic:\n\n    ```python\n    def search(lst):\n        frequency = {}\n        for num in lst:\n            if num in frequency:\n                frequency[num] += 1\n            else:\n                frequency[num] = 1\n        \n        max_num = -1\n        for num, count in frequency.items():\n            if count >= num:\n                max_num = max(max_num, num)\n        \n        return max_num if max_num != -1 else -1\n    ```\n\n    This function first creates a frequency dictionary to count the occurrences of each number. Then, it iterates through the dictionary to find the largest number that appears at least as many times as its value. If no such number is found, it returns -1.\n", "requirement analysis:\nThe problem requires calculating the mean of an array and finding pairs of positions to delete such that the mean remains unchanged. This involves understanding the mathematical properties of the mean and implementing efficient algorithms to handle the constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find pairs of positions to delete\n- Ensure the solution is optimized for large inputs\n- Provide clear and concise output\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and mathematical calculations. The main challenge is to find pairs of positions that, when removed, do not change the mean of the remaining elements. We will iterate through the array, calculate the mean of the entire array, and then check each pair of elements to see if removing them results in the mean remaining unchanged. This approach will ensure that we handle the constraints given in the problem statement.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements in a collection.\n    Explanation: In the requirement, the mean of an array is calculated by taking the sum of its elements and dividing by the count of the items. Monocarp wants to delete exactly two elements from the array so that the mean of the remaining elements remains equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of elements in the array is greater than a certain threshold.\n    'at least as many times': means that the number of times a certain value appears is greater than or equal to a given number.\n\n# [degree adverb] \n    'largest': refers to the element with the highest value in the array.\n    'greatest': similar to 'largest', but used to describe the maximum value in a set of values.\n    'shortest': refers to the smallest value in a collection.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] (i < j) in the array.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs of elements that can be removed to keep the mean unchanged because all elements are distinct.\n    search([2, 2, 2, 2]) = 6\n    Explanation: All elements are the same, so removing any two elements will keep the mean unchanged. There are 6 possible pairs: [0,1], [0,2], [0,3], [1,2], [1,3], and [2,3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return n * (n - 1) / 2  # Number of ways to choose 2 elements from n\n\n    This code will ensure that we handle the edge case efficiently by avoiding unnecessary computations.\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements whose removal maintains the same mean. This involves iterating through the array to check each possible pair of positions. The challenge lies in handling large inputs efficiently without excessive memory usage or runtime.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when removed, maintain the original mean.\n- Ensure the solution is optimized for large inputs.\n- Develop a user-friendly interface for easy interaction.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, maintain the same mean. We will use a nested loop to check each possible pair of positions. This method ensures that we can handle large inputs efficiently without excessive memory usage or runtime.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that maintain the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions results in the mean of the remaining elements being equal to the original mean.\n    4. Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: No pair of elements can be removed to maintain the mean, as the mean of the array is not an integer.\n    search([1, 3, 5, 7, 9]) = 0\n    explanation: No pair of elements can be removed to maintain the mean, as the mean of the array is not an integer.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to check if the mean remains the same after removing a pair of elements is straightforward and does not require additional complexity for edge cases.\n\nPlease note that the edge cases provided in the example are not valid for this problem as stated, since the mean of the array must be an integer. Therefore, the edge cases provided do not apply directly. The correct edge cases should involve arrays where the mean is not an integer, as shown in the example.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] where removing the elements at these positions will not change the mean of the array. This requires summing the elements, calculating the mean, and then iterating through pairs to check if removing them changes the mean. The solution must be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through pairs of positions and check if removing them changes the mean.\n- Ensure the solution is optimized for large inputs.\n- Add user interface elements for input and output.\n- Implement error handling for invalid inputs.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing the elements at these positions will not change the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is calculated by summing all elements and dividing by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices where removing the elements at these positions will not change the mean of the remaining elements.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not comparing values directly.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at positions i and j results in the mean of the remaining elements being equal to the original mean.\n    4. Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The original mean is 4, and the pairs that can be removed to maintain this mean are [1, 2], [1, 3], and [2, 3].\n    search([1, 1, 1, 1]) = 6\n    explanation: All pairs can be removed to maintain the mean of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle arrays of any size.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle arrays of any size.\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements whose removal does not change the mean. This involves a two-step process: first, calculate the mean, and then iterate through all possible pairs to check if their removal maintains the mean. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Calculate the mean of the array.\n- Iterate through all pairs of elements and check if their removal maintains the mean.\n- Optimize the process for large inputs to ensure efficiency.\n- Ensure the solution is scalable and can handle the sum of n over all test cases up to 2 \u22c5 10^5.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. We will calculate the mean of the array once and then iterate through all possible pairs of elements to check if their removal maintains the mean. The key is to ensure that the solution is optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is calculated by summing all elements and dividing by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean of the remaining elements.\n\n# [degree adverb] \n    'largest': refers to finding the largest integers in the array that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The mean of the array is (1+2+3+4+5+6+7)/7 = 4. If we remove the elements at positions 1 and 3 (0-based index), we get [2, 4, 5, 6, 7] with a mean of (2+4+5+6+7)/5 = 4.5, which is not equal to the original mean. However, if we remove elements at positions 1 and 4, we get [1, 3, 5, 6, 7] with a mean of (1+3+5+6+7)/5 = 4, which is equal to the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        (code for handling the edge case)\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array where deleting two elements maintains the mean of the remaining elements. This involves calculating the mean of the array, then checking each pair of positions to see if their deletion does not change the mean. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions to delete.\n- Ensure the solution is optimized for large inputs.\n- Test the solution with various test cases to ensure correctness.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through all possible pairs of positions to check if deleting them maintains the mean. We will use a nested loop to iterate through each pair of positions and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of positions where deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. Check if deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element in the array, so there are no pairs to delete. The expected output is 0.\n    search([2, 2, 2, 2]) = 6\n    explanation: There are four elements in the array, and the mean is 2. We can delete any two elements to keep the mean the same. The possible pairs are [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3], giving us a total of 6 pairs.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only one element or all elements are the same.\n    For example, if the array has only one element, return 0 since there are no pairs to delete. If all elements are the same, return the number of elements choose 2 (nC2), which is n * (n - 1) / 2.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array where deleting two elements maintains the mean of the remaining elements unchanged. This involves calculating the mean of the entire array, then checking each pair of positions to see if their deletion does not change the mean. The challenge lies in the need for efficiency due to the potential size of the input.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all pairs of positions in the array.\n- Develop a check to verify if deleting two elements maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if deleting those positions maintains the mean. We will use a simple brute-force method to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': not explicitly mentioned in the requirement, but implied in the need to find pairs that maintain the mean after deletion.\n\n# [degree adverb] \n    'largest': not explicitly mentioned in the requirement, but implied in the need to find the largest number of pairs.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a brute-force approach to iterate through all possible pairs of positions and check if deleting those positions maintains the mean.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] that can be deleted to keep the mean unchanged.\n    search([2, 2, 2]) = 3\n    explanation: There are three pairs [0, 1], [0, 2], and [1, 2] that can be deleted to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. This can be done by checking if all elements in the array are equal and then calculating the number of pairs accordingly.\n\n    def search(lst):\n        if all(x == lst[0] for x in lst):\n            return len(lst) * (len(lst) - 1) // 2\n        # Other code for general case\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements. This can be done by checking the length of the array and handling the case separately.\n\n    def search(lst):\n        if len(lst) == 3:\n            return 1 if lst[0] == lst[1] == lst[2] else 0\n        # Other code for general case\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array where deleting two elements maintains the mean of the remaining elements unchanged. This involves calculating the mean of the entire array and then checking pairs of elements to see if their deletion does not alter the mean. The challenge lies in efficiently handling large inputs and ensuring the solution is scalable.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions where deleting two elements maintains the mean.\n- Ensure the solution is optimized for large inputs and handles edge cases.\n- Develop a user-friendly interface for input and output.\n- Test the solution against multiple test cases to ensure accuracy and reliability.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of elements to check if their deletion maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose deletion does not change the mean of the remaining elements.\n\n# [degree adverb] \n    'largest': refers to finding the largest integers in the array that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element that appears more than or equal to itself, which is 1.\n    search([2, 2, 3, 3, 3]) = 4\n    explanation: Both 2 and 3 appear more than or equal to themselves, but we need to count pairs. There are 4 pairs: (0, 2), (0, 3), (1, 2), and (1, 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly count the pairs based on the given logic.\n\nPlease note that the code logic and edge cases are not provided in the initial response due to the complexity of the problem. The focus was on identifying the core concepts, phrases, and degree adverbs as per the given format. For a complete solution, the actual implementation details would need to be provided.\n", "requirement analysis:\nThe primary requirement is to calculate the mean of the array and determine the number of pairs of positions that, when deleted, maintain the mean. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Calculate the mean of the array and identify pairs of positions to delete for maintaining the mean.\n- Ensure the solution is efficient and can handle up to 2 * 10^5 elements across multiple test cases.\n- Provide a user-friendly interface for easy understanding and usage.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and calculations. The key steps include reading the input, calculating the mean, and then iterating through the array to find pairs of positions that, when deleted, maintain the mean. We will use a list to store the array elements and perform the necessary calculations.\nPlease read and understand the following inteperation before coding\n Based on the provided plan and requirement, here is the analysis and breakdown of the coding plan:\n\n# [core concept]\n    'mathematic mean': This refers to the average of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: The mathematic mean (average) of an array is calculated by summing all the elements and dividing by the number of elements. Monocarp wants to delete exactly two elements from the array such that the mean of the remaining elements remains the same.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that a certain condition must be met by a certain quantity.\n    Explanation: In this context, 'more than' is used to indicate that the number of elements being deleted (2) is less than the total number of elements in the array (n), and the mean of the remaining elements should be equal to the original mean.\n\n# [degree adverb] \n    'exactly': This adverb specifies the exact number of elements to be deleted.\n    Explanation: 'Exactly' means that only two elements are to be deleted from the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests the following steps:\n    1. Read the input for each test case, including the number of elements and the array elements.\n    2. Calculate the mean of the array elements.\n    3. Iterate through all possible pairs of indices in the array.\n    4. For each pair, calculate the mean of the remaining elements after deleting the two specified elements.\n    5. Compare the calculated mean with the original mean and count the pairs that maintain the mean.\n    6. Output the count of such pairs for each test case.\n\n# [edge case] \n    Edge case 1: n = 3, array = [3, 3, 3]\n    Expected output: 1\n    Explanation: Since all elements are the same, deleting any two elements will not change the mean. There is only one pair to consider: [0, 1], [0, 2], or [1, 2].\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 0\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. There is no way to delete two elements such that the mean of the remaining elements is still 2.5.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    Expected output: 3\n    Explanation: The mean of the array is (1+2+3+4+5)/5 = 3. Possible pairs to delete are [0, 1], [0, 2], [1, 2], [0, 3], [1, 3], [2, 3], [0, 4], [1, 4], [2, 4], [3, 4].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle these cases correctly.\n\nThis analysis provides a detailed breakdown of the requirement, the core concepts, the quantity relationships, the degree adverbs, the logic needed to implement the code, and the identification of edge cases.\n"], "scores": [], "pass_results": [false, true, true, true, false, false, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 388, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 299}
