{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp wonders if there is a way to find these pairs efficiently instead of manually checking each combination.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp wonders if there is a way to find these pairs efficiently instead of manually checking each combination.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp wonders if there is a way to find these pairs more quickly, rather than checking each pair one by one.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp wants to find pairs efficiently without manually checking each combination.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # Initialize the result counter\n    result_count = 0\n    \n    # Iterate through all possible pairs of positions (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Calculate the mean of the remaining elements\n            if remaining_count > 0:\n                remaining_mean = remaining_sum / remaining_count\n                \n                # Check if the mean of the remaining elements is equal to the original mean\n                if remaining_mean == original_mean:\n                    result_count += 1\n    \n    return result_count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    result = find_pairs(n, arr, float(input()))\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    pair_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == k:\n                    pair_count += 1\n    \n    return pair_count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nk = float(input())\nresult = find_pairs(n, arr, k)\nprint(result)\n", "from typing import List\ndef find_pairs(arr: list, k: float) -> int:\n    n = len(arr)\n    pair_count = 0\n    \n    # Calculate the sum of all elements in the array\n    total_sum = sum(arr)\n    \n    # Iterate through all possible pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the pair (i, j)\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == k:\n                pair_count += 1\n    \n    return pair_count\n\n# Read input from stdin\nn = int(input())\narr = list(map(int, input().split()))\nk = sum(arr) / n\n\n# Call the function and print the result\nresult = find_pairs(arr, k)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    if n < 3:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                if sum(new_arr) / (n - 2) == k:\n                    count += 1\n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nk = sum(arr) / n\n\n# Call the function and print the result\nresult = find_pairs(n, arr, k)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int], k: float) -> int:\n    if n < 3:\n        return 0\n    \n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # Initialize the count of pairs\n    pair_count = 0\n    \n    # Use a set to store the expected value after deleting each pair\n    expected_values = set()\n    \n    # Iterate through all possible pairs of positions (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting a_i and a_j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of the remaining elements is equal to k\n            if remaining_sum / remaining_count == original_mean:\n                pair_count += 1\n    \n    return pair_count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nk = float(input())\nresult = find_pairs_to_maintain_mean(n, arr, k)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    count = 0\n    seen_sums = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            if new_n > 0 and new_sum / new_n == k:\n                count += 1\n            seen_sums[(i, j)] = new_sum\n    \n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nk = sum(arr) / n\nresult = find_pairs(n, arr, k)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    target_mean = k * (n - 2)\n    \n    if total_sum == target_mean:\n        return n * (n - 1) // 2\n    \n    count_map = {}\n    result = 0\n    \n    for i in range(n):\n        for j in range(i + 2, n):\n            subarray_sum = total_sum - arr[i] - arr[j]\n            if subarray_sum == target_mean:\n                result += 1\n            count_map[subarray_sum] = count_map.get(subarray_sum, 0) + 1\n    \n    return result\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nk = float(input())\nresult = find_pairs(n, arr, k)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    # Calculate the original mean of the array\n    original_mean = sum(arr) / n\n    \n    # If the original mean is not equal to k, no pairs can satisfy the condition\n    if original_mean != k:\n        return 0\n    \n    # Initialize a counter for the number of valid pairs\n    count = 0\n    \n    # Use a hash map to keep track of the sums of subarrays\n    sum_map = {}\n    \n    # Calculate the sum of the entire array\n    total_sum = sum(arr)\n    \n    # Iterate through possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            \n            # Check if the new mean is equal to k\n            if new_sum / (n - 2) == k:\n                count += 1\n    \n    return count\n\n# Read input from the user\nn = int(input())\narr = list(map(int, input().split()))\nk = float(input())\n\n# Call the function and print the result\nresult = find_pairs(n, arr, k)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    mean_of_array = total_sum / n\n    \n    # If the mean of the array is not equal to k, we can immediately return 0\n    if mean_of_array != k:\n        return 0\n    \n    # Initialize a hash map to store counts of differences\n    diff_count = {}\n    result = 0\n    \n    # Iterate through the array to find pairs of positions\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new count after deleting elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            \n            # Calculate the new mean\n            new_mean = new_sum / new_count\n            \n            # Check if the new mean is equal to k\n            if new_mean == k:\n                # Create a tuple representing the pair (i, j)\n                pair = tuple(sorted((i, j)))\n                \n                # Increment the count in the hash map\n                if pair in diff_count:\n                    diff_count[pair] += 1\n                else:\n                    diff_count[pair] = 1\n    \n    # The result is the number of unique pairs that satisfy the condition\n    result = len(diff_count)\n    return result\n\n# Read input from the user\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the mean of the array\ntotal_sum = sum(arr)\nmean_of_array = total_sum / n\n\n# Find and print the number of pairs\nresult = find_pairs(n, arr, mean_of_array)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(arr: List[int], k: float) -> int:\n    n = len(arr)\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n    \n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nk = sum(arr) / n\nresult = find_pairs(arr, k)\nprint(result)\n"], "plans": ["requirement analysis:\nThe requirement involves finding pairs of positions in an array such that the deletion of these positions does not change the mean of the remaining elements. This is a complex task that requires efficient computation. The input size can be large, up to 2 * 10^5 elements, making the problem challenging. The solution must be scalable and efficient to handle such large inputs.\nrequirement pool:\n- Implement an efficient algorithm to find pairs of positions that do not change the mean of the array.\n- Ensure the algorithm can handle large inputs efficiently.\n- Optimize the code to minimize computation time and memory usage.\nTo efficiently find pairs of positions that do not change the mean of the array, we will use a combination of mathematical analysis and algorithmic optimization. We will leverage Python's built-in data structures and libraries to ensure the solution is both efficient and scalable. The algorithm will involve calculating the mean of the entire array and then checking pairs of positions to see if their deletion results in a mean equal to the original mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In the requirement, we need to find pairs of positions in an array such that deleting those positions does not change the mean of the remaining elements. The mean of the entire array is a key concept as we need to compare the mean of the remaining elements to this value.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where deleting them does not change the mean.\n    Explanation: The phrase 'more than' is used to indicate that we are looking for pairs of positions where the deletion does not affect the mean of the array. This means that the sum of the elements at these positions should be equal to the sum of the elements not at these positions, scaled by the factor of the number of elements not deleted.\n\n# [degree adverb] \n    'efficiently': means that we need to find pairs of positions quickly and with minimal computational overhead.\n    Explanation: The adverb 'efficiently' emphasizes the need for an optimized approach to find pairs of positions that do not change the mean. This implies that the solution should be designed to handle large inputs within reasonable time constraints.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j results in the mean of the remaining elements being equal to the original mean.\n    4. Count the number of such pairs and return the count.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it is impossible to delete any pair of elements and have the mean of the remaining elements equal to the original mean.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The mean of the array is 3. Deleting the pair (1, 3) leaves [2, 6] with a mean of 4, which is not equal to 3. Deleting the pair (1, 2) leaves [3, 6] with a mean of 4.5, which is not equal to 3. Deleting the pair (2, 3) leaves [1, 6] with a mean of 3.5, which is not equal to 3. Deleting the pair (1, 6) leaves [2, 3] with a mean of 2.5, which is not equal to 3. Deleting the pair (2, 6) leaves [1, 3] with a mean of 2, which is not equal to 3. Deleting the pair (3, 6) leaves [1, 2] with a mean of 1.5, which is not equal to 3. There is no pair of positions that, when deleted, results in the mean of the remaining elements being equal to 3.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    expected output: 3\n    Explanation: The mean of the array is 3. Deleting the pair (1, 2) leaves [3, 4, 5] with a mean of 4, which is not equal to 3. Deleting the pair (1, 3) leaves [2, 4, 5] with a mean of 3.5, which is not equal to 3. Deleting the pair (1, 4) leaves [2, 3, 5] with a mean of 3.33, which is not equal to 3. Deleting the pair (1, 5) leaves [2, 3, 4] with a mean of 3, which is not equal to 3. Deleting the pair (2, 3) leaves [1, 4, 5] with a mean of 3.33, which is not equal to 3. Deleting the pair (2, 4) leaves [1, 3, 5] with a mean of 3, which is not equal to 3. Deleting the pair (2, 5) leaves [1, 3, 4] with a mean of 2.67, which is not equal to 3. Deleting the pair (3, 4) leaves [1, 2, 5] with a mean of 2.67, which is not equal to 3. Deleting the pair (3, 5) leaves [1, 2, 4] with a mean of 2.33, which is not equal to 3. Deleting the pair (4, 5) leaves [1, 2, 3] with a mean of 2, which is not equal to 3. There are three pairs of positions that, when deleted, result in the mean of the remaining elements being equal to 3: (1, 5), (2, 4), and (3, 5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic should be sufficient to find pairs of positions that do not change the mean of the array.\n", "requirement analysis:\nThe primary requirement is to find pairs of positions in an array such that deleting these positions results in the mean of the remaining elements being equal to a given value k. The solution must be efficient and scalable to handle large inputs efficiently.\nrequirement pool:\n- Implement an efficient algorithm to find pairs of positions that meet the given condition.\n- Ensure the solution can handle large inputs within a reasonable time frame.\n- Develop a user-friendly interface for easy interaction.\n- Optimize the algorithm to minimize computation time.\nTo efficiently find pairs of positions in an array such that deleting these positions results in the mean of the remaining elements being equal to a given value k, we will use Python's built-in libraries and optimize the algorithm to minimize computation time. The approach involves iterating through the array to calculate the mean of all elements and then checking pairs of positions to see if their deletion results in the remaining elements having the same mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. For a set of numbers, the mean is calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'as many times': Indicates a comparison between the frequency of an element and its value.\n\n# [degree adverb] \n    'largest': Indicates the maximum value sought among a set of numbers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves:\n    1. Calculating the mean of the entire array.\n    2. Iterating through all possible pairs of positions (i, j) where i < j.\n    3. Checking if deleting the elements at positions i and j results in the remaining elements having the same mean as the original array.\n    4. Counting the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to delete two elements and still have a mean of k for the remaining element.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The mean of the array is 2.5. The only pair (0, 3) results in the remaining elements having a mean of 2.5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    This ensures that the function immediately returns 0 for the smallest possible array size, as no pairs can be formed.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array such that deleting these positions maintains the mean of the array. This requires calculating the mean of the entire array and then checking each pair to see if their deletion maintains the mean. The challenge lies in the efficiency of this process, especially given the constraints on the size of the input.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all pairs of positions in the array.\n- Develop a check to see if deleting a pair of positions maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Provide user feedback on the performance of the solution.\nTo efficiently find pairs of positions in an array that maintain the mean after deletion, we will use Python's built-in functions and libraries. The key steps include calculating the mean of the array, iterating through all possible pairs, and checking if the deletion of these pairs maintains the mean. We will optimize the solution by leveraging Python's efficient list operations and avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements\n    'efficiently find pairs': find pairs of positions in an array that maintain the mean after deletion\n\n# [phrase showing quantity relationship]\n    'the number of elements': means the total count of elements in the array\n    'the sum of n over all testcases': means the total number of elements across all testcases\n\n# [degree adverb] \n    'efficiently': means the solution should be optimized and not require manual checking of each combination\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Calculate the mean of the array\n    - Iterate through all possible pairs of positions [i, j] where i < j\n    - Check if the deletion of these pairs maintains the mean\n    - Count the number of such pairs\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only 3 elements, there are no pairs to delete, so the output is 0.\n\n    n = 4, a = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The mean of the array is (1+2+3+6)/4 = 3. If we delete the pairs (1, 3) or (2, 6), the remaining elements' mean is still 3. So, there is 1 pair that maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for finding pairs already accounts for the minimum array size of 3.\n", "requirement analysis:\nThe problem requires finding pairs of elements in an array that can be deleted to maintain the same mean. This involves calculating the mean of the entire array and then checking pairs to see if their deletion maintains the same mean. The challenge lies in the efficiency of finding these pairs, especially given the constraints on the size of the array.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of elements that can be deleted to maintain the same mean.\n- Optimize the function to handle large arrays efficiently.\n- Consider parallel processing or GPU acceleration for even greater scalability.\n- Implement a hybrid approach combining different algorithms for optimal performance.\nTo efficiently find pairs of elements in an array that can be deleted to maintain the same mean, we will use a mathematical approach that avoids brute force methods. We will calculate the mean of the entire array and then use a hash map to store the counts of the differences between the elements and the mean. This will allow us to quickly find pairs that, when deleted, maintain the same mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. It is calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of positions in an array such that deleting those positions results in the remaining elements having the same mean as the original array. The mean of the original array is given by the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the value of the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': Indicates that we are looking for the largest integer that meets the condition.\n    Explanation: In the requirement, we need to find the largest integer that appears at least as many times as itself in the list.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To efficiently find pairs of elements in an array that can be deleted to maintain the same mean, we will use a mathematical approach that avoids brute force methods. We will calculate the mean of the entire array and then use a hash map to store the counts of the differences between the elements and the mean. This will allow us to quickly find pairs that, when deleted, maintain the same mean.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = -1\n    Explanation: In this case, there is no integer that appears as many times as itself, so the function should return -1.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number among them.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears once, number 3 appears twice, and number 4 appears three times. None of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array such that deleting these positions maintains the same mean of the remaining elements. This requires calculating the mean of the entire array and then checking each pair to see if their deletion maintains this mean. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that can be deleted to maintain the same mean.\n- Ensure the solution is optimized for large inputs.\n- Add error handling for invalid inputs.\n- Include user documentation for easy understanding and usage.\nTo efficiently find pairs of elements in an array that can be deleted to maintain the same mean, we will use Python's built-in libraries and optimize the process using efficient algorithms. The key steps include calculating the mean of the array, iterating through pairs of positions, and checking if deleting these positions maintains the same mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In the requirement, we need to find pairs of positions in an array such that deleting these positions maintains the same mean of the remaining elements. This involves calculating the mean of the entire array and then checking pairs of elements to see if their deletion does not change the mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the deletion of elements does not change the mean.\n    'at least as many times': not directly mentioned in the requirement, but implied in the context of maintaining the mean.\n\n# [degree adverb] \n    'largest': not directly mentioned in the requirement, but implied in the context of finding the most significant pairs.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To efficiently find pairs of elements that can be deleted to maintain the same mean, we can follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j maintains the same mean for the remaining elements.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's impossible to delete any pair and maintain the same mean.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The mean of the array is 3. Deleting the pair (1, 3) leaves [2, 6] with a mean of 4, which is not equal to 3. However, deleting the pair (2, 3) leaves [1, 6] with a mean of 3.5, which is not equal to 3 either. There is no pair that can be deleted to maintain the same mean.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    expected output: 3\n    Explanation: The mean of the array is 3. Possible pairs that can be deleted to maintain the same mean are (0, 3), (1, 2), and (1, 4).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array such that the removal of these positions does not significantly alter the mean of the array. This involves calculating the mean of the entire array and then checking each pair to see if their removal results in a mean close to the original mean. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions in the array.\n- Ensure the function can handle large inputs efficiently.\n- Optimize the algorithm for performance.\n- Provide clear and concise output for each test case.\nTo efficiently find pairs of positions in an array that affect the mean, we will use a combination of mathematical calculations and efficient data structures. The approach involves calculating the mean of the entire array and then using a hash map to quickly check if the sum of the remaining elements after removing a pair matches the expected mean. This method ensures that we can handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In the requirement, we need to find pairs of positions in an array such that the mean of the remaining elements after removing those positions equals a given value k. This involves calculating the mean of the entire array and then checking if the mean of the remaining elements matches this value.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where the removal affects the mean.\n    Explanation: The phrase 'more than' is not explicitly mentioned in the requirement, but the need to find pairs that affect the mean implies a comparison of the mean before and after the removal of elements.\n\n# [degree adverb] \n    'quickly': means that we need an efficient method to find the pairs, rather than checking each pair one by one.\n    Explanation: The requirement asks for a more efficient approach than checking each possible pair, suggesting that a faster method is needed to solve the problem.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To efficiently find pairs of positions in an array that affect the mean, we will use a combination of mathematical calculations and efficient data structures. The approach involves:\n    1. Calculating the mean of the entire array.\n    2. Using a hash map to quickly check if the sum of the remaining elements after removing a pair matches the expected mean.\n    3. Iterate through the array to find all possible pairs and check the condition.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's not possible to remove any pair to affect the mean, so the output is 0.\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    expected output: 1\n    Explanation: The mean of the array is 2.5. Removing the pair (1, 3) leaves [2, 4] with a mean of 3, which matches the expected mean.\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    expected output: 2\n    Explanation: The mean of the array is 3. Removing the pair (1, 4) leaves [2, 3, 5] with a mean of 3.33, which does not match the expected mean. Similarly, removing (2, 3) leaves [1, 4, 5] with a mean of 3.33, which also does not match.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can be extended to check all possible pairs and their effects on the mean, including the edge cases.\n", "requirement analysis:\nThe requirement is to find pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to a given value k. The solution should be efficient and scalable to handle large inputs within the given constraints.\nrequirement pool:\n- Implement an efficient algorithm to find pairs of positions.\n- Ensure the solution handles large inputs within the given constraints.\n- Optimize the performance to meet the time complexity requirements.\n- Provide accurate results for the number of pairs.\n- Ensure the solution is scalable and efficient.\nTo efficiently find pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to a given value k, we will use a combination of mathematical calculations and efficient data structures. We will iterate through the array and use a hash map to keep track of the sums of subarrays and their counts. This approach will allow us to avoid manual checking of each combination and handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    In the requirement, it refers to the average of the numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the mean of the remaining elements is greater than k.\n    'at least as many times': suggests that the count of the elements in the pair should be such that when removed, the mean of the remaining elements equals k.\n\n# [degree adverb] \n    'efficiently': emphasizes the need for a method that can handle large inputs without manual checking, ensuring speed and scalability.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To efficiently find pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to a given value k, we will:\n    1. Iterate through the array to calculate the sum of all elements.\n    2. For each element, calculate the potential sum of the subarray that would result in the mean of the remaining elements being equal to k.\n    3. Use a hash map to store the counts of these potential sums.\n    4. Iterate through the array again to find pairs that satisfy the condition.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, array = [1, 2, 3], k = 2\n    Explanation: The sum of the array is 6. The mean of the array is 2. There are no pairs [i, j] such that deleting elements at these positions results in the mean of the remaining elements being equal to 2.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, array = [1, 3, 2, 3], k = 2\n    Explanation: The sum of the array is 9. The mean of the array is 2.25. The pairs [i, j] that satisfy the condition are [0, 2] and [1, 3].\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe requirement is to find pairs of positions [i, j] such that the deletion of these positions results in the mean of the remaining elements being equal to a given value k. The solution should be efficient and scalable to handle up to 2 \u22c5 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement an efficient algorithm to find pairs of positions [i, j] such that the deletion results in the mean of the remaining elements being equal to k.\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements across multiple test cases.\n- Optimize the algorithm for minimal computation time.\nTo efficiently find pairs of positions [i, j] such that the deletion of these positions results in the mean of the remaining elements being equal to a given value k, we will use a combination of mathematical analysis and algorithmic optimization. We will leverage the properties of means and use a hash map to keep track of the counts of the sums of subarrays. This approach will allow us to avoid manual checking of each combination and ensure scalability to handle large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    In the requirement, it refers to the average of the numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the deletion of two positions results in the mean of the remaining elements being greater than k.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To efficiently find pairs of positions [i, j] such that the deletion of these positions results in the mean of the remaining elements being equal to a given value k, we will use a combination of mathematical analysis and algorithmic optimization. We will leverage the properties of means and use a hash map to keep track of the counts of the sums of subarrays. This approach will allow us to avoid manual checking of each combination and ensure scalability to handle large inputs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], k=3) = 2\n    Explanation:\n    The original array mean is (1+2+3+4+5)/5 = 3. We can delete the pairs [0, 2] and [1, 3] to get a mean of 3 for the remaining elements.\n    search([1, 3, 2, 4, 5], k=3) = 1\n    Explanation:\n    The original array mean is (1+3+2+4+5)/5 = 3. We can delete the pair [0, 2] to get a mean of 3 for the remaining elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic should work for the given constraints.\n", "requirement analysis:\nThe primary requirement is to find pairs of positions efficiently without manually checking each combination. The solution should be scalable and handle large inputs within the given constraints. The output should be an integer representing the number of such pairs.\nrequirement pool:\n- Implement an efficient algorithm to find pairs of positions.\n- Ensure the solution is scalable and can handle large inputs.\n- Optimize the solution for minimal computational time and space complexity.\n- Ensure the solution is user-friendly and easy to understand.\nTo efficiently find pairs of positions in an array such that deleting the elements at these positions results in the remaining elements having the same mean, we can use a mathematical approach. We will iterate through the array and calculate the mean of the entire array. Then, for each pair of positions, we will check if deleting these positions results in the remaining elements having the same mean as the original array. This approach will be optimized using a hash map to store the counts of the differences between the elements and the target mean, which helps in efficiently counting the pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. For a set of n numbers, the mean is calculated by summing all the numbers and then dividing by n.\n    Explanation: In this problem, we need to find pairs of positions in an array such that deleting the elements at these positions results in the remaining elements having the same mean as the original array. This involves calculating the mean of the entire array and then checking if the mean of the remaining elements (after deleting two specific positions) is equal to this value.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the deletion of elements results in the remaining elements having the same mean.\n    Explanation: The phrase \"more than\" is used to indicate that we need to find pairs where the deletion of elements results in the remaining elements having the same mean as the original array. This means we need to check pairs of positions and ensure that the mean of the remaining elements is equal to the mean of the original array.\n\n# [degree adverb] \n    'efficiently': Indicates that we need to find pairs without manually checking each combination, which is crucial given the constraints of the problem.\n    Explanation: The adverb \"efficiently\" means that we need to use an optimized approach to find pairs of positions in the array. This involves using a mathematical approach and a hash map to store the counts of the differences between the elements and the target mean, which helps in efficiently counting the pairs.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through the array and calculating the mean of the entire array. Then, for each pair of positions, checking if deleting these positions results in the remaining elements having the same mean as the original array. This can be optimized using a hash map to store the counts of the differences between the elements and the target mean.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to delete two elements and still have the remaining element have the same mean as the original array. Therefore, the number of pairs is 0.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. The only pair that satisfies the condition is deleting elements at positions 1 and 3 (1 and 3 are the only elements not equal to the mean), leaving [2, 3] with a mean of 2.5.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    Expected output: 2\n    Explanation: The mean of the array is (1+2+3+4+5)/5 = 3. The pairs that satisfy the condition are deleting elements at positions 1 and 3 (1 and 3 are the only elements not equal to the mean), leaving [2, 4, 5] with a mean of 3. Similarly, deleting elements at positions 1 and 4 or 2 and 3 also result in a mean of 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can be used to find pairs of positions that satisfy the condition, and the edge cases provided are straightforward to handle within the given logic.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array such that deleting these pairs maintains the mean of the remaining elements unchanged. This requires calculating the mean of the entire array and then checking each pair to see if their deletion does not change the mean. The challenge lies in efficiently handling large inputs and ensuring the solution is scalable.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that can be deleted without changing the mean.\n- Ensure the solution is efficient and can handle large inputs.\n- Optimize the algorithm for better performance.\n- Scale the solution to handle even larger inputs.\nTo efficiently find pairs of positions in an array that can be deleted to maintain the same mean, we will use Python's built-in libraries and optimize the solution using efficient algorithms. The key steps include calculating the mean of the array, iterating through pairs of positions, and checking if deleting these pairs maintains the mean. We will use a simple and scalable approach to ensure the solution can handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. In this context, it refers to the mean of the entire array and the mean of the array after removing two elements.\n    Explanation: The mean is calculated by summing all the elements in the array and dividing by the number of elements. The goal is to find pairs of positions in the array where deleting those positions results in the mean of the remaining elements being equal to a given value k.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of elements in the array is greater than a certain threshold.\n    Explanation: In this case, the array must have more than 3 elements to form pairs.\n\n# [degree adverb] \n    'efficiently': Indicates that the solution should be optimized for large inputs and should not be solved manually.\n    Explanation: The solution should use efficient algorithms and built-in libraries to handle large inputs efficiently.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves calculating the mean of the array and then iterating through pairs of positions to check if deleting those positions maintains the mean. This can be done efficiently using nested loops to check all pairs of positions.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: With only 3 elements, it is impossible to delete any pairs to maintain the mean, so the output is 0.\n    Edge case 2: All elements are the same\n    Expected output: The number of pairs that can be formed with the same element.\n    Explanation: If all elements are the same, any pair of the same element will maintain the mean. The number of such pairs is given by the combination formula nC2 = n * (n - 1) / 2.\n    Edge case 3: Large input size\n    Expected output: The number of valid pairs for the given input.\n    Explanation: This edge case checks the efficiency of the solution by testing it with the largest possible input size that the problem allows.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n        (other code)\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 700, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 583}
