{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp's challenge lies in ensuring that the mean remains constant after removing exactly two elements from the array. The key challenge is to maintain the same mean before and after the removal of the elements. This requires careful selection of which elements to remove.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp's challenge lies in ensuring that the mean remains constant after removing exactly two elements from the array. The key challenge is to maintain the same mean before and after the removal of the elements. This requires careful selection of which elements to remove.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp needs to make sure that the average of the numbers in the array stays the same after he removes two elements. This is tricky because he has to pick the right numbers to take out.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp's challenge involves maintaining a constant mean after removing exactly two elements from the array. The main challenge is to ensure that the mean remains the same before and after the removal of the elements, which necessitates selecting the right elements to remove.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef calculate_mean_after_removal(arr, n, k):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining (n - 2) elements is equal to k.\n\n    Args:\n        arr (list): List of integers representing the array.\n        n (int): Number of elements in the array.\n        k (float): The mean of the original array.\n\n    Returns:\n        int: The number of pairs of positions that maintain the mean after removal.\n    \"\"\"\n    count = 0\n    original_sum = sum(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = original_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n\n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = calculate_mean_after_removal(arr, n, k)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The input list of integers.\n    \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef count_pairs_with_same_mean(arr: List[int]) -> int:\n    \"\"\"\n    Count the number of pairs of positions [i, j] (i < j) such that removing the elements at these positions results in the same mean.\n    \n    Args:\n        arr (List[int]): The input list of integers.\n    \n    Returns:\n        int: The count of pairs with the same mean.\n    \"\"\"\n    n = len(arr)\n    if n < 3:\n        return 0  # No pairs can be formed if there are fewer than 3 elements.\n\n    original_sum = sum(arr)\n    original_mean = original_sum / n\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = original_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == original_mean:\n                count += 1\n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\noriginal_mean = calculate_mean(arr)\nresult = count_pairs_with_same_mean(arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = count_pairs_to_maintain_mean(n, arr)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr, avg):\n    \"\"\"\n    This function calculates the number of pairs of indices in the array that, when removed, maintain the original average.\n    \n    Args:\n    arr (list): A list of integers representing the array.\n    avg (float): The original average of the array.\n    \n    Returns:\n    int: The number of pairs of indices that maintain the original average when removed.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    \n    # Calculate the sum of the array\n    total_sum = sum(arr)\n    \n    # Iterate through all possible pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements when removing the pair (i, j)\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new average of the remaining elements\n            new_avg = new_sum / (n - 2)\n            # Check if the new average matches the original average\n            if new_avg == avg:\n                count += 1\n    \n    return count\n\n# Read input from the user\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    avg = sum(arr) / n\n    result = find_pairs(arr, avg)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], target_avg: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    # Iterate through all possible pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Calculate the average of the new array\n            new_avg = sum(new_arr) / (n - 2)\n            # Check if the new average is the same as the target average\n            if new_avg == target_avg:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the target average\ntarget_avg = sum(arr) / n\n\n# Calculate and print the number of valid pairs\nresult = calculate_pairs(arr, target_avg)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_remove(arr: List[int], n: int, avg: float) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            if temp_sum / (n - 2) == avg:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    total_sum = sum(arr)\n    original_avg = total_sum / n\n    result = find_pairs_to_remove(arr, n, original_avg)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The list of integers.\n    \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef count_valid_pairs(arr: List[int], mean: float) -> int:\n    \"\"\"\n    Count the number of valid pairs of positions that, when removed, result in the mean of the remaining elements being unchanged.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        mean (float): The mean of the original array.\n    \n    Returns:\n        int: The count of valid pairs.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    total_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum > 0 and new_sum / (n - 2) == mean:\n                count += 1\n    return count\n\ndef main():\n    \"\"\"\n    Main function to handle input and output.\n    \n    Returns:\n        int: The count of valid pairs for each test case.\n    \"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        mean = calculate_mean(arr)\n        result = count_valid_pairs(arr, mean)\n        results.append(result)\n    return results\n\nif __name__ == \"__main__\":\n    results = main()\n    for result in results:\n        print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_with_same_mean(arr: List[int], n: int) -> int:\n    # Calculate the original mean of the array\n    original_mean = sum(arr) / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing the pair (i, j)\n            remaining_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            remaining_count = n - 2\n            \n            # Calculate the mean of the remaining elements\n            new_mean = remaining_sum / remaining_count\n            \n            # Check if the mean before and after removal is the same\n            if new_mean == original_mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_with_same_mean(arr, n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_of_positions(arr: List[int], target_mean: float) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == target_mean:\n                count += 1\n    return count\n\n# Main program\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    target_mean = sum(arr) / len(arr)\n    result = calculate_pairs_of_positions(arr, target_mean)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_mean_after_removal(arr, n, k):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining (n - 2) elements is equal to k.\n    \n    Args:\n        arr (list): List of integers representing the array.\n        n (int): Number of elements in the array.\n        k (float): Mean of the original array.\n    \n    Returns:\n        int: Number of pairs of positions that maintain the mean after removal.\n    \"\"\"\n    count = 0\n    original_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = original_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    k = sum(arr) / n  # Mean of the original array\n    result = calculate_mean_after_removal(arr, n, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that, when removed, maintain the mean of the array. This involves understanding the mathematical properties of the mean and how removing elements affects it. The solution must be efficient and scalable to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a function to find pairs of positions to remove.\n- Ensure the solution is efficient and can handle large inputs.\n- Provide clear and accurate output for each test case.\n- Ensure the solution is user-friendly and easy to use.\nTo solve the problem of maintaining the mean after removing exactly two elements from the array, we will use Python's built-in libraries and data structures. The key steps include calculating the mean of the array, identifying pairs of elements that, when removed, do not change the mean, and counting these pairs. We will use a simple and efficient approach to ensure scalability and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. To maintain the same mean after removing two elements, the sum of the remaining elements should be the same as the original sum, but divided by the new number of elements (n-2).\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n    Explanation: For example, if we have an array [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. Removing elements 1 and 4 (which sum to 5) will leave a mean of (2+3)/2 = 2.5, which is the same as the original mean.\n\n# [degree adverb] \n    'largest': refers to finding the largest possible pairs that maintain the mean.\n    Explanation: In the example above, the largest pairs that can be removed to maintain the mean are the first and last elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. Check if removing each pair maintains the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 3, 2, 4], k = 2.5\n    Expected output: 1\n    Explanation: The mean of the array is (1+3+2+4)/4 = 2.5. Removing elements 1 and 4 (which sum to 5) will leave a mean of (3+2)/2 = 2.5, which is the same as the original mean.\n\n    Edge case 2: [5, 5, 5, 5], k = 5\n    Expected output: 6\n    Explanation: All elements are the same, so removing any two elements will not change the mean. There are 6 possible pairs: (0,1), (0,2), (0,3), (1,2), (1,3), and (2,3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle arrays with all identical elements.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions in an array that, when removed, maintain the mean of the remaining elements. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to the original mean. The constraints are high due to the potential size of the input, requiring efficient handling of large datasets.\nrequirement pool:\n- Implement a function to calculate the mean of an array.\n- Create a function to iterate through all pairs of positions in the array.\n- Develop a function to count the number of pairs that maintain the same mean after removal.\n- Ensure the solution is efficient enough to handle up to 2 * 10^5 elements.\n- Optimize the code for readability and maintainability.\nTo solve the problem of maintaining the mean after removing two elements from the array, we will follow a step-by-step approach. First, we will calculate the mean of the entire array. Then, we will iterate through all possible pairs of positions in the array and check if removing these two elements results in the same mean. This approach requires careful handling of large datasets, so we will ensure our solution is efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. To maintain the same mean after removing two elements, the sum of the remaining elements must be equal to the original sum minus the sum of the two removed elements, divided by the number of remaining elements (n - 2).\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In this problem, we need to find pairs of positions [i, j] such that removing the elements at these positions results in the same mean as the original array.\n\n# [degree adverb] \n    'largest': indicates the greatest or highest value in a set.\n    Explanation: In the context of the problem, we are looking for the largest integer that appears at least as many times as the integer itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] (i < j).\n    3. For each pair, calculate the new mean after removing the elements at positions i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. Removing any pair of elements will change the mean. The only pair that maintains the mean is removing elements 1 and 4 (1+2+3)/3 = 2, which is equal to the original mean.\n\n    Edge case 2: [5, 5, 5, 5]\n    Expected output: 6\n    Explanation: The original mean is (5+5+5+5)/4 = 5. Removing any pair of elements will change the mean. The pairs that maintain the mean are [5, 5], [5, 5], [5, 5], [5, 5], [5, 5], and [5, 5], which are six pairs in total.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0  # No pairs can be formed if there are fewer than 3 elements.\n\n        original_sum = sum(a)\n        original_mean = original_sum / n\n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                new_sum = original_sum - a[i] - a[j]\n                if new_sum / (n - 2) == original_mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions maintains the original mean. This requires iterating through the array, calculating the mean, and checking all possible pairs to ensure the mean remains constant after removal. The solution must be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through the array to find all possible pairs [i, j] where i < j.\n- Check if removing the elements at positions i and j maintains the original mean.\n- Count and return the number of such pairs.\n- Ensure the solution is optimized for performance and can handle large inputs.\nTo solve Monocarp's challenge efficiently, we will use Python's built-in libraries and data structures. The main approach involves calculating the mean of the array and then iterating through all possible pairs of positions [i, j] where i < j to check if removing the elements at these positions maintains the original mean. We will use a nested loop to iterate through all pairs and a set to quickly check if the mean remains constant after removal.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array before and after the removal of two elements must be the same.\n    Explanation: The mean (average) of an array is calculated by dividing the sum of all elements by the number of elements. To maintain the same mean after removing two elements, the sum of the remaining elements must be the same as the original sum, divided by the new number of elements (n - 2).\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions [i, j] such that removing the elements at these positions does not change the mean of the array.\n    'at least as many times': not directly applicable in this context, as we are looking for specific pairs of positions that maintain the mean.\n\n# [degree adverb] \n    'largest': not directly applicable in this context, as we are looking for pairs of positions that maintain the mean, not the size of the elements.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the new mean if these elements are removed.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4], n = 4\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. Removing any pair of elements will change the mean. For example, removing elements at positions 1 and 2 results in a mean of (3+4)/2 = 3.5.\n    Edge case 2:\n    Input: [1, 3, 2, 6], n = 4\n    Explanation: The original mean is (1+3+2+6)/4 = 3. Removing elements at positions 1 and 3 results in a mean of (3+2)/2 = 2.5. This does not match the original mean, so it is not a valid pair.\n    Edge case 3:\n    Input: [5, 5, 5, 5], n = 4\n    Explanation: The original mean is (5+5+5+5)/4 = 5. Removing any pair of elements will still result in a mean of 5. For example, removing elements at positions 1 and 2 results in a mean of (5+5)/2 = 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to check for valid pairs that maintain the mean.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. This requires understanding the mathematical properties of averages and efficiently iterating through the array to find valid pairs.\nrequirement pool:\n- Implement a function to calculate the average of the array\n- Iterate through the array to find pairs [i, j] where removing elements at these positions keeps the average unchanged\n- Ensure the solution is efficient enough to handle the upper limits of the input constraints\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the average of the array and then iterating through the array to find pairs of indices that, when removed, maintain the original average. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in a set.\n    Explanation: The average (mean) of a set of numbers is calculated by dividing the sum of all the numbers by the count of numbers in the set. In this problem, Monocarp needs to ensure that the average of the remaining elements after removing two is the same as the original average.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    'at least as many times': means the same or more than a specified number.\n\n# [degree adverb] \n    'largest': refers to the biggest value in a set.\n    'greatest': also refers to the biggest value but often used more poetically or rhetorically.\n    'shortest': refers to the smallest or shortest length or duration.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original average of the array.\n    2. Iterate through all possible pairs of indices in the array.\n    3. For each pair, calculate the new average of the remaining elements.\n    4. Compare the new average with the original average to see if they match.\n    5. Count the number of pairs that maintain the original average when removed.\n\n# [edge case] \n    Edge case 1: [1, 2, 3], expected output: 0\n    Explanation: The original average is (1+2+3)/3 = 2. There are no pairs that can be removed to maintain this average since removing any two elements will change the average.\n    Edge case 2: [4, 4, 4, 4], expected output: 6\n    Explanation: The original average is (4+4+4+4)/4 = 4. There are 6 pairs that can be removed to maintain this average: (1,2), (1,3), (1,4), (2,3), (2,4), and (3,4).\n    Edge case 3: [5, 5, 5, 15], expected output: 1\n    Explanation: The original average is (5+5+5+15)/4 = 7.5. The only pair that can be removed to maintain this average is (1,4) where the sum of the remaining elements is 10, which is twice the average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle all cases, including when no pairs can maintain the original average or when there are multiple pairs that do.\n", "requirement analysis:\nThe problem requires the user to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the remaining elements unchanged. This involves calculating the sum of the array, the average, and then checking pairs to ensure the average remains the same after removal. The constraints are high, requiring the solution to be efficient and handle up to 2 * 10^5 elements.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of indices to remove such that the average remains unchanged.\n- Ensure the solution is efficient and can handle up to 2 * 10^5 elements.\n- Add input handling to read multiple test cases.\n- Implement output formatting to print the result for each test case.\nTo solve this problem efficiently, we will use Python's built-in data structures and functions to handle the array operations. We will calculate the average of the array and then iterate through all possible pairs of indices to check if removing these elements keeps the average unchanged. This approach will be efficient due to Python's handling of large data sets and the use of simple arithmetic operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pair of positions': two distinct indices in the array\n    'remove elements': decrease the number of elements in the array by two\n\n# [phrase showing quantity relationship]\n    'the number of elements': indicates the total count of elements in the array\n\n# [degree adverb] \n    'the same': means that the average remains unchanged after removing the elements\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Calculate the average of the array.\n    Iterate through all possible pairs of indices (i, j) where i < j.\n    Check if removing the elements at these positions keeps the average unchanged.\n    Count the number of such pairs.\n\n# [edge case] \n    n = 3, array = [1, 2, 3]\n    expected output = 1\n    Explanation: There is only one pair (1, 2) that can be removed to keep the average unchanged.\n    n = 5, array = [1, 2, 3, 4, 5]\n    expected output = 0\n    Explanation: No pair of elements can be removed to keep the average unchanged since the average of the entire array is not an integer.\n    n = 6, array = [1, 1, 1, 1, 1, 1]\n    expected output = 15\n    Explanation: Any pair of elements can be removed since all elements are equal. The number of pairs is calculated as n*(n-1)/2 = 15.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to calculate the number of pairs is straightforward and does not require additional complexity for edge cases.\n", "requirement analysis:\nThe requirement is to find the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the remaining elements unchanged. This requires calculating the average of the entire array and then checking for pairs of elements whose removal does not change the average.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of indices whose removal does not change the average.\n- Ensure the solution is efficient and can handle large inputs.\n- Provide clear and accurate output for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to find pairs of indices whose removal does not change the average of the array. We will first calculate the total sum of the array and then for each pair of indices, check if removing them results in the average of the remaining elements being the same as the original average.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'sum': the total sum of all elements in the array\n    'pair': a combination of two elements from the array\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the average\n\n# [degree adverb] \n    'right': suggests that we need to select the correct pairs of indices to remove\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    explanation: With only three elements, removing any two will change the average, so the expected output is 0.\n    search([2, 2, 4]) = 1\n    explanation: The original average is (2+2+4)/3 = 2.67. Removing the two 2's results in an average of 4/1 = 4, which is the same as the original average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly check if the array has only three elements and return 0, as removing any two will change the average. For larger arrays, we can proceed with the main logic to find the pairs.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions in an array that, when removed, result in the mean of the remaining elements being unchanged. This requires iterating through all possible pairs of positions, calculating the mean before and after removal, and counting the pairs that meet the condition.\nrequirement pool:\n- Implement a function to calculate the mean of an array.\n- Create a function to count the number of valid pairs of positions.\n- Ensure the program can handle multiple test cases efficiently.\nTo solve the problem of finding pairs of positions in an array that, when removed, result in the mean of the remaining elements being unchanged, we can follow these steps: \n1. Calculate the mean of the entire array for each test case. \n2. Iterate through all possible pairs of positions in the array. \n3. For each pair, calculate the new mean after removing the elements at those positions. \n4. Count the pairs that result in the same mean as the original array mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the new mean should be the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the value of the removed elements should be greater than zero.\n    Explanation: Since the elements are positive integers, the sum of the remaining elements after removal should still be positive.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible values to remove to maintain the original mean.\n    Explanation: The goal is to find pairs of elements that, when removed, do not significantly alter the mean of the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array for each test case.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the new mean after removing the elements at those positions.\n    4. Count the pairs that result in the same mean as the original array mean.\n\n# [edge case] \n    Edge case 1: [1, 2, 3], expected output: 0\n    Explanation: The mean of the array is (1+2+3)/3 = 2. Removing any pair of elements will change the mean, so there are no valid pairs.\n    Edge case 2: [4, 4, 4, 4], expected output: 6\n    Explanation: The mean of the array is (4+4+4+4)/4 = 4. There are 6 pairs that can be removed to maintain the mean: (0,1), (0,2), (0,3), (1,2), (1,3), and (2,3).\n    Edge case 3: [5, 5, 5, 5, 5], expected output: 10\n    Explanation: The mean of the array is (5+5+5+5+5)/5 = 5. There are 10 pairs that can be removed to maintain the mean: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), and (3,4).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    To handle edge cases where the array has only a few elements or where all elements are the same, we should implement a specific check for these scenarios.\n    For example, if the array has only three elements, there are no pairs to remove, so the output should be 0. If all elements are the same, any pair can be removed, so the number of valid pairs is the number of pairs in the array.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions in an array that, when removed, result in the mean of the remaining elements being unchanged. This requires iterating through all possible pairs of positions, calculating the mean before and after removal, and counting the pairs that meet the condition.\nrequirement pool:\n- Implement a function to calculate the mean of an array.\n- Iterate through all pairs of positions in the array.\n- Check if removing the elements at these positions results in the same mean.\n- Count the number of such pairs.\nTo solve the problem of finding pairs of positions in an array that, when removed, result in the mean of the remaining elements being unchanged, we can follow these steps: \n1. Calculate the mean of the entire array. \n2. Iterate through all possible pairs of positions in the array. \n3. For each pair, calculate the mean of the remaining elements after removal. \n4. Check if the mean before and after removal is the same. \n5. Count the number of such pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the new mean should be the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the value of the removed elements should be greater than zero.\n    Explanation: Since the elements are positive integers, the sum of the remaining elements after removal should still be positive.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible values to remove to maintain the same mean.\n    Explanation: This implies that we should consider the largest elements in the array for removal to ensure the mean remains unchanged.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the new mean after removal and compare it with the original mean.\n    4. Count the pairs that result in the same mean before and after removal.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. Removing the elements at positions 1 and 3 (values 2 and 4) results in the mean of the remaining elements (1+3)/2 = 2, which is the same as the original mean.\n\n    Edge case 2: [5, 5, 5, 5]\n    Expected output: 6\n    Explanation: The original mean is (5+5+5+5)/4 = 5. Removing any two elements will always result in a mean of 5, so there are 6 possible pairs to remove (0-1, 0-2, 0-3, 1-2, 1-3, 2-3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where the array has repeated elements.\n\n    However, for very large arrays, optimizing the iteration through pairs could be beneficial. For example, we can use nested loops with a condition to stop early if the remaining sum is not likely to match the original mean.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions in an array that, when removed, result in the mean of the remaining elements being unchanged. This requires iterating through all possible pairs of positions, calculating the mean before and after removal, and counting the pairs that meet the condition.\nrequirement pool:\n- Implement a function to calculate the mean of an array.\n- Iterate through all possible pairs of positions in the array.\n- Check if removing the elements at these positions results in the same mean.\n- Count the number of such pairs.\nTo solve the problem of finding pairs of positions in an array that, when removed, result in the mean of the remaining elements being unchanged, we can follow these steps: \n1. Calculate the mean of the entire array. \n2. Iterate through all possible pairs of positions in the array. \n3. For each pair, calculate the mean of the remaining elements after removal. \n4. Check if the mean before and after removal is the same. \n5. Count the number of such pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the new mean should be the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In this problem, we need to find pairs of elements whose removal does not change the mean of the array.\n\n# [degree adverb] \n    'largest': refers to the greatest value in a set of numbers.\n    Explanation: We need to consider the largest possible values to ensure we are evaluating the most significant pairs for mean preservation.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the mean of the remaining elements after removal.\n    4. Check if the mean before and after removal is the same.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. Removing the elements at positions 1 and 3 (values 2 and 4) leaves [1, 3], which has a mean of (1+3)/2 = 2, which is the same as the original mean.\n\n    Edge case 2: [5, 5, 5, 5]\n    Expected output: 6\n    Explanation: The original mean is (5+5+5+5)/4 = 5. Removing any two elements will always result in a mean of 5, which is the same as the original mean. There are 6 possible pairs to remove: (1,2), (1,3), (1,4), (2,3), (2,4), (3,4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where all elements are the same.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that, when removed, maintain the mean of the array. This involves understanding the mathematical properties of the mean and how removing elements affects it. The solution must be efficient and scalable to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a function to find pairs of positions to remove.\n- Ensure the solution is efficient and can handle large inputs.\n- Provide clear and accurate output for each test case.\n- Ensure the solution is user-friendly and easy to use.\nTo solve the problem of maintaining the mean after removing exactly two elements from the array, we will use Python's built-in libraries and data structures. The key steps include calculating the mean of the array, identifying pairs of elements that, when removed, do not change the mean, and counting these pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. To maintain the same mean after removing two elements, the sum of the remaining elements must be equal to the original sum minus the sum of the two removed elements, divided by the new number of elements (n-2).\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the value of the removed elements should not affect the mean.\n    Explanation: When removing two elements, the sum of the remaining elements must be equal to the original sum minus the sum of the two removed elements, divided by the new number of elements (n-2).\n\n# [degree adverb] \n    'largest': refers to the maximum value in the array that can be used to maintain the mean.\n    Explanation: To maintain the mean, the sum of the two removed elements should be such that the mean of the remaining elements remains unchanged. This involves finding the largest possible values to remove.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new mean if these elements were removed.\n    4. Count the number of pairs that result in the same mean as the original array.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    expected output: 1\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. Removing the elements at positions 1 and 3 (values 2 and 3) results in the new mean being (1+3)/2 = 2, which is the same as the original mean.\n\n    Edge case 2: [5, 5, 5, 5]\n    expected output: 6\n    Explanation: The mean of the array is (5+5+5+5)/4 = 5. Removing any two elements will not change the mean since all elements are the same. There are 6 possible pairs (0-1, 0-2, 0-3, 1-2, 1-3, 2-3) that can be removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle arrays with all identical elements.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 561, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "parent_index": 461}
