{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp possesses an array a composed of n integers, and let's define k as the arithmetic average of these elements, although when computed, k might be a fractional value instead of a whole number. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array consists of at least two elements. You should consider corner cases where the numbers are very large or very small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp possesses an array a composed of n integers, and let's define k as the arithmetic average of these elements, although when computed, k might be a fractional value instead of a whole number. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array consists of at least two elements. You should consider corner cases where the numbers are very large or very small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a with n elements, and he wants to find the arithmetic mean k of these elements. However, k might be a decimal value. He needs to remove exactly two elements from array a such that the mean of the remaining (n - 2) elements is still k. The task is to determine the number of pairs of indices [i, j] (where i < j) where if the elements at these indices are deleted, the mean of the remaining (n - 2) elements will be equal to k. The array may contain very large or very small numbers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the average of these elements. He wants to remove two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) whose removal results in the mean of (n - 2) elements being equal to k. The array has at least two elements, and the numbers can be very large or small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new number of elements after deleting elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            \n            # Check if the new mean equals the original mean\n            if new_sum / new_n == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_of_positions(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the mean of the remaining elements after removing the elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            remaining_mean = remaining_sum / remaining_count\n            \n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_mean == mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = calculate_pairs_of_positions(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef count_valid_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If the mean is not a fractional value, it's impossible to remove two elements and still have the mean the same\n    if mean * n % 1 != 0:\n        return 0\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions [i, j]\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            # Calculate the mean of the remaining elements\n            remaining_mean = remaining_sum / (n - 2)\n            # Check if the remaining mean is equal to the original mean\n            if remaining_mean == mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = count_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing the elements at indices i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of these remaining elements is equal to k\n            if remaining_sum / remaining_count == k:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Find and print the number of pairs\n    result = find_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_delete(n: int, arr: List[int]) -> int:\n    if all(x == arr[0] for x in arr):\n        # If all elements are the same, any two elements can be removed\n        return n * (n - 1) // 2\n    \n    total_sum = sum(arr)\n    target_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == target_mean:\n                count += 1\n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_delete(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the result counter\n    result_count = 0\n    \n    # Iterate through all pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new count after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            new_mean = new_sum / new_count\n            \n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                result_count += 1\n    \n    return result_count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = find_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_remove(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    pairs_to_remove = 0\n    \n    # Create a dictionary to store the frequency of the differences\n    # that can result in the same mean after removal\n    diff_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the difference when elements at indices i and j are removed\n            diff = arr[i] + arr[j]\n            if diff not in diff_count:\n                diff_count[diff] = 0\n            diff_count[diff] += 1\n    \n    # Check how many differences can result in the original mean\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = arr[i] + arr[j]\n            target_diff = 2 * original_mean * n - diff\n            if target_diff in diff_count:\n                pairs_to_remove += diff_count[target_diff]\n    \n    return pairs_to_remove\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs_to_remove(n, arr):\n    original_mean = sum(arr) / n\n    count = 0\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = sum(arr) - arr[i] - arr[j]\n            remaining_count = n - 2\n\n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_sum / remaining_count == original_mean:\n                # Check if the remaining elements are the same as the original mean\n                remaining_mean = remaining_sum / remaining_count\n                if remaining_mean == original_mean:\n                    # Check if the remaining elements form a valid pair\n                    if i != j:\n                        count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    \n    # Read the array elements\n    arr = list(map(int, input().strip().split()))\n    \n    # Calculate and print the result for the current test case\n    result = calculate_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that removing the elements at these positions keeps the mean of the remaining elements unchanged.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] such that removing them keeps the mean unchanged.\n    \"\"\"\n    original_mean = sum(arr) / n\n    count = 0\n\n    # Calculate the sum of all elements in the array\n    total_sum = sum(arr)\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate through all possible pairs [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n\n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_sum / remaining_count == original_mean:\n                count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr):\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    count += 1\n    return count\n\n# Interface\ninput_lines = sys.stdin.readlines()\nt = int(input_lines[0])\nline_index = 1\n\nfor _ in range(t):\n    n = int(input_lines[line_index].strip())\n    line_index += 1\n    arr = list(map(int, input_lines[line_index].strip().split()))\n    line_index += 1\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements involve calculating the arithmetic mean of an array and then finding pairs of elements to delete such that the mean of the remaining elements remains the same. This requires efficient handling of large inputs and accurate calculations. The solution should be robust against edge cases and handle potential large numbers accurately.\nrequirement pool:\n- Calculate the arithmetic mean of the array\n- Find pairs of elements to delete\n- Ensure the mean of the remaining elements is unchanged\n- Handle large inputs efficiently\n- Provide clear and accurate output\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array, then iterating through all possible pairs of elements to check if their deletion maintains the mean. We will use a nested loop to iterate through pairs and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements\n    'fractional value': a number that has a decimal part\n    'pairs': two elements in a sequence, where order matters\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to consider pairs of positions [i, j] where i < j\n\n# [degree adverb] \n    'largest': not applicable in this context as it doesn't fit the requirement of finding pairs\n    'smallest': not applicable in this context as it doesn't fit the requirement of finding pairs\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after deletion.\n    4. Count the pairs where the new mean equals the original mean.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs that can be deleted to maintain this mean.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 5, 7]\n    Explanation: The original mean is (1+3+5+7)/4 = 4. The pair [1, 2] (deleting elements at positions 1 and 2) results in a mean of (1+5)/2 = 3, which is not equal to 4. The pair [0, 2] (deleting elements at positions 0 and 2) results in a mean of (1+7)/2 = 4, which is equal to 4.\n    Expected output: 1\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has only a few elements or where the elements are very large or very small.\n        if n == 3:\n            return 0  # No pairs can be deleted if there are only three elements\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2  # All pairs will maintain the mean if all elements are the same\n\n    This code checks for the smallest possible array size and ensures that no pairs can be deleted, and for the case where all elements are the same, any pair will maintain the mean.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires iterating through all pairs of positions in the array, checking the mean of the remaining elements, and counting the pairs that meet the condition.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions in the array\n- Check if deleting the elements at the pair's positions results in the mean of the remaining elements being equal to the original mean\n- Count the pairs that meet the condition\n- Handle edge cases such as very large or very small numbers\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all pairs of positions to check if deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. We will use a brute-force method to ensure simplicity and correctness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements\n    'fractional value': a number that has a decimal part\n    'pairs of positions': two distinct positions in an array\n\n# [phrase showing quantity relationship]\n    'exactly two elements': we need to remove two elements from the array\n    'remaining elements': the elements left after removing two elements\n\n# [degree adverb] \n    'equal to': the remaining elements' mean should match the original mean\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the mean of the remaining elements is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have a mean of the remaining elements equal to the original mean.\n\n    n = 4, a = [1, 3, 5, 7]\n    expected output: 1\n    Explanation: The original mean is (1+3+5+7)/4 = 4. Removing the first and last elements results in [3, 5], which also has a mean of 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic already accounts for the minimum number of elements required.\n\n    However, for very large inputs, we should consider optimizing the process to avoid unnecessary computations, such as using a more efficient algorithm or data structures to handle large arrays.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This involves iterating through all possible pairs, checking the mean before and after deletion, and counting valid pairs. The constraints are high, with up to 2 * 10^5 elements, requiring the solution to be efficient.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions [i, j] and check the mean after deletion\n- Count the number of valid pairs where the mean remains unchanged\n- Optimize the algorithm to handle large inputs efficiently\n- Ensure the solution is clear and easy to understand\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through all possible pairs of positions [i, j] to check if deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. We will optimize the algorithm to handle large inputs efficiently by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements\n    'fractional value': a number that has a decimal part\n    'pairs of positions': two positions in an array, i and j, where i < j\n\n# [phrase showing quantity relationship]\n    'exactly two elements': we need to remove exactly 2 elements from the array\n    'remaining elements': the elements left after removing two elements\n\n# [degree adverb] \n    'equal to': the remaining elements' mean should be the same as the original array's mean\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Calculate the mean of the entire array\n    - Iterate through all possible pairs of positions [i, j]\n    - For each pair, calculate the new mean of the remaining elements\n    - Check if the new mean is equal to the original mean\n    - Count the number of pairs that satisfy the condition\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have a mean equal to the original mean.\n\n    n = 4, a = [1, 3, 5, 7]\n    expected output: 1\n    Explanation: The original mean is (1+3+5+7)/4 = 4. Removing the first and last elements (1 and 7) leaves [3, 5], which also has a mean of 4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the arithmetic mean of an array and determine the number of pairs of indices that can be removed to maintain the same mean. The array can contain very large numbers, and the solution must be efficient to handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Develop a method to find pairs of indices that can be removed to maintain the mean.\n- Ensure the solution is efficient and can handle large inputs.\n- Provide clear and accurate output for the number of pairs.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through all possible pairs of indices to check if removing them maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    'decimal value': a number that has a fractional part.\n    'pairs of indices': a combination of two different positions in a sequence.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the array.\n\n# [degree adverb] \n    'exactly': means that we need to find pairs of indices where removing exactly two elements results in the mean of the remaining elements being equal to k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the arithmetic mean k of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at indices i and j.\n    4. Check if the mean of these remaining elements is equal to k.\n    5. Count the number of such pairs.\n    6. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] that can be removed to maintain the mean.\n    search([2, 2, 2]) = 3\n    explanation: All pairs [0, 1], [0, 2], and [1, 2] can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any two elements can be removed to maintain the mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n    This edge case can be handled by checking if all elements in the array are equal at the beginning of the code logic.\n", "requirement analysis:\nThe primary requirement is to calculate the mean of the array and determine the number of pairs of indices that, when deleted, result in the remaining elements having the same mean. The challenge lies in handling large inputs efficiently and ensuring precision in mean calculations, especially for decimal values.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices that, when deleted, result in the mean remaining unchanged.\n- Ensure the solution is optimized for large inputs and handles edge cases.\n- Provide clear and accurate output for each test case.\n- Test the solution with large datasets to ensure performance and accuracy.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing them results in the mean of the remaining elements being the same. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    'decimal value': a number that has a fractional part.\n    'pairs of indices': a combination of two distinct positions in a sequence.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove exactly 2 elements from the array.\n\n# [degree adverb] \n    'largest': not applicable in this context as it does not relate to the problem's requirements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves:\n    1. Calculating the mean of the entire array.\n    2. Iterating through all possible pairs of indices (i, j) where i < j.\n    3. Removing the elements at these indices and checking if the mean of the remaining elements equals the calculated mean.\n    4. Counting the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] where if the elements at these indices are deleted, the mean of the remaining elements is 1.\n    search([2, 2, 2]) = 3\n    explanation: There are three pairs [0, 1], [0, 2], and [1, 2] where if the elements at these indices are deleted, the mean of the remaining elements is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any two elements can be removed, and the mean of the remaining elements will still be the same as the original mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any two elements can be removed, and the mean of the remaining elements will still be the same as the original mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n", "requirement analysis:\nThe primary requirement is to find the number of pairs of indices [i, j] where deleting the elements at these indices will result in the mean of the remaining elements being equal to the given mean k. The array can contain very large numbers, and the solution must be efficient to handle large inputs within the given constraints.\nrequirement pool:\n- Implement an efficient algorithm to find the number of pairs of indices [i, j] that can be deleted to maintain the mean k.\n- Ensure the solution can handle large inputs efficiently within the given constraints.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm to handle edge cases and large inputs.\n- Enhance user interface for easy input and output.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing them results in the mean of the remaining elements being equal to the calculated mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    'decimal value': a number that has a fractional part.\n    'pairs of indices': a combination of two different positions in a sequence.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the array.\n\n# [degree adverb] \n    'exactly': means that we need to find pairs of indices where removing exactly two elements results in the mean of the remaining elements being equal to k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the mean k of the array.\n    2. Iterate through all pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean is equal to k.\n    5. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair (0, 1) where removing elements at these indices results in the mean of the remaining element being 1.\n    search([2, 2, 2]) = 3\n    explanation: There are three pairs (0, 1), (0, 2), and (1, 2) where removing elements at these indices results in the mean of the remaining elements being 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements in the array are the same. In such a case, any pair of indices can be removed to achieve the desired mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n# [extra code for edge case]\n    def handle_edge_case(arr):\n        if all(x == arr[0] for x in arr):\n            return len(arr) * (len(arr) - 1) // 2\n        return 0\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of elements that need to be removed from the array such that the mean remains unchanged. This involves understanding the properties of the mean and how removing elements affects it. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a method to find pairs of indices whose removal does not change the mean.\n- Ensure the solution is optimized for large arrays.\n- Add error handling for invalid inputs.\n- Provide user-friendly output and input interfaces.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries. The approach involves calculating the mean of the array and then finding pairs of indices whose removal does not change the mean. We will optimize the solution for large arrays by avoiding unnecessary computations and leveraging Python's efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the operation of deleting elements from an array\n    'mean preservation': the condition that the mean of the remaining elements is equal to the original mean after removal\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another\n    'at least as many times': indicates a comparison where one quantity is at least as large as another\n\n# [degree adverb] \n    'largest': indicates the greatest value in a set of values\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, removing any two elements will change the mean, so the output is 0.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The only pair that can be removed to keep the mean unchanged is [0, 3] since (2+3)/2 = 2.5 and (1+2+3)/3 = 2.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    Expected output: 3\n    Explanation: The pairs that can be removed to keep the mean unchanged are [0, 2], [0, 3], and [1, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can be used to solve all test cases.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs [i, j] (i < j) whose removal results in the mean of (n - 2) elements being equal to k. The array has at least two elements, and the numbers can be very large or small. The solution should be efficient and optimized for large inputs within the given constraints.\nrequirement pool:\n- Implement a solution to calculate the number of pairs of positions whose removal results in the mean of the remaining elements being equal to the original mean.\n- Ensure the solution is optimized for large inputs within the given constraints.\n- Provide a clear and concise output for each test case.\n- Test the solution with various test cases to ensure accuracy and efficiency.\n- Implement user-friendly interfaces for easy interaction.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing them results in the mean of the remaining elements being equal to the original mean. We will use a brute-force method initially to ensure correctness, and then we can optimize it further if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal': the process of deleting elements from a list\n    'mean': the sum of the remaining elements divided by the number of remaining elements after removal\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs whose removal does not change the mean\n    'at least as many times': means that the number of times an element appears should be considered\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that meets the condition\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    explanation: There are no pairs of indices whose removal would result in the mean of the remaining elements being equal to the original mean.\n    search([2, 2, 4, 4]) = 3\n    explanation: The pairs [0, 2] and [1, 3] both result in the mean of the remaining elements being 3, which is the original mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly check all pairs and count those that do not change the mean.\n\n# [code logic]\n    Calculate the original mean of the array.\n    Iterate through all possible pairs of indices (i, j) where i < j.\n    For each pair, calculate the sum of the remaining elements after removal.\n    Check if the mean of these remaining elements is equal to the original mean.\n    Count the number of such pairs.\n    Return the count.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the mean of the remaining elements unchanged. The solution must be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all possible pairs [i, j] and check if removing them keeps the mean unchanged.\n- Optimize the solution to handle large inputs efficiently.\n- Ensure the code is well-documented and easy to understand.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs [i, j] such that removing the elements at these positions keeps the mean of the remaining elements unchanged. We will first calculate the mean of the array, then iterate through all possible pairs and check if removing them keeps the mean unchanged. To optimize the solution for large inputs, we will ensure that our solution is time-efficient and uses minimal memory.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the mean or average of a set of numbers is the sum of the numbers divided by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that removing the elements at these indices keeps the mean of the remaining elements unchanged. This means the sum of the remaining elements divided by their count should equal the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that the number of times a value appears in the array is greater than the value itself.\n    'at least as many times': means that the number of times a value appears in the array is greater than or equal to the value itself.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs [i, j] (i < j).\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3]\n    Expected output: 0\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs [i, j] such that removing them keeps the mean unchanged because the sum of any two elements will change the mean.\n\n    Edge case 2: [4, 4, 4, 4]\n    Expected output: 6\n    Explanation: The original mean is (4+4+4+4)/4 = 4. There are 6 pairs [i, j] that can be removed to keep the mean unchanged: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for any given array.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires a good understanding of arithmetic operations and array manipulation. The solution should be efficient enough to handle up to 2 * 10^5 elements, which implies the need for optimized algorithms.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] such that deleting elements at these positions maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Add user interface elements for input and output.\n- Include error handling for invalid inputs.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing those elements results in the mean of the remaining elements being equal to the original mean. We will optimize this by avoiding unnecessary computations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic average'\n    In the requirement, it refers to the sum of all elements divided by the number of elements, which can be a fractional value.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests calculating the mean of the array and then iterating through all possible pairs of indices to check if removing those elements results in the mean of the remaining elements being equal to the original mean. This approach involves:\n    1. Calculating the mean of the array.\n    2. Iterating through all pairs of indices (i, j) where i < j.\n    3. Checking if removing the elements at indices i and j results in the mean of the remaining elements being equal to the original mean.\n    4. Counting the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The mean of the array is (1+2+3)/3 = 2. There are no pairs [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to 2.\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 2, 4]\n    Explanation: The mean of the array is (1+3+2+4)/4 = 2.5. The pairs [i, j] that result in the mean of the remaining elements being equal to 2.5 are [0, 2] and [1, 3].\n    Edge case 3:\n    Input: n = 5, a = [10, 20, 30, 40, 50]\n    Explanation: The mean of the array is (10+20+30+40+50)/5 = 30. The only pair [i, j] that results in the mean of the remaining elements being equal to 30 is [0, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already accounts for the smallest and largest possible values in the array.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 442, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 321}
