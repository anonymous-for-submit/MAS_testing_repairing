{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game, where his character has to kill a dragon, and the battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start, and the dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger); however, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game, where his character has to kill a dragon, and the battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start, and the dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger); however, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin", " Monocarp is engaged in a challenging video game where his character must defeat a dragon. The battle with the dragon lasts an incredibly long duration of 100^{500} seconds. During this time, Monocarp will repeatedly use a poisoned dagger to attack the dragon, with each attack occurring at the start of the a_i-th second. The poisoned dagger does not directly deal damage but instead applies a poison effect that lasts for k seconds, during which the dragon takes 1 damage per second. If the dragon is already poisoned, the dagger's poison will overwrite the existing effect.\n\nMonocarp\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin", " Monocarp needs to determine the minimum value of k, the duration of the poison effect, to ensure he deals at least h damage to the dragon in a battle lasting 100^{500} seconds, where attacks are made at the beginning of a_i-th second, and the poison effect deals 1 damage each second it is active, updating the effect if the dragon is already poisoned.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_poison_end = 0\n        for attack_time in attacks:\n            poison_start = attack_time\n            poison_end = poison_start + k - 1\n            damage_this_attack = 0\n            if poison_start > last_poison_end:\n                damage_this_attack = 1\n            else:\n                damage_this_attack = poison_end - last_poison_end\n            total_damage += damage_this_attack\n            last_poison_end = max(last_poison_end, poison_end)\n        return total_damage >= h\n\n    # Binary search to find the minimum k\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    # Sort the attacks to process them in order\n    attacks.sort()\n    \n    # If all attacks are at the same second, the poison effect will last for k seconds\n    if len(set(attacks)) == 1:\n        return len(attacks)\n    \n    # Initialize the range for binary search\n    left, right = 1, 10**18\n    \n    # Function to calculate the total damage dealt with a given k\n    def total_damage(k: int) -> int:\n        damage = 0\n        time = 0\n        for i in range(len(attacks)):\n            if i == 0 or attacks[i] != attacks[i - 1]:\n                time = attacks[i]\n            damage += k - (attacks[i] - time)\n        return damage\n    \n    # Binary search to find the minimum k\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    \n    # Check if the minimum k found is sufficient\n    return left if total_damage(left) >= h else -1\n\n# Read input and output the result for each test case\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        result = find_min_k(attacks, h)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    # Sort the attack times\n    attacks.sort()\n    \n    # Define a function to calculate the total damage dealt for a given k\n    def total_damage(k: int) -> int:\n        damage = 0\n        n = len(attacks)\n        for i in range(n):\n            # Calculate the damage for each attack\n            if i == n - 1:\n                # Last attack, calculate damage for the remaining seconds\n                damage += (attacks[-1] - attacks[i]) // k + 1\n            else:\n                # Calculate damage for the current attack and the next (k-1) seconds\n                damage += (attacks[i + 1] - attacks[i]) // k\n        return damage\n    \n    # Use binary search to find the minimum k that ensures Monocarp deals at least h damage to the dragon\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_minimum_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time <= k:\n                total_damage += attack_time - last_attack_time\n            else:\n                total_damage += k\n            last_attack_time = attack_time\n        total_damage += k\n        return total_damage >= h\n\n    left, right = 1, max(attacks)\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_minimum_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_attack_end = 0\n        for attack_time in attacks:\n            if attack_time > last_attack_end:\n                total_damage += k\n                last_attack_end = attack_time + k - 1\n        return total_damage >= h\n\n    left, right = 1, 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = calculate_min_k(n, h, attacks)\n    results.append(result)\nfor result in results:\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_minimum_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time > k:\n                total_damage += k\n            else:\n                total_damage += attack_time - last_attack_time\n            last_attack_time = attack_time\n        total_damage += k\n        return total_damage >= h\n\n    left, right = 1, max(attacks)\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\nresult = find_minimum_k(n, h, attacks)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_poison_duration(n: int, h: int, attacks: List[int]) -> int:\n    # Sort the attack times\n    attacks.sort()\n    \n    # Define the binary search range\n    left, right = 1, 10**18\n    \n    # Binary search to find the minimum k\n    while left < right:\n        mid = (left + right) // 2\n        \n        # Calculate the total damage dealt with the current mid value of k\n        damage = 0\n        time = 0\n        for attack in attacks:\n            if time + mid > attack:\n                damage += (attack - time)\n            else:\n                damage += mid\n            time = attack\n        \n        # Check if the total damage is at least h\n        if damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_poison_duration(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_poison_duration(n: int, h: int, attacks: List[int]) -> int:\n    # Sort the attack times\n    attacks.sort()\n    \n    # Define the binary search function to find the minimum k\n    def can_deal_damage(k: int) -> bool:\n        damage = 0\n        i = 0\n        while i < n and attacks[i] <= k:\n            damage += 1\n            i += 1\n        damage += (k - attacks[i - 1]) if i > 0 else 0\n        return damage >= h\n    \n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    # Read the number of attacks and the required damage\n    n, h = map(int, input().split())\n    # Read the attack times\n    attacks = list(map(int, input().split()))\n    # Find and print the minimum poison duration\n    result = find_min_poison_duration(n, h, attacks)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef can_deal_damage(k: int, attacks: List[int], h: int) -> bool:\n    damage = 0\n    last_attack_time = 0\n    for attack_time in attacks:\n        duration = attack_time - last_attack_time\n        damage += (duration + k - 1) // k  # Ceiling division to calculate the number of times the poison effect is updated\n        last_attack_time = attack_time\n    return damage >= h\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    left, right = 1, 10**18  # Set initial bounds for binary search\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid, attacks, h):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input and process each test case\nt = int(input().strip())\nfor _ in range(t):\n    n, h = map(int, input().strip().split())\n    attacks = list(map(int, input().strip().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    # Sort the attacks to process them in order\n    attacks.sort()\n    \n    # Define the function to calculate the total damage for a given k\n    def calculate_total_damage(k: int) -> int:\n        total_damage = 0\n        n = len(attacks)\n        for i in range(n - 1):\n            # Calculate the damage for each attack considering the poison effect duration\n            total_damage += (attacks[i + 1] - attacks[i]) * (k - 1)\n        # Add the damage from the last attack\n        total_damage += k\n        return total_damage\n    \n    # Define the binary search function to find the minimum k\n    def binary_search_min_k(low: int, high: int) -> int:\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_total_damage(mid) < h:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n    \n    # Start the binary search with initial bounds\n    return binary_search_min_k(1, max(attacks[-1], h))\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n"], "plans": ["requirement analysis:\nThe project requires a solution to determine the minimum value of k, which represents the duration of the poison effect. The input consists of multiple test cases, each with a specific number of attacks and the required damage. The attacks are given in ascending order, and the goal is to find the smallest k such that the total damage inflicted is at least h. The solution must be efficient as the number of test cases and the range of values can be large.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case.\n- Ensure the solution is efficient and can handle large inputs.\n- Develop a user-friendly interface for input and output.\n- Test the solution with various edge cases to ensure robustness.\n- Optimize the code for performance.\nTo solve the problem of determining the minimum value of k, we will use a binary search approach to efficiently find the smallest k that ensures Monocarp deals at least h damage to the dragon. The binary search will help us minimize the number of iterations needed to find the solution, especially given the large possible values of h.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find an element in a sorted array by repeatedly dividing the search interval in half.\n    'poison damage': The poison deals 1 damage during each of the next k seconds, starting with the same second when the dragon was stabbed by the dagger.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the required damage must be at least h.\n\n# [degree adverb] \n    'minimum possible': The goal is to find the smallest value of k that ensures at least h damage is dealt.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum k. The binary search will be performed over a range of possible values for k, starting from 1 up to a large enough value that ensures Monocarp can deal at least h damage. For each value of k, we will simulate the attacks to calculate the total damage dealt and check if it is at least h.\n\n# [edge case] \n    Edge case 1: Monocarp attacks at the same second as the poison effect starts.\n    Expected output: 1\n    Explanation: Since the attack and the poison effect start at the same time, the poison effect immediately deals 1 damage, which is enough to deal h damage in a single attack.\n\n    Edge case 2: Monocarp attacks at the start of every second, starting from the first second.\n    Expected output: h\n    Explanation: If Monocarp attacks at the start of every second, the poison effect will deal 1 damage during each of the next k seconds for each attack. Since there are n attacks and each attack deals damage over k seconds, the total damage will be n * k, which should be at least h. The minimum k in this case is h, as each attack will deal damage over k seconds, and there are n attacks.\n\n    Edge case 3: Monocarp attacks at the start of every second, but the dragon is already poisoned at the beginning of the battle.\n    Expected output: 1\n    Explanation: Since the dragon is already poisoned at the beginning of the battle, the first attack will update the poison effect and deal 1 damage during the next k seconds. The subsequent attacks will continue to deal damage over k seconds each. The minimum k in this case is 1, as the poison effect will deal damage during the next k seconds starting from the same second the attack is made.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these cases by considering the smallest and largest possible values of k.\n", "requirement analysis:\nThe project requires creating a game where the player has to deal damage to a dragon using poisoned daggers. The challenge lies in determining the minimum duration of the poison effect required to deal at least h damage to the dragon. The game should be designed with user-friendly features and accessible across different platforms.\nrequirement pool:\n- Implement the game logic for calculating the minimum poison duration.\n- Develop a user interface that allows players to input their attacks and view the results.\n- Ensure the game is responsive and works well on various devices.\n- Include different difficulty levels to cater to players of varying skill.\n- Implement a score tracking system to monitor player progress.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently determine the smallest k that ensures Monocarp deals at least h damage to the dragon. We will sort the attack times and then use a function to calculate the total damage dealt by Monocarp's attacks given a specific k. This function will simulate the poison effects and sum up the damage for each attack.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a method used to find the minimum value of k that ensures Monocarp deals at least h damage to the dragon. It involves iteratively narrowing down the possible values of k.\n\n    'damage calculation': This involves simulating the poison effects and summing up the damage for each attack. The poison effect lasts for k seconds, and if the dragon is already poisoned, the new poison effect updates the previous one.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the damage dealt must be equal to or greater than h.\n\n# [degree adverb] \n    'minimum possible': This means we need to find the smallest value of k that still ensures the required damage is dealt.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Sort the attack times.\n    2. Use binary search to find the minimum k.\n    3. For each potential k, calculate the total damage dealt using a function that simulates the poison effects.\n    4. Adjust the binary search range based on whether the total damage is sufficient or not.\n\n# [edge case] \n    Edge case 1: Monocarp attacks at the same second.\n    search([1, 1, 1]) with h = 3\n    expected output: 3\n    Explanation: Since all attacks are at the same second, the poison effect will be applied once, and it will deal damage for k = 3 seconds.\n\n    Edge case 2: Monocarp attacks are insufficient to deal the required damage.\n    search([1, 2, 3]) with h = 10\n    expected output: -1\n    Explanation: The total damage dealt by the attacks is 1+2+3 = 6, which is less than h. Therefore, no value of k will be sufficient.\n\n    Edge case 3: Monocarp attacks cover a wide range of times.\n    search([1, 1000000000, 2000000000]) with h = 10\n    expected output: 3\n    Explanation: The attacks are spaced far apart, so the poison effect will only last for 3 seconds to cover all attacks.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where Monocarp attacks at the same second.\n        if len(set(a)) == 1:\n            return k\n\n    This code checks if all elements in the list a are the same and returns k if true, as the poison effect will only last for k seconds.\n", "requirement analysis:\nThe project requires creating a game where the player has to deal damage to a dragon using poisoned daggers. The challenge lies in determining the minimum duration of the poison effect required to deal at least h damage to the dragon. The game should be designed with different difficulty levels and a user-friendly interface. The competitive analysis shows that there is a need to improve the reach and engagement of the game.\nrequirement pool:\n- Implement the game logic for calculating the minimum poison effect duration.\n- Develop a user interface that allows players to choose difficulty levels and see their scores.\n- Ensure the game is responsive and can be played on various devices.\n- Add a restart button for players to easily retry a game.\n- Implement additional game modes to cater to different player preferences.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently determine the smallest k that ensures Monocarp deals at least h damage to the dragon. We will sort the attack times and then use a function to calculate the total damage dealt by Monocarp's attacks given a specific k. This function will simulate the poison effects and sum up the damage for each attack.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    'simulation': This involves iterating through the attack times and calculating the total damage dealt by Monocarp's attacks given a specific k.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Sort the attack times.\n    2. Define a function to calculate the total damage dealt for a given k.\n    3. Use binary search to find the minimum k that ensures Monocarp deals at least h damage to the dragon.\n\n# [edge case]\n    Edge case 1:\n    Input: n = 3, h = 10, attacks = [1, 2, 3]\n    Explanation: The minimum k that ensures Monocarp deals at least 10 damage is 3. The poison effect starts at the beginning of the 1st second and lasts for 3 seconds, dealing 1 damage each second. The total damage is 3, which is not enough. If k is increased to 4, the poison effect starts at the beginning of the 1st second and lasts for 4 seconds, dealing 1 damage each second. The total damage is 4 for the first attack, 4 for the second attack, and 3 for the third attack, summing up to 11, which is enough to slay the dragon.\n\n    Edge case 2:\n    Input: n = 1, h = 5, attacks = [1]\n    Explanation: Since there is only one attack, the minimum k must be at least as large as the total damage needed, which is 5.\n\n    Edge case 3:\n    Input: n = 2, h = 2, attacks = [1, 3]\n    Explanation: The minimum k that ensures Monocarp deals at least 2 damage is 2. The poison effect starts at the beginning of the 1st second and lasts for 2 seconds, dealing 1 damage each second. The total damage is 2, which is exactly what is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach will naturally handle cases where the attacks are very close together or very spread out.\n", "requirement analysis:\nThe requirement involves calculating the minimum value of k such that Monocarp's attacks, when combined with a poison effect lasting k seconds, will deal at least h damage to the dragon. This requires a binary search approach to find the minimum k, as the relationship between k and the total damage is non-linear.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the program can handle large inputs efficiently\n- Develop a user interface for input and output\n- Optimize the algorithm for large values of n and h\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently find the smallest k that ensures Monocarp's attacks deal at least h damage to the dragon. We will iterate over possible values of k, checking if the total damage after applying a poison effect lasting k seconds is sufficient to deal h damage. The search space for k will be between 1 and the maximum possible value of a_i, since the poison effect must cover at least one attack.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    'poison effect': The poison effect lasts for k seconds, during which the dragon takes 1 damage per second.\n    'damage calculation': The total damage dealt to the dragon is calculated based on the number of attacks and the duration of the poison effect.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the total damage must be at least h.\n\n# [degree adverb] \n    'minimum': Indicates that we need to find the smallest value of k.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum value of k. The binary search will be performed over the range from 1 to the maximum possible value of a_i, since the poison effect must cover at least one attack. For each potential value of k, we will simulate the attacks and calculate the total damage to determine if it is sufficient to deal at least h damage to the dragon.\n\n# [edge case] \n    Test case:\n    Input:\n    1\n    3 10\n    1 2 4\n    Expected Output:\n    3\n    Explanation:\n    The dragon needs to be dealt at least 10 damage. With k = 3, the poison effect will last for 3 seconds, and the attacks will occur at the start of the 1st, 2nd, and 4th seconds. The total damage dealt will be 3 (from the first attack) + 2 (from the second attack) + 1 (from the third attack) = 6, which is less than the required 10 damage. Increasing k to 4 will ensure that the total damage is 3 (from the first attack) + 2 (from the second attack) + 2 (from the third attack) = 7, which is still less than the required 10 damage. However, with k = 5, the total damage will be 3 (from the first attack) + 3 (from the second attack) + 3 (from the third attack) = 9, which is still less than the required 10 damage. With k = 6, the total damage will be 3 (from the first attack) + 3 (from the second attack) + 4 (from the third attack) = 10, which is sufficient to deal the required 10 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The binary search approach will naturally handle cases where the required damage can be achieved with a value of k that is greater than the maximum attack interval.\n", "requirement analysis:\nThe requirement involves calculating the minimum value of k such that Monocarp's attacks, when combined with a poison effect lasting k seconds, will deal at least h amount of damage to the dragon. This requires a binary search approach to find the minimum k, as the damage dealt by each attack depends on the duration of the poison effect.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the program can handle up to 1000 test cases efficiently\n- Optimize the algorithm to work within the constraints of the problem\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently find the smallest k that ensures Monocarp's attacks deal at least h amount of damage to the dragon. We will iterate through possible values of k, checking if the total damage dealt is sufficient for each test case. The time complexity of this approach is O(t * n * log(max_a_i)), where t is the number of test cases, n is the number of attacks, and max_a_i is the maximum value of a_i.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a certain condition. It works by repeatedly dividing the search interval in half and checking the midpoint.\n\n    'poison damage': Monocarp's attacks apply a poison effect that lasts for k seconds, dealing 1 damage per second during this period.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the required amount of damage must be met or exceeded.\n\n# [degree adverb] \n    'minimum': This indicates that we need to find the smallest value of k that still meets the condition.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum value of k. The binary search will be performed within a range defined by the smallest and largest possible values of k, which are 1 and the maximum possible value of a_i (10^9). For each potential value of k, we will simulate the attacks and calculate the total damage dealt. If the total damage is at least h, we have found a valid k; otherwise, we need to try a larger value.\n\n# [edge case] \n    Edge Case 1:\n    Input: n = 1, h = 10, a = [1]\n    Explanation: There is only one attack at the start of the 1st second. The minimum k should be 10 since the poison lasts for k seconds and deals 1 damage per second.\n    Expected Output: 10\n\n    Edge Case 2:\n    Input: n = 2, h = 5, a = [1, 3]\n    Explanation: There are two attacks, one at the start of the 1st second and another at the start of the 3rd second. The minimum k should be 3 because the poison from the first attack will last for 3 seconds, covering both attacks and dealing 5 damage in total.\n    Expected Output: 3\n\n    Edge Case 3:\n    Input: n = 3, h = 10, a = [1, 2, 3]\n    Explanation: There are three attacks at the start of the 1st, 2nd, and 3rd seconds. The minimum k should be 4 because the poison from the first attack will last for 4 seconds, covering all three attacks and dealing 10 damage in total.\n    Expected Output: 4\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles cases where the attacks are very close together or far apart, ensuring we find the minimum k required to deal at least h damage.\n", "requirement analysis:\nThe requirement involves calculating the minimum value of k such that Monocarp's attacks, when combined with a poison effect lasting k seconds, will deal at least h damage to the dragon. This requires a binary search approach to find the minimum k, as the relationship between k and the total damage is non-linear.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the program can handle large inputs efficiently\n- Develop a user interface for input and output\n- Optimize the algorithm for large values of n and h\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently find the smallest k that ensures Monocarp's attacks deal at least h damage to the dragon. We will iterate through possible values of k, checking if the total damage after applying a poison effect lasting k seconds is sufficient to deal h damage. The search space for k will be between 1 and the maximum possible value of a_i, as the poison effect must cover at least one attack.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    'poison effect': The poison effect lasts for k seconds, during which the dragon takes 1 damage per second.\n    'damage calculation': The total damage dealt to the dragon is calculated based on the number of attacks and the duration of the poison effect.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the total damage must be at least h.\n\n# [degree adverb] \n    'minimum': Indicates that we need to find the smallest value of k.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum value of k. The binary search will be performed between 1 and the maximum possible value of a_i, as the poison effect must cover at least one attack. For each potential value of k, we will simulate the attacks and calculate the total damage to determine if it is sufficient to deal at least h damage to the dragon.\n\n# [edge case] \n    Test case:\n    Input:\n    1\n    3 10\n    1 3 5\n    Expected Output:\n    3\n    Explanation:\n    The dragon needs to be dealt at least 10 damage. With k = 3, the poison effect will last for 3 seconds, and the attacks will occur at the start of the 1st, 3rd, and 5th seconds. The total damage dealt will be 3 (from the first attack) + 2 (from the second attack) + 1 (from the third attack) = 6, which is less than the required 10 damage. Increasing k to 4 will result in a total damage of 4 + 3 + 2 = 9, which is still less than the required 10 damage. However, with k = 5, the total damage will be 5 + 4 + 3 = 12, which is sufficient to deal at least 10 damage to the dragon.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case, as the binary search approach inherently handles cases where the required damage can be achieved with a suitable value of k.\n", "requirement analysis:\nThe primary requirement is to calculate the minimum value of k, the duration of the poison effect, to ensure Monocarp deals at least h damage to the dragon. The solution must handle multiple test cases efficiently and provide accurate results for each case.\nrequirement pool:\n- Implement a function to calculate the minimum poison duration for each test case.\n- Ensure the solution can handle large inputs within the given constraints.\n- Provide clear and accurate output for each test case.\n- Test the solution with multiple test cases to ensure robustness.\n- Optimize the solution for performance to handle large inputs efficiently.\nTo solve this problem, we will use a binary search approach to efficiently find the minimum value of k. The binary search will help us narrow down the possible values of k by leveraging the fact that if a value of k works, then any larger value will also work. This approach will be efficient and suitable for handling large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value of k must be sufficient to ensure at least h damage is dealt.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we need to find the smallest possible value of k that satisfies the condition.\n\n# [code logic]\n    To implement the binary search, we will follow these steps:\n    1. Sort the attack times.\n    2. Initialize the binary search range with 1 and the maximum possible value (10^18).\n    3. While the search range is valid:\n        a. Calculate the midpoint of the current range.\n        b. Check if the midpoint value of k can ensure at least h damage is dealt.\n        c. Adjust the search range based on the result of the check.\n    4. Return the minimum value of k that satisfies the condition.\n\n# [edge case] \n    Test case:\n    Input: 4\n    2 5\n    1 5\n    3 10\n    2 4 10\n    5 3\n    1 2 4 5 7\n    4 1000\n    3 25 64 1337\n\n    Output: 3\n    4\n    1\n    470\n\n    Explanation:\n    - For the first test case, the attacks are at seconds 1 and 5. With k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7], which is enough to deal 5 damage.\n    - For the second test case, the attacks are at seconds 2, 4, and 10. With k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13], which is enough to deal 10 damage.\n    - For the third test case, the attacks are at seconds 1, 2, 4, 5, and 7. With k=1, damage is dealt in seconds [1, 2, 4, 5, 7], which is enough to deal 3 damage.\n    - For the fourth test case, the attacks are at seconds 3, 25, 64, and 1337. The minimum k required to ensure at least 1000 damage is 470.\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the binary search approach inherently handles large inputs efficiently.\n", "requirement analysis:\nThe primary requirement is to determine the minimum value of k, the duration of the poison effect, to ensure Monocarp deals at least h damage to the dragon. The solution must be efficient and capable of handling large inputs within reasonable time limits. The algorithm should minimize the number of iterations and calculations to ensure optimal performance.\nrequirement pool:\n- Implement an efficient algorithm to calculate the minimum poison duration k.\n- Ensure the solution can handle large inputs within reasonable time limits.\n- Optimize the algorithm to minimize the number of iterations and calculations.\n- Provide clear and accurate results after inputting the data.\n- Ensure the user interface is user-friendly and easy to navigate.\nTo solve this problem, we will use a binary search approach to efficiently find the minimum value of k. This method will help us minimize the number of iterations and calculations needed to determine the minimum poison duration k. We will also use a sorted list of attack times to ensure we can quickly determine when the poison effect should be applied to maximize damage without overlapping.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a method to find the minimum value of k by repeatedly dividing the search interval in half. It is efficient for finding the optimal solution when the function is monotonic (either non-increasing or non-decreasing).\n\n    'sorted list': We need to maintain a sorted list of attack times to efficiently determine when to apply the poison effect.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the required damage must be met or exceeded.\n\n# [degree adverb] \n    'minimum': Indicates that we are looking for the smallest possible value of k.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases.\n    2. For each test case, read the number of attacks and the required damage.\n    3. Read the attack times and sort them.\n    4. Use binary search to find the minimum value of k.\n    5. For each potential k, calculate the total damage dealt and compare it with the required damage.\n    6. Return the minimum k that ensures at least h damage.\n\n# [edge case] \n    Test case: 1 1\n    Input: [1]\n    Explanation: There is only one attack, and the required damage is 1. The minimum k is 1 because the attack is at the first second, and the poison effect will last for 1 second to deal the exact damage.\n    Expected output: 1\n\n# [extra code for edge case]\n    We do not need extra code for this edge case as the logic for binary search will handle it correctly.\n\n# [code logic continued]\n    Here is a more detailed breakdown of the binary search approach:\n    1. Initialize the search range for k from 1 to h.\n    2. While the search range is valid:\n        - Calculate the midpoint of the current range.\n        - Check if the midpoint value of k can deal at least h damage.\n        - Adjust the search range based on the result.\n    3. Return the minimum k found.\n", "requirement analysis:\nThe primary requirement is to calculate the minimum value of k, the duration of the poison effect, to ensure Monocarp deals at least h damage to the dragon. The solution must be efficient and capable of handling large inputs efficiently. The algorithm should consider the sequence and timing of attacks to determine the minimum poison duration needed to meet the damage requirement.\nrequirement pool:\n- Implement an efficient algorithm to calculate the minimum poison duration.\n- Ensure the solution can handle up to 1000 test cases.\n- Optimize the solution for handling large numbers up to 10^18.\n- Include input parsing to handle the specified format.\n- Provide clear and concise output as specified.\nTo solve this problem, we will use a binary search approach to efficiently find the minimum value of k. The binary search will help us narrow down the possible values of k by leveraging the fact that if a certain k works, then any value greater than k will also work. This approach will be efficient and capable of handling the large input sizes specified in the problem.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a given condition. It works by repeatedly dividing the search interval in half and checking the condition at the midpoint.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the binary search, we need to:\n    1. Define a function to check if a given k results in at least h damage being dealt.\n    2. Use binary search to find the minimum k that satisfies the condition.\n    3. For each test case, apply the binary search to determine the minimum k.\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n           [1]\n    Explanation: There is only one attack, and the damage needed is 1. The minimum k is 1 because the attack is at the beginning of the first second.\n    Edge case 2:\n    Input: 2 3\n           [1, 3]\n    Explanation: There are two attacks, and the damage needed is 3. The minimum k is 2 because the attacks are at the beginning of the 1st and 3rd seconds, and the poison effect will last for at least 2 seconds to deal 3 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the binary search approach inherently handles cases where the number of attacks is very large.\n\n# [code logic]\n    Here's a Python function to implement the binary search approach:\n\n    ```python\n    def can_deal_damage(k, attacks, h):\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            duration = attack_time - last_attack_time\n            damage += (duration + k - 1) // k  # Ceiling division to calculate the number of times the poison effect is updated\n            last_attack_time = attack_time\n        return damage >= h\n\n    def find_min_k(n, h, attacks):\n        left, right = 1, 10**18  # Set initial bounds for binary search\n        while left < right:\n            mid = (left + right) // 2\n            if can_deal_damage(mid, attacks, h):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # Read input and process each test case\n    t = int(input())\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        print(find_min_k(n, h, attacks))\n    ```\n\n    This code defines a function `can_deal_damage` to check if a given k results in at least h damage being dealt. The `find_min_k` function performs a binary search to find the minimum k. For each test case, it reads the input, applies the binary search, and prints the result.\n", "requirement analysis:\nThe project requires a main function that reads input from stdin, processes the data to find the minimum k value for each test case, and outputs the result to stdout. The input includes multiple test cases, each with a number of attacks and the required damage. The output should provide the minimum k value for each test case to deal at least the required damage.\nrequirement pool:\n- Implement a function to calculate the minimum k value for each test case.\n- Ensure the program can handle multiple test cases efficiently.\n- Develop a user-friendly interface for input and output.\n- Add support for different difficulty levels.\n- Include a feature to track and display player scores.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will be used to efficiently find the smallest k that ensures Monocarp deals at least h damage to the dragon. We will sort the attack times and then use a function to calculate the total damage caused by a given k. This approach will ensure we efficiently find the minimum k without having to test every possible value of k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a method used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    'damage calculation': This involves summing up the damage dealt by each attack considering the duration of the poison effect (k seconds).\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the total damage must be equal to or greater than h.\n\n# [degree adverb] \n    'minimum possible': Refers to the smallest value of k that still ensures Monocarp deals at least h damage.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Sort the attack times.\n    2. Use binary search to find the minimum k.\n    3. For each potential k, calculate the total damage using a function that iterates through the attack times and adds up the damage based on the poison effect duration.\n    4. Return the minimum k that ensures the total damage is at least h.\n\n# [edge case] \n    Test case: n = 3, h = 10, attacks = [1, 2, 3]\n    Expected output: 3\n    Explanation: With k = 3, the poison effect from each attack will deal damage over 3 seconds, summing up to 3 + 3 + 4 = 10 damage, which is exactly the required h.\n\n    Test case: n = 2, h = 5, attacks = [1, 10]\n    Expected output: 5\n    Explanation: With k = 5, the first attack will deal damage over 5 seconds, and the second attack will deal damage over 5 seconds, summing up to 1 + 5 = 6 damage, which is less than h. Increasing k to 6 will ensure the total damage is at least 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the attacks are very close together, requiring a large k to ensure the total damage is at least h. This can be done by adjusting the binary search boundaries and recalculating the damage for each iteration of the search.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 15, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "condense_two2one", "parent_index": 15}
