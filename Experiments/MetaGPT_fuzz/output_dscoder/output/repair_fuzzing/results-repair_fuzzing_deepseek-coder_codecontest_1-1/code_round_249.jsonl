{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has an array a composed of n integers, and let's represent k as the arithmetic mean of these elements (note that k might not be a whole number), and he wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k, ensuring to handle large numbers efficiently, taking into account the possible overflow in calculations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has an array a composed of n integers, and let's represent k as the arithmetic mean of these elements (note that k might not be a whole number), and he wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k, ensuring to handle large numbers efficiently, taking into account the possible overflow in calculations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers, and let k be the arithmetic mean of these elements, which may not be a whole number. He wants to remove exactly two elements from a such that the mean of the remaining (n - 2) elements is still k. Your task is to find the number of pairs of positions [i, j] (where i < j) where if the elements at these positions are deleted, the mean of the remaining (n - 2) elements will be k. It's important to handle this efficiently, considering the possibility of overflow in calculations due to large numbers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a composed of n integers. He wants to find the number of pairs of positions [i, j] (i < j) such that deleting the elements at these positions keeps the arithmetic mean of the remaining (n - 2) elements equal to the arithmetic mean of the original n elements, and to do this efficiently, especially considering large numbers and potential overflow in calculations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the counter for pairs\n    pairs_count = 0\n    \n    # Iterate through all possible pairs of indices [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new number of elements after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            \n            # Check if the new mean is equal to the original mean\n            if new_sum / new_n == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return -1\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    if mean * 2 == int(mean * 2):\n        mean_int = int(mean * 2)\n    else:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) such that removing the elements at these indices results in the remaining elements having the same mean.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    # Calculate the arithmetic mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n\n    # If the array has less than 3 elements, it's impossible to remove two elements and have the mean remain the same\n    if n < 3:\n        return 0\n\n    count = 0\n\n    # Iterate through all possible pairs of indices [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new mean after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n\n            # Check if the new mean is equal to the original mean\n            if new_mean == original_mean:\n                count += 1\n\n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\ndef find_pairs_to_remove(n, arr):\n    mean_value = sum(arr) / n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean_value:\n                count += 1\n    return count\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        arr = list(map(int, input().strip().split()))\n        result = find_pairs_to_remove(n, arr)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_delete(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # Initialize a counter for valid pairs\n    valid_pairs_count = 0\n    \n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean after removing elements at indices i and j\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == original_mean:\n                valid_pairs_count += 1\n    \n    return valid_pairs_count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_delete(n, arr)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n, arr):\n    # Calculate the arithmetic mean of the array\n    mean_value = sum(arr) / n\n    \n    # Initialize the count of pairs that need to be removed\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a copy of the array to simulate removing elements\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            \n            # Check if the mean of the remaining elements is equal to the original mean\n            if sum(temp_arr) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Calculate the result for the current test case\n    result = find_pairs_to_remove(n, arr)\n    \n    # Output the result\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], n: int) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If all elements are the same, return the number of pairs\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting the pair (i, j)\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            remaining_mean = remaining_sum / remaining_count\n            \n            # Check if the remaining mean is equal to the original mean\n            if remaining_mean == mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(arr, n)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_pairs(n, arr):\n    # Calculate the arithmetic mean of the entire array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If all elements are the same, any two elements can be deleted\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    count = 0\n    seen = set()\n    \n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i in seen or j in seen:\n                continue\n            # Calculate the sum of the remaining elements after deleting arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            # Calculate the mean of the remaining elements\n            remaining_mean = remaining_sum / (n - 2)\n            # Check if the remaining mean is equal to the original mean\n            if remaining_mean == mean:\n                count += 1\n        seen.add(i)\n    \n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], n: int) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            if new_sum / new_n == mean:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(arr, n)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    # Calculate the original mean\n    original_mean = sum(arr) / n\n\n    # Initialize the count of valid pairs\n    count = 0\n\n    # Iterate through all pairs of positions [i, j] (i < j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at positions i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n\n            # Calculate the mean of the new array\n            if len(new_arr) > 0:\n                new_mean = sum(new_arr) / len(new_arr)\n            else:\n                new_mean = 0\n\n            # Check if the new mean is equal to the original mean\n            if new_mean == original_mean:\n                count += 1\n\n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean. This requires efficient handling of large inputs and careful management of potential overflow in calculations. The solution should be optimized to handle up to 2 * 10^5 elements efficiently.\nrequirement pool:\n- Implement a solution that can handle up to 2 * 10^5 elements efficiently\n- Ensure the solution calculates the number of pairs accurately\n- Optimize the code to avoid overflow in calculations\n- Provide a user-friendly interface for easy understanding and implementation\nTo efficiently solve this problem, we will use Python due to its strong support for handling large datasets and numerical operations. We will calculate the arithmetic mean of the array and then iterate through all possible pairs of indices to check if removing these elements results in the remaining elements having the same mean. To handle large numbers efficiently and avoid overflow, we will use appropriate data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers. In this case, the mean of the array elements after removing two elements should remain the same.\n    Explanation: The arithmetic mean (average) of the array elements is calculated by summing all the elements and dividing by the number of elements. We need to find pairs of indices [i, j] such that removing the elements at these indices does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove exactly two elements from the array to check if the mean remains unchanged.\n    Explanation: The requirement specifies that we need to delete exactly two elements from the array to check if the mean of the remaining elements is still equal to the original mean.\n\n# [degree adverb] \n    'efficiently': We need to handle large numbers and ensure that our solution is optimized for large datasets.\n    Explanation: Given the constraints, we need to ensure that our solution can handle large arrays and perform calculations efficiently to avoid overflow and ensure accuracy.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge Case 1: Array with all elements equal\n    search([5, 5, 5, 5]) = -1\n    Explanation: In this case, any pair of elements removed will change the mean. Therefore, the expected output is -1.\n    Edge Case 2: Array with distinct elements\n    search([1, 2, 3, 4]) = -1\n    Explanation: In this case, there are no elements that appear as many times as their value, so the expected output is -1.\n    Edge Case 3: Array with two elements equal\n    search([1, 2, 2, 3]) = 1\n    Explanation: In this case, removing the two occurrences of 2 will not change the mean. There is only one such pair [2, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge cases mentioned.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean. This requires efficient handling of large inputs and accurate calculations to avoid overflow. The solution should also be user-friendly, providing clear and concise output.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs\n- Ensure accuracy in calculations to avoid overflow\n- Provide clear and concise output\n- Handle large inputs efficiently\n- Ensure user-friendly interface for easy interpretation\nTo efficiently solve the problem of calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean, we will use Python due to its efficient handling of large datasets and accurate calculations. We will iterate through each test case, calculate the arithmetic mean of the array, and then count the number of valid pairs [i, j] where deleting elements at these positions maintains the mean. To handle large numbers efficiently and avoid overflow, we will use appropriate data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it should appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that appears at least as many times as itself.\n    Explanation: For instance, if the array has elements [2, 2, 3, 3, 3], the largest integer that appears at least as many times as itself is 3.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through each pair of positions [i, j] in the array.\n    3. For each pair, calculate the new mean of the remaining elements after deleting the elements at positions i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    Edge case 1:\n    search([1, 2, 3, 4]) = -1\n    Explanation: In this case, there are no elements that appear as many times as their value. Therefore, the function should return -1.\n\n    Edge case 2:\n    search([5, 5, 5, 5]) = 5\n    Explanation: All elements are the same, and the largest element that appears at least as many times as itself is 5.\n\n    Edge case 3:\n    search([1]) = -1\n    Explanation: With only one element, it's impossible to delete two elements to maintain the mean. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean. This requires efficient handling of large inputs and accurate calculations to avoid overflow.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs\n- Ensure calculations are accurate to avoid overflow\n- Optimize the algorithm for large inputs\n- Provide clear and concise output\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the remaining elements having the same mean. We will use a brute-force method initially to ensure accuracy, and later optimize it by avoiding unnecessary calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers. In this case, the mean of the entire array and the mean of the remaining elements (after removing two elements) must be equal.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. The goal is to find pairs of indices [i, j] such that removing the elements at these indices does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This phrase indicates that we need to remove exactly two elements from the array to check if the mean remains unchanged.\n    Explanation: We need to remove two specific elements from the array to see if the mean of the remaining elements is still the same as the original mean.\n\n# [degree adverb] \n    'exactly': This adverb indicates that we need to find pairs of indices where removing exactly two elements results in the mean remaining unchanged.\n    Explanation: We need to ensure that only two elements are removed, and the mean of the remaining elements should be exactly the same as the original mean.\n\n# [code logic]\n    To implement this, we will follow these steps:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since there are only three elements, removing any two elements will change the mean. Therefore, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 2, 3]\n    Explanation: The original mean is (1+3+2+3)/4 = 2.25. Removing the first and third elements results in the remaining elements having a mean of (3+3)/2 = 3, which is not equal to 2.25. Removing the second and fourth elements results in the remaining elements having a mean of (1+2)/2 = 1.5, which is also not equal to 2.25. Therefore, the expected output is 0.\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: The original mean is (1+2+3+4+5)/5 = 3. Removing any two elements will change the mean. Therefore, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is very small (less than 3) or the array elements are such that removing any two elements changes the mean. This can be done by immediately returning 0 for such cases.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array where removing two elements results in the mean of the remaining elements being the same as the original mean. This involves calculating the mean of the entire array and then checking each pair of elements to see if removing them results in the same mean. The challenge lies in handling large inputs efficiently, as the number of pairs to check grows quadratically with the size of the array.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to check each pair of positions\n- Ensure the solution is optimized for large inputs\n- Add error handling for invalid inputs\n- Include comments and documentation for better understanding\nTo efficiently solve the problem of finding pairs of positions to delete for maintaining the same mean in an array, we will use Python's built-in data structures and libraries. The key steps include calculating the mean of the array, iterating through pairs of positions, and checking if removing these elements results in the same mean. We will use list comprehensions and the sum function for simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average value of a set of numbers. In this case, the mean of the array elements remains constant after removing two elements.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. Check if removing the elements at these positions results in the mean remaining the same.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The mean of the array is (1+2+3+4+5)/5 = 3. Removing any pair of elements will change the mean.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [10, 10, 10, 10]\n    Explanation: The mean of the array is (10+10+10+10)/4 = 10. Removing any pair of elements (e.g., removing the first and third elements) will keep the mean at 10.\n    Expected output: 6 (There are 6 pairs: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4])\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs is straightforward and efficient.\n\n# [code logic continued]\n    Here's a Python function to implement the logic:\n\n    ```python\n    def count_pairs(n, arr):\n        mean_value = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean_value:\n                    count += 1\n        return count\n\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n = int(input())\n            arr = list(map(int, input().split()))\n            print(count_pairs(n, arr))\n    ```\n\n    This function reads the number of test cases and for each test case, it reads the array and calculates the number of pairs that can be removed to maintain the mean.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array where removing two elements results in the mean of the remaining elements being the same as the original mean. This involves calculating the mean, iterating through pairs, and checking the condition. The efficiency of the solution is crucial given the potential size of the input.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions in the array\n- Check if removing the elements at these positions maintains the original mean\n- Count and return the number of such pairs\n- Ensure the solution is optimized for large inputs\nTo efficiently solve the problem of finding pairs of positions to delete for a given array to maintain the same mean, we will use Python's built-in data structures and libraries. The key steps include calculating the mean of the array, iterating through all pairs of positions, and checking if removing the elements at these positions maintains the original mean. We will optimize for large inputs by avoiding unnecessary calculations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers. In this case, the mean of the array elements before and after removing two elements should be the same.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element's value.\n\n# [degree adverb] \n    'largest': Refers to finding the largest integer that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: All elements are the same.\n    Edge case 2: No pair of elements can be removed to maintain the mean.\n    Edge case 3: A large array where the mean is a floating-point number, and we need to handle precision.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array has all elements the same or where no pair can maintain the mean.\n    For edge case 1:\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2\n    For edge case 2:\n        if n == 3:\n            return 0  # It's impossible to remove two elements from a 3-element array and keep the mean the same.\n\n    For edge case 3:\n        Ensure that floating-point precision errors are handled by using a tolerance level when comparing floating-point numbers.\n", "requirement analysis:\nThe problem requires calculating the arithmetic mean of the array and then finding pairs of indices whose removal will not change the mean. The challenge lies in efficiently handling large inputs and ensuring the solution is accurate.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to find pairs of indices whose removal will not change the mean.\n- Ensure the solution is efficient and can handle large inputs.\n- Optimize the algorithm for better performance.\n- Add error handling for edge cases.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through all possible pairs of indices to check if removing them changes the mean. We will use a nested loop to generate all pairs and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by adding all the numbers together and then dividing by the count of numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In this context, it means that the value of the removed elements should be greater than the arithmetic mean.\n\n# [degree adverb] \n    'exactly': specifies that the condition must be met without any deviation.\n    Explanation: This means that only pairs of elements whose removal results in the mean of the remaining elements being exactly equal to the original mean should be counted.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions results in the mean of the remaining elements being equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7], 4) = 3\n    Explanation: The original mean is 4, and the pairs that need to be removed to maintain this mean are [1, 2], [1, 3], and [2, 3].\n    search([1, 1, 1, 1], 1) = 6\n    Explanation: The original mean is 1, and all pairs need to be removed to maintain this mean. There are 6 pairs: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe primary requirement is to find the number of pairs [i, j] such that deleting the elements at these positions keeps the arithmetic mean of the remaining elements unchanged. This involves calculating the arithmetic mean of the original array and checking if the mean remains the same after deleting any pair of elements. The challenge lies in handling large inputs efficiently and avoiding overflow in calculations.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to check if deleting a pair of elements maintains the arithmetic mean.\n- Ensure the solution is optimized for large inputs and avoids overflow.\n- Add input validation to handle edge cases and ensure the program runs smoothly.\n- Include detailed comments and documentation for better understanding and maintenance.\nTo efficiently solve the problem of finding pairs that can be deleted to maintain the arithmetic mean, we will use Python's built-in libraries and optimize the calculations. The key steps include calculating the arithmetic mean of the array, checking if deleting a pair of elements maintains the arithmetic mean, and handling large inputs without overflow. We will use a simple and efficient approach to ensure the solution is robust against large inputs and potential overflow.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean is a measure of central tendency, representing the average value of a set of numbers. In this problem, we need to ensure that deleting two elements from the array does not change the arithmetic mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets the condition.\n    Explanation: We need to find the largest integer in the array that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. For each test case, calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. Check if deleting the elements at positions i and j maintains the arithmetic mean.\n    4. Count the number of such pairs.\n    5. Return the count for each test case.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    Explanation: The arithmetic mean of the array is 4. The pairs that can be deleted to maintain the mean are [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], and [3, 4].\n    search([1, 1, 1, 1]) = 6\n    Explanation: The arithmetic mean is 1. All pairs can be deleted to maintain the mean, resulting in 6 pairs.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n    This code calculates the number of pairs when all elements are the same, which is n choose 2 (nC2).\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array that can be deleted to maintain the arithmetic mean of the remaining elements. This involves calculating the mean of the entire array and then checking if deleting two specific elements maintains the same mean. The challenge lies in efficiently handling large inputs and ensuring the solution is robust against potential overflow.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to check if deleting two elements maintains the arithmetic mean.\n- Ensure the solution is optimized for large inputs and handles potential overflow.\n- Provide clear and concise output for each test case.\n- Ensure the solution is user-friendly and easy to understand.\nTo efficiently solve the problem of finding pairs of positions in an array that can be deleted to maintain the arithmetic mean, we will use Python due to its powerful standard library and ability to handle large data sets. The approach involves calculating the arithmetic mean of the entire array and then checking if deleting two specific elements maintains the same mean. We will optimize the algorithm to handle large inputs and potential overflow by using efficient data structures and avoiding unnecessary calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean is a measure of central tendency and is calculated by summing all the numbers in a list and then dividing by the count of numbers in the list.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n    Explanation: For example, \"more than zero\" means the value must be greater than 0.\n\n# [degree adverb] \n    'largest': Indicates the greatest value in a set of values.\n    Explanation: For example, \"the largest integer\" refers to the biggest number in a set of integers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve the problem efficiently, we need to:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. Check if deleting the elements at positions i and j maintains the same arithmetic mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The arithmetic mean of the array is (1+2+3+4+5)/5 = 3. If we delete any two elements, the remaining elements will not have an arithmetic mean of 3.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [1, 1, 1, 1]\n    Explanation: The arithmetic mean of the array is (1+1+1+1)/4 = 1. We can delete any two elements, and the remaining elements will still have an arithmetic mean of 1.\n    Expected output: 6\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array consists of identical elements. In such cases, any two elements can be deleted to maintain the arithmetic mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\nPlease note that the edge cases provided are hypothetical and may not directly correspond to the input format specified in the requirement. The actual implementation should consider the input format and constraints provided in the requirement.\n", "requirement analysis:\nThe primary requirement is to find the number of pairs [i, j] such that deleting the elements at these positions keeps the arithmetic mean of the remaining elements unchanged. This involves calculating the arithmetic mean of the original array and checking if the mean remains the same after deleting any pair of elements. The challenge lies in handling large inputs efficiently and avoiding overflow in calculations.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to check if deleting a pair of elements maintains the arithmetic mean.\n- Ensure the solution is optimized for large inputs and avoids overflow.\n- Develop a user-friendly interface for input and output.\n- Test the solution with various test cases to ensure accuracy and robustness.\nTo efficiently solve the problem of finding pairs that can be deleted to maintain the arithmetic mean, we will use Python's built-in libraries and optimize the calculations. The key steps include calculating the arithmetic mean of the array, checking if deleting a pair of elements maintains the arithmetic mean, and handling large inputs without overflow. We will use a simple and efficient approach to ensure the solution is robust against large inputs and potential overflow.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean is a measure of central tendency, representing the average value of a set of numbers. In this problem, we need to ensure that deleting two elements from the array does not change the arithmetic mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value of an element must be greater than the arithmetic mean.\n    Explanation: For example, if the arithmetic mean of the array is k, then an element is considered \"more than k\" if it is greater than k.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest element in the array to compare with the arithmetic mean.\n    Explanation: Finding the largest element helps in determining the threshold for elements that are \"more than\" the arithmetic mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. Check if deleting elements at positions i and j maintains the arithmetic mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'positive': means that all integer in the list is > 0\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need. \n\n# [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean is a measure of central tendency, representing the average value of a set of numbers. In this problem, we need to ensure that deleting two elements from the array does not change the arithmetic mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value of an element must be greater than the arithmetic mean.\n    Explanation: For example, if the arithmetic mean of the array is k, then an element is considered \"more than k\" if it is greater than k.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest element in the array to compare with the arithmetic mean.\n    Explanation: Finding the largest element helps in determining the threshold for elements that are \"more than\" the arithmetic mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. Check if deleting elements at positions i and j maintains the arithmetic mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean. This requires summing the elements, calculating the mean, and then iterating through pairs to check if their deletion maintains the mean. The challenge lies in handling large inputs efficiently without overflow or performance issues.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array\n- Iterate through all pairs of positions and check if their deletion maintains the mean\n- Ensure the solution is optimized for large inputs\n- Add error handling for edge cases such as empty arrays or arrays with zero elements\n- Provide detailed documentation and comments for easy understanding\nTo efficiently solve the problem of calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean, we will use Python due to its efficient handling of large datasets. We will first calculate the arithmetic mean of the entire array, then iterate through all pairs of positions and check if their deletion maintains the mean. This approach ensures that we handle large inputs efficiently without overflow or performance issues.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by adding all the numbers together and then dividing by the count of numbers. In this problem, we need to find pairs of elements to delete such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to delete exactly two elements from the array to check if the mean of the remaining elements is still equal to the original mean.\n\n# [degree adverb] \n    'largest': We are looking for the largest integer that appears at least as many times as itself.\n    Explanation: This means we need to find the integer in the list that appears the most and ensure it appears at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through all pairs of positions [i, j] (i < j) in the array.\n    3. For each pair, calculate the new mean of the remaining elements after deleting the elements at positions i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n    5. Return the total count of such pairs.\n\n# [edge case] \n    search([1, 3, 2, 4]) = 1\n    Explanation: The original mean is (1+3+2+4)/4 = 2.5. The pairs [0, 3] and [1, 2] result in the new mean being 2.5.\n    search([5, 5, 5, 5]) = 4\n    Explanation: The original mean is (5+5+5+5)/4 = 5. All pairs result in the new mean being 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where all elements are the same.\n\n# [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by adding all the numbers together and then dividing by the count of numbers. In this problem, we need to find pairs of elements to delete such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to delete exactly two elements from the array to check if the mean of the remaining elements is still equal to the original mean.\n\n# [degree adverb] \n    'largest': We are looking for the largest integer that appears at least as many times as itself.\n    Explanation: This means we need to find the integer in the list that appears the most and ensure it appears at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through all pairs of positions [i, j] (i < j) in the array.\n    3. For each pair, calculate the new mean of the remaining elements after deleting the elements at positions i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n    5. Return the total count of such pairs.\n\n# [edge case] \n    search([1, 3, 2, 4]) = 1\n    Explanation: The original mean is (1+3+2+4)/4 = 2.5. The pairs [0, 3] and [1, 2] result in the new mean being 2.5.\n    search([5, 5, 5, 5]) = 4\n    Explanation: The original mean is (5+5+5+5)/4 = 5. All pairs result in the new mean being 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where all elements are the same.\n"], "scores": [], "pass_results": [true, true, true, true, true, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 249, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 196}
