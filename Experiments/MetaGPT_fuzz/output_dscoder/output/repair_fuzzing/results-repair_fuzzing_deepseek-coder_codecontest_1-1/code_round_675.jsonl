{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got a list a composed of n integers. Let's denote k as the average of these elements (note that it's possible that k is not an integer).\n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. The sum is divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to determine the count of pairs of indices [i, j] (where i < j) such that if the elements at these indices are removed, the mathematic mean of (n - 2) remaining elements matches k (that is, it is equal to the mathematic mean of n elements of the original array a). The solution should efficiently handle cases with larger values of n. Consider edge cases where there are multiple possible pairs that satisfy the condition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got a list a composed of n integers. Let's denote k as the average of these elements (note that it's possible that k is not an integer).\n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. The sum is divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to determine the count of pairs of indices [i, j] (where i < j) such that if the elements at these indices are removed, the mathematic mean of (n - 2) remaining elements matches k (that is, it is equal to the mathematic mean of n elements of the original array a). The solution should efficiently handle cases with larger values of n. Consider edge cases where there are multiple possible pairs that satisfy the condition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has a list of n integers, and the average of these elements is denoted as k. The average of an array of n elements is calculated by dividing the sum of the elements by the number of these elements. Monocarp wants to remove exactly two elements from this list so that the average of the remaining (n - 2) elements is still equal to k.\n\nYour task is to find the number of pairs of indices [i, j] (where i < j) such that if the elements at these indices are removed, the average of the remaining (n - 2) elements matches k. This\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has a list a of n integers, and k is the average of these elements. He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Determine the count of pairs of indices [i, j] (where i < j) such that removing the elements at these indices keeps the mean of the remaining elements equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(arr: List[int], target_mean: float) -> int:\n    \"\"\"\n    Count the number of pairs of indices [i, j] (where i < j) such that if the elements at these indices are removed, the mean of the remaining elements is equal to the target mean.\n    \n    Args:\n        arr (List[int]): The input array of integers.\n        target_mean (float): The target mean of the original array.\n    \n    Returns:\n        int: The count of such pairs.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == target_mean:\n                count += 1\n    return count\n\n# Read input from stdin\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    target_mean = sum(arr) / len(arr)\n    result = count_pairs_to_maintain_mean(arr, target_mean)\n    print(result)\n", "from typing import List\n## main.py\n\ndef count_pairs_to_delete(arr: list) -> int:\n    n = len(arr)\n    mean_of_arr = sum(arr) / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == mean_of_arr:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(arr: List[int], target_mean: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == target_mean:\n                count += 1\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    target_mean = sum(arr) / n\n    result = count_pairs_to_maintain_mean(arr, target_mean)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    count = 0\n    element_count = [0] * n\n    \n    for i in range(n):\n        new_sum = total_sum - arr[i]\n        if (new_sum / (n - 1)) == original_average:\n            count += element_count[i]\n        element_count[i] = count\n    \n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_remove(n, arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    pairs_to_remove = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_average = new_sum / (n - 2)\n            if new_average == original_average:\n                pairs_to_remove += 1\n    \n    return pairs_to_remove\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_remove(n, arr)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n, arr):\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == average:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\ndef calculate_pairs_to_remove(n: int, arr: list) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n\n    if all(x == arr[0] for x in arr):\n        # If all elements are the same, any pair can be removed to maintain the mean\n        return n * (n - 1) // 2\n\n    pairs_to_remove = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == original_mean:\n                pairs_to_remove += 1\n\n    return pairs_to_remove\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    total_sum = sum(arr)\n    mean = total_sum / n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                count += 1\n\n    return count\n\n# Read input and process test cases\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    original_mean = sum(arr) / n\n    total_sum = sum(arr)\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == original_mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef count_pairs_to_remove(n, arr):\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            if new_sum / new_n == average:\n                count += 1\n    return count\n\n# Read input\ninput_lines = sys.stdin.readlines()\ninput_iter = iter(input_lines)\nt = int(next(input_iter))\n\nfor _ in range(t):\n    n = int(next(input_iter))\n    arr = list(map(int, next(input_iter).split()))\n    result = count_pairs_to_remove(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices that can be deleted from the array to maintain the original mean. The solution should be efficient enough to handle up to 2 * 10^5 elements across multiple test cases. The input consists of multiple test cases, each with a different number of elements and values. The output should be the count of valid pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through pairs of indices and check if removing them maintains the original mean.\n- Ensure the solution is optimized for large inputs and multiple test cases.\n- Add error handling for invalid inputs.\n- Provide a user-friendly interface for easy interaction.\nTo efficiently handle the problem of finding pairs of indices to delete from an array such that the mean remains unchanged, we will use Python's built-in data structures and algorithms. The main challenge is to ensure that the solution is optimized for large inputs and can handle multiple test cases. We will calculate the mean of the array and then iterate through pairs of indices to check if their removal maintains the original mean. The solution will be encapsulated in a main function that reads input from stdin and prints the output.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' (mean)\n    The average (mean) of a list of numbers is the sum of the numbers divided by the number of elements in the list.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs of indices that maintain the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at these indices maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation:\n    The mean of the array is (1+2+3+4+5)/5 = 3. We can remove the elements at indices [0, 1], [0, 2], or [1, 2] to maintain the mean of 3.\n    search([1, 1, 1, 1]) = 6\n    Explanation:\n    The mean of the array is (1+1+1+1)/4 = 1. We can remove any two elements to maintain the mean of 1. There are 6 possible pairs: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any pair of elements can be removed to maintain the mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\nPlease note that the edge cases provided in the example are hypothetical and may not directly apply to the given problem statement. The actual edge cases should be derived from the input constraints and requirements of the problem.\n", "requirement analysis:\nThe primary requirement is to determine the number of pairs of indices [i, j] such that removing the elements at these indices results in the remaining elements having the same mean as the original array. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all possible pairs of indices and check if removing them results in the same mean.\n- Ensure the solution is optimized for large inputs and multiple test cases.\n- Add error handling for invalid inputs.\n- Include detailed documentation and comments for easier understanding.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair-wise comparisons. The key steps include calculating the mean of the array, iterating through all possible pairs of indices, and checking if removing these indices results in the same mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' (mean)\n    The average (mean) of a list of numbers is the sum of the numbers divided by the number of elements in the list.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the mean.\n\n# [degree adverb] \n    'largest': suggests that we need to consider the largest possible pairs of indices that can be removed without changing the mean.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at indices i and j results in the mean remaining unchanged.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: The mean of the array is 3. Possible pairs to remove are [1, 2], [1, 3], [2, 3], [2, 4], [3, 4], and [4, 5].\n    search([1, 1, 1, 1]) = 6\n    Explanation: All elements are the same, so any pair can be removed to keep the mean unchanged. There are 6 possible pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs is straightforward and efficient.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices [i, j] such that the removal of elements at these indices maintains the original mean. This requires a thorough understanding of the mean calculation and efficient handling of large datasets. The solution should be robust enough to handle edge cases and ensure that the mean remains unchanged after the removal of two elements.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices [i, j] that can be removed to maintain the mean.\n- Ensure the solution is optimized for large datasets.\n- Handle edge cases where multiple pairs can maintain the mean.\n- Provide a user-friendly interface for input and output.\nTo solve this problem efficiently, we will use Python's built-in data structures and algorithms. The main challenge is to find pairs of indices that, when removed, do not change the mean of the array. We will calculate the mean of the entire array and then iterate through the array to find pairs of elements whose removal does not alter the mean. This approach will be optimized to handle large datasets by avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' and 'mean': These concepts refer to the sum of elements divided by the number of elements in a list. The average (mean) of an array is calculated by summing all the elements and then dividing by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find pairs of indices whose removal does not change the mean of the array.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to consider the largest possible pairs of indices that could be removed without altering the mean.\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: In this case, there are no pairs of indices that can be removed to keep the mean unchanged because the array elements are distinct and no pair will result in the mean remaining the same.\n    search([2, 2, 4, 4]) = 3\n    explanation: There are three pairs that can be removed to keep the mean unchanged: (0, 2), (0, 3), and (1, 2).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has all identical elements. In such cases, any pair of elements can be removed without changing the mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\nPlease note that the edge case handling code provided is a simplified example and may not cover all edge cases. The actual implementation should consider all possible edge cases and ensure the code is efficient and handles large inputs correctly.\n", "requirement analysis:\nThe requirement is to find the number of pairs of indices [i, j] such that removing the elements at these indices maintains the average of the remaining elements as k. This involves calculating the sum of the array, the average, and then checking pairs of indices to ensure the average remains the same after removal.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of indices [i, j] where i < j.\n- Ensure the function checks if removing the elements at these indices maintains the average as k.\n- Optimize the solution for handling large inputs efficiently.\n- Provide clear and accurate results for each test case.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the sum of the array and the average, then iterating through all possible pairs of indices to check if removing them maintains the average. We will optimize this by using a single pass to calculate the sum and then another pass to count the valid pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'removal of elements': the process of deleting elements from a list\n    'mathematical mean': the sum of elements divided by the number of elements\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another\n    'at least as many times': indicates a comparison where one quantity is at least as large as another\n\n# [degree adverb] \n    'largest': indicates the greatest or highest value in a set of values\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the total sum of the array.\n    2. For each pair of indices (i, j), calculate the sum of the remaining elements.\n    3. Check if the average of the remaining elements is equal to the original average.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 2\n    explanation: The original average is 3. Removing the elements at indices 2 and 3 (values 3 and 4) results in the remaining elements [1, 2, 5] having an average of 2.8, which is not equal to 3. There are two valid pairs: [2, 3] and [3, 4].\n    search([1, 1, 1, 1]) = 6\n    explanation: The original average is 1. Removing any two elements will always result in an average of 1, since all elements are the same. There are 6 pairs: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe problem requires finding pairs of indices to remove from a list such that the average of the remaining elements remains unchanged. This involves calculating the average of the entire list, then checking each pair of indices to see if removing them results in the same average. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a function to calculate the average of the list.\n- Iterate through all pairs of indices and check if removing them maintains the average.\n- Optimize the solution to handle large inputs efficiently.\n- Add support for multiple test cases.\n- Ensure the solution is robust and handles edge cases.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries. The main challenge is to iterate through all pairs of indices and check if removing them maintains the average. We will calculate the total sum of the list and use this to quickly check the new average after removing any pair of elements. The solution will be optimized to handle large inputs efficiently by avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'remove elements': the operation of excluding certain elements from a list\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the list\n\n# [degree adverb] \n    'exactly': means we need to find pairs of indices where removing exactly two elements maintains the average\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to iterate through all pairs of indices (i, j) where i < j, remove the elements at these indices, and check if the new average of the remaining elements is still k.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 3) = 2\n    explanation: Removing the elements at indices 0 and 1 (1 and 2) results in a new average of 3, which is the original average. Similarly, removing the elements at indices 1 and 2 (2 and 3) also results in a new average of 3.\n    search([1, 1, 1, 1], 1) = 2\n    explanation: Removing any two elements from the list of ones will result in an average of 1, which is the original average. There are two pairs that can be removed: (0, 1) and (0, 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find pairs of indices that maintain the average is already part of the main solution logic.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of indices that, when removed, result in the average of the remaining elements being the same as the original average. This involves a straightforward calculation and a nested loop to check each pair of indices.\nrequirement pool:\n- Implement the calculation of the average of the array.\n- Find pairs of indices that, when removed, result in the average of the remaining elements being the same as the original average.\n- Ensure the solution is efficient enough to handle large inputs within the given constraints.\n- Optimize the algorithm for performance and memory usage.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the average of the array and then iterating through all possible pairs of indices to check if removing them results in the average of the remaining elements being the same as the original average. We will use a nested loop to check each pair of indices.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the process of deleting specific elements from a list\n    'nested loop': a programming technique where two loops are used to iterate through all possible pairs of elements in a list\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of elements being considered is greater than a specified value\n    'at least as many times': means that the frequency of an element is at least as much as its value\n\n# [degree adverb] \n    'largest': refers to the biggest value in a list\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: There are no pairs of indices that can be removed to keep the average the same since the average of all elements is 3, and removing any two elements will change the average.\n    search([3, 3, 3, 3]) = 6\n    explanation: There are six pairs of indices that can be removed to keep the average the same: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find pairs of indices can be implemented directly in the function.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of indices to be deleted such that the mean of the remaining elements remains unchanged. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their removal maintains the mean. The constraints are high, requiring the solution to be efficient and scalable.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all possible pairs of indices and check if their removal maintains the mean.\n- Ensure the solution is efficient and can handle the upper limits of the input constraints.\n- Add error handling for invalid inputs.\n- Optimize the algorithm for better performance.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the mathematical operations and iteration. The key steps include calculating the mean of the array, iterating through all possible pairs of indices, and checking if the removal of these pairs maintains the mean. We will use a list to store the input array and a nested loop to check each pair of indices.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the process of deleting specific elements from a list\n    'mean preservation': the condition that the mean of the remaining elements is equal to the original mean after the removal of elements\n\n# [phrase showing quantity relationship]\n    'more than': not applicable in this context\n    'at least as many times': not applicable in this context\n\n# [degree adverb] \n    'largest': not applicable in this context\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] that can be removed to keep the mean unchanged.\n    search([2, 2, 2]) = 3\n    explanation: There are three pairs [0, 1], [0, 2], and [1, 2] that can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2\n\n    This code checks if all elements in the array are the same and calculates the number of pairs accordingly.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices [i, j] such that removing the elements at these indices keeps the mean of the remaining elements equal to the original mean. This involves iterating through the array, calculating the mean, and then checking pairs of elements to ensure the mean remains unchanged after their removal.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices [i, j] that can be removed without changing the mean.\n- Ensure the program can handle large inputs efficiently.\n- Add user input handling for test cases.\n- Implement output formatting as specified.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to iterate through the array and check pairs of indices to ensure the mean remains unchanged after their removal. We will calculate the mean of the array once and then iterate through all possible pairs of indices to check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the mean of the elements in the list\n    'removal of elements': deleting two specific elements from the list to maintain the average\n    'pairs of indices': combinations of two different indices from the list\n\n# [phrase showing quantity relationship]\n    'more than': not applicable in this context\n    'at least as many times': not applicable in this context\n\n# [degree adverb] \n    'largest': not applicable in this context\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Calculate the mean of the array\n    - Iterate through all possible pairs of indices (i, j) where i < j\n    - Check if removing the elements at these indices keeps the mean of the remaining elements equal to the original mean\n    - Count the number of such pairs\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] that can be removed to keep the mean unchanged.\n    search([2, 2, 2]) = 3\n    explanation: All pairs [0, 1], [0, 2], [1, 2] can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs is straightforward and does not require additional complexity for edge cases.\n\n# [code logic]\n    ```python\n    def count_pairs(n, arr):\n        total_sum = sum(arr)\n        k = total_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                    count += 1\n        return count\n\n    # Read input and process test cases\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(count_pairs(n, arr))\n    ```\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] that can be removed to keep the mean unchanged.\n    search([2, 2, 2]) = 3\n    explanation: All pairs [0, 1], [0, 2], [1, 2] can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs is straightforward and does not require additional complexity for edge cases.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices [i, j] that can be deleted to maintain the mean of the array. The input consists of multiple test cases, and each test case has a specific number of elements and their values. The output should be the count of such pairs for each test case.\nrequirement pool:\n- Implement the function to calculate the mean of the array.\n- Develop a method to find pairs of indices [i, j] that can be deleted without changing the mean.\n- Ensure the solution is efficient enough to handle large inputs within the given constraints.\n- Optimize the code for readability and maintainability.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the mean of the array for each test case, then finding all possible pairs of indices [i, j] where i < j, and removing these elements does not change the mean. This can be efficiently done by iterating through the array and using a set to track the sum of the remaining elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the mean of a list of numbers is the sum of the numbers divided by the number of elements in the list.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that removing the elements at these indices keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': In this context, it means that the sum of the remaining elements after removing two should still be equal to the original sum multiplied by the new count (n - 2).\n\n# [degree adverb] \n    'largest': This is not directly applicable in the context of the requirement, but the concept of finding the largest integer that appears at least as many times as itself is relevant.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the new mean of the remaining elements is still equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [3, 3, 3]\n    Expected output: 0\n    Explanation: Since there are only three elements and removing any two will change the mean, there are no valid pairs.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. The only pair that keeps the mean unchanged is [0, 3] since removing 1 and 4 leaves a mean of (2+3)/2 = 2.5.\n\n    Edge case 3: n = 5, array = [1, 1, 2, 2, 3]\n    Expected output: 2\n    Explanation: The original mean is (1+1+2+2+3)/5 = 1.8. The valid pairs are [0, 2], [0, 3], [1, 2], [1, 3], [2, 4], and [3, 4], but only [0, 2] and [1, 3] keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can be used to solve all test cases, including the edge cases.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices [i, j] such that removing the elements at these indices results in the remaining elements having the same average as the original array. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to iterate through all possible pairs of indices and check the condition.\n- Optimize the function to handle large inputs efficiently.\n- Ensure the solution can handle edge cases where no pairs satisfy the condition.\nTo efficiently solve this problem, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the average of the array and then iterating through all possible pairs of indices to check if removing the elements at these indices results in the remaining elements having the same average. We will optimize the solution to handle large inputs efficiently by avoiding unnecessary computations and leveraging Python's built-in functions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'pair': two elements in a list\n    'removal': deleting elements from a list\n\n# [phrase showing quantity relationship]\n    'more than': indicates the need to find pairs that, when removed, do not change the average\n\n# [degree adverb] \n    'largest': suggests finding the maximum number of pairs that can be removed\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: No pair of elements can be removed to maintain the average, as all elements are distinct.\n    search([1, 1, 1, 1, 1]) = 10\n    explanation: Any pair of elements can be removed since all elements are the same. There are 5 elements, so the number of pairs is 5 choose 2, which is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly calculate the number of pairs using the combination formula.\n\n# [code logic]\n    def count_pairs(lst):\n        n = len(lst)\n        total_sum = sum(lst)\n        k = total_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (total_sum - lst[i] - lst[j]) / (n - 2) == k:\n                    count += 1\n        return count\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: No pair of elements can be removed to maintain the average, as all elements are distinct.\n    search([1, 1, 1, 1, 1]) = 10\n    explanation: Any pair of elements can be removed since all elements are the same. There are 5 elements, so the number of pairs is 5 choose 2, which is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly calculate the number of pairs using the combination formula.\n"], "scores": [], "pass_results": [true, true, true, false, true, true, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 675, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 560}
