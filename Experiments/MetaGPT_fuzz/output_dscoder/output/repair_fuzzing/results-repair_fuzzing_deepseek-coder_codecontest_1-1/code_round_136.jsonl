{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Consider edge cases when powers of n contribute significantly to the formation of special numbers. Ensure that you handle cases where the base n is large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Consider edge cases when powers of n contribute significantly to the formation of special numbers. Ensure that you handle cases where the base n is large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis is fascinated by sequences of positive integers and has been studying sequences composed solely of special numbers. His teacher, Yeltsa Kcir, has given him a problem involving a sequence where each number is special, meaning it can be expressed as a sum of distinct non-negative powers of a given base \\( n \\). For instance, for \\( n = 4 \\), the number 17 is special because it can be written as \\( 4^0 + 4^2 = 1 + 16 = 17 \\). Conversely, the number 9 is not special, as it cannot be expressed\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis needs help with finding the k-th special number in a sequence consisting of only special numbers, which can be expressed as sums of distinct non-negative powers of n, modulo 10^9+7. He should consider edge cases and handle large bases.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport sys\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in increasing order for a given base n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base of the powers.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    def generate_special_numbers(base, max_power):\n        dp = [0] * (max_power + 1)\n        dp[0] = 1  # There's one way to represent 0, which is not to use any power\n        \n        for power in range(1, max_power + 1):\n            dp[power] = dp[power - 1] * base % MOD\n        \n        return dp\n    \n    # Generate special numbers for the given base\n    dp = generate_special_numbers(n, 32)  # 32 is chosen because 2^31 is the largest power of 2 that fits in a 32-bit integer\n    \n    # Generate the k-th special number\n    current_sum = 0\n    power = 0\n    while k > 0:\n        if k & 1:\n            current_sum = (current_sum + dp[power]) % MOD\n        k >>= 1\n        power += 1\n    \n    return current_sum\n\n# Read input and output results\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    def is_special_number(x, n):\n        power = 1\n        while power <= x:\n            if x & power:\n                x -= power\n            power *= n\n        return x == 0\n\n    low, high = 1, 2**63 - 1\n    while low < high:\n        mid = (low + high) // 2\n        if is_special_number(mid, n):\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low % MOD\n\n# Read input from stdin\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number modulo 10^9+7.\n    \n    A special number is defined as a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n    \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_special(n: int, k: int) -> bool:\n    \"\"\"\n    Check if a number k can be expressed as a sum of distinct non-negative powers of a given base n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The number to check.\n    \n    Returns:\n        bool: True if k can be expressed as a sum of distinct non-negative powers of n, False otherwise.\n    \"\"\"\n    powers = []\n    i = 0\n    while k > 0:\n        if k % 2 == 1:\n            powers.append(i)\n        k //= 2\n        i += 1\n    return sum(n**p for p in powers) == k\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Find the k-th special number for a given base n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n    \n    Returns:\n        int: The k-th special number.\n    \"\"\"\n    special_numbers = []\n    i = 0\n    while len(special_numbers) < k:\n        if is_special(n, i):\n            special_numbers.append(i)\n        i += 1\n    return special_numbers[-1]\n\n# Interface\nn = int(input())\nk = int(input())\nresult = find_kth_special_number(n, k)\nprint(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    while k > 0:\n        result += (k % n) * power\n        k //= n\n        power *= n\n        result %= MOD\n    return result\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        print(find_kth_special_number(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number for a given base n.\n    \n    A special number is one that can be represented as the sum of distinct non-negative powers of the base n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number.\n    \"\"\"\n    if n < 2 or k < 1:\n        return -1\n    \n    special_numbers = []\n    power = 0\n    \n    while True:\n        value = n**power\n        if value > k:\n            break\n        special_numbers.append(value)\n        power += 1\n    \n    if len(special_numbers) < k:\n        return -1\n    \n    return special_numbers[k - 1]\n\n# Interface\nn = int(input())\nk = int(input())\nresult = find_kth_special_number(n, k)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\nimport io\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence consisting of sums of distinct non-negative powers of n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n    \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\ninput = io.BytesIO(sys.stdin.read).readline\nt = int(input().decode().strip())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().decode().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence consisting of sums of distinct non-negative powers of n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base of the powers.\n        k (int): The position in the sequence.\n    \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence consisting of sums of distinct non-negative powers of a given base n, modulo 10^9+7.\n    \n    Args:\n    n (int): The base of the powers.\n    k (int): The position in the sequence of special numbers.\n    \n    Returns:\n    int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    special_numbers = []\n    i = 0\n    while True:\n        power = n**i\n        if power > k:\n            break\n        current_numbers = [power]\n        for num in special_numbers:\n            if num + power <= k:\n                current_numbers.append(num + power)\n        special_numbers.extend(current_numbers)\n        i += 1\n    \n    special_numbers.sort()\n    if k <= len(special_numbers):\n        return special_numbers[k - 1]\n    else:\n        return -1\n\n# Provide the Interface\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nline_index = 1\nfor _ in range(t):\n    n = int(data[line_index])\n    k = int(data[line_index + 1])\n    line_index += 2\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    return result\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        result = find_kth_special_number(n, k)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires finding the k-th special number in a sequence that consists of numbers which are sums of distinct non-negative powers of a given base n. The special numbers must be calculated modulo 10^9+7 to handle large values. The solution should be efficient and capable of handling large inputs efficiently. The base n can be as large as 10^9, and k can be as large as 10^9, making this a challenging problem.\nrequirement pool:\n- Implement a function to calculate special numbers based on powers of n.\n- Ensure the output is given modulo 10^9+7 to handle large numbers.\n- Develop an efficient algorithm to find the k-th special number.\n- Test the solution with various large inputs to ensure performance.\n- Optimize the algorithm for handling large values of n and k.\nTo solve this problem, we will use a mathematical approach to generate the k-th special number based on the base n. The special numbers are sums of distinct non-negative powers of n, and we need to handle large numbers modulo 10^9+7. We will use a dynamic programming approach to efficiently generate these numbers without explicitly storing all of them, which is crucial for handling large values of n and k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a base n.\n    Explanation: In the context of this problem, a special number is formed by summing up different powers of a given base n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than a certain value.\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending order.\n\n# [code logic]\n    To generate the k-th special number in increasing order for a given base n, we can use a dynamic programming approach to efficiently find the sum of distinct non-negative powers of n without explicitly storing all special numbers. This approach is crucial for handling large values of n and k.\n\n# [edge case] \n    Edge case 1: n = 2, k = 1\n    expected output: 1\n    Explanation: For n = 2, the sequence of special numbers is [1, 2, 4, 8, ...]. The 1st special number is 1.\n\n    Edge case 2: n = 3, k = 4\n    expected output: 9\n    Explanation: For n = 3, the sequence of special numbers is [1, 3, 4, 9, ...]. The 4th special number is 9.\n\n    Edge case 3: n = 5, k = 10\n    expected output: 29524\n    Explanation: For n = 5, the sequence of special numbers is [1, 5, 6, 10, ...]. The 10th special number is 29524.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the base n is large and the k-th special number is significantly large. The dynamic programming approach ensures that we can handle these cases efficiently without explicitly storing all special numbers.\n\n    To handle large numbers modulo 10^9+7, we can use modular arithmetic to ensure that the results remain within the required range. This is crucial for handling large values of n and k efficiently.\n", "requirement analysis:\nThe requirements involve finding the k-th special number in a sequence of numbers that can be expressed as sums of distinct non-negative powers of a given base n. The challenge lies in handling large numbers and ensuring the output is modulo 10^9+7. The system should be able to process multiple test cases efficiently.\nrequirement pool:\n- Implement a function to find the k-th special number for a given base n.\n- Ensure the solution can handle large values of n and k.\n- Implement the modulo operation to keep the numbers within the specified range.\n- Optimize the algorithm for performance, especially for large inputs.\n- Provide a user-friendly interface for input and output.\nTo solve this problem, we will use a mathematical approach to generate the k-th special number for a given base n. The key idea is to recognize that the sequence of special numbers for a given base n can be seen as a sum of distinct non-negative powers of n. This can be efficiently computed using bit manipulation, as each power of n corresponds to a bit in a binary representation. We will use the modulo operation to ensure the numbers stay within the specified range. The algorithm will be optimized to handle large values of n and k efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a base n.\n    Explanation: In the context of this problem, a special number is formed by summing up different powers of the base n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'at least as many times': means that the frequency of the number in the sequence should be at least equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    To find the k-th special number, we need to generate the sequence of special numbers for a given base n and find the k-th element. This can be done by iterating through the powers of n and summing them up, ensuring that we only consider distinct powers. The result should be taken modulo 10^9+7 to keep the numbers within the specified range.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear at least as many times as themselves, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest number that meets the condition.\n\n# [core concept]\n    'sum of distinct non-negative powers of n': means that each special number is a sum of different powers of n, where n is the base.\n    Explanation: For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'at least as many times': means that the frequency of the number in the sequence should be at least equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    To find the k-th special number, we need to generate the sequence of special numbers for a given base n and find the k-th element. This can be done by iterating through the powers of n and summing them up, ensuring that we only consider distinct powers. The result should be taken modulo 10^9+7 to keep the numbers within the specified range.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear at least as many times as themselves, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest number that meets the condition.\n", "requirement analysis:\nThe requirements involve understanding the concept of special numbers formed by sums of distinct non-negative powers of a given base n. The challenge lies in handling large inputs and ensuring the output is accurate modulo 10^9+7. The system should be able to process multiple test cases efficiently.\nrequirement pool:\n- Implement a function to find the k-th special number for given n and k.\n- Handle large inputs and ensure the output is modulo 10^9+7.\n- Ensure the system can process multiple test cases efficiently.\n- Design a user-friendly interface for input and output.\n- Optimize the algorithm for performance and scalability.\nTo solve the problem of finding the k-th special number modulo 10^9+7, we will use a mathematical approach based on the properties of numbers expressed as sums of distinct non-negative powers of a given base n. The approach involves understanding the binary representation of numbers, where each bit represents whether a particular power of n is included in the sum. This method allows us to efficiently generate special numbers without explicitly constructing the entire sequence, which is crucial for handling large inputs and bases.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    Explanation: A special number is formed by adding together different powers of a base number n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'at least as many times': means that we need to find numbers that appear greater than or equal to their value.\n\n# [degree adverb] \n    'largest': means that we need the biggest number that appears greater or equal to its value.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach based on the binary representation of numbers. Each bit in the binary representation of k indicates whether a particular power of n is included in the sum. We can generate special numbers by iterating through possible sums of powers of n and checking if they are special.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear greater than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'sum of distinct non-negative powers': means that we are adding different powers of a base number n, and each power can only be used once.\n    Explanation: This is crucial for understanding how special numbers are formed. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'at least as many times': means that we need to find numbers that appear greater than or equal to their value.\n\n# [degree adverb] \n    'largest': means that we need the biggest number that appears greater or equal to its value.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach based on the binary representation of numbers. Each bit in the binary representation of k indicates whether a particular power of n is included in the sum. We can generate special numbers by iterating through possible sums of powers of n and checking if they are special.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear greater than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirements involve generating special numbers based on a given base and position. The challenge lies in efficiently computing these numbers, especially for large values of n and k. The application should be able to handle multiple test cases efficiently to provide accurate results.\nrequirement pool:\n- Implement a function to determine if a number is special for a given base.\n- Develop a function to generate the k-th special number in increasing order.\n- Ensure the application can handle multiple test cases efficiently.\n- Implement input/output handling to read from standard input and print to standard output.\n- Test the application with various inputs to ensure accuracy and efficiency.\nTo efficiently generate the k-th special number for a given base n, we will use a mathematical approach that leverages the properties of powers of n. We will implement a function to check if a number is special for a given base, and then use this function to generate the k-th special number in increasing order. The application will handle multiple test cases efficiently by using an optimized algorithm that minimizes computation time.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    Explanation: In this context, a special number is one that can be represented as a sum of different powers of the base n, where each power is a non-negative integer.\n\n# [phrase showing quantity relationship]\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending numerical order.\n\n# [code logic]\n    To generate the k-th special number for a given base n, we can use a mathematical approach to find the representation of k as a sum of distinct non-negative powers of n. This involves converting k into a base-n representation where each digit represents a power of n, and then summing these powers.\n\n# [edge case] \n    n = 2, k = 5 = 101_2 (binary)\n    Explanation: The binary representation of 5 is 101, which corresponds to 2^2 + 2^0 = 4 + 1 = 5. This is the 5th special number for base 2.\n    Expected output: 5\n\n    n = 3, k = 10\n    Explanation: The 10th special number for base 3 cannot be directly represented by a simple power sum as in the previous example. We need to find the representation of 10 in base-3, which is not straightforward due to the nature of powers of 3.\n    Expected output: 12 (since 3^1 + 3^0 = 3 + 1 = 4, but we need to find the correct combination that matches the 10th position in the sequence)\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where k is larger than the number of possible special numbers for a given base n. This requires a more sophisticated algorithm to find the k-th special number, possibly involving dynamic programming or a more complex mathematical approach to enumerate all special numbers up to the k-th one.\n\n    Example code snippet to handle edge cases:\n    ```python\n    def find_kth_special_number(n, k):\n        special_numbers = []\n        i = 0\n        while len(special_numbers) < k:\n            if is_special(n, i):\n                special_numbers.append(i)\n            i += 1\n        return special_numbers[-1]\n\n    def is_special(n, num):\n        powers = []\n        i = 0\n        while num > 0:\n            if num % 2 == 1:\n                powers.append(i)\n            num //= 2\n            i += 1\n        return sum(n**p for p in powers)\n    ```\n\n    This code checks each number up to k to see if it is special for the given base n, and collects them until it has k special numbers. The `is_special` function checks if a number can be expressed as a sum of distinct non-negative powers of n.\n", "requirement analysis:\nThe requirements involve creating a program that can compute the k-th special number for a given base n. The special number is defined as a sum of distinct non-negative powers of n. The program must handle a large number of test cases efficiently, which requires optimization in both algorithm and implementation. The output should be given modulo 10^9+7 to ensure it fits within standard integer limits.\nrequirement pool:\n- Implement a function to determine the k-th special number for a given base n.\n- Optimize the algorithm to handle large values of n and k efficiently.\n- Ensure the output is given modulo 10^9+7 to avoid overflow.\n- Develop a user-friendly interface for inputting the base and position.\n- Include detailed documentation and examples to guide users.\nTo solve this problem, we will use Python due to its strong support for large integer operations and its extensive standard library. The algorithm will involve converting the number k into its base-n representation and summing the corresponding powers of n. This approach ensures that we can handle large values of n and k efficiently. We will also ensure that the output is given modulo 10^9+7 to avoid overflow.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    Explanation: In this problem, we need to find the k-th special number in a sequence where each number is a sum of distinct non-negative powers of a base n. This involves understanding how to represent numbers in a non-standard base and summing the corresponding powers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we will follow these steps:\n    1. Read the number of test cases.\n    2. For each test case, read the base n and the position k.\n    3. Convert the number k into its base-n representation.\n    4. Sum the corresponding powers of n to get the k-th special number.\n    5. Output the result modulo 10^9+7.\n\n# [edge case] \n    Test case: 2 12\n    Expected output: 12\n    Explanation: The base-2 representation of 12 is 1100, which corresponds to the powers of 2: 2^3 + 2^2 = 8 + 4 = 12.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given approach directly converts the number k into its base-n representation and sums the corresponding powers of n.\n\n# [code logic]\n    Here's the Python code to implement the solution:\n\n    ```python\n    MOD = 10**9 + 7\n\n    def find_kth_special_number(n, k):\n        result = 0\n        power = 1\n        while k > 0:\n            result += (k % n) * power\n            k //= n\n            power *= n\n            result %= MOD\n        return result\n\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n, k = map(int, input().split())\n            print(find_kth_special_number(n, k))\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n    This code reads the number of test cases and for each test case, it reads the base n and the position k. It then calculates the k-th special number by converting k into its base-n representation and summing the corresponding powers of n, outputting the result modulo 10^9+7.\n", "requirement analysis:\nThe requirements involve understanding the concept of special numbers that can be expressed as sums of distinct non-negative powers of a given base. The application needs to handle large inputs and provide results quickly. The user interface should be simple and intuitive to facilitate ease of use.\nrequirement pool:\n- Implement a function to calculate special numbers based on given base and position.\n- Ensure the application can handle large inputs efficiently.\n- Provide results modulo 10^9+7 for each test case.\n- Develop a user-friendly interface for input and output.\n- Optimize the application for fast response times.\nTo implement the function that calculates the k-th special number based on a given base n, we will use Python's mathematical capabilities to handle the calculations efficiently. We will leverage the properties of powers and sums of distinct non-negative powers to determine if a number is special. The function will be designed to work efficiently even for large inputs by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    Explanation: In this context, a special number is one that can be represented as the sum of different powers of the base n, where each power is a non-negative integer.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    'at least as many times': means that we need to find integers that appear a certain number of times or more.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that meets the condition.\n\n# [code logic]\n    To find the k-th special number for a given base n, we need to:\n    1. Understand the mathematical properties of powers and sums.\n    2. Generate numbers that can be expressed as sums of distinct non-negative powers of n.\n    3. Ensure the numbers are generated in increasing order.\n    4. Return the k-th special number.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    Explanation: In this context, a special number is one that can be represented as the sum of different powers of the base n, where each power is a non-negative integer.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    'at least as many times': means that we need to find integers that appear a certain number of times or more.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that meets the condition.\n\n# [code logic]\n    To find the k-th special number for a given base n, we need to:\n    1. Understand the mathematical properties of powers and sums.\n    2. Generate numbers that can be expressed as sums of distinct non-negative powers of n.\n    3. Ensure the numbers are generated in increasing order.\n    4. Return the k-th special number.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence of numbers that are sums of distinct non-negative powers of n, modulo 10^9+7. The challenge lies in handling large bases and ensuring the solution is efficient. The solution must be able to process multiple test cases efficiently and provide the correct output for each.\nrequirement pool:\n- Implement an algorithm to find the k-th special number.\n- Ensure the algorithm handles large bases efficiently.\n- Implement modulo 10^9+7 to handle large numbers.\n- Test the solution with multiple test cases.\n- Optimize the algorithm for performance.\nTo solve the problem of finding the k-th special number in a sequence consisting of sums of distinct non-negative powers of n, modulo 10^9+7, we will use a mathematical approach that leverages the properties of binary numbers. Each special number can be represented as a sum of distinct powers of n, which is similar to the binary representation of numbers. We will use this insight to generate the k-th special number efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sums of distinct non-negative powers of n': This refers to numbers that can be represented as a sum of unique powers of a base number n, similar to how binary numbers are sums of distinct powers of 2.\n    Explanation: In this context, a special number is formed by adding up different powers of n (where n is a positive integer and the powers are non-negative). This is akin to how binary numbers are constructed by adding powers of 2.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach based on the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, similar to how binary numbers are sums of distinct powers of 2. We will use this insight to generate the k-th special number efficiently.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'sums of distinct non-negative powers of n': This refers to numbers that can be represented as a sum of unique powers of n, similar to how binary numbers are sums of distinct powers of 2.\n    Explanation: In this context, a special number is formed by adding up different powers of n (where n is a positive integer and the powers are non-negative). This is akin to how binary numbers are constructed by adding powers of 2.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than 0.\n    'at least as many times': means that we need to find the integer whose appearances are greater than or equal to its value.\n\n# [degree adverb] \n    'largest': means that we need the largest integer that appears greater or equal to its value.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach based on the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, similar to how binary numbers are sums of distinct powers of 2. We will use this insight to generate the k-th special number efficiently.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n", "requirement analysis:\nThe requirement involves finding the k-th special number in a sequence of numbers that are sums of distinct non-negative powers of a given base n, modulo 10^9+7. This requires an efficient algorithm to handle large bases and large values of k. The solution must be accurate and handle edge cases, such as when k is very large.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number.\n- Handle large bases and values of k efficiently.\n- Ensure the solution is accurate and handles edge cases correctly.\n- Optimize the algorithm to work within performance constraints.\n- Implement the solution modulo 10^9+7.\nTo solve this problem efficiently, we will use a mathematical approach that leverages the properties of binary numbers. Each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in binary form. We will generate the k-th special number by converting k to its binary representation and then mapping each bit to the corresponding power of n. This approach ensures that we handle large bases and values of k efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': A number that can be expressed as sums of distinct non-negative powers of a base n, modulo 10^9+7.\n    Explanation: The concept involves understanding that any special number can be represented as a sum of distinct powers of n, similar to how binary numbers are sums of distinct powers of 2. This representation is unique and can be used to find the k-th special number in a sequence.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we need to:\n    1. Convert k to its binary representation.\n    2. For each bit in the binary representation, if the bit is set, add the corresponding power of n to the result.\n    3. Return the result modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n# [code logic]\n    To find the k-th special number, we need to:\n    1. Convert k to its binary representation.\n    2. For each bit in the binary representation, if the bit is set, add the corresponding power of n to the result.\n    3. Return the result modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n# [code logic]\n    To find the k-th special number, we need to:\n    1. Convert k to its binary representation.\n    2. For each bit in the binary representation, if the bit is set, add the corresponding power of n to the result.\n    3. Return the result modulo 10^9+7.\n", "requirement analysis:\nThe requirement involves finding the k-th special number in a sequence of numbers that are sums of distinct non-negative powers of a given base n, modulo 10^9+7. The challenge lies in handling large bases and values of k efficiently. The solution must be able to process multiple test cases and provide accurate results for each. Edge cases such as small and large values of n and k must be handled to ensure the solution is robust.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number\n- Handle large bases and values of k\n- Ensure accuracy and reliability in results\n- Optimize performance for large inputs\n- Provide clear and concise output\nTo efficiently find the k-th special number in a sequence consisting of sums of distinct non-negative powers of a given base n, modulo 10^9+7, we will use a mathematical approach that leverages the properties of binary numbers. Each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in binary form. By generating these sums for increasing values of n, we can find the k-th special number efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sums of distinct non-negative powers of n': This refers to numbers that can be formed by adding different powers of n together. For example, in base 2, the number 5 can be represented as 4 (2^2) + 1 (2^0), which are distinct powers of 2.\n    Explanation: The concept involves understanding that any number can be represented uniquely as a sum of distinct powers of n, similar to how numbers are represented in binary.\n\n# [phrase showing quantity relationship]\n    'distinct non-negative powers': This means that each power of n used in the sum must be unique and non-negative.\n    Explanation: For example, in base 2, the number 5 can be represented as 4 (2^2) + 1 (2^0), where 4 and 1 are distinct powers of 2.\n\n# [degree adverb] \n    'increasing order': This means that the special numbers should be listed in a sequence from smallest to largest.\n    Explanation: The sequence of special numbers starts with the smallest number that can be formed by sums of distinct powers of n and continues to larger numbers.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach that leverages the properties of binary numbers. Each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in binary form. By generating these sums for increasing values of n, we can find the k-th special number efficiently.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'sums of distinct non-negative powers of n': This refers to numbers that can be formed by adding different powers of n together. For example, in base 2, the number 5 can be represented as 4 (2^2) + 1 (2^0), which are distinct powers of 2.\n    Explanation: The concept involves understanding that any number can be represented uniquely as a sum of distinct powers of n, similar to how numbers are represented in binary.\n\n# [phrase showing quantity relationship]\n    'distinct non-negative powers': This means that each power of n used in the sum must be unique and non-negative.\n    Explanation: For example, in base 2, the number 5 can be represented as 4 (2^2) + 1 (2^0), where 4 and 1 are distinct powers of 2.\n\n# [degree adverb] \n    'increasing order': This means that the special numbers should be listed in a sequence from smallest to largest.\n    Explanation: The sequence of special numbers starts with the smallest number that can be formed by sums of distinct powers of n and continues to larger numbers.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach that leverages the properties of binary numbers. Each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in binary form. By generating these sums for increasing values of n, we can find the k-th special number efficiently.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number for a given base n, which is a power of an integer. The special numbers are sums of distinct non-negative powers of n. The challenge lies in handling large inputs and ensuring the solution is efficient. The output should be modulo 10^9+7 to avoid large number computations. The system should be able to handle multiple test cases efficiently.\nrequirement pool:\n- Implement an algorithm to find the k-th special number for a given base n.\n- Ensure the solution is efficient and can handle large inputs.\n- Implement the modulo operation to keep the numbers within the specified range.\n- Develop a user interface for easy input and output of base and position.\n- Conduct thorough testing to ensure accuracy and robustness.\nTo solve the problem of finding the k-th special number for a given base n, we will use a mathematical approach that leverages the properties of powers of n. The special numbers are sums of distinct non-negative powers of n, which can be represented as a sum of powers of 2 when n is expressed in binary. This allows us to efficiently find the k-th special number by converting k to its binary representation and mapping each bit to a power of n. The result will be modulo 10^9+7 to ensure the numbers remain within the specified range.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given base n.\n    Explanation: In this problem, we need to find the k-th special number in a sequence where each number is a sum of distinct non-negative powers of n. The base n can be very large, and we need to handle it efficiently.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve the problem, we need to:\n    1. Read the number of test cases.\n    2. For each test case, read the base n and the position k.\n    3. Convert k to its binary representation.\n    4. Use the binary representation to determine which powers of n are included in the sum.\n    5. Calculate the sum of these powers, taking modulo 10^9+7.\n    6. Output the result for each test case.\n\n# [edge case] \n    Edge case 1: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for base 2 is 1, which is 2^0.\n\n    Edge case 2: n = 3, k = 4\n    Expected output: 9\n    Explanation: The sequence for base 3 is [1, 3, 4, 9, ...]. The 4th special number is 9, which is 3^2.\n\n    Edge case 3: n = 10^9, k = 1\n    Expected output: 1\n    Explanation: For a very large base n, the first special number is always 1, which is n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is sufficient to find the k-th special number for any given base n and position k.\n"], "scores": [], "pass_results": [true, true, true, false, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 136, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "add_1_sentence_at_end", "parent_index": 116}
