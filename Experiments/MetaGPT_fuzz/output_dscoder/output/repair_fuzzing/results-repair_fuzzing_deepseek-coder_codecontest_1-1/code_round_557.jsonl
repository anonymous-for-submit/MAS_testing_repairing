{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp's challenge lies in ensuring that the mean remains constant after removing exactly two elements from the array.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp's challenge lies in ensuring that the mean remains constant after removing exactly two elements from the array.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp needs to make sure that the average of the numbers in the array stays the same after he removes two elements from it.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp's challenge is to maintain the mean of the array after removing exactly two elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef count_pairs(arr: List[int], k: float) -> int:\n    \"\"\"\n    Count the number of pairs [i, j] where i < j such that the mean of the remaining elements after removing the pair is equal to k.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        k (float): The target mean.\n        \n    Returns:\n        int: The count of pairs that result in the mean of the remaining elements being equal to k.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Calculate the mean of the new array\n            new_mean = calculate_mean(new_arr)\n            # Check if the new mean is equal to k\n            if new_mean == k:\n                count += 1\n    \n    return count\n\n# Provide input interface\nn = int(input())\narr = list(map(int, input().split()))\n\n# Provide output interface\nresult = count_pairs(arr, calculate_mean(arr))\nprint(result)\n", "from typing import List\n## main.py\nimport sys\n\ndef calculate_pairs(n, arr, k):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining (n - 2) elements is equal to k.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n        k (float): The target mean value.\n\n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    # Calculate the original mean of the array\n    original_mean = sum(arr) / n\n\n    # Initialize the count of valid pairs\n    count = 0\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate through all possible pairs of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n\n            # Check if the length of the new array is greater than 1\n            if len(new_arr) > 1:\n                # Calculate the mean of the new array\n                new_mean = sum(new_arr) / len(new_arr)\n\n                # Check if the new mean is equal to the target mean k\n                if new_mean == k:\n                    count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Read the target mean value\n    k = float(input())\n    \n    # Calculate and print the result\n    result = calculate_pairs(n, arr, k)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of an array.\n    \n    Args:\n        arr (List[int]): The input array of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef count_valid_pairs(arr: List[int], k: int) -> int:\n    \"\"\"\n    Count the number of valid pairs where the mean of the remaining elements equals the original mean.\n    \n    Args:\n        arr (List[int]): The input array of integers.\n        k (int): The original mean of the array.\n        \n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if calculate_mean(new_arr) == k:\n                count += 1\n    \n    return count\n\n# Read input from stdin\nn = int(input())\narr = list(map(int, input().split()))\nresult = count_valid_pairs(arr, n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_remove(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    target_average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == target_average:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_valid_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == original_average:\n                count += 1\n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    freq = defaultdict(int)\n    for num in arr:\n        freq[num] += 1\n    \n    valid_pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_to_check = total_sum - arr[i] - arr[j]\n            if sum_to_check / (n - 2) == original_average:\n                valid_pairs_count += 1\n    \n    return valid_pairs_count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_mean_and_pairs(n: int, arr: list[int], k: float) -> int:\n    if n == 3:\n        return 0\n    if all(element == arr[0] for element in arr):\n        return 0\n\n    total_sum = sum(arr)\n    mean_of_array = total_sum / n\n\n    if mean_of_array == k:\n        return n * (n - 1) // 2\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == k:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = float(input())\n    result = calculate_mean_and_pairs(n, arr, k)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    if not arr:\n        return 0\n    return sum(arr) / len(arr)\n\ndef find_pairs(arr: List[int], k: float) -> int:\n    \"\"\"\n    Find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to k.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        k (float): The target mean value.\n        \n    Returns:\n        int: The number of such pairs.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    mean_arr = calculate_mean(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr and calculate_mean(new_arr) == k:\n                count += 1\n    return count\n\ndef largest_frequent_element(arr: List[int]) -> int:\n    \"\"\"\n    Find the largest integer that appears at least as many times as its value.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        \n    Returns:\n        int: The largest integer that appears at least as many times as its value.\n    \"\"\"\n    from collections import Counter\n    freq_dict = Counter(arr)\n    for val in sorted(freq_dict.keys(), reverse=True):\n        if freq_dict[val] >= val:\n            return val\n    return -1\n\n# Interface for the program\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        largest_freq_element = largest_frequent_element(arr)\n        if largest_freq_element == -1:\n            print(0)\n        else:\n            mean_value = calculate_mean(arr)\n            result = find_pairs(arr, mean_value)\n            print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef find_pairs(arr: List[int], k: float) -> int:\n    \"\"\"\n    Find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to k.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        k (float): The target mean value.\n        \n    Returns:\n        int: The number of such pairs.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) > 0 and calculate_mean(new_arr) == k:\n                count += 1\n    \n    return count\n\n# Main function to read input, call the functions, and print the result\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        mean_value = calculate_mean(arr)\n        result = find_pairs(arr, mean_value)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport sys\n\ndef calculate_pairs(arr, k):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that removing the elements at these positions maintains the mean of the remaining elements equal to a given value k.\n\n    Args:\n        arr (list): A list of integers representing the array.\n        k (float): The target mean value.\n\n    Returns:\n        int: The number of pairs [i, j] that maintain the mean.\n    \"\"\"\n    n = len(arr)\n    if n < 3:\n        return -1  # It's impossible to remove two elements and maintain the mean\n\n    total_sum = sum(arr)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == k:\n                count += 1\n\n    return count\n\n# Interface for the program\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(arr, sum(arr) / n)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Create a function to find all pairs of positions [i, j] where i < j\n- Compare the mean of the remaining elements after removing the pair to the given mean k\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to iterate through all possible pairs of positions [i, j] where i < j, calculate the mean of the remaining elements after removing the pair, and compare it to the given mean k. We will use a function to calculate the mean of an array and another function to find all pairs of positions [i, j].\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. After removing two elements, the mean of the remaining elements should be equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer should be at least as high as the integer itself.\n    Explanation: For example, if the integer is 3, it should appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: If there are multiple integers that meet the condition, we should return the largest one.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the pair.\n    4. Count the number of pairs that result in the mean of the remaining elements being equal to the original mean.\n\n# [edge case] \n    search([1, 2, 3]) = -1\n    Explanation: With only three elements, it's impossible to remove two elements and still have the mean remain constant. Therefore, the expected output is -1.\n    search([2, 2, 3, 3]) = 4\n    Explanation: There are four pairs that can be removed to maintain the mean: [0, 1], [0, 2], [0, 3], and [1, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the case of having only three elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements.\n        if n == 3:\n            return 1  # Only one pair can be removed, which is any two elements.\n\n    (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Calculate the mean of the remaining elements after removing each pair\n- Compare the calculated mean with the given value k\n- Count and return the number of pairs that satisfy the condition\nTo solve this problem, we will use Python due to its simplicity and powerful standard libraries. The main challenge is to efficiently calculate the mean of the remaining elements after removing any two elements from the array and compare it with the given value k. We will use list operations and basic arithmetic to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. After removing two elements, the mean of the remaining elements should be equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new mean after removing those two elements.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The original mean of the array is (1+2+2+3+3+3+4+4+4)/9 = 3. Removing any pair of 3s will result in the mean of the remaining elements being 3.\n    search([1, 1, 1, 2, 2, 3]) = 0\n    Explanation: The original mean of the array is (1+1+1+2+2+3)/6 = 1.5. There are no pairs of elements that can be removed to keep the mean constant at 1.5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where no such pair exists.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This requires iterating through all possible pairs of positions, calculating the mean of the remaining elements, and comparing it to k.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Calculate the mean of the remaining elements after removing each pair\n- Compare the calculated mean with the given value k\n- Count and return the number of pairs that satisfy the condition\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to iterate through all possible pairs of positions in the array, calculate the mean of the remaining elements, and compare it to the given value k. We will use a function to calculate the mean of an array and iterate through all pairs of positions to find the valid ones.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. After removing two elements, the mean of the remaining elements should remain the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': indicates a comparison between the value of an element and its frequency in the array.\n    Explanation: For example, if an element has a value of 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'equal to': specifies that the mean after removal of two elements should match the original mean.\n    Explanation: This means that the sum of the remaining elements (excluding the two removed elements) divided by the number of remaining elements should equal the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of positions in the array.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Count the number of pairs where the mean of the remaining elements equals the original mean.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4] with k = 2.5\n    Expected output: 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. Removing any pair of elements will result in a mean of 2.5. The valid pairs are [1, 2] and [2, 3].\n\n    Edge case 2: [5, 5, 5, 5] with k = 5\n    Expected output: 6\n    Explanation: The original mean is (5+5+5+5)/4 = 5. Removing any two elements will still result in a mean of 5. The valid pairs are [0, 1], [0, 2], [0, 3], [1, 2], and [1, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle arrays with all identical elements.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. This requires a thorough understanding of array manipulation and mathematical operations. The algorithm must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases, summing up to 2 * 10^5 elements in total.\nrequirement pool:\n- Implement the algorithm to calculate the number of pairs [i, j] that can be removed without changing the average.\n- Ensure the code is optimized for large inputs to handle up to 2 * 10^5 elements across multiple test cases.\n- Develop a user-friendly interface for input and output.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the average of the array and then finding pairs of indices whose removal does not change the average. This can be efficiently done by iterating through the array and using a hash map to track the counts of the required sums.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pairwise removal': removing two elements from the array and checking if the average remains the same\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the average\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not comparing values directly\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 1, 1]) = 0\n    explanation: With only three elements, removing any two will change the average, so the expected output is 0.\n    search([2, 2, 2, 2]) = 6\n    explanation: With four elements, there are six possible pairs (0,1), (0,2), (0,3), (1,2), (1,3), (2,3) that can be removed without changing the average, which is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find pairs can be directly applied to the given input.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. This requires a solution that can handle large inputs efficiently and accurately.\nrequirement pool:\n- Implement a solution to calculate the number of valid pairs efficiently.\n- Ensure the program can handle large inputs within reasonable time limits.\n- Provide clear and accurate output for each test case.\nTo solve the problem of finding pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged, we can follow these steps: \n1. Calculate the total sum of the array.\n2. For each pair (i, j), calculate the new sum after removing the elements at positions i and j.\n3. Check if the new sum divided by (n - 2) equals the original average. \n4. Count all such valid pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pair': two elements selected from a sequence\n    'removal': the act of taking out elements from a sequence\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of pairs should be counted based on a comparison\n    'at least as many times': suggests that the count should be based on a minimum frequency\n\n# [degree adverb] \n    'largest': refers to finding the maximum number of pairs that maintain the average\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the total sum of the array.\n    2. Calculate the original average.\n    3. Iterate through all possible pairs (i, j) where i < j.\n    4. For each pair, calculate the new sum after removal and check if it equals the original average multiplied by (n - 2).\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 6\n    Explanation: In this case, the array has four elements all equal to 1. Any pair of elements removed will leave an average of 1 for the remaining two elements. There are 4 choose 2 = 6 pairs.\n    search([2, 2, 2, 2]) = 6\n    Explanation: Similar to the previous edge case, but with all elements equal to 2. There are still 6 pairs that can be removed to maintain the average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs is straightforward and does not change with the input values.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged. This requires a solution that is both efficient and accurate, capable of handling large inputs within the given constraints.\nrequirement pool:\n- Implement a solution to calculate the number of valid pairs efficiently.\n- Ensure the solution works correctly for all test cases.\n- Optimize the algorithm to handle large inputs within the given constraints.\n- Provide clear and accurate output for each test case.\nTo solve the problem of finding pairs of positions [i, j] such that removing the elements at these positions keeps the average of the array unchanged, we can follow these steps: \n1. Calculate the total sum of the array.\n2. For each pair of positions [i, j], calculate the new sum after removing the elements at these positions.\n3. Check if the new sum divided by (n - 2) equals the original average. \n4. Count all such valid pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pair': a combination of two elements from the array\n    'sum': the total of elements in the array\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where removing two elements results in the average remaining the same\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not comparing values directly\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the total sum of the array.\n    2. Calculate the original average.\n    3. Iterate through all possible pairs [i, j] where i < j.\n    4. For each pair, calculate the new sum after removing the elements at these positions.\n    5. Check if the new sum divided by (n - 2) equals the original average.\n    6. Count all such valid pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    Explanation:\n    The original average is (1+2+3+4+5+6+7)/7 = 4.\n    The pairs that can be removed to keep the average unchanged are [1, 4], [2, 3], [2, 4], [3, 4], [5, 6], [5, 7], [6, 7].\n    There are 3 such pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal results in the mean of the remaining elements being equal to k.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to k.\n- Ensure the solution is efficient enough to handle the upper limits of the input constraints.\n- Optimize the code for readability and maintainability.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to efficiently calculate the mean of the array and then find all pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to a given value k. We will use a brute-force approach initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. The goal is to find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to a given value k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array should be greater than the element itself.\n    Explanation: For example, if an element is 3, it must appear more than 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'exactly': means that the condition must be met without any deviation.\n    Explanation: In this context, it means that the mean of the remaining elements after removing two specific positions should be exactly equal to k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the calculated mean equals k.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: If there are only three elements in the array, there are no pairs to remove, so the output is 0.\n    Edge case 2: All elements are the same\n    Expected output: 0\n    Explanation: If all elements in the array are the same, removing any two elements will not change the mean, so the output is 0.\n    Edge case 3: k is not achievable by removing any two elements\n    Expected output: 0\n    Explanation: If the mean k cannot be achieved by removing any two elements from the array, the output should be 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n = 3 or all elements are the same.\n        if n == 3:\n            return 0\n        if all(element == a[0] for element in a):\n            return 0\n        (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal results in the mean of the remaining elements being equal to k.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to k.\n- Ensure the solution is efficient enough to handle the upper limits of the input constraints.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to efficiently calculate the mean of the array and then find all pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to a given value k. We will use a brute-force approach to iterate through all possible pairs and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the mean of the remaining elements should be calculated and compared to a given value k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as its value.\n    Explanation: We need to find the largest integer in the array that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases and iterate through each case.\n    2. For each test case, read the number of elements and the array elements.\n    3. Calculate the mean of the array.\n    4. Iterate through all possible pairs of positions [i, j] (i < j) and check if removing these positions results in the mean of the remaining elements being equal to k.\n    5. Count the number of such pairs and print the result.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3. It appears 3 times, which is equal to its value.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3. It appears 3 times, which is equal to its value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array might not have a number that appears at least as many times as its value.\n        if not any(freq >= val for val, freq in freq_dict.items()):\n            return -1\n        (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal results in the mean of the remaining elements being equal to k.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to k.\n- Ensure the solution is efficient enough to handle the upper limits of the input constraints.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to efficiently calculate the mean of the array and then find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being equal to a given value k. We will use a brute-force approach to iterate through all possible pairs of positions and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. When two elements are removed, the mean of the remaining elements should be calculated and compared to a given value k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases and iterate through each case.\n    2. For each test case, read the number of elements and the array elements.\n    3. Calculate the mean of the array.\n    4. Iterate through all possible pairs of positions [i, j] (i < j) and check if removing these positions results in the mean of the remaining elements being equal to k.\n    5. Count the number of such pairs and print the result.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3. It appears 3 times, which is equal to its value.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3. It appears 3 times, which is equal to its value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3. It appears 3 times, which is equal to its value.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3. It appears 3 times, which is equal to its value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions results in the mean of the remaining elements being equal to a given value k. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal maintains the mean.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all pairs [i, j] where i < j.\n- Develop a check to see if removing the elements at positions i and j maintains the mean.\nTo solve this problem, we will use Python due to its simplicity and powerful standard libraries. The main challenge is to efficiently calculate the number of pairs [i, j] such that removing the elements at these positions maintains the mean of the remaining elements equal to a given value k. We will use a brute-force approach initially to ensure correctness, and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. The goal is to find pairs of positions [i, j] such that removing the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: The largest integer in the array that satisfies the condition of appearing at least as many times as itself is the target we need to find.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the new mean after removing the elements at positions i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    search([1, 2, 3]) = -1\n    Explanation: With only three elements, it's impossible to remove two elements and still have the mean remain constant. Therefore, the expected output is -1.\n    search([2, 2, 3, 3]) = 4\n    Explanation: The number 2 appears twice and the number 3 appears twice. There are 4 pairs that can be removed to maintain the mean: (0, 2), (0, 3), (1, 2), and (1, 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case of having only three elements in the array.\n"], "scores": [], "pass_results": [true, false, false, false, false, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 557, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 461}
