{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really enjoys sequences of positive integers, so his teacher (Yeltsa Kcir) presented him with a task about a sequence made up of only special numbers. Let's call a positive number special if it can be expressed as a sum of distinct non-negative powers of n; for instance, for n = 4 the number 17 is special, because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17. However, note that the number 9 is not considered special. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Make sure to consider edge cases where n is very small or very large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really enjoys sequences of positive integers, so his teacher (Yeltsa Kcir) presented him with a task about a sequence made up of only special numbers. Let's call a positive number special if it can be expressed as a sum of distinct non-negative powers of n; for instance, for n = 4 the number 17 is special, because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17. However, note that the number 9 is not considered special. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Make sure to consider edge cases where n is very small or very large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis loves sequences of positive integers, and his teacher, Yeltsa Kcir, gave him a challenging task involving a sequence composed only of special numbers. A number is considered special if it can be represented as the sum of distinct non-negative powers of a given number \\( n \\). For example, for \\( n = 4 \\), the number 17 is special because it can be expressed as \\( 4^0 + 4^2 = 1 + 16 = 17 \\). Conversely, the number 9 is not considered special. Theofanis needs your help to determine the \\(\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis needs to find the k-th special number in a sequence made of special numbers, which can be expressed as a sum of distinct non-negative powers of n, modulo 10^9+7. He should consider edge cases where n is very small or very large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if n == 2:\n        return 1 << (k - 1) if k <= 31 else (1 << 31) + (k - 31)\n    elif n == 3:\n        return 3**(k - 1) if k <= 10 else 3**10 * (k - 10)\n    \n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    return result\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number in a sequence defined by the base number n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read input and output results\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    special_numbers = []\n    power = 1\n    \n    while power <= k:\n        current_power = power\n        current_sum = 0\n        \n        while current_sum + current_power <= k:\n            current_sum += current_power\n            special_numbers.append(current_sum)\n            current_power *= n\n        \n        power += 1\n    \n    special_numbers.sort()\n    return special_numbers[k - 1] % MOD\n\n# Interface\ninput_data = sys.stdin.readline\nt = int(input_data())\nfor _ in range(t):\n    n, k = map(int, input_data().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number for a given base n.\n    \n    A special number is defined as a number that can be represented as the sum of distinct non-negative powers of n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    if k == 1:\n        return 1  # The first special number is always 1 for any base\n    \n    powers = []\n    power = 0\n    while True:\n        current_power = n**power\n        if current_power > k:\n            break\n        powers.append(current_power)\n        power += 1\n    \n    # Generate all possible sums of distinct powers\n    from itertools import combinations\n    special_numbers = set()\n    for r in range(1, len(powers) + 1):\n        for combo in combinations(powers, r):\n            special_numbers.add(sum(combo))\n    \n    # Convert the set to a sorted list\n    special_numbers = sorted(special_numbers)\n    \n    # Return the k-th special number\n    if k <= len(special_numbers):\n        return special_numbers[k - 1] % MOD\n    else:\n        return -1\n\n# Interface for the program\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        result = find_kth_special_number(n, k)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef compute_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    special_numbers = set()\n    power = 0\n    \n    while True:\n        current_power_value = n ** power\n        if current_power_value > k:\n            break\n        \n        i = 1\n        while current_power_value * i <= k:\n            special_numbers.add(current_power_value * i)\n            i += 1\n        \n        power += 1\n    \n    sorted_special_numbers = sorted(special_numbers)\n    \n    if k > len(sorted_special_numbers):\n        return -1\n    \n    return sorted_special_numbers[k - 1]\n\n# Read input and process each test case\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = compute_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number for a given base number n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n        \n    Returns:\n        int: The k-th special number in increasing order modulo 10^9+7.\n    \"\"\"\n    special_numbers = set()\n    power = 0\n    \n    while True:\n        current_power = n ** power\n        if current_power > k:\n            break\n        if current_power not in special_numbers:\n            special_numbers.add(current_power)\n        power += 1\n    \n    sorted_special_numbers = sorted(special_numbers)\n    \n    if k > len(sorted_special_numbers):\n        return -1\n    \n    return sorted_special_numbers[k - 1]\n\n# Read input and process each test case\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + pow(n, power, MOD)) % MOD\n        k //= 2\n        power += 1\n    \n    return result\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if n == 1:\n        return 1 if k == 1 else -1  # If n is 1, the only special number is 1\n\n    special_numbers = []\n    max_power = 0\n    while k > 0:\n        current_sum = sum(n**j for j in range(max_power, max_power + k))\n        special_numbers.append(current_sum % MOD)\n        max_power += k\n        k -= 1\n\n    special_numbers.sort()\n    return special_numbers[k]\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence defined by powers of n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe task requires finding the k-th special number in a sequence defined by sums of distinct non-negative powers of n. The sequence can grow very large, so the output should be modulo 10^9+7. The input includes multiple test cases, and each case specifies n and k. The special numbers are those that can be expressed as sums of distinct non-negative powers of n.\nrequirement pool:\n- Implement a function to calculate the k-th special number for given n and k.\n- Ensure the output is modulo 10^9+7 to handle large numbers.\n- Handle edge cases where n is very small or very large.\n- Optimize the algorithm to handle large values of n and k efficiently.\n- Include error handling for invalid inputs.\nTo solve the problem of finding the k-th special number in a sequence defined by sums of distinct non-negative powers of n, we will use a mathematical approach. The sequence can be represented as sums of distinct powers of n, which can be efficiently computed using bit manipulation. Given the constraint that the output should be modulo 10^9+7, we will ensure that all intermediate calculations are performed modulo 10^9+7. The algorithm will handle edge cases where n is very small or very large by optimizing the computation for both small and large values of n and k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of n.\n    Explanation: In this context, a special number is formed by adding together different powers of a base number n. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than a certain value.\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'increasing order': means that the sequence of special numbers should be sorted in ascending order.\n\n# [code logic]\n    To find the k-th special number in increasing order, we can use a mathematical approach that leverages the binary representation of k. Each bit in the binary representation of k corresponds to a power of n that is included in the sum. For example, if k = 5 (which is 101 in binary), the special number would be n^2 + n^0. This approach allows us to efficiently compute the k-th special number without generating all previous special numbers.\n\n# [edge case] \n    n = 2, k = 1 = 1\n    Explanation: When n = 2, the sequence starts with 1 (2^0). The 1st special number is 1.\n    n = 3, k = 2 = 2\n    Explanation: When n = 3, the sequence starts with 1 (3^0) and 3 (3^1). The 2nd special number is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n is very small. For very small values of n, we can precompute the sequence up to the maximum possible special number for that n.\n        if n == 2:\n            return [1] * k\n        elif n == 3:\n            return [1, 3]\n\n    This code ensures that we can handle small values of n efficiently without performing complex calculations.\n", "requirement analysis:\nThe primary requirement is to generate the k-th special number in a sequence defined by the base number n, which is a power of 2. The output should be modulo 10^9+7 to handle large numbers. The system should be robust enough to handle multiple test cases efficiently. Edge cases such as very small or very large values of n should also be considered.\nrequirement pool:\n- Implement a function to generate the k-th special number based on the base n.\n- Ensure the output is modulo 10^9+7 to handle large numbers.\n- Develop a system to handle multiple test cases efficiently.\n- Include error handling for invalid inputs such as negative values of n or k.\n- Optimize the algorithm for large values of n and k to ensure performance.\nTo generate the k-th special number in a sequence defined by the base number n, we will use a mathematical approach that leverages the properties of binary representation. Each special number can be represented as a sum of distinct non-negative powers of n, which is similar to binary representation but with base n instead of base 2. We will use this insight to generate the sequence efficiently. The output will be modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a base number n.\n    Explanation: In this context, a special number is akin to a binary number where the digits are powers of n instead of 2. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we are looking for numbers greater than a certain value.\n    Explanation: In the context of special numbers, we are looking for numbers that can be expressed as sums of distinct non-negative powers of n, and we need to find the k-th such number.\n\n# [degree adverb] \n    'largest': indicates that we are looking for the largest possible special number.\n    Explanation: In the context of special numbers, we might need to find the largest special number that is less than or equal to a given value.\n\n# [code logic]\n    To generate the k-th special number in a sequence defined by the base number n, we will use a mathematical approach that leverages the properties of binary representation. Each special number can be represented as a sum of distinct non-negative powers of n, which is similar to binary representation but with base n instead of base 2. We will use this insight to generate the sequence efficiently. The output will be modulo 10^9+7 to handle large numbers.\n\n# [edge case] \n    n = 2, k = 1 = 1\n    Explanation: For n = 2, the first special number is 1 (2^0), so the expected output is 1.\n    n = 3, k = 2 = 2\n    Explanation: For n = 3, the second special number is 2 (3^0), so the expected output is 2.\n    n = 4, k = 5 = 17\n    Explanation: For n = 4, the fifth special number is 17, which can be expressed as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to generate the k-th special number for any valid input.\n", "requirement analysis:\nThe requirements involve generating special numbers based on powers of a given base, with the ability to handle a large number of test cases efficiently. The output should be the k-th special number modulo 10^9+7. The system should be robust enough to handle large values of n and k.\nrequirement pool:\n- Implement a function to generate special numbers based on powers of n.\n- Ensure the system can handle multiple test cases efficiently.\n- Implement output formatting to return the k-th special number modulo 10^9+7.\n- Optimize the algorithm for large values of n and k.\n- Design a user-friendly interface for input and output.\nTo implement the special number generator, we will use Python due to its efficiency and ease of handling large numbers. The approach involves generating all possible special numbers for a given base n up to a certain limit, then sorting them and returning the k-th one modulo 10^9+7. We will use a set to store unique special numbers for efficient membership checking.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a base n.\n    Explanation: In the context of the problem, a special number is one that can be represented as the sum of different powers of a given base n. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the sum of powers results in a positive number.\n\n# [degree adverb] \n    'largest': means that we need to find the largest special number.\n    Explanation: The requirement does not specify a need to find the largest special number, so this is not applicable in this context.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the k-th special number, we need to:\n    1. Generate all possible special numbers for a given base n up to a certain limit.\n    2. Sort these numbers in increasing order.\n    3. Return the k-th number modulo 10^9+7.\n\n# [edge case] \n    Edge case 1: n = 1, k = 1\n    expected output: 1\n    Explanation: If n = 1, then the only special number is 1 raised to any power, which is always 1. So, the first and only special number is 1.\n\n    Edge case 2: n = 2, k = 10\n    expected output: 1025\n    Explanation: For n = 2, the sequence of special numbers includes powers of 2: 1, 2, 4, 8, 16, ..., which are all distinct and sum to special numbers. The 10th special number is 1025 (2^0 + 2^3 + 2^7 = 1 + 8 + 128).\n\n    Edge case 3: n = 10^9, k = 1\n    expected output: 1\n    Explanation: If n is very large, the smallest special number is always 1, as any power of a large number is still a large number, and the sum of no terms is 0, which is not a special number.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases where n is very small or very large.\n", "requirement analysis:\nThe requirements involve creating a program that can compute the k-th special number for a given base n, where a special number is defined as the sum of distinct non-negative powers of n. The program should handle multiple test cases efficiently and output the results modulo 10^9+7. The user needs to input the base and the position to find the special number.\nrequirement pool:\n- Implement a function to calculate the sum of distinct non-negative powers of a given base.\n- Handle multiple test cases efficiently.\n- Output results modulo 10^9+7.\n- Ensure the program can handle large inputs within performance constraints.\n- Provide a user-friendly interface for input and output.\nTo implement the solution, we will use Python due to its extensive standard library and ease of use. The main challenge lies in efficiently calculating the k-th special number for a given base n, especially when k is large. We will use a mathematical approach to generate the sequence of special numbers, leveraging the properties of powers of n. The sequence will be generated modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be represented as the sum of distinct non-negative powers of a given number n.\n    Explanation: In the context of the problem, a special number is one that can be expressed as a sum of different powers of a base number n, where the powers are non-negative.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than a certain value.\n    'distinct': means that the powers used in the sum must be different.\n\n# [degree adverb] \n    'increasing order': means that the numbers should be listed in ascending order.\n\n# [code logic]\n    To generate the k-th special number for a given base n, we can use a mathematical approach to find the sum of distinct non-negative powers of n. We will iterate through the powers and keep adding them until we reach the k-th special number. The result will be taken modulo 10^9+7 to ensure it fits within the specified range.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [edge case] \n    search([1,2,3,4,5]) = 3\n    Explanation: The sequence is already in increasing order, so the third element is 3.\n    search([10,20,30,40]) = -1\n    Explanation: There is no number that appears more than or equal to its value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The sequence is already in increasing order, so we can directly return the k-th element.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('') returns 4.\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n", "requirement analysis:\nThe requirements involve creating a program that can compute the k-th special number for a given base n, where a number is considered special if it can be represented as the sum of distinct non-negative powers of n. The program should handle multiple test cases efficiently and output the results modulo 10^9+7. The user should be able to input the base and position values, and the program should provide the k-th special number in increasing order.\nrequirement pool:\n- Implement a function to compute the k-th special number for a given base n.\n- Handle multiple test cases efficiently.\n- Output the result modulo 10^9+7.\n- Ensure the program is user-friendly and can handle large inputs.\n- Provide a clear and concise interface for users to input the base and position values.\nTo solve this problem, we will use Python due to its powerful standard library and ability to handle large numbers efficiently. The approach involves generating the sequence of special numbers for a given base n and then finding the k-th special number in the sequence. We will use the property that each special number can be represented as a sum of distinct non-negative powers of n, which can be efficiently computed using a loop and modular arithmetic.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': A number that can be represented as the sum of distinct non-negative powers of a given number n.\n    Explanation: In the context of the problem, a special number is one that can be expressed as a sum of distinct powers of a base number n, where the powers are non-negative integers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times a special number appears must be greater than or equal to the number itself.\n    Explanation: For example, in the requirement, the phrase \"appears at least as many times as the integer itself\" means that if a number appears more than once, it must appear at least as many times as its value.\n\n# [degree adverb] \n    'largest': Indicates that the function should return the largest integer that meets the condition.\n    Explanation: In the requirement, the phrase \"largest integer that is more than zero and appears at least as many times as the integer itself\" means that the function should find the biggest number that appears at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Iterate through possible powers of n.\n    2. Calculate the sum of these powers to get special numbers.\n    3. Store these special numbers in a list.\n    4. Sort the list to ensure the numbers are in increasing order.\n    5. Return the k-th special number from the sorted list.\n\n# [edge case] \n    search([1]) = 1\n    Explanation: The edge case where the list contains only one element, which is 1, is a special case where the largest integer that appears at least as many times as itself is 1.\n    search([2, 2, 3, 3, 3]) = -1\n    Explanation: In this edge case, the list contains numbers that do not meet the condition of appearing at least as many times as themselves. Therefore, the function should return -1.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: This edge case demonstrates a scenario where no number appears at least as many times as itself. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases by checking if the list is empty or if no number meets the condition.\n\n# [core concept]\n    'special number': A number that can be represented as the sum of distinct non-negative powers of a given number n.\n    Explanation: In the context of the problem, a special number is one that can be expressed as a sum of distinct powers of a base number n, where the powers are non-negative integers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times a special number appears must be greater than or equal to the number itself.\n    Explanation: For example, in the requirement, the phrase \"appears at least as many times as the integer itself\" means that if a number appears more than once, it must appear at least as many times as its value.\n\n# [degree adverb] \n    'largest': Indicates that the function should return the largest integer that meets the condition.\n    Explanation: In the requirement, the phrase \"largest integer that is more than zero and appears at least as many times as the integer itself\" means that the function should find the biggest number that appears at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Iterate through possible powers of n.\n    2. Calculate the sum of these powers to get special numbers.\n    3. Store these special numbers in a list.\n    4. Sort the list to ensure the numbers are in increasing order.\n    5. Return the k-th special number from the sorted list.\n\n# [edge case] \n    search([1]) = 1\n    Explanation: The edge case where the list contains only one element, which is 1, is a special case where the largest integer that appears at least as many times as itself is 1.\n    search([2, 2, 3, 3, 3]) = -1\n    Explanation: In this edge case, the list contains numbers that do not meet the condition of appearing at least as many times as themselves. Therefore, the function should return -1.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: This edge case demonstrates a scenario where no number appears at least as many times as itself. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases by checking if the list is empty or if no number meets the condition.\n", "requirement analysis:\nThe task requires generating special numbers based on the sum of distinct non-negative powers of a given base. The output should be the k-th such number in increasing order, with results modulo 10^9+7. The system must handle multiple test cases efficiently, considering the upper limits of the input values.\nrequirement pool:\n- Implement a function to calculate special numbers based on given base and position.\n- Ensure the system can handle large inputs and perform calculations modulo 10^9+7.\n- Develop a user interface for easy input and output of data.\n- Optimize the algorithm for scalability and performance.\nTo solve this problem, we will use Python due to its strong support for mathematical operations and handling large numbers. We will leverage the properties of powers and modular arithmetic to generate the special numbers efficiently. The main challenge is to ensure the solution is optimized for large inputs and performs calculations modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be represented as the sum of distinct non-negative powers of a given number n.\n    Explanation: In this context, a special number is derived from raising the base number n to various non-negative powers and summing them up, ensuring all powers used are distinct.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times a special number appears must be greater than its value.\n    Explanation: For example, in the sequence generated by n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17, and 17 appears more than once.\n\n# [degree adverb] \n    'increasing order': means the sequence should be sorted in ascending order.\n    Explanation: This is crucial for finding the k-th special number efficiently.\n\n# [code logic]\n    To generate the k-th special number for a given n, we need to:\n    1. Understand the mathematical representation of special numbers.\n    2. Use a loop to generate these numbers in increasing order.\n    3. Ensure each number is unique and a sum of distinct non-negative powers of n.\n    4. Use modulo 10^9+7 to keep the numbers within the specified range.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'special number': a number that can be represented as the sum of distinct non-negative powers of a given number n.\n    Explanation: In this context, a special number is derived from raising the base number n to various non-negative powers and summing them up, ensuring all powers used are distinct.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times a special number appears must be greater than its value.\n    Explanation: For example, in the sequence generated by n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17, and 17 appears more than once.\n\n# [degree adverb] \n    'increasing order': means the sequence should be sorted in ascending order.\n    Explanation: This is crucial for finding the k-th special number efficiently.\n\n# [code logic]\n    To generate the k-th special number for a given n, we need to:\n    1. Understand the mathematical representation of special numbers.\n    2. Use a loop to generate these numbers in increasing order.\n    3. Ensure each number is unique and a sum of distinct non-negative powers of n.\n    4. Use modulo 10^9+7 to keep the numbers within the specified range.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence made of special numbers, which can be expressed as a sum of distinct non-negative powers of n, modulo 10^9+7. The solution should be efficient and capable of handling large values of n and k. The output should be accurate and meet the requirements specified.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number\n- Ensure the solution can handle large values of n and k\n- Provide accurate and reliable output\n- Develop a scalable solution that can handle edge cases\n- Enhance user experience with a user-friendly interface\nTo solve the problem of finding the k-th special number in a sequence made of special numbers, which can be expressed as a sum of distinct non-negative powers of n, modulo 10^9+7, we will use a mathematical approach. The sequence of special numbers can be generated using the binary representation of k. Each bit in the binary representation of k corresponds to a power of n, and if the bit is set, we include that power in the sum. This approach is efficient and can handle large values of n and k due to the properties of binary representation and modular arithmetic.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum of distinct non-negative powers of n'\n    This means that each special number can be represented as a sum of unique powers of n, where n is a positive integer.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we need to consider the binary representation of k. For each bit in the binary representation of k, if the bit is set, we include the corresponding power of n in the sum. This process is repeated until we have considered all bits of k. The result is the k-th special number modulo 10^9+7.\n\n# [edge case] \n    n = 2, k = 1\n    expected output: 1\n    Explanation: The binary representation of 1 is 1 (in binary). This corresponds to the first power of 2, which is 2^0 = 1.\n\n    n = 3, k = 5\n    expected output: 28\n    Explanation: The binary representation of 5 is 101 (in binary). This corresponds to 2^2 + 2^0 = 4 + 1 = 5. However, we need to consider the powers of n modulo 10^9+7. So, 3^2 + 3^0 = 9 + 1 = 10, and 10 modulo 10^9+7 is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic is sufficient to find the k-th special number for any valid input.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence generated by summing distinct non-negative powers of n, modulo 10^9+7. The solution must handle a large number of test cases efficiently. The input constraints are such that n can be as large as 10^9 and k can be as large as 10^9, requiring the solution to be optimized for performance.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large values of n and k efficiently.\n- Implement modulo 10^9+7 to ensure results are within the required range.\n- Develop a user-friendly interface for input and output.\n- Optimize the algorithm to handle multiple test cases within a reasonable time frame.\nTo efficiently find the k-th special number in a sequence made of distinct non-negative powers of n, modulo 10^9+7, we will use a mathematical approach that avoids generating the entire sequence. Given the constraints of n and k being very large, we will leverage Python's capabilities to handle large integers and optimize the algorithm for performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct non-negative powers of n'\n    Explanation: This refers to numbers that can be formed by summing different powers of a base number n, where each power is a non-negative integer.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we need to consider that the sequence is essentially a binary representation of k when k is expressed in the base-n system. Each bit in this binary representation corresponds to a power of n. We can use this insight to directly compute the k-th special number without generating the entire sequence.\n\n# [edge case] \n    n = 2, k = 1\n    expected output: 1\n    Explanation: The sequence starts with 1 (2^0), so the 1st special number is 1.\n\n    n = 3, k = 2\n    expected output: 2\n    Explanation: The sequence starts with 1 (3^0), 3 (3^1), and the 2nd special number is 2 (3^1).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to compute the k-th special number directly.\n\n# [core concept]\n    'modulo 10^9+7'\n    Explanation: This means that all calculations should be done modulo 10^9+7 to prevent integer overflow and to keep the results within the specified range.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently find the k-th special number, we can use a mathematical approach that leverages the properties of powers of n and the modulo operation. This approach avoids generating the entire sequence, making it suitable for large values of n and k.\n\n# [edge case] \n    n = 10^9, k = 10^9\n    expected output: 999999937\n    Explanation: Given the large values of n and k, the k-th special number is calculated using the properties of powers of n and the modulo operation. The result is 999999937, which is the remainder when the k-th special number is divided by 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to compute the k-th special number directly, even for large values of n and k.\n", "requirement analysis:\nThe requirement involves finding the k-th special number in a sequence generated by summing distinct non-negative powers of n, modulo 10^9+7. This requires a solution that can handle large values of n and k efficiently. The output should be accurate and in the specified format. The solution should also handle edge cases where n is very small or very large.\nrequirement pool:\n- Implement a function to find the k-th special number in the sequence\n- Ensure the function can handle large values of n and k\n- Output the result modulo 10^9+7\n- Handle edge cases where n is very small or very large\n- Ensure the solution is efficient and can handle multiple test cases\nTo solve this problem efficiently, we will use a mathematical approach to generate the sequence of special numbers. The sequence is generated by summing distinct non-negative powers of n, and we need to find the k-th special number in this sequence modulo 10^9+7. Given the constraints, we will use Python's built-in capabilities to handle large numbers and perform modular arithmetic.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct non-negative powers of n': means that each power of n is used only once in the sum, and the sum is taken modulo 10^9+7.\n    Explanation: The sequence consists of numbers that can be formed by summing distinct powers of n, and the result is taken modulo 10^9+7 to ensure it fits within the specified range.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To generate the k-th special number, we need to consider all possible sums of distinct powers of n, starting from the smallest (0th power) up to the highest power that can be represented without repetition. We will use a loop to iterate through these sums and find the k-th smallest special number.\n\n# [edge case] \n    n = 2, k = 1\n    expected output: 1\n    Explanation: The sequence starts with 1 (2^0), so the 1st special number is 1.\n    n = 3, k = 2\n    expected output: 2\n    Explanation: The sequence includes 1 (3^0) and 3 (3^1), so the 2nd special number is 2.\n    n = 10, k = 5\n    expected output: 31\n    Explanation: The sequence includes numbers like 1, 10, 100, 1000, etc. The 5th special number is 31 (2^4 + 2^3 + 2^1 + 2^0).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n is very small. For very small n, we might need to handle cases where k exceeds the number of possible sums directly.\n        if n == 1:\n            return 1 if k == 1 else -1  # If n is 1, the only special number is 1\n        (other code)\n\n    Additionally, for very large values of k, we need to ensure that we do not exceed the range of integers modulo 10^9+7.\n        if k > 2**30:  # 2**30 is a large enough power of 2 to cover most cases\n            k = k % (10**9 + 7)  # Adjust k if it exceeds the range\n        (other code)\n", "requirement analysis:\nThe primary requirement is to generate the k-th special number in a sequence defined by powers of n, modulo 10^9+7. The system should handle a large number of test cases efficiently. The input values for n and k can range from very small to extremely large, requiring robust algorithms.\nrequirement pool:\n- Implement an algorithm to generate special numbers based on powers of n.\n- Ensure the output is modulo 10^9+7 to handle large numbers.\n- Optimize the algorithm for handling a large number of test cases efficiently.\n- Develop a user-friendly interface for easy input and output.\nTo generate the k-th special number in a sequence defined by powers of n, modulo 10^9+7, we will use a mathematical approach based on the properties of binary representation. Each special number can be represented as a sum of distinct non-negative powers of n, which is similar to binary numbers where each bit represents whether a power of n is included in the sum. We will optimize the algorithm to handle a large number of test cases efficiently. The output will be modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of n.\n    Explanation: In this context, a special number is akin to a binary number where each bit represents whether a power of n is included in the sum. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers greater than zero.\n    Explanation: The requirement specifies that we are dealing with positive numbers, so we need to find special numbers that are greater than zero.\n\n# [degree adverb] \n    'largest': means that we need the biggest special number.\n    Explanation: The requirement does not specify a need to find the largest special number, so this degree adverb is not applicable in this context.\n\n# [code logic]\n    To generate the k-th special number in a sequence defined by powers of n, modulo 10^9+7, we will use a mathematical approach based on the properties of binary representation. Each special number can be represented as a sum of distinct non-negative powers of n, which is similar to binary numbers where each bit represents whether a power of n is included in the sum. We will optimize the algorithm to handle a large number of test cases efficiently. The output will be modulo 10^9+7 to handle large numbers.\n\n# [edge case] \n    n = 2, k = 1 = 1\n    Explanation: For n = 2, the first special number is 1 (2^0). Since k = 1, the expected output is 1.\n    n = 3, k = 2 = 2\n    Explanation: For n = 3, the special numbers are 1 (3^0), 3 (3^1), and so on. The second special number is 3. Since k = 2, the expected output is 2.\n    n = 10, k = 5 = 5\n    Explanation: For n = 10, the special numbers are 1, 10, 100, 1000, 10000, and so on. The fifth special number is 10000. Since k = 5, the expected output is 10000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to find the k-th special number for any given n and k.\n"], "scores": [], "pass_results": [true, false, false, true, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 355, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "rephrase_one", "parent_index": 283}
