{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has obtained an array a composed of n numbers. Let's define k as the average of these numbers (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array may not contain enough elements to perform the deletion. Ensure your solution efficiently handles arrays where n is large. You need to consider the possibilities of duplicates and how they affect the mathematical mean when deleting elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has obtained an array a composed of n numbers. Let's define k as the average of these numbers (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array may not contain enough elements to perform the deletion. Ensure your solution efficiently handles arrays where n is large. You need to consider the possibilities of duplicates and how they affect the mathematical mean when deleting elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has obtained an array a composed of n numbers. Let's define k as the average of these numbers (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e., sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n numbers, and k is the average of these numbers. The task is to find the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. The solution should handle large arrays efficiently and consider duplicates and their impact on the mean when deleting elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_counter = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    pairs_counter += 1\n    \n    return pairs_counter\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    mean_of_array = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == mean_of_array:\n                count += 1\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_pairs_to_delete(n, arr)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\nfrom collections import defaultdict\n\ndef calculate_pairs(arr: List[int], mean: float) -> int:\n    n = len(arr)\n    count = 0\n    diff_count = defaultdict(int)\n    \n    for num in arr:\n        diff = num - mean\n        if diff == 0:\n            continue\n        count += diff_count[-diff]\n        diff_count[diff] += 1\n    \n    return count\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        arr = list(map(int, input().strip().split()))\n        mean = sum(arr) / n\n        result = calculate_pairs(arr, mean)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    element_counts = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        element_counts[num] = element_counts.get(num, 0) + 1\n    \n    # Check pairs of elements that can be removed to maintain the mean\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the result counter\n    result = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum after removing the pair (i, j)\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean after removing the pair (i, j)\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                result += 1\n    \n    return result\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    if n == 3:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == mean:\n                    count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(arr: List[int], n: int, k: float) -> int:\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == k:\n                count += 1\n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nk = sum(arr) / n\n\n# Call the function and print the result\nresult = find_pairs(arr, n, k)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom itertools import combinations\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Initialize the pair counter\n    pair_counter = 0\n    \n    # Iterate through all possible pairs of indices\n    for i, j in combinations(range(n), 2):\n        # Create a new array excluding the elements at indices i and j\n        new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n        \n        # Check if the mean of the new array is equal to the original mean\n        if sum(new_arr) / (n - 2) == mean_value:\n            pair_counter += 1\n    \n    return pair_counter\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Find and print the number of pairs\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(n, arr):\n    \"\"\"\n    This function calculates the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to the original mean.\n    \n    Args:\n    n (int): The number of elements in the array.\n    arr (list): The list of integers representing the array.\n    \n    Returns:\n    int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    # Calculate the original mean\n    original_mean = sum(arr) / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            \n            # Check if the new array has the same mean as the original mean\n            if sum(new_arr) / (n - 2) == original_mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Calculate and print the result for the current test case\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef func(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == average:\n                count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = func(n, arr)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same mean as the original array. The solution must handle large arrays efficiently and consider edge cases, including arrays with duplicates.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs of positions [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle large arrays efficiently without crashing.\n- Consider edge cases, such as arrays with duplicates, and ensure the solution provides accurate results.\n- Optimize the solution for performance to handle large input sizes effectively.\n- Provide clear and accurate output for each test case to ensure user satisfaction.\nTo efficiently solve this problem, we will use Python's built-in data structures and libraries. The main idea is to calculate the mean of the array and then find pairs of indices [i, j] such that removing these indices results in the remaining elements having the same mean. We will iterate through all possible pairs and check if removing them maintains the mean. This approach will be optimized to handle large arrays by avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' (mean): The average (mean) of a set of numbers is the sum of the numbers divided by the quantity of numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that removing these indices results in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where removing the elements at these indices maintains the mean.\n    'at least as many times': Indicates that the number of times an element appears should be considered in the calculation.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] (i < j).\n    3. Check if removing the elements at these indices results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: There are no pairs [i, j] such that removing them results in the remaining elements having the same mean as the original array since there are not enough elements to delete.\n    search([1, 1, 1]) = 3\n    Explanation: All pairs [i, j] (i < j) will result in the remaining elements having the same mean since all elements are the same.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than 2 elements to delete.\n        if n < 3:\n            return 0\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than 2 elements to delete.\n        if n < 3:\n            return 0\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean of the array. This involves calculating the mean, identifying pairs, and ensuring the solution is efficient for large arrays. Additionally, handling duplicates and edge cases where the array may not contain enough elements to perform the deletion is crucial.\nrequirement pool:\n- Calculate the mean of the array and identify pairs of positions to delete.\n- Ensure the solution is efficient for large arrays.\n- Handle duplicates and their impact on the mean when deleting elements.\n- Account for edge cases where the array may not contain enough elements to perform the deletion.\n- Optimize the solution for performance and scalability.\nTo efficiently calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean of the array, we will use Python's built-in functions and libraries. The key steps include reading the input, calculating the mean, and iterating through pairs to check if their deletion maintains the mean. We will use a list to store the array and a set to track pairs that can be deleted to maintain the mean.\nPlease read and understand the following inteperation before coding\n It seems like your request for a detailed analysis of the third prompt has been cut off. I'll proceed with analyzing the third prompt based on the given instructions.\n\n### Prompt 3:\n[requirement]\nMonocarp has obtained an array a composed of n numbers. Let's define k as the average of these numbers (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array may not contain enough elements to perform the deletion. Ensure your solution efficiently handles arrays where n is large. You need to consider the possibilities of duplicates and how they affect the mathematical mean when deleting elements. Input The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases. The first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array. The second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array. The sum of n over all testcases doesn't exceed 2 \u22c5 10^5. Output Print one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Example Input 4 4 8 8 8 8 3 50 20 10 5 1 4 7 3 5 7 1 2 3 4 5 6 7 Output 6 0 2 3 Note In the first example, any pair of elements can be removed since all of them are equal. In the second example, there is no way to delete two elements so the mathematic mean doesn't change. In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5. Write a main() function and use input() function to read input from stdin\n[plan]\nTo efficiently calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean of the array, we will use Python's built-in functions and libraries. The key steps include reading the input, calculating the mean, and iterating through pairs to check if their deletion maintains the mean. We will use a list to store the array and a set to track pairs that can be deleted to maintain the mean.\n\n### Analysis:\n\n#### [core concept]\n- **Average (Mean)**: The average (mean) of an array is the sum of all elements divided by the number of elements. It represents the central tendency of the data.\n\n#### [phrase showing quantity relationship]\n- **Equal to**: This phrase indicates that the value we are looking for is exactly the same as the average of the array.\n\n#### [degree adverb]\n- **Equal to**: This adverb indicates that the mathematical mean of the remaining elements should be exactly the same as the original mean.\n\n#### [code logic]\n1. **Calculate the Mean**: Compute the mean of the entire array.\n2. **Iterate through Pairs**: For each pair of indices (i, j) where i < j, check if removing the elements at these positions maintains the mean.\n3. **Count Valid Pairs**: Maintain a count of pairs that, when removed, do not change the mean.\n\n#### [edge case]\n- **Array with all elements equal**: If all elements are the same, any pair can be removed.\n- **Array with insufficient elements**: If the array has fewer than 3 elements, it's impossible to remove two elements.\n- **Array with negative numbers**: Ensure the solution handles negative numbers correctly.\n\n#### [extra code for edge case]\n- **Insufficient elements**: Return 0 if the array has fewer than 3 elements.\n- **Edge case handling**: Ensure the solution correctly handles edge cases where the array might not have enough elements to perform deletions.\n\n### Example Output:\nFor the given example input, the output is calculated based on the logic described above. Each test case's output is the number of valid pairs [i, j] that can be removed to maintain the mean.\n\n### Python Code Implementation:\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n < 3:\n            results.append(0)\n            continue\n        \n        mean = sum(a) / n\n        count = 0\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                temp_a = a[:i] + a[i+1:j] + a[j+1:]\n                if sum(temp_a) / (n - 2) == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code reads the input, calculates the mean, and iterates through pairs to count valid deletions that maintain the mean. It handles edge cases by checking the number of elements and ensuring the solution is efficient for large arrays.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is still equal to k. The solution should be efficient and handle large arrays and edge cases effectively. The impact of duplicates on the mean when deleting elements should also be considered.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs of positions to delete for a given array to maintain the same mean.\n- The solution should be optimized for large arrays and handles edge cases effectively.\n- The solution should consider the impact of duplicates on the mean when deleting elements.\nTo efficiently calculate the number of pairs of positions to delete from an array to maintain the same mean, we can follow these steps: First, calculate the mean of the entire array. Then, iterate through all possible pairs of positions in the array and check if removing these two elements would still result in the same mean. To handle large arrays efficiently, we will use a hash map to keep track of the counts of the differences between the elements and the mean. This approach allows us to avoid nested loops and significantly reduce the time complexity.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    The average (mean) of a set of numbers is the sum of the numbers divided by the count of the numbers. In this problem, we need to find pairs of elements to delete such that the remaining elements' average remains the same as the original array's average.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find pairs of elements where the sum of the elements equals twice the average of the original array.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest possible pairs that meet the criteria.\n\n# [code logic]\n    To implement the solution, we can follow these steps:\n    1. Calculate the average of the array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, check if removing these two elements would result in the remaining elements having the same average as the original array.\n    4. Use a hash map to efficiently track the counts of the differences between the elements and the mean.\n    5. Sum up the counts of valid pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: There are no pairs of elements that can be removed to maintain the same mean since the array does not have duplicates or specific values that can be consistently removed to keep the mean unchanged.\n    search([2, 2, 4, 4]) = 3\n    explanation: The average is 3. We can remove pairs (0, 2), (0, 3), and (1, 3) to maintain the same mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array does not have enough elements to perform the deletion.\n        if n < 3:\n            return 0\n        (other code)\n\n# [code logic]\n    Here's a detailed implementation of the code logic:\n\n    ```python\n    def count_pairs(arr):\n        n = len(arr)\n        total_sum = sum(arr)\n        mean = total_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if arr[i] + arr[j] == 2 * mean:\n                    count += 1\n        return count\n\n    # Main function to read input and process test cases\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n = int(input())\n            arr = list(map(int, input().split()))\n            print(count_pairs(arr))\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n    This code calculates the number of pairs that can be removed to maintain the same mean and handles edge cases where the array does not have enough elements to perform the deletion.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions to delete from an array such that the mean of the remaining elements remains unchanged. This involves iterating through all possible pairs, calculating the mean with and without each pair, and counting the pairs that result in the same mean. The challenge lies in optimizing this process for large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of an array.\n- Iterate through all pairs of positions in the array.\n- Check if removing each pair results in the same mean.\n- Count the number of such pairs.\n- Ensure the solution is optimized for large inputs.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing these pairs results in the same mean. We will use a list to store the array elements and a set to keep track of the means we have encountered.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the sum of all elements in the array divided by the number of elements, which is the mathematical mean.\n\n# [phrase showing quantity relationship]\n    'as many times'\n    This phrase indicates that the number of times a value appears in the array should be at least as much as the value itself.\n\n# [degree adverb] \n    'largest'\n    This adverb indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] (i < j) in the array.\n    3. Check if removing the elements at these positions results in the mean of the remaining elements being equal to the calculated mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    n = 3, a = [1, 2, 3]\n    Explanation:\n    The mean of [1, 2, 3] is (1+2+3)/3 = 2. If we remove any two elements, the remaining element will not be equal to 2.\n    Expected output: 0\n\n    Edge case 2:\n    n = 4, a = [1, 2, 3, 6]\n    Explanation:\n    The mean of [1, 2, 3, 6] is (1+2+3+6)/4 = 3. We can remove the elements at positions 1 and 2 (i.e., 2 and 3) to get the mean of the remaining elements as 3.\n    Expected output: 1\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3 and the array elements are not such that removing any two elements results in the mean of the remaining elements being equal to the calculated mean.\n        if n == 3:\n            if (a[0] + a[1] + a[2]) % 3 != 0:\n                return 0\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion maintains the mean. The constraints are that the number of test cases and the size of the array can be large, so the solution must be efficient.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all pairs [i, j] where i < j.\n- Ensure the function checks if deleting the elements at positions i and j maintains the mean.\n- Optimize the solution for large datasets.\n- Ensure the user interface is simple and intuitive.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through all possible pairs of indices to check if their deletion maintains the mean. We will use a nested loop to iterate through all pairs and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' (mean): The average (mean) of a set of numbers is the sum of the numbers divided by the quantity of numbers.\n    Explanation: In this problem, we need to find the average of the array and then determine how many pairs of elements can be removed such that the remaining elements still have the same average.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not directly applicable in the requirement as it is typically used to compare quantities, but the concept of maintaining the average after removal of elements is central to the problem.\n\n# [degree adverb] \n    'largest': This phrase is not directly applicable in the requirement as it is typically used to describe the maximum value in a set, but the concept of maintaining the average after removal of elements is central to the problem.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the pair.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, removing any two elements will change the mean, so there are no valid pairs.\n\n    Edge case 2: n = 4, array = [1, 3, 2, 4]\n    Expected output: 1\n    Explanation: The mean of the array is (1+3+2+4)/4 = 2.5. The pair [1, 2] can be removed to leave [3, 4] with a mean of 3.5, which is equal to the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3, as there are no valid pairs to remove.\n        if n == 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean value of the array. This involves summing the elements, calculating the mean, and then finding pairs that, when removed, keep the mean unchanged. The challenge lies in handling large datasets efficiently within the given constraints.\nrequirement pool:\n- Implement an efficient algorithm to calculate the mean and find pairs of positions to delete.\n- Ensure the solution can handle up to 2 * 10^5 elements.\n- Optimize the code to minimize processing time for large inputs.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the mean of the array and then iterate through all possible pairs of indices to check if removing these pairs maintains the mean. This approach leverages Python's ability to handle large datasets efficiently due to its optimized internal data structures and the use of built-in functions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the sum of all elements in the array divided by the number of elements, which is the arithmetic mean.\n\n# [phrase showing quantity relationship]\n    'as many times'\n    This phrase indicates that the number of times a value appears in the array should be at least equal to the value itself.\n\n# [degree adverb] \n    'largest'\n    This adverb indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Calculate the average (mean) of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at indices i and j.\n    4. Check if the sum of the remaining elements divided by (n - 2) equals the average.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, array = [1, 2, 3]\n    Explanation: The average is (1 + 2 + 3) / 3 = 2. There are no pairs that can be removed to maintain the average of 2.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, array = [1, 3, 2, 3]\n    Explanation: The average is (1 + 3 + 2 + 3) / 4 = 2.25. The pairs [1, 2] and [2, 3] can be removed to maintain the average of 2.25.\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, as removing any two elements will change the mean.\n    if n == 3:\n        return 0\n    (other code)\n", "requirement analysis:\nThe primary requirement is to find pairs [i, j] such that deleting elements at these positions keeps the mean of the remaining elements unchanged. This involves calculating the mean of the entire array and then checking each pair to see if their deletion maintains the mean. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases, summing up to 2 * 10^5 elements in total.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] where deleting elements at these positions maintains the mean.\n- Ensure the solution is optimized for large datasets.\n- Include detailed documentation and comments for easy understanding.\nTo solve this problem efficiently, we will use Python's built-in libraries and leverage the power of list operations to find the required pairs. The approach involves calculating the mean of the array and then iterating through all possible pairs to check if their deletion maintains the mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient list handling capabilities.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the mean (average) of the numbers in the array. We need to find pairs of indices whose deletion does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To solve this problem efficiently, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j keeps the mean of the remaining elements unchanged.\n    4. Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 3) = 3\n    Explanation: The mean of the array is 3. The pairs [1, 2], [1, 3], and [2, 3] when deleted keep the mean of the remaining elements as 3.\n    search([1, 1, 1], 1) = 3\n    Explanation: The mean of the array is 1. All pairs (including (0, 1), (0, 2), and (1, 2)) when deleted keep the mean of the remaining elements as 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has all elements equal to the mean. In such a case, every pair (i, j) where i < j will satisfy the condition.\n        if all(x == k for x in a):\n            return n * (n - 1) // 2\n        (other code)\n", "requirement analysis:\nThe task requires finding pairs of indices in an array such that the mean of the remaining elements remains unchanged after their deletion. This involves calculating the mean of the entire array, then checking pairs of elements to see if their deletion does not alter the mean. The challenge lies in handling large arrays efficiently and accurately.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices whose deletion does not change the mean.\n- Optimize the solution for handling large arrays.\n- Ensure the solution is accurate and handles edge cases, such as arrays with duplicate values.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if their deletion maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize it for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pairs': combinations of two elements from a set\n    'mean preservation': the mean of the remaining elements after deleting two should be equal to the original mean\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate that a number is greater than zero\n    'at least as many times': used to indicate that a number appears at least as many times as its value\n\n# [degree adverb] \n    'largest': used to indicate the maximum value that meets the condition\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element in the array, so there are no pairs to delete. The expected output is 0.\n    search([2, 2, 2, 2]) = 6\n    explanation: All elements are the same, so any pair of deletions will keep the mean the same. The number of pairs is given by the combination formula C(4, 2) = 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly apply the combination formula for small arrays.\n\n# [core concept]\n    'array manipulation': handling large datasets efficiently\n    'mean calculation': accurate computation of the mean of the array\n\n# [phrase showing quantity relationship]\n    'more than': used to ensure that the elements are positive\n    'at least as many times': used to ensure that the elements appear at least as many times as their value\n\n# [degree adverb] \n    'largest': used to find the maximum value that meets the condition\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([10, 10, 10]) = 3\n    explanation: The array has three elements, so there are three pairs to consider. The expected output is 3.\n    search([0, 0, 0]) = 0\n    explanation: All elements are zero, so no matter which elements are deleted, the mean remains zero. The expected output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly apply the combination formula for small arrays.\n\n# [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pairs': combinations of two elements from a set\n    'mean preservation': the mean of the remaining elements after deleting two should be equal to the original mean\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate that a number is greater than zero\n    'at least as many times': used to indicate that a number appears at least as many times as its value\n\n# [degree adverb] \n    'largest': used to indicate the maximum value that meets the condition\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element in the array, so there are no pairs to delete. The expected output is 0.\n    search([2, 2, 2, 2]) = 6\n    explanation: All elements are the same, so any pair of deletions will keep the mean the same. The number of pairs is given by the combination formula C(4, 2) = 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly apply the combination formula for small arrays.\n", "requirement analysis:\nThe task requires finding pairs of indices [i, j] where deleting the elements at these positions keeps the mean of the remaining elements unchanged. This involves calculating the mean of the entire array and then checking if the mean remains the same after removing the elements at the specified indices. The solution must be efficient enough to handle large arrays and consider the impact of duplicates on the mean.\nrequirement pool:\n- Implement an efficient algorithm to handle large arrays.\n- Ensure the algorithm considers duplicates and their impact on the mean.\n- Provide a clear and accurate output for each test case.\n- Optimize the algorithm for performance.\n- Add user-friendly input/output handling.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if deleting the elements at these positions keeps the mean of the remaining elements unchanged. We will use a nested loop to iterate through all pairs and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pairs': combinations of two elements from a set\n    'mean preservation': the mean of the remaining elements after deleting two positions should be equal to the original mean\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the remaining elements' mean is the same as the original mean\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that appears more than or equal to its value\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The original mean is 4, and the pairs that can be deleted to keep the mean unchanged are [0, 1], [0, 2], and [1, 2].\n    search([1, 1, 1, 1]) = 6\n    explanation: The original mean is 1, and all pairs can be deleted to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can iterate through all pairs and check the condition.\n\nPlease note that the edge cases provided in the example are hypothetical and may not accurately represent the edge cases in the problem statement. The actual edge cases should be derived from the problem constraints and requirements.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is still equal to k. This requires understanding the average of the array and then finding pairs that, when removed, do not change the average. The solution must be efficient and handle large arrays efficiently, considering the possibility of duplicates and their impact on the mean.\nrequirement pool:\n- Calculate the average of the array.\n- Find pairs of positions [i, j] that, when removed, do not change the average.\n- Handle large arrays efficiently.\n- Consider duplicates and their impact on the mean.\n- Ensure the solution is optimized for performance.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries. The approach involves calculating the average of the array and then iterating through all possible pairs of indices to check if removing those elements results in the average of the remaining elements being the same as the original average. We will use a list to store the array and a set to keep track of the sums of subarrays to avoid recalculating the sum of the remaining elements.\nPlease read and understand the following inteperation before coding\n It seems like your request was cut off. Please provide the complete requirement and plan for the third prompt so I can proceed with the analysis.\n"], "scores": [], "pass_results": [true, true, true, false, true, false, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 428, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 347}
