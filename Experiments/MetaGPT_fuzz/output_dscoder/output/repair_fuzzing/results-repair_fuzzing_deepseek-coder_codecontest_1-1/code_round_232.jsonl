{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has an array a composed of n integers, and let's represent k as the arithmetic mean of these elements (note that k might not be a whole number). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k, ensuring to handle large numbers efficiently, taking into account the possible overflow in calculations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has an array a composed of n integers, and let's represent k as the arithmetic mean of these elements (note that k might not be a whole number). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k, ensuring to handle large numbers efficiently, taking into account the possible overflow in calculations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers, and let's denote k as the arithmetic mean of these elements. Note that k might not be a whole number. Monocarp wants to remove exactly two elements from the array a such that the arithmetic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to determine the number of pairs of positions [i, j] (where i < j) in the array a, such that if the elements at these positions are deleted, the arithmetic mean of the remaining (n - 2) elements is still equal to k\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a composed of n integers, and k is the arithmetic mean of these elements. He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs of positions [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k, and handle large numbers efficiently to avoid overflow in calculations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of positions [i, j] (i < j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            # Check if the arithmetic mean of the remaining elements is equal to the mean\n            if remaining_sum / remaining_count == mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result for the current test case\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n\n    return count\n\n# Example usage:\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        result = calculate_pairs(n, arr)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = arr[0:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_sum) / (n - 2) == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n, arr):\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If all elements are the same, return the number of pairs\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of pairs\n    pairs_count = 0\n    \n    # Iterate through all possible pairs of indices [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if removing the elements at indices i and j maintains the mean\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef func(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    freq = {}\n    \n    # Count the frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of the remaining elements is equal to the mean of the original array\n            if remaining_sum / remaining_count == mean:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = func(n, arr)\n    print(result)\n", "from typing import List\ndef find_pairs_to_remove(n, arr):\n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    if k * n != total_sum:  # Check if k is a valid arithmetic mean\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    if original_mean * 2 == total_sum:\n        # If the original mean is exactly half of the total sum, we can delete any two elements to maintain the mean\n        return n * (n - 1) // 2\n    \n    count = 0\n    diff_count = {}\n    for num in arr:\n        diff = num - original_mean\n        if diff in diff_count:\n            diff_count[diff] += 1\n        else:\n            diff_count[diff] = 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = (arr[i] + arr[j]) - 2 * original_mean\n            if diff in diff_count:\n                count += diff_count[diff]\n    \n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nimport numpy as np\nfrom itertools import combinations\nfrom typing import List\n\ndef calculate_pairs_of_indices(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    original_mean = np.mean(arr)\n    count = 0\n    \n    for i, j in combinations(range(n), 2):\n        new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n        if np.mean(new_arr) == original_mean:\n            count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_of_indices(n, arr)\n    print(result)\n", "from typing import List\nimport numpy as np\n\ndef calculate_pairs(n: int, arr: list[int]) -> int:\n    total_sum = np.sum(arr)\n    mean_value = total_sum / n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean_value:\n                count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the number of pairs of positions to delete from an array such that the arithmetic mean of the remaining elements remains unchanged. This involves summing the elements, calculating the mean, and then finding pairs that, when deleted, result in the same mean. The challenge lies in handling large inputs efficiently and ensuring the solution is robust against potential overflow.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to find pairs of positions that, when deleted, result in the same mean.\n- Ensure the solution handles large inputs efficiently without overflow.\n- Provide clear and accurate output for each test case.\n- Optimize the solution for performance.\nTo efficiently solve this problem, we will use Python due to its robust standard library and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through all possible pairs of positions to check if their deletion results in the same mean. We will use a list to store the array and perform the necessary calculations and checks.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by adding all the numbers together and then dividing by the count of numbers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates a comparison where one quantity is greater than another.\n    Explanation: In the context of the requirement, 'more than' is used to compare the arithmetic mean of the remaining elements after deletion with the original arithmetic mean.\n\n# [degree adverb] \n    'largest': Indicates the greatest or highest value in a set of numbers.\n    Explanation: In the context of the requirement, 'largest' is used to find the largest integer that appears at least as many times as itself in the list.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] (i < j) in the array.\n    3. For each pair, check if the deletion of the elements at these positions results in the arithmetic mean of the remaining elements being equal to the calculated mean.\n    4. Count the number of such pairs and return the count.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: The arithmetic mean of the array is (1+2+3+4+5)/5 = 3. The pairs that can be deleted to maintain the mean are [1, 2], [1, 3], and [2, 3].\n    search([1, 1, 1, 1]) = 6\n    Explanation: The arithmetic mean is 1. Any pair of elements can be deleted to maintain the mean. There are 6 possible pairs: [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], and [3, 4].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where all elements are the same.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean. This requires efficient handling of large datasets and accurate arithmetic operations to avoid overflow. The solution should also be optimized for performance to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of valid pairs\n- Ensure the solution handles large inputs without overflow\n- Optimize the algorithm for performance\n- Implement error handling for invalid inputs\n- Provide user-friendly output and interface\nTo efficiently handle the problem of calculating the number of pairs [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean, we will use Python due to its strong support for large integer arithmetic and efficient handling of large datasets. We will iterate through all possible pairs of indices in the array, calculate the mean with these elements removed, and check if the resulting mean matches the original mean. To ensure accuracy and prevent overflow, we will use floating-point arithmetic for the mean calculation and then verify the result with integer arithmetic.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions results in the remaining elements having the same arithmetic mean as the original array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases and iterate through each case.\n    2. For each test case, read the number of elements and the array.\n    3. Calculate the original arithmetic mean.\n    4. Iterate through all possible pairs of indices [i, j] where i < j.\n    5. For each pair, calculate the new sum after removing the elements at indices i and j.\n    6. Check if the new mean (new sum / (n - 2)) is equal to the original mean.\n    7. Count the number of valid pairs.\n    8. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    Explanation: In this case, there is only one pair [0, 1] that can be deleted to maintain the original mean.\n    search([2, 2, 2]) = 3\n    Explanation: All pairs [i, j] where i < j are valid, so there are three pairs: [0, 1], [0, 2], and [1, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases with fewer elements.\n\n# [code logic]\n    Here's a Python function that implements the above logic:\n\n    ```python\n    def count_pairs(test_cases):\n        results = []\n        for case in test_cases:\n            n = case['n']\n            arr = case['arr']\n            total_sum = sum(arr)\n            original_mean = total_sum / n\n            count = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    new_sum = total_sum - arr[i] - arr[j]\n                    new_mean = new_sum / (n - 2)\n                    if new_mean == original_mean:\n                        count += 1\n            results.append(count)\n        return results\n\n    # Example usage:\n    test_cases = [\n        {'n': 4, 'arr': [8, 8, 8, 8]},\n        {'n': 3, 'arr': [50, 20, 10]},\n        {'n': 5, 'arr': [1, 4, 7, 3, 5]},\n        {'n': 7, 'arr': [1, 2, 3, 4, 5, 6, 7]}\n    ]\n    print(count_pairs(test_cases))  # Output: [6, 0, 2, 3]\n    ```\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    Explanation: In this case, there is only one pair [0, 1] that can be deleted to maintain the original mean.\n    search([2, 2, 2]) = 3\n    Explanation: All pairs [i, j] where i < j are valid, so there are three pairs: [0, 1], [0, 2], and [1, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases with fewer elements.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the arithmetic mean of the array. The challenge lies in handling large inputs efficiently and ensuring that calculations do not overflow. The solution should be optimized to handle up to 2 * 10^5 elements and their sums up to 10^9.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs\n- Ensure the solution handles large inputs without overflow\n- Optimize the algorithm for fast performance\n- Add input validation to handle edge cases\n- Include detailed documentation for debugging and maintenance\nTo efficiently handle the problem of calculating the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the arithmetic mean of the array, we will use Python's built-in data structures and mathematical operations. The key is to iterate through the array and check for pairs that, when removed, do not change the arithmetic mean of the remaining elements. We will ensure that our solution is optimized for large inputs and handles potential overflow by using appropriate data types and avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by adding all the numbers together and then dividing by the count of numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new sum of the array after removing the elements at indices i and j.\n    4. Check if the new arithmetic mean is still equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4]\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. There are no pairs that can be removed to keep the mean unchanged.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [5, 5, 5, 5]\n    Explanation: The original mean is (5+5+5+5)/4 = 5. Any pair of elements can be removed to keep the mean unchanged.\n    Expected output: 6 (There are 4 elements, and the number of ways to choose 2 out of 4 is 6.)\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array elements are all the same, as in the second edge case. In such cases, any pair of elements can be removed to maintain the mean. The number of such pairs can be calculated using the combination formula nC2 = n*(n-1)/2, where n is the number of elements.\n\n    def count_pairs(arr):\n        n = len(arr)\n        mean = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                new_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n                if (new_sum / (n - 2)) == mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe problem requires calculating the arithmetic mean of the array and then finding pairs of indices whose removal maintains the same mean. This involves a two-step process: first, calculate the mean, and then iterate through pairs to check if their removal maintains the mean. The challenge lies in optimizing this for large inputs efficiently.\nrequirement pool:\n- Calculate the arithmetic mean of the array.\n- Iterate through pairs of indices and check if their removal maintains the mean.\n- Optimize the algorithm for large inputs.\n- Ensure the code is easy to understand and maintain.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the arithmetic mean of the array and then iterate through pairs of indices to check if their removal maintains the mean. We will optimize the algorithm to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that removing the elements at these indices keeps the arithmetic mean of the remaining elements unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the array.\n    Explanation: We need to identify pairs of indices [i, j] where i < j and remove the elements at these indices.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not comparing values directly.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, check if removing the elements at these indices maintains the arithmetic mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    Explanation: There is only one pair [0, 1] that can be removed to keep the mean unchanged.\n    search([2, 2, 2]) = 3\n    Explanation: All pairs [i, j] where i < j can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n    This edge case can be handled by checking if all elements in the array are equal before iterating through pairs. If they are, we can directly calculate the number of pairs using the formula for combinations (n choose 2).\n", "requirement analysis:\nThe problem requires calculating the arithmetic mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array and checking each possible pair of elements. The constraints are high, with up to 2 * 10^5 elements, so the solution must be efficient to handle this.\nrequirement pool:\n- Calculate the arithmetic mean of the array.\n- Find pairs of elements that, when removed, result in the same mean.\n- Ensure the solution is efficient enough to handle up to 2 * 10^5 elements.\n- Optimize the algorithm for large inputs.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The key steps include calculating the arithmetic mean of the array, iterating through the array to find pairs of elements that, when removed, result in the same mean, and counting these pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Calculate the arithmetic mean of the array.\n    (2) Iterate through all possible pairs of indices (i, j) where i < j.\n    (3) For each pair, check if removing the elements at indices i and j results in the arithmetic mean of the remaining elements being equal to the calculated mean.\n    (4) Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The arithmetic mean of the array is 4. The pairs that can be removed to maintain the mean are [1, 2], [1, 3], and [2, 3].\n    search([1, 1, 1, 1]) = 6\n    explanation: The arithmetic mean of the array is 1. All pairs can be removed to maintain the mean, resulting in 6 pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle arrays of any size.\n\nPlease note that the edge cases provided in the example are hypothetical and may not accurately represent the edge cases in the problem statement. The actual implementation should consider all possible edge cases as described in the problem statement.\n", "requirement analysis:\nThe problem requires calculating the arithmetic mean of the array and then finding pairs of positions that, when removed, result in the same arithmetic mean. This involves iterating through the array and checking each possible pair of positions. The constraints are high, with up to 2 * 10^5 elements, so the solution must be optimized to handle this efficiently.\nrequirement pool:\n- Calculate the arithmetic mean of the array\n- Find pairs of positions that, when removed, result in the same arithmetic mean\n- Optimize the solution for large inputs\n- Ensure the code is easy to understand and maintain\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through the array to find pairs of positions that, when removed, result in the same arithmetic mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. For example, the arithmetic mean of [1, 2, 3, 4] is (1+2+3+4)/4 = 2.5.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In the context of this problem, \"more than\" is used to compare the arithmetic mean of the remaining elements after removing two elements with the original arithmetic mean.\n\n# [degree adverb] \n    'exactly': means that the condition must be met without any deviation.\n    Explanation: In this problem, \"exactly\" is used to specify that the arithmetic mean of the remaining elements after removal must be exactly equal to the original arithmetic mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original arithmetic mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n# [core concept] \n    'positive': means that all integer in the list is > 0\n\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find interger > 0\n    'at least as many times': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n\n# [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. For example, the arithmetic mean of [1, 2, 3, 4] is (1+2+3+4)/4 = 2.5.\n\n# [phrase showing quantity relationship]\n    'exactly': indicates that the condition must be met without any deviation.\n    Explanation: In this problem, \"exactly\" is used to specify that the arithmetic mean of the remaining elements after removal must be exactly equal to the original arithmetic mean.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value.\n    Explanation: In this context, \"largest\" is used to find the integer that appears the most times in the list, which is greater than or equal to its value.\n\n# [code logic]\n    To solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through the array to find pairs of positions that, when removed, result in the same arithmetic mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient list operations.\n\n# [edge case] \n    Input:\n    4\n    4\n    8 8 8 8\n    3\n    50 20 10\n    5\n    1 4 7 3 5\n    7\n    1 2 3 4 5 6 7\n\n    Output:\n    6\n    0\n    2\n    3\n\n    Explanation:\n    For the first test case, there are 6 pairs of positions that can be removed to maintain the arithmetic mean: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n    For the second test case, no pair of positions can be removed to maintain the arithmetic mean.\n    For the third test case, there are 2 pairs of positions that can be removed: [1, 2] and [2, 3].\n    For the fourth test case, there are 3 pairs of positions that can be removed: [0, 1], [1, 2], and [2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has fewer elements or where the elements are not positive.\n        if n < 3:\n            return 0\n        if all(x <= 0 for x in a):\n            return -1\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves summing the elements, calculating the mean, and then iterating through pairs to check the condition. The challenge lies in handling large inputs efficiently to avoid overflow and ensure performance.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions [i, j] and check the condition\n- Optimize the solution for large inputs\n- Add error handling for edge cases\n- Provide user feedback on the progress and completion of the task\nTo efficiently handle the problem of calculating the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean, we will use Python due to its efficient handling of large datasets and user-friendly syntax. We will first calculate the mean of the array and then iterate through all pairs of positions [i, j] to check if deleting the elements at these positions keeps the mean unchanged. To ensure efficiency, we will use a mathematical approach to avoid overflow and ensure performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers. In this case, the mean of the array elements before and after deleting two elements should be the same.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. The goal is to find pairs of positions [i, j] such that deleting the elements at these positions does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it should appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets the condition.\n    Explanation: We need to find the largest integer in the array that appears at least as many times as itself.\n\n# [code logic]\n    To efficiently handle the problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of positions [i, j] (i < j) to check if deleting the elements at these positions keeps the mean unchanged.\n    3. Use a mathematical approach to avoid overflow and ensure performance.\n\n# [edge case] \n    Edge case 1:\n    search([1, 2, 3, 4, 5]) = 6\n    Explanation: The mean of the array is 3. The pairs [i, j] that can be deleted to keep the mean unchanged are [0, 1], [0, 2], [0, 3], [0, 4], [1, 2], and [1, 3]. There are 6 such pairs.\n\n    Edge case 2:\n    search([2, 2, 2, 2]) = 6\n    Explanation: The mean of the array is 2. All elements are the same, and each element appears at least as many times as itself. The pairs [i, j] that can be deleted to keep the mean unchanged are [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3]. There are 6 such pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will correctly calculate the number of pairs for any given array.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k. This involves understanding the arithmetic mean and ensuring that the sum of the remaining elements divided by the number of remaining elements equals k. The challenge lies in handling large datasets efficiently to avoid overflow and ensure accuracy.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array\n- Create a function to find pairs of positions [i, j] such that deleting the elements at these positions keeps the mean unchanged\n- Ensure the solution handles large datasets efficiently\n- Implement error handling for edge cases\n- Optimize the code for better performance\nTo efficiently handle the calculation of the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k, we will use Python's built-in data structures and libraries. The key steps include calculating the arithmetic mean of the array, iterating through possible pairs of positions, and ensuring that the mean remains unchanged after deletion. We will use list comprehensions and the sum function to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers. In this case, the mean of the array elements before deletion should be equal to the mean of the array elements after deletion of two elements.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k, we can follow these steps:\n    1. Calculate the total sum of the array elements.\n    2. For each pair (i, j) where i < j, calculate the sum of the remaining elements after deleting the elements at positions i and j.\n    3. Check if the mean of the remaining elements is equal to the original mean k.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, it's impossible to delete two elements and still have a mean of k. Therefore, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The original mean k is (1+2+3+4)/4 = 2.5. We can delete the elements at positions 1 and 3 (0-indexed) to get [2, 4], which has a mean of (2+4)/2 = 3. This does not match the original mean, so the expected output is 0.\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: The original mean k is (1+2+3+4+5)/5 = 3. We can delete the elements at positions 0 and 2 (0-indexed) to get [2, 4, 5], which has a mean of (2+4+5)/3 = 3.5, and we can delete the elements at positions 1 and 3 to get [1, 3, 5], which also has a mean of 3. Therefore, the expected output is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has fewer than 3 elements or where it's impossible to achieve the original mean after any deletion. This can be done by checking the length of the array and ensuring that the mean can be maintained after any two elements are deleted.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves summing the elements, calculating the mean, and then finding pairs that, when removed, maintain the same mean. The challenge lies in handling large inputs efficiently to avoid overflow and ensure performance.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find pairs of indices [i, j] that, when removed, maintain the original mean\n- Ensure the solution is optimized for large datasets\n- Add error handling for edge cases such as all elements being the same\n- Provide clear and concise output\nTo efficiently handle the problem of calculating the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean, we will use Python due to its strong support for large number calculations and efficient handling of large datasets. We will employ the use of itertools to generate pairs of indices and numpy to handle large integers without overflow. The approach involves calculating the mean of the array, iterating through all possible pairs of indices, and checking if the mean remains unchanged after their removal.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average value of a set of numbers. In this case, the mean of the array elements before and after the deletion of any two elements should be the same.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. The goal is to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that appears at least as many times as itself.\n    Explanation: This means we need to find the biggest number in the array that meets the condition of appearing at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To efficiently handle the problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, check if the mean of the remaining elements is still equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to delete any two elements and still have a mean of the remaining elements equal to the original mean.\n\n    Edge case 2: n = 4, array = [1, 3, 2, 3]\n    Expected output: 2\n    Explanation: The original mean is (1+3+2+3)/4 = 2.25. Deleting the first and third elements (1 and 2) or the second and fourth elements (3 and 3) both result in a mean of 3, which is equal to the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    This additional code ensures that the function immediately returns 0 for the edge case where it's impossible to delete two elements and maintain the original mean.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean. This requires efficient handling of large inputs and calculations to avoid overflow and ensure performance.\nrequirement pool:\n- Implement a solution that can handle large inputs efficiently.\n- Ensure the solution calculates the arithmetic mean correctly.\n- Provide a clear and accurate output for each test case.\n- Optimize the solution to handle edge cases effectively.\n- Ensure the user interface is user-friendly and easy to use.\nTo efficiently handle the problem of calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original mean, we will use Python due to its strong support for large integers and efficient handling of large datasets. We will leverage the NumPy library to handle large arrays and perform arithmetic operations efficiently. The solution will involve calculating the mean of the entire array, then iterating through all possible pairs of indices (i, j) where i < j, and checking if removing the elements at these positions maintains the original mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    'large numbers': integers that can be very large, requiring efficient handling to avoid overflow.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship specifically mentioned.\n\n# [degree adverb] \n    No degree adverb specifically mentioned.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases and iterate through each case.\n    2. For each test case, read the number of elements and the array.\n    3. Calculate the arithmetic mean of the array.\n    4. Iterate through all pairs of indices (i, j) where i < j.\n    5. For each pair, calculate the new mean after removing the elements at positions i and j.\n    6. Count the number of pairs that result in the new mean being equal to the original mean.\n    7. Output the count for each test case.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    Explanation: The original mean is (1+2+3+4+5+6+7)/7 = 4. The pairs that can be removed to maintain the mean are [1, 2], [1, 3], and [2, 3], resulting in the remaining elements summing to 28, which is 4 * 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case and any other large input.\n"], "scores": [], "pass_results": [true, true, false, false, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 232, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 191}
