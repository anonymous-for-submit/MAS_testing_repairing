{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the average of these elements (note that it's possible that k is not an integer).\n\nThe average of an array with n items is the total of its elements divided by the count of these items. This means it is equal to the total divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the average of these elements (note that it's possible that k is not an integer).\n\nThe average of an array with n items is the total of its elements divided by the count of these items. This means it is equal to the total divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a with n elements. The average of this array, denoted as k, is calculated by dividing the sum of all elements by the number of elements, n. Monocarp wants to remove two elements from the array a such that the average of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i < j) in the array a, where removing the elements at these positions will result in the average of the remaining elements being equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the average of these elements. He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef func(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        average = total_sum / n\n        count_diff = {}\n        pairs = 0\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = 2 * a[i] + 2 * a[j] - total_sum\n                if diff in count_diff:\n                    pairs += count_diff[diff]\n                if diff not in count_diff:\n                    count_diff[diff] = 1\n                else:\n                    count_diff[diff] += 1\n        \n        results.append(pairs)\n    \n    return results\n\n# Interface\nn = int(input())\ntest_cases = []\nfor _ in range(n):\n    _ = input()\n    a = list(map(int, input().split()))\n    test_cases.append((len(a), a))\n\nresult = func(n, test_cases)\nfor r in result:\n    print(r)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = calculate_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == original_average:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the average of the array\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the average of the remaining elements is still equal to the original average\n            if remaining_sum / remaining_count == average:\n                # Check if the remaining elements can form a valid pair\n                if arr[i] == arr[j]:\n                    # If both elements are the same, we need to check if there are at least two such elements\n                    if element_count[arr[i]] >= 2:\n                        count += 1\n                else:\n                    # If both elements are different, we need to check if they are both present in the array\n                    if arr[i] in element_count and arr[j] in element_count:\n                        count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_average = new_sum / (n - 2)\n                if new_average == original_average:\n                    count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(n, arr):\n    \"\"\"\n    This function calculates the number of pairs of positions [i, j] (i < j) in the array such that if the elements on these positions are deleted, the average of the remaining elements is equal to the original average.\n    \n    Args:\n    n (int): The number of elements in the array.\n    arr (list): The list of integers representing the array.\n    \n    Returns:\n    int: The number of valid pairs.\n    \"\"\"\n    # Calculate the average of the array\n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    # Initialize the count of valid pairs\n    valid_pairs_count = 0\n    \n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if removing the pair maintains the average\n            if remaining_sum / remaining_count == original_average:\n                valid_pairs_count += 1\n    \n    return valid_pairs_count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    sum_counts = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                current_sum = arr[i] + arr[j]\n                if current_sum in sum_counts:\n                    sum_counts[current_sum] += 1\n                else:\n                    sum_counts[current_sum] = 1\n    \n    for current_sum, count in sum_counts.items():\n        remaining_sum = total_sum - current_sum\n        if remaining_sum / (n - 2) == original_mean:\n            count += sum_counts[current_sum]\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    # Calculate the average of the array\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    # Initialize the count of pairs to delete\n    pairs_to_delete = 0\n    \n    # Iterate through all pairs of positions [i, j] (i < j) in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if removing the elements at positions i and j maintains the average\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == average:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of positions that, when removed, result in the same average. This involves iterating through the array and checking each possible pair of positions. The constraints are high, with up to 2 * 10^5 elements, so the solution must be optimized for performance.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of positions that, when removed, result in the same average.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the user interface is simple and intuitive, guiding the user through the process.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the average of the array and then iterating through the array to find pairs of positions that, when removed, result in the same average. We will use a dictionary to keep track of the counts of the differences between the elements and the average, which allows us to quickly determine the number of pairs that need to be deleted.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in the array.\n    Explanation: The average (mean) of an array is a fundamental statistical measure that represents the central tendency of the data. In this problem, we need to find pairs of elements that, when removed, do not change the average of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not directly used in the requirement, but the concept of 'at least as many times' is implied when we need to find elements that, when removed, do not change the average.\n\n# [degree adverb] \n    'largest': This phrase is not directly used in the requirement, but the concept of 'largest integer' is implied when we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the average of the array.\n    2. For each pair of elements in the array, check if removing them results in the average of the remaining elements being equal to the original average.\n    3. Use a dictionary to keep track of the counts of the differences between the elements and the average.\n    4. Count the number of valid pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs of elements that can be removed without changing the average. The average of the array is 3, and no pair of elements can be removed to keep the average the same.\n    search([1, 1, 1, 1, 1]) = 10\n    Explanation: Since all elements are the same, any pair of elements can be removed to keep the average the same. There are 10 possible pairs (0-1, 0-2, ..., 3-4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases, including when all elements are the same.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions will not change the mean of the array. This involves understanding the concept of mean and how deleting elements affects it. The solution should be efficient enough to handle up to 2 * 10^5 elements across multiple test cases, summing up to 2 * 10^5 elements in total.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all pairs [i, j] and check if deleting the elements at these positions maintains the mean.\n- Ensure the solution is optimized to handle the upper limits of input size efficiently.\n- Add input validation to handle edge cases and ensure the program does not crash.\n- Implement a user interface for easy input and output of data.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to calculate the mean of the array and then find all pairs [i, j] such that deleting the elements at these positions maintains the mean. We will use a brute-force approach initially to ensure correctness and then optimize it based on performance requirements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    The average of an array is the sum of its elements divided by the count of these elements. Monocarp wants to delete two elements from the array so that the remaining elements' average remains the same.\n\n# [phrase showing quantity relationship]\n    'as many times'\n    This phrase indicates that the number of times a value appears in the array should be at least as much as the value itself.\n\n# [degree adverb] \n    'largest'\n    This adverb indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Calculate the average of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions keeps the average the same.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: There are no pairs that can be removed to keep the average the same since all elements are distinct.\n    search([2, 2, 4, 4]) = 3\n    Explanation: Possible pairs are [0, 2], [0, 3], [1, 2]. Removing elements at these positions results in an average of 3 for the remaining elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs can be directly applied to any array, including the edge case where all elements are distinct.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the average of the remaining elements being equal to the original average k. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases, each with a sum not exceeding the same limit.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Iterate through all possible pairs [i, j] and check if deleting them results in the average remaining elements being equal to k.\n- Optimize the solution to handle large inputs efficiently.\n- Add input validation to ensure the input format is correct.\n- Include error handling for edge cases such as empty arrays or arrays with zero elements.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to iterate through all possible pairs of positions [i, j] and check if deleting them results in the average of the remaining elements being equal to the original average k. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    Explanation: The average (mean) of an array is calculated by summing all the elements and then dividing by the number of elements. Monocarp wants to delete two elements from the array such that the average of the remaining elements is still equal to the original average.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the value must be greater than the average for a condition to be met.\n    Explanation: In this context, 'more than' is used to specify that the elements to be deleted must be greater than the average to ensure the remaining elements' average remains unchanged.\n\n# [degree adverb] \n    'exactly': means that the number of elements to be deleted is specified as two.\n    Explanation: The adverb 'exactly' indicates that we need to delete exactly two elements from the array to achieve the desired average.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original average (k) of the array.\n    2. Iterate through all possible pairs of positions [i, j] in the array.\n    3. For each pair, calculate the sum of the remaining elements after deletion.\n    4. Check if the sum of the remaining elements divided by (n - 2) equals the original average k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs of elements that can be deleted to keep the average unchanged since all elements are distinct.\n    search([2, 2, 4, 4]) = 3\n    Explanation: There are three pairs of positions [i, j] that can be deleted to keep the average unchanged: [0, 2], [0, 3], and [1, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of elements that, when removed, maintain the same average. This involves a straightforward calculation of the sum and average, followed by a search for pairs that, when removed, do not change the average. The challenge lies in optimizing this process for large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find pairs of elements that, when removed, do not change the average.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and accurate output as per the given requirements.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the average of the array and then iterating through pairs of elements to check if their removal maintains the average. We will use a brute-force method initially to ensure correctness, then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: The average (k) of an array is calculated by dividing the sum of all its elements by the number of elements (n). Monocarp wants to remove two elements from the array such that the average of the remaining elements is still equal to k.\n\n# [phrase showing quantity relationship]\n    'more than': means that the number of times a value appears in the array is greater than or equal to the value itself.\n    'at least as many times': means that the number of times a value appears in the array is greater than or equal to the value itself.\n\n# [degree adverb] \n    'largest': means that the value is the biggest in the array that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the average (k) of the array.\n    2. Iterate through all pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions maintains the average (k).\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: The average (k) of the array is 3. The pairs that can be removed to maintain the average are [1, 2], [1, 3], and [2, 3].\n    search([1, 1, 1, 1]) = 6\n    Explanation: The average (k) of the array is 1. All pairs can be removed to maintain the average.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any pair can be removed to maintain the average.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any pair can be removed to maintain the average.\n        if all elements are the same:\n            return n * (n - 1) // 2\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] in the array such that removing the elements at these positions results in the average of the remaining elements being equal to the original average k. The solution must be efficient and scalable to handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find all pairs [i, j] where i < j.\n- Ensure the solution is optimized for large inputs.\n- Add error handling for invalid inputs.\n- Include user documentation for easy understanding and usage.\nTo solve this problem efficiently, we will use Python due to its performance and ease of use. The approach involves calculating the average of the array and then iterating through all possible pairs of indices to check if removing the elements at these positions maintains the original average. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: The average (k) of an array is calculated by dividing the sum of all its elements by the number of elements (n). Monocarp wants to remove two elements from the array such that the average of the remaining elements is still equal to k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to the element itself.\n    'at least as many times': means the frequency of an element should be at least equal to its value.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the average (k) of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions maintains the original average.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    Explanation: The original average is (1+2+3+4+5+6+7)/7 = 4. Removing the elements at positions [3, 5] (values 4 and 6) results in the remaining elements [1, 2, 3, 5, 7] having an average of (1+2+3+5+7)/5 = 3.6, which is not equal to 4. There are three such pairs: [3, 5], [3, 6], and [4, 6].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to find the number of pairs that maintain the original average after removal of two elements.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of elements whose removal does not change the average. This involves a two-step process: first, calculate the average, and then iterate through all possible pairs to check if their removal maintains the average. The constraints are high, with up to 2 * 10^5 elements, so the solution must be optimized for time complexity.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find all pairs of indices and check if removing them maintains the average.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is user-friendly and provides clear output.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The key steps include calculating the average of the array, iterating through all possible pairs of indices, and checking if removing these pairs maintains the average. We will use list comprehensions and the sum function to achieve these steps.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'removal of elements': the average of the remaining elements should remain the same after removing two specific elements\n\n# [phrase showing quantity relationship]\n    'more than': implies that we need to find pairs of indices where removing the elements at these positions will not change the average\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs of indices that maintain the average\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The average of the array is 4. Removing the pairs [0, 4], [1, 5], and [2, 3] will result in the average of the remaining elements being 4.\n    search([1, 1, 1, 1, 1]) = 6\n    explanation: The average of the array is 1. Removing any pair of elements will result in the average of the remaining elements being 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan should be sufficient to handle all test cases.\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion maintains the mean. The constraints are high, with up to 2 * 10^5 test cases and up to 2 * 10^5 elements per test case.\nrequirement pool:\n- Implement a solution that calculates the mean and checks pairs efficiently.\n- Ensure the solution can handle large inputs without crashing.\n- Provide clear and concise output.\n- Optimize the algorithm for better performance.\n- Improve user interface for better understanding of results.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if their deletion maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'deleting elements': removing elements from the array to change its mean\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the deletion maintains the mean\n\n# [degree adverb] \n    'exactly': means we need to find specific pairs to delete\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n    4. Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: There are no pairs of indices (i, j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n    search([2, 2, 4]) = 1\n    Explanation: The only pair is [0, 2] where deleting elements at these positions (0 and 2) keeps the mean of the remaining elements equal to the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, as there are no pairs to delete.\n        if n == 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion maintains the mean. The constraints are high, with up to 2 * 10^5 test cases and up to 2 * 10^5 elements per test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all possible pairs and check if their deletion maintains the mean\n- Ensure the solution is efficient and can handle large inputs\n- Optimize the algorithm for better performance\n- Add user interface elements for better interaction\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair-wise comparisons. We will calculate the mean of the array once and then iterate through all possible pairs to check if their deletion maintains the mean. The key is to ensure that the solution is optimized to handle the large input constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the mean (average) of the elements in the array. We need to find pairs of elements whose deletion does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after deleting the elements at positions i and j.\n    4. Count the number of pairs that result in the same mean as the original array.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, deleting any two elements will change the mean. Therefore, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. The pairs [1, 2], [1, 3], and [2, 3] result in the mean of the remaining elements being 2.5. Therefore, the expected output is 3.\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: The original mean is (1+2+3+4+5)/5 = 3. The pairs [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], and [3, 4] result in the mean of the remaining elements being 3. Therefore, the expected output is 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k. The solution must be efficient and scalable to handle large inputs within performance constraints.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle up to 2 * 10^5 elements efficiently.\n- Provide clear and accurate results for each test case.\n- Optimize the code for performance to handle large inputs.\nTo solve this problem efficiently, we will use Python's built-in data structures and algorithms. The main challenge is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. We will iterate through the array and use a dictionary to count the occurrences of the sum of elements excluding the current element and its pair. This approach ensures that we can handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the mean of a set of numbers is the sum of the numbers divided by the count of the numbers.\n    'deleting elements': removing elements from a list can affect the average of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the elements at these positions, when removed, keeps the average unchanged.\n\n# [degree adverb] \n    'largest': refers to finding the largest possible value that, when removed, maintains the original average.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves iterating through the array to find pairs [i, j] such that the sum of the remaining elements' average remains the same. This requires calculating the total sum of the array and the original average, then checking pairs to see if their removal does not change the average.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    Explanation: The original average is (1+2+3+4)/4 = 2.5. Removing any pair of elements will change the average. For example, removing elements at positions 1 and 2 (values 2 and 3) results in [1, 4] with an average of (1+4)/2 = 2.5, which is the same as the original average.\n    Edge case 2: [5, 5, 5, 5]\n    Explanation: The original average is (5+5+5+5)/4 = 5. Removing any pair of elements (since all elements are the same) will not change the average. For example, removing elements at positions 1 and 2 (values 5 and 5) results in [5, 5] with an average of (5+5)/2 = 5, which is the same as the original average.\n    Edge case 3: [1, 3, 2, 6]\n    Explanation: The original average is (1+3+2+6)/4 = 3. Removing elements at positions 1 and 3 (values 3 and 6) results in [1, 2] with an average of (1+2)/2 = 1.5, which is not the same as the original average.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        For each test case, calculate the original average and total sum. Then, iterate through all possible pairs [i, j] and check if their removal does not change the average. This requires careful handling to ensure efficiency, especially with large inputs.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the average of the remaining elements being the same as the original average. This requires summing the elements, calculating the average, and then iterating through pairs to check if their deletion maintains the average. The constraints are that the number of test cases and the size of the array can be large, so the solution must be optimized for performance.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Iterate through all pairs of positions and check if their deletion maintains the average.\n- Ensure the solution is optimized to handle large inputs within the given constraints.\n- Add error handling for invalid inputs.\n- Provide detailed output for each test case.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. We will calculate the average of the array once and then iterate through all pairs of positions to check if their deletion maintains the average. Given the constraints, we need to ensure our solution is optimized for performance, especially with large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in the array.\n    Explanation: The average (mean) of an array is a fundamental statistical measure that represents the central tendency of the data. In this problem, we need to ensure that after removing two elements, the average of the remaining elements remains the same as the original average.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not explicitly mentioned in the requirement, but the concept of 'at least as many times' implies a comparison of quantities.\n    'at least as many times': This phrase indicates that the number of times a value appears in the array should be at least equal to the value itself.\n\n# [degree adverb] \n    'largest': This phrase is not explicitly mentioned in the requirement, but the concept of 'largest integer' is implied by the need to find the largest value that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the average of the array.\n    2. Iterate through all pairs of positions [i, j] (i < j) in the array.\n    3. Check if removing the elements at positions i and j maintains the average.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs that can be removed to maintain the average because the array does not have any duplicate elements.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The average is 3. Removing one pair of 2's or one pair of 4's will maintain the average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to check pairs and maintain the average is straightforward and does not require additional complexity.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array does not have any duplicate elements, ensuring that we do not count pairs that do not exist.\n"], "scores": [], "pass_results": [false, true, true, true, false, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 335, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 266}
