{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has obtained an array a composed of n numbers and wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k, which is the average of these numbers (note that it's possible that k is not an integer). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your solution is efficient enough to handle large inputs within the provided constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has obtained an array a composed of n numbers and wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k, which is the average of these numbers (note that it's possible that k is not an integer). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your solution is efficient enough to handle large inputs within the provided constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n elements and wants to remove exactly two elements from it. He wants the average of the remaining (n - 2) elements to remain the same as k, which is the average of the original n elements. You need to find the number of pairs of indices [i, j] (where i < j) where if the elements at these positions are removed, the average of the remaining elements will still be k. Your solution should be efficient enough to work with large arrays within the given constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n numbers and wants to delete exactly two elements to keep the mean of the remaining (n - 2) elements equal to k. Calculate the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. Ensure the solution is efficient for large inputs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs_of_positions(n: int, arr: List[int], k: float) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = calculate_pairs_of_positions(n, arr, k)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int], k: float) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == k:\n                    count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr, sum(arr) / n)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef count_pairs(n: int, arr: List[int], k: float) -> int:\n    total_sum = sum(arr)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            remaining_sum = total_sum - arr[i] - arr[j]\n            if remaining_sum == (n - 2) * k:\n                count += 1\n\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = count_pairs(n, arr, k)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int], k: float) -> int:\n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_avg = new_sum / (n - 2)\n            if new_avg == k:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = find_pairs_to_remove(n, arr, k)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int], k: float) -> int:\n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the elements of the array\n    arr = list(map(int, input().split()))\n    # Calculate the average\n    k = sum(arr) / n\n    # Call the find_pairs function\n    result = find_pairs(n, arr, k)\n    # Output the result\n    print(result)\n", "from typing import List\ndef find_pairs_to_remove(n: int, arr: list[int], k: float) -> int:\n    total_sum = sum(arr)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = find_pairs_to_remove(n, arr, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr, k):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the mean of (n - 2) elements equal to k.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (List[int]): The array of integers.\n        k (float): The target mean value.\n\n    Returns:\n        int: The number of valid pairs [i, j].\n    \"\"\"\n    if n < 3:\n        return 0\n\n    total_sum = sum(arr)\n    count = 0\n    seen_sums = {}\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_count = n - 2\n                if new_sum / new_count == k:\n                    count += 1\n                if new_sum not in seen_sums:\n                    seen_sums[new_sum] = 1\n                else:\n                    seen_sums[new_sum] += 1\n\n    return count\n\n# Interface\ninput_lines = sys.stdin.readlines()\nt = int(input_lines[0])\nline_index = 1\nfor _ in range(t):\n    n = int(input_lines[line_index].strip())\n    line_index += 1\n    arr = list(map(int, input_lines[line_index].strip().split()))\n    line_index += 1\n    k = sum(arr) / n\n    result = calculate_pairs(n, arr, k)\n    print(result)\n", "from typing import List\ndef calculate_pairs(n, arr, k):\n    total_sum = sum(arr)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == k:\n                count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate the target mean k\n    k = sum(arr) / n\n    # Calculate and print the number of pairs\n    result = calculate_pairs(n, arr, k)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int], k: float) -> int:\n    total_sum = sum(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == k:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr, sum(arr) / n)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int], k: float) -> int:\n    total_sum = sum(arr)\n    target_sum = (n - 2) * k\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum == target_sum:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = calculate_pairs(n, arr, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to k. This involves summing the elements, calculating the mean, and then checking pairs to see if their deletion maintains the mean. The challenge lies in ensuring the solution is efficient enough to handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through pairs of indices and check if deleting the elements at these indices maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Add error handling for edge cases such as empty arrays or arrays with zero elements.\n- Provide user feedback on the number of valid pairs found.\nTo efficiently solve this problem, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the sum of the array and then iterating through pairs of indices to check if deleting the elements at these positions maintains the mean. We will use a list to store the array and a set to keep track of the sums of the remaining elements after deleting each pair.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements\n    'deleting elements': removing specific elements from a list to calculate the new mean\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the list\n\n# [degree adverb] \n    'efficiently': means the solution should be optimized to handle large inputs within the provided constraints\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves:\n    1. Calculating the total sum of the array.\n    2. Iterating through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculating the sum of the remaining elements after deleting the elements at positions i and j.\n    4. Checking if the mean of these remaining elements is equal to k.\n    5. Counting the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: There are no pairs to delete since there are only 3 elements. The expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The only pair is [0, 1]. If we delete elements at positions 0 and 1, the remaining elements are [3, 4], and their mean is (3 + 4) / 2 = 3.5, which is not equal to k. The expected output is 0.\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: The pair [0, 1] results in the remaining elements [3, 4, 5], and their mean is (3 + 4 + 5) / 3 = 4.0, which is equal to k. The pair [0, 2] results in the remaining elements [2, 4, 5], and their mean is (2 + 4 + 5) / 3 = 3.67, which is not equal to k. The pair [0, 3] results in the remaining elements [1, 2, 5], and their mean is (1 + 2 + 5) / 3 = 2.67, which is not equal to k. The pair [0, 4] results in the remaining elements [1, 2, 3], and their mean is (1 + 2 + 3) / 3 = 2.0, which is not equal to k. The pair [1, 2] results in the remaining elements [1, 4, 5], and their mean is (1 + 4 + 5) / 3 = 3.33, which is not equal to k. The pair [1, 3] results in the remaining elements [2, 3, 5], and their mean is (2 + 3 + 5) / 3 = 3.33, which is not equal to k. The pair [1, 4] results in the remaining elements [2, 3, 4], and their mean is (2 + 3 + 4) / 3 = 3.0, which is not equal to k. The pair [2, 3] results in the remaining elements [1, 2, 4], and their mean is (1 + 2 + 4) / 3 = 2.33, which is not equal to k. The pair [2, 4] results in the remaining elements [1, 2, 3], and their mean is (1 + 2 + 3) / 3 = 2.0, which is not equal to k. The pair [3, 4] results in the remaining elements [1, 2, 3], and their mean is (1 + 2 + 3) / 3 = 2.0, which is not equal to k. The expected output is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to k. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of valid pairs\n- Ensure the solution can handle large inputs efficiently\n- Provide clear and accurate output\n- Optimize the algorithm for better performance\n- Add user interface elements for better user interaction\nTo solve this problem efficiently, we will use a combination of mathematical analysis and data structures. The key idea is to calculate the sum of the array and then iterate through all possible pairs of indices (i, j) where i < j. For each pair, we will check if removing the elements at these positions results in the mean of the remaining elements being equal to k. This approach will be optimized using pre-computation where necessary to ensure it can handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    In the requirement, it refers to the average of the numbers in the array.\n    Explanation: The mean of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. For example, the mean of [1, 2, 3] is (1 + 2 + 3) / 3 = 2.\n\n# [phrase showing quantity relationship]\n    'as many times'\n    Explanation: This phrase indicates that the number of times a value appears in the array should be at least equal to the value itself. For example, if a number appears 3 times, it should be at least 3.\n\n# [degree adverb] \n    'largest'\n    Explanation: This adverb indicates that we need to find the largest integer that meets the condition.\n\n# [code logic]\n    To solve this problem efficiently, we can follow these steps:\n    1. Calculate the total sum of the array.\n    2. For each pair of indices (i, j) where i < j, calculate the sum of the remaining elements after removing the elements at positions i and j.\n    3. Check if the mean of these remaining elements is equal to k.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge Case 1: n = 3, array = [1, 2, 3]\n    Expected Output: 0\n    Explanation: With only 3 elements, it's impossible to delete any two elements and still have the mean of the remaining elements equal to k.\n\n    Edge Case 2: n = 4, array = [1, 2, 3, 4]\n    Expected Output: 1\n    Explanation: There is only one pair (0, 1) where if we delete elements at positions 0 and 1, the mean of the remaining elements [3, 4] is equal to k = 3.5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    This ensures that the function immediately returns 0 for the edge case where there are only 3 elements, as no pairs can be formed.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same average as the original array. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a solution that calculates the number of pairs efficiently\n- Ensure the solution can handle large inputs without performance issues\n- Provide clear and accurate output\n- Optimize the algorithm for better performance\n- Add error handling for unexpected input\nTo efficiently solve this problem, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the sum of the array and then iterating through pairs of indices to check if removing these elements results in the remaining sum being equal to (n - 2) * k. This method ensures that we only consider valid pairs and avoid unnecessary computations, making it suitable for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements\n    'sum of elements': the total value of all elements in a collection\n    'pairs of positions': two distinct positions in a sequence or array\n\n# [phrase showing quantity relationship]\n    'exactly two elements': we need to remove exactly two elements from the array\n    'remaining elements': the elements left after removing two elements\n\n# [degree adverb] \n    'equal to': the remaining sum of elements should match the required sum\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    1. Calculate the total sum of the array.\n    2. For each pair of positions [i, j] where i < j:\n        a. Calculate the sum of the remaining elements after removing the elements at positions i and j.\n        b. Check if this sum is equal to (n - 2) * k.\n        c. Count the number of such pairs.\n    3. Return the count of such pairs.\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    k = (1 + 2 + 3) / 3 = 2\n    expected output: 0\n    Explanation: With only three elements, removing any two will change the mean, so there are no valid pairs.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    This ensures that we do not perform unnecessary calculations for the smallest valid array size.\n", "requirement analysis:\nThe problem requires finding pairs of indices to remove from an array such that the average of the remaining elements remains the same as the original average. This involves calculating the sum of the array, the average, and then checking pairs of elements to see if their removal maintains the average. The constraints are large, so the solution must be efficient.\nrequirement pool:\n- Implement a function to calculate the average of the array\n- Create a function to find pairs of indices to remove\n- Ensure the solution is optimized for large inputs\n- Add error handling for edge cases\n- Improve the algorithm for better performance\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The approach involves calculating the sum of the array and the average, then iterating through pairs of indices to check if their removal maintains the average. We will use a simple and efficient algorithm to ensure it works within large constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'removal of elements': the sum of remaining elements should be adjusted for the removed elements\n\n# [phrase showing quantity relationship]\n    'more than': not applicable in this context\n    'at least as many times': not applicable in this context\n\n# [degree adverb] \n    'largest': not applicable in this context\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The average of the array is 4. The pairs that can be removed to maintain the average are [0, 4], [0, 5], and [0, 6].\n    search([1, 1, 1, 1, 1]) = 6\n    explanation: The average of the array is 1. Any pair of indices can be removed to maintain the average.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic can be implemented directly by iterating through all pairs of indices.\n\nPlease note that the edge cases provided in the example are not in the correct format as per the instructions. The correct format should include the input and expected output for each edge case. Here is the corrected format for the edge cases:\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    Explanation: The average of the array is 4. The pairs that can be removed to maintain the average are [0, 4], [0, 5], and [0, 6].\n    search([1, 1, 1, 1, 1]) = 6\n    Explanation: The average of the array is 1. Any pair of indices can be removed to maintain the average.\n\nPlease provide the plan and requirement for the next prompt, and I will continue with the analysis.\n", "requirement analysis:\nThe problem requires finding pairs of indices [i, j] where removing the elements at these indices maintains the original average k. This involves calculating the sum of the array, the average, and then checking all possible pairs to see if removing them maintains the average. The challenge lies in the efficiency, as the constraints allow for up to 2 * 10^5 elements, and the solution must handle this efficiently.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to iterate through all possible pairs of indices.\n- Ensure the solution is optimized to handle large inputs within the given constraints.\n- Add error handling for invalid inputs.\n- Include user documentation for easy understanding and usage.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the sum of the array and the average, then iterating through all possible pairs of indices to check if removing them maintains the average. We will use a brute-force method initially to ensure correctness, and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'removal of elements': the sum of remaining elements should be adjusted for the removed elements\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to its value\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that meets the condition\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The average of the array is 4. Removing pairs (1, 2), (1, 3), and (2, 3) will keep the average the same.\n    search([1, 1, 1, 1]) = 6\n    explanation: The average is 1. Removing any pair of elements will keep the average the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can iterate through all possible pairs and check the condition.\n\n# [code logic]\n    Here's a detailed logic to implement the code:\n    1. Read the number of test cases.\n    2. For each test case:\n        a. Read the number of elements in the array.\n        b. Read the elements of the array.\n        c. Calculate the sum of the array.\n        d. Calculate the average of the array.\n        e. Iterate through all possible pairs of indices (i, j) where i < j.\n        f. For each pair, calculate the sum of the remaining elements and check if it equals (n - 2) * k.\n        g. Count and return the number of such pairs.\n\n# [edge case]\n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    Explanation: The average of the array is 4. Removing pairs (1, 2), (1, 3), and (2, 3) will keep the average the same.\n    search([1, 1, 1, 1]) = 6\n    Explanation: The average is 1. Removing any pair of elements will keep the average the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can iterate through all possible pairs and check the condition.\n", "requirement analysis:\nThe primary requirement is to find pairs of indices [i, j] such that removing the elements at these indices results in the average of the remaining elements being equal to the original average k. The solution must be efficient to handle large inputs efficiently.\nrequirement pool:\n- Implement an efficient algorithm to find the required pairs of indices.\n- Ensure the solution works within the given constraints.\n- Provide clear and accurate output for each test case.\nTo solve this problem efficiently, we will use Python's built-in data structures and algorithms. The main idea is to calculate the sum of all elements in the array and then for each pair of indices [i, j], check if removing these elements results in the average of the remaining elements being equal to k. This approach will be efficient due to the use of basic operations and data structures that are optimized for such tasks in Python.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'sum': the total of all elements in a collection\n    'pair': a combination of two elements from a set or list\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another\n    'at least as many times': means the same or more than\n\n# [degree adverb] \n    'largest': refers to the biggest or greatest in a set of values\n\n# [code logic]\n    To solve this problem efficiently, we will follow these steps:\n    1. Calculate the total sum of the array elements.\n    2. For each pair of indices [i, j] where i < j, calculate the sum of the remaining elements after removing the elements at indices i and j.\n    3. Check if the average of these remaining elements is equal to k.\n    4. Count the number of such pairs.\n    5. Output the count.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, removing any two elements will leave us with a single element, which cannot have an average equal to k. Therefore, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The sum of the array is 10. If we remove elements at indices 1 and 2 (with values 2 and 3), the remaining sum is 5, and the average is 2.5, which is not equal to k (which is the average of the original array, 2.5). Therefore, the expected output is 1 (the pair [1, 2]).\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: The sum of the array is 15. If we remove elements at indices 2 and 3 (with values 3 and 4), the remaining sum is 8, and the average is 4, which is equal to k (which is the average of the original array, 3). Therefore, the expected output is 2 (the pairs [2, 3] and [2, 4]).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has only a few elements or where the sum of the remaining elements does not match k.\n    For example, if n < 3, we can immediately return 0 since we cannot remove two elements to have an average.\n    Additionally, we need to ensure that the sum of the remaining elements divided by (n - 2) equals k. If not, we should not count that pair.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] where deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. The solution must be efficient and scalable to handle large inputs efficiently. The output should be clear and concise for each test case.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle large inputs efficiently, even with the sum of n over all testcases not exceeding 2 \u22c5 10^5.\n- Provide clear and concise output for each test case.\n- Test the solution with various edge cases to ensure accuracy.\nTo efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the mean of the array and then iterating through pairs of indices to check if deleting the elements at these positions maintains the mean equal to k. We will use a nested loop to check all possible pairs, which is straightforward and easy to implement. To ensure efficiency, we will optimize the process by breaking early when the sum of remaining elements exceeds the required mean multiplied by the remaining count, which helps in reducing unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, we need to find pairs of indices that, when removed, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the remaining elements divided by the count of remaining elements equals k.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest integer that appears more than or equal to its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem efficiently, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements and check if their mean equals k.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since there are only 3 elements, deleting any two elements will leave us with a single element, which cannot have a mean equal to k. Therefore, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: We can delete the elements at positions 1 and 2 (0-indexed), leaving us with elements at positions 2 and 3. The sum of these elements is 7, and their mean is 3.5, which does not equal k. We need to check all pairs to ensure we count the valid ones.\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: We can delete the elements at positions 0 and 1, leaving us with elements at positions 2, 3, and 4. The sum of these elements is 12, and their mean is 4, which equals k. This is one valid pair.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is very small or the array elements are such that no pair can maintain the mean equal to k. This can be done by adding checks before counting pairs to ensure that the remaining elements can indeed form a mean equal to k.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] where deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. The solution must be efficient to handle large inputs efficiently. The output should be a single integer representing the number of such pairs.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements efficiently.\n- Provide clear and concise output in the form of a single integer.\n- Optimize the code for large-scale data processing.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of elements to check if their deletion maintains the mean at k. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, we need to find pairs of elements that, when deleted, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To solve this problem, we will follow these steps:\n    1. For each test case, read the array and the target mean k.\n    2. Calculate the sum of the entire array.\n    3. Iterate through all possible pairs of elements in the array.\n    4. For each pair, calculate the sum of the remaining elements after deletion.\n    5. Check if the sum of the remaining elements divided by (n - 2) equals k.\n    6. Count the number of such pairs.\n    7. Output the count for each test case.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    n = 3\n    a = [1, 2, 3]\n    k = 2\n    Explanation:\n    The sum of the array is 6. The mean of the array is 2. There are no pairs to delete to keep the mean at 2.\n    Expected output: 0\n\n    Edge case 2:\n    Input:\n    n = 4\n    a = [1, 2, 3, 4]\n    k = 2.5\n    Explanation:\n    The sum of the array is 10. The mean of the array is 2.5. The pairs to delete are [0, 1] and [2, 3].\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, and the mean cannot be maintained by deleting any two elements.\n    if n == 3:\n        return 0\n\n    (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] where deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. The solution must be efficient to handle up to 2 \u22c5 10^5 elements. The output should be a single integer for each test case indicating the number of such pairs.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the solution for large inputs to ensure fast and reliable performance.\nTo efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the total sum of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to k. We will use a nested loop to check each pair, which is acceptable given the constraint of up to 2 \u22c5 10^5 elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, we need to find pairs of indices that, when removed, result in the mean of the remaining elements being equal to a given value k.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the total sum of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to k. We will use a nested loop to check each pair, which is acceptable given the constraint of up to 2 \u22c5 10^5 elements.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since there are only 3 elements, removing any two elements will leave us with a single element, which cannot have a mean equal to k. Therefore, the expected output is 0.\n\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: We can remove the elements at positions 1 and 2 (0-indexed), or positions 1 and 3, or positions 2 and 3. In each case, the remaining elements are [3, 4] and their mean is (3 + 4) / 2 = 3.5, which is not equal to k. Therefore, the expected output is 3.\n\n    Edge case 3:\n    Input: n = 5, a = [1, 2, 3, 4, 5]\n    Explanation: We can remove the elements at positions 0 and 1, or positions 0 and 2, etc. The pairs are [0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]. In each case, the remaining elements are [3, 4, 5] and their mean is (3 + 4 + 5) / 3 = 4, which is equal to k. Therefore, the expected output is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is efficient for large inputs as it only requires a nested loop over the pairs of indices, which is acceptable given the constraint of up to 2 \u22c5 10^5 elements.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same average as the original array. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a solution that calculates the number of pairs efficiently\n- Ensure the solution can handle large inputs without performance issues\n- Provide clear and accurate output\n- Optimize the algorithm for better performance\n- Add error handling for unexpected input\nTo efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the sum of the array and then iterating through pairs of indices to check if removing these elements results in the remaining sum being equal to (n - 2) * k. This method ensures that we only consider valid pairs and avoid unnecessary computations, making it scalable for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements\n    'sum of elements': the total value of all elements in an array\n    'pairs of positions': combinations of two distinct positions in an array\n\n    Explanation: The requirement is to find pairs of indices [i, j] such that removing the elements at these indices results in the remaining elements having a mean equal to k. This involves calculating the sum of the array and checking if removing two specific elements maintains the mean at k.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': specifically refers to removing two distinct elements from the array\n    'the number of pairs': indicates the count of valid pairs [i, j] that can be formed\n\n# [degree adverb] \n    'efficiently': means the solution should handle large inputs within the provided constraints without excessive computation time\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through pairs of indices to check if removing the elements at these positions maintains the mean at k. This can be efficiently implemented using nested loops to consider all pairs of indices.\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have a mean of k. Therefore, the number of pairs is 0.\n\n    n = 4, a = [1, 2, 3, 4]\n    expected output: 1\n    Explanation: The sum of the array is 10, and k is (1+2+3+4)/4 = 2.5. Removing elements at positions 1 and 2 (0-indexed) results in the sum of the remaining elements being 7, which is equal to (4-2)*2.5. Thus, there is one valid pair.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle the edge case of having only three elements by immediately returning 0, as it's impossible to form a pair in this scenario.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle the edge case of having only three elements by immediately returning 0, as it's impossible to form a pair in this scenario.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 434, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 338}
