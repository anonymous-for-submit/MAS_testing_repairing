{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer), which is the sum of elements divided by the number of these elements (i.e. sum divided by n) and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). This problem requires you to take advantage of mathematical equations to determine valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer), which is the sum of elements divided by the number of these elements (i.e. sum divided by n) and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). This problem requires you to take advantage of mathematical equations to determine valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a with n integers. The mean k of these elements is calculated by dividing the sum of the elements by the number of elements (n). Monocarp wants to remove two elements from the array so that the mean of the remaining (n - 2) elements is still k. Your task is to find the number of pairs of positions [i, j] (where i < j) where if the elements at these positions are removed, the mean of the remaining elements is still k. This requires using mathematical equations to identify valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers. The mean k of these elements is calculated as the sum of elements divided by the number of elements (n). He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k. This requires using mathematical equations to find valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport sys\n\ndef count_valid_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mathematic mean of (n - 2) remaining elements is still equal to k (that is, it is equal to the mathematic mean\n    of n elements of the original array a).\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers representing the array.\n\n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Read input and output the result\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = count_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr, mean_value):\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            if remaining_sum / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean_value = sum(arr) / n\n    result = find_pairs(arr, mean_value)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_valid_pairs(n, arr):\n    \"\"\"\n    This function calculates the number of pairs [i, j] (i < j) where removing the elements at these positions\n    maintains the mean of the remaining elements.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n        \n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    mean_value = sum(arr) / n\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == mean_value:\n                valid_pairs += 1\n    return valid_pairs\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(n, arr):\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Calculate the sum of the array\n    total_sum = sum(arr)\n    \n    # Iterate through all pairs of positions (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if removing the elements at positions i and j maintains the mean\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If all elements are the same, return the number of pairs\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing the elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of these remaining elements is still equal to the original mean\n            if remaining_sum / remaining_count == mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_valid_pairs(n, arr):\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Initialize the count of valid pairs\n    valid_pairs_count = 0\n    \n    # Calculate the sum of all elements in the array\n    total_sum = sum(arr)\n    \n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing the pair (i, j)\n            remaining_sum = total_sum - arr[i] - arr[j]\n            \n            # Check if removing these two elements results in the mean of the remaining elements being equal to the original mean\n            if (remaining_sum / (n - 2)) == mean_value:\n                # Check if the remaining elements still form a valid pair\n                if remaining_sum / (n - 2) == mean_value:\n                    valid_pairs_count += 1\n    \n    return valid_pairs_count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    # Read the array elements\n    arr = list(map(int, input().strip().split()))\n    # Calculate and print the result\n    result = calculate_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    original_mean = sum(arr) / n\n\n    # Initialize the count of valid pairs\n    count = 0\n\n    # Iterate through all pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Calculate the mean of the new array\n            new_mean = sum(new_arr) / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == original_mean:\n                count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_valid_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == original_mean:\n                    count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_pairs(n, arr):\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Create a dictionary to store the frequency of each element's contribution to the sum\n    # when one element is removed\n    sum_contributions = {}\n    \n    for i in range(n):\n        # Calculate the sum when the i-th element is removed\n        new_sum = total_sum - arr[i]\n        # Calculate the new mean when the i-th element is removed\n        new_mean = new_sum / (n - 1)\n        \n        # Check if the new mean is equal to the original mean\n        if new_mean == mean:\n            # Increment the count for this contribution\n            contribution = new_sum - (n - 1) * mean\n            if contribution in sum_contributions:\n                sum_contributions[contribution] += 1\n            else:\n                sum_contributions[contribution] = 1\n    \n    # Count the pairs based on the contributions\n    for contribution, freq in sum_contributions.items():\n        if freq > 1:\n            count += freq * (freq - 1) // 2\n    \n    return count\n\n# Read the number of test cases\nt = int(sys.stdin.readline())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(sys.stdin.readline())\n    # Read the array elements\n    arr = list(map(int, sys.stdin.readline().split()))\n    # Find and print the number of valid pairs\n    result = find_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the mean of the remaining elements being equal to the original mean. This involves mathematical calculations and efficient data handling to ensure the solution is scalable.\nrequirement pool:\n- Calculate the mean of the array\n- Find pairs of elements to delete\n- Ensure the solution is efficient and scalable\n- Handle large inputs efficiently\n- Provide clear and accurate output\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of elements to check if their removal would still result in the mean of the remaining elements being equal to the original mean. This will be done in a way that ensures the solution is both efficient and scalable.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements.\n    Explanation: The mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of elements that, when removed, do not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the elements at these positions is significant in relation to the total sum of the array.\n\n# [degree adverb] \n    'largest': suggests that we are looking for the most significant pairs that could affect the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new mean of the remaining elements.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, removing any two elements will change the mean, so there are no valid pairs.\n\n    Edge case 2: n = 4, array = [1, 3, 2, 4]\n    Expected output: 1\n    Explanation: The original mean is (1+3+2+4)/4 = 2.5. Removing the elements at positions 1 and 3 (1 and 2) results in the mean of the remaining elements being (3+4)/2 = 3.5, which is not equal to 2.5. However, removing elements at positions 0 and 2 (1 and 2) results in the mean of the remaining elements being (3+4)/2 = 3.5, which is not equal to 2.5. There is one valid pair: removing elements at positions 1 and 2 (3 and 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements whose removal does not change the mean. This involves a mathematical approach to determine valid pairs. The solution should be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of elements whose removal does not change the mean.\n- Ensure the solution is optimized to handle the upper limits of input size.\n- Provide clear and accurate output.\n- Ensure the user interface is simple and easy to use.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the mean of the array and then find pairs of elements whose removal does not change the mean. We will iterate through the array to find such pairs, ensuring that the solution is optimized to handle the upper limits of input size.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements.\n    Explanation: The mean of an array is calculated by summing all the elements and then dividing by the number of elements. Monocarp wants to delete two elements from the array such that the mean of the remaining elements remains the same.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n    Explanation: For example, if we have an array [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. If we remove the elements 2 and 3, the remaining array is [1, 4], and the mean is (1+4)/2 = 2.5, which is the same as the original mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs of elements to delete.\n    Explanation: In the context of the problem, 'largest' might refer to the elements with the highest values in the array, as these could have the most significant impact on the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. Check if removing these two elements results in the mean of the remaining elements being equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 1, 2]\n    expected output: 1\n    Explanation: The mean of the array is (1+1+2)/3 = 1.33. Removing any two elements will change the mean. The only pair [i, j] is [0, 2] (removing elements at indices 0 and 2 results in [1, 1], whose mean is 1, which is equal to the original mean).\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    expected output: 1\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. Removing elements 2 and 3 results in [1, 4], whose mean is 2.5, which is equal to the original mean.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    expected output: 2\n    Explanation: The mean of the array is (1+2+3+4+5)/5 = 3. Removing pairs [0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4] will change the mean. The valid pairs are [0, 4] and [1, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    To ensure the solution is efficient, we need to consider the constraints and optimize the iteration process. For example, we can use a nested loop to iterate through all possible pairs and check the condition.\n\n    def count_pairs(n, arr):\n        mean_original = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n-2)) == mean_original:\n                    count += 1\n        return count\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements whose deletion does not change the mean. This involves a straightforward calculation of the mean and then iterating through pairs to check if their deletion maintains the mean. The challenge lies in handling large inputs efficiently within the given constraints.\nrequirement pool:\n- Calculate the mean of the array\n- Iterate through pairs of positions\n- Check if the deletion of a pair maintains the mean\n- Optimize the solution for large inputs\n- Ensure the solution is clear and easy to understand\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of positions to check if their deletion maintains the mean. We will optimize the solution for large inputs by using efficient data structures and avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean'\n    In the requirement, it refers to the sum of all elements in the array divided by the number of elements, which is a measure of central tendency.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs that can be removed to maintain this mean since removing any two elements will change the mean.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 2, 3]\n    Explanation: The original mean is (1+3+2+3)/4 = 2.25. The pairs [1, 2] and [2, 3] can be removed to maintain this mean.\n    Expected output: 2\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs can be implemented directly within the main loop.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] where removing the elements at these positions maintains the original mean. This involves summing the elements, calculating the mean, and then iterating through pairs to check if removing them maintains the mean. The solution must be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all pairs of positions [i, j] where i < j\n- Check if removing the elements at positions [i, j] maintains the mean\n- Count and return the number of valid pairs\n- Ensure the solution is optimized for large inputs\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array, then iterating through all pairs of positions [i, j] where i < j to check if removing the elements at these positions maintains the mean. We will use a brute-force method initially to ensure correctness, and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    'pairwise positions': a combination of two positions in a list where the first position is less than the second position.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where removing two elements results in the mean of the remaining elements being the same as the original mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The mean of the array is 4. The pairs that can be removed to maintain the mean are [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], and [3, 4].\n    search([1, 1, 1, 1]) = 6\n    explanation: The mean of the array is 1. Any pair of positions can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only a few elements, as the brute-force method will be efficient enough.\n        (code for handling the edge case)\n", "requirement analysis:\nThe primary requirement is to find pairs of positions in an array where removing two elements maintains the mean. This involves calculating the mean of the array, iterating through pairs of positions, and checking if removing those elements results in the same mean. The solution must handle multiple test cases efficiently, which requires optimizing the algorithm for large inputs.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all pairs of positions in the array.\n- Check if removing the elements at these positions maintains the mean.\n- Optimize the algorithm for handling large inputs efficiently.\n- Ensure the solution can handle multiple test cases.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all pairs of positions to check if removing the elements at these positions maintains the mean. We will optimize the algorithm to handle large inputs efficiently by avoiding unnecessary computations and leveraging Python's built-in functions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    'pairwise positions': a combination of two positions in a list where the first position is less than the second position.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an integer appears in the list should be greater than or equal to the integer itself.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of positions (i, j) where i < j.\n    3. For each pair, check if removing the elements at these positions maintains the mean.\n    4. Count the number of such pairs.\n    5. Return the count of valid pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    explanation: The mean of the array is 3. The pairs [1, 2], [1, 3], and [2, 3] can be removed to maintain the mean of 3.\n    search([1, 1, 1, 1]) = 6\n    explanation: The mean of the array is 1. All pairs can be removed to maintain the mean of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any pair can be removed to maintain the mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any pair can be removed to maintain the mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] where removing the elements at these positions results in the mean of the remaining elements being the same as the original mean. This requires a mathematical approach to identify valid pairs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find pairs of positions [i, j] where removing elements results in the same mean\n- Ensure the solution is optimized for large inputs\n- Provide clear and concise output\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of indices to check if removing the elements at these positions results in the mean of the remaining elements being the same as the original mean. We will use a mathematical approach to avoid unnecessary computations and ensure the solution is optimized for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers; calculated by dividing the sum of the numbers by the count of the numbers.\n    'pairwise removal': removing two elements from the array to check if the mean of the remaining elements is still the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices where removing the elements at these positions will not change the mean of the array.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs of positions that maintain the mean, not the largest individual element.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at positions i and j.\n    4. Check if the mean of these remaining elements is still equal to the original mean.\n    5. Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 6\n    Explanation: In this case, all elements are the same, and removing any two elements will not change the mean. There are 6 possible pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).\n    search([2, 2, 4, 4]) = 6\n    Explanation: Here, the mean is 3. Removing two elements that are not the mean value will change the mean. The valid pairs are (0,2), (0,3), (1,2), (1,3), (2,3).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such cases, we can immediately return the number of pairs without iterating through them.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n    This formula calculates the number of ways to choose 2 elements from n, which is the number of valid pairs when all elements are identical.\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves a mathematical approach to find pairs that, when removed, do not alter the mean of the remaining elements. The solution must be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find pairs [i, j] such that deleting them keeps the mean unchanged\n- Ensure the solution is optimized for large inputs\n- Provide clear and accurate output for each test case\n- Offer a user-friendly interface for easy interaction\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of elements to check if their removal would keep the mean unchanged. We will use a mathematical approach to avoid unnecessary computations and ensure the solution is optimized for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers\n    Explanation: The mean (average) of an array is calculated by dividing the sum of all elements by the number of elements in the array. Monocarp wants to delete two elements from the array such that the mean of the remaining elements is still the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of elements whose removal does not change the mean\n\n# [degree adverb] \n    'exactly': means that we need to find pairs of elements that, when removed, result in the mean of the remaining elements being equal to the original mean\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. Check if removing these two elements results in the mean of the remaining elements being equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, no matter which two elements are removed, the mean of the remaining elements will change. Therefore, the expected output is 0.\n    search([1, 1, 1, 1, 1]) = 10\n    Explanation: Since all elements are the same, removing any two elements will keep the mean unchanged. There are 10 possible pairs to remove (4 choose 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs can be directly applied without modification for cases where all elements are the same.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\nPlease note that the edge cases provided in the example are hypothetical and may not directly apply to the problem statement as given. The actual implementation should consider the specific constraints and requirements of the problem.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This requires a mathematical approach to find valid pairs. The input consists of multiple test cases, and the output should be the number of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find pairs [i, j] such that deleting elements at these positions keeps the mean unchanged\n- Ensure the solution is scalable to handle large inputs efficiently\n- Implement error handling for invalid inputs\n- Provide a user-friendly interface for easy interaction\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the mean of the array and then iterating through pairs of indices to check if deleting the elements at these positions keeps the mean unchanged. We will use a mathematical approach to ensure that the solution is both efficient and accurate.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the elements at the positions i and j is greater than the original sum of all elements.\n    'at least as many times': means that the frequency of the elements at positions i and j should be such that their deletion does not change the mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integers in the array.\n    'greatest': means that we need to find the greatest mean value.\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 6\n    explanation: The original mean is (1+2+3+4+5)/5 = 3. We need to find pairs [i, j] such that deleting the elements at these positions keeps the mean unchanged. For example, deleting elements at positions 2 and 4 (3 and 5) keeps the mean as 3. There are 6 such pairs: [0,1], [0,2], [0,3], [0,4], [1,2], [1,3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can iterate through all pairs of indices and check if their deletion keeps the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only one possible pair that keeps the mean unchanged. This requires checking all pairs and ensuring that their deletion does not change the mean.\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves understanding the mathematical properties of means and pairs. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find all pairs [i, j] where i < j\n- Ensure the function checks if deleting the elements at positions i and j keeps the mean unchanged\n- Optimize the solution for large inputs\n- Provide clear and accurate output for each test case\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair calculations. We will focus on optimizing the solution for large inputs by avoiding unnecessary computations and leveraging Python's efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, Monocarp wants to delete two elements from the array such that the mean of the remaining elements is still the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not explicitly mentioned in the requirement, but it can be inferred from the need to find pairs of elements that, when removed, keep the mean unchanged.\n\n# [degree adverb] \n    'largest': This phrase is not explicitly mentioned in the requirement, but it can be inferred from the need to find the largest possible pairs that, when removed, keep the mean unchanged.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. Check if removing these two elements keeps the mean unchanged.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 4, a = [8, 8, 8, 8]\n    Explanation: Since all elements are equal, any pair of elements can be removed, and the mean will remain the same. There are 6 possible pairs: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3].\n    Expected output: 6\n\n    Edge case 2:\n    Input: n = 3, a = [50, 20, 10]\n    Explanation: The mean of the array is (50 + 20 + 10) / 3 = 26.67. There is no way to remove two elements and keep the mean unchanged.\n    Expected output: 0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle all cases, including the edge cases.\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements whose deletion does not change the mean. This involves a two-step process: first, calculate the mean of the array, and then iterate through all possible pairs to check if their deletion maintains the mean. The challenge lies in optimizing this process to handle large inputs efficiently.\nrequirement pool:\n- Calculate the mean of the array\n- Find pairs of positions to delete\n- Optimize the process for large inputs\n- Ensure code readability and maintainability\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the mean of the array and then find pairs of elements whose deletion does not change the mean. We will use a mathematical approach to avoid unnecessary computations. The algorithm will involve calculating the mean, iterating through all possible pairs, and checking if their deletion maintains the mean. We will optimize the process for large inputs by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements\n    'pairs of positions': combinations of two different positions in an array\n\n# [phrase showing quantity relationship]\n    'exactly two elements': we need to remove two elements from the array\n    'remaining elements': after removing two elements, the number of elements in the array\n\n# [degree adverb] \n    'equal to': the mean of the remaining elements should match the mean of the original array\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    explanation: The mean of the array is (1+2+3)/3 = 2. Removing any two elements will change the mean.\n    n = 4, a = [1, 2, 3, 6]\n    explanation: The mean of the array is (1+2+3+6)/4 = 3. Removing elements at positions 1 and 3 (values 2 and 3) will leave a mean of 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where removing any two elements changes the mean.\n        if n == 3:\n            return 0\n        (other code)\n\nPlease provide the coding plan and requirement for the next prompt, and I will continue with the analysis.\n"], "scores": [], "pass_results": [true, true, false, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 238, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 159}
