{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let k be defined as the mathematical mean of these components; this term signifies the average value of the elements. The average value of a group of numbers is referred to as the mean. It is important to note that it's possible that k is not an integer.\n\nThe mathematical mean of an array of n elements is obtained by taking the total sum of the components and dividing it by the count of the components (i.e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematical mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematical mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematical mean of n elements of the original array a). Consider cases where no pair exists as well, and ensure your solution efficiently handles large inputs. Pay close attention to edge cases and handle scenarios where the array cannot be modified to meet the condition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let k be defined as the mathematical mean of these components; this term signifies the average value of the elements. The average value of a group of numbers is referred to as the mean. It is important to note that it's possible that k is not an integer.\n\nThe mathematical mean of an array of n elements is obtained by taking the total sum of the components and dividing it by the count of the components (i.e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematical mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematical mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematical mean of n elements of the original array a). Consider cases where no pair exists as well, and ensure your solution efficiently handles large inputs. Pay close attention to edge cases and handle scenarios where the array cannot be modified to meet the condition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " \nMonocarp has an array a consisting of n integers. The average value of these components is called the mathematical mean, which is calculated by dividing the sum of the components by the count of the components (i.e., sum divided by n).\n\nMonocarp wants to remove exactly two elements from the array a such that the average value of the remaining (n - 2) elements is still equal to the mathematical mean of the original array.\n\nYour task is to find the number of pairs of positions [i, j] (where i < j) in the array such that if the elements at these\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the average of these components. The task is to find the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. The solution should handle large inputs efficiently and consider cases where no such pairs exist or the array cannot be modified.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining (n - 2) elements is still equal to the mean of the original array.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers representing the array.\n\n    Returns:\n        int: The number of pairs that meet the condition.\n    \"\"\"\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    mean = total_sum / n\n\n    # Initialize the result counter\n    result = 0\n\n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing the pair (i, j)\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n\n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_sum / remaining_count == mean:\n                result += 1\n\n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result for the current test case\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean:\n                count += 1\n    \n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_maintain_mean(n, arr)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr):\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Create a dictionary to count the occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of the remaining elements is still equal to the original mean\n            if remaining_sum / remaining_count == mean:\n                # Check if the remaining elements are the same as the original mean\n                if remaining_sum % remaining_count == 0:\n                    remaining_mean = remaining_sum // remaining_count\n                    # Check if the remaining elements can form pairs with the same mean\n                    if remaining_mean in element_count:\n                        count += element_count[remaining_mean]\n    \n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    # Read the array elements\n    arr = list(map(int, input().strip().split()))\n    # Calculate and print the result\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_pairs_to_remove(n, arr, mean_value):\n    \"\"\"\n    This function calculates the number of pairs of positions [i, j] (where i < j) in the array\n    such that if the elements at these positions are deleted, the average value of the remaining\n    (n - 2) elements is still equal to the mathematical mean of the original array.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers representing the array.\n        mean_value (float): The mathematical mean of the original array.\n\n    Returns:\n        int: The number of pairs of positions [i, j] that can be removed to maintain the same average.\n    \"\"\"\n    count = 0\n    total_sum = sum(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean value\n            new_mean_value = new_sum / (n - 2)\n            # Check if the new mean value is exactly the same as the original mean value\n            if new_mean_value == mean_value:\n                count += 1\n    return count\n\n# Read input from stdin\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean_value = sum(arr) / n\n    result = find_pairs_to_remove(n, arr, mean_value)\n    results.append(result)\n\n# Print results to stdout\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n, arr, mean_value):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the elements at indices i and j\n            new_sum = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Check if the new sum divided by the new length equals the mean value\n            if sum(new_sum) / (n - 2) == mean_value:\n                count += 1\n    return count\n\n# Read input\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean_value = sum(arr) / n\n    result = find_pairs_to_remove(n, arr, mean_value)\n    results.append(result)\n\n# Output results\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(arr, mean_value) -> int:\n    n = len(arr)\n    count = 0\n    \n    # Calculate the sum of the array\n    total_sum = sum(arr)\n    \n    # Iterate through all possible pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new count after removing the elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            \n            # Check if the new average is equal to the original mean\n            if new_sum / new_count == mean_value:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Call the function and print the result\n    result = find_pairs_to_remove(arr, mean_value)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], mean: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    # Check all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Calculate the mean of the new array\n            new_mean = sum(new_arr) / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate the mean of the array\n    mean = sum(arr) / n\n    # Find and print the number of pairs\n    result = find_pairs(arr, mean)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], n: int) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    \n    # Count the frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Check pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == mean:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(arr, n)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], mean: float) -> int:\n    n = len(arr)\n    if n < 3:\n        return 0\n    if len(set(arr)) == 1:\n        return 0\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr and sum(new_arr) / len(new_arr) == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nmean = sum(arr) / n\nresult = find_pairs(arr, mean)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_of_positions(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            current_sum = total_sum - arr[i] - arr[j]\n            if current_sum / (n - 2) == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = calculate_pairs_of_positions(n, arr)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must be efficient to handle large inputs and must correctly handle edge cases where no pairs exist or the array cannot be modified to meet the condition.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs.\n- Handle large inputs efficiently without crashing.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear and accurate output for each test case.\n- Optimize the solution for speed and accuracy.\nTo efficiently solve this problem, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the remaining elements having the same mean. We will use a nested loop to iterate through all pairs and a set to quickly check if the mean of the remaining elements matches the original mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean' (average): the sum of all elements divided by the number of elements.\n    Explanation: The mean (average) of an array is calculated by summing all its elements and then dividing by the number of elements. Monocarp wants to delete two elements from the array such that the mean of the remaining elements remains the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n    'at least as many times': implies that the number of times an element appears should be considered in the calculation.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that meet the condition.\n    'smallest': implies that we need to consider the smallest possible pairs that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the pair.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with all elements equal to the mean.\n    Expected output: 0\n    Explanation: If all elements are equal to the mean, removing any two elements will change the mean.\n\n    Edge case 2: Array with no elements that can be removed to maintain the mean.\n    Expected output: 0\n    Explanation: If no pair of elements can be removed without changing the mean, the result should be 0.\n\n    Edge case 3: Large array with a single unique element.\n    Expected output: 0\n    Explanation: If the array has only one unique element, removing any two elements will change the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array cannot be modified to meet the condition.\n    For example, if all elements are the same and equal to the mean, we should return 0 immediately.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must be efficient to handle large inputs and must correctly handle edge cases where no pairs exist or the array cannot be modified to meet the condition.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] that can be deleted to maintain the mean.\n- Ensure the solution is optimized for large inputs and handles edge cases.\n- Add support for multiple test cases.\n- Improve user interface for better user experience.\nTo efficiently solve this problem, we will use Python's built-in libraries and data structures. The main approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if deleting the elements at these positions maintains the mean. We will optimize this by avoiding unnecessary calculations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean' (or 'average'): the sum of all elements divided by the number of elements.\n    Explanation: The mean is a fundamental statistical concept that represents the central tendency of a set of numbers. In this problem, we need to ensure that after removing two elements, the mean of the remaining elements remains the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the mean.\n    'at least as many times': implies that the number of pairs should be counted where the removal does not alter the mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible number of such pairs.\n    Explanation: This degree adverb indicates that we should aim to maximize the number of pairs removed while maintaining the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at these positions maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 1, 1]\n    expected output: 0\n    Explanation: With only three elements, removing any two elements will change the mean. Therefore, the expected output is 0.\n\n    Edge case 2: n = 4, array = [2, 2, 4, 4]\n    expected output: 2\n    Explanation: The mean of the array is 3. Removing the pairs (0, 2) and (1, 3) will keep the mean unchanged.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    expected output: 1\n    Explanation: The mean of the array is 3. Removing the pair (0, 1) will keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array cannot be modified to meet the condition.\n    For example, if the array has all elements equal, no pairs can be removed to maintain the mean.\n\n    def count_pairs(n, arr):\n        mean = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must handle large inputs efficiently and accurately. Edge cases to consider include arrays where no pairs can maintain the mean, and arrays with all elements being the same.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs that can be deleted to maintain the mean.\n- The solution should handle large inputs efficiently.\n- The solution should accurately calculate the number of pairs that can be deleted to maintain the mean.\n- The solution should handle edge cases where no pairs can maintain the mean.\n- The solution should be optimized for performance and accuracy.\nTo efficiently calculate the number of pairs [i, j] such that deleting the elements at these positions maintains the mean of the array, we will use Python's built-in functions and libraries. The approach involves calculating the mean of the array, then iterating through all possible pairs to check if their deletion maintains the mean. We will use a brute-force method initially to ensure correctness, and later optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean' (average): the sum of all elements divided by the number of elements.\n    Explanation: The mean (average) of an array is calculated by summing all its elements and then dividing by the number of elements. Monocarp wants to delete two elements from the array such that the mean of the remaining elements remains the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose deletion does not change the mean.\n    'at least as many times': implies that the number of times an element appears should be considered in relation to its value.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that maintain the mean.\n    'smallest': implies that we need to consider the smallest possible pairs that maintain the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. Check if deleting the elements at positions i and j maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3]\n    Expected output: 0\n    Explanation: The mean of the array is (1+2+3)/3 = 2. There are no pairs of elements that can be deleted to maintain the mean of 2.\n\n    Edge case 2: [4, 4, 4, 4]\n    Expected output: 6\n    Explanation: The mean of the array is (4+4+4+4)/4 = 4. There are 6 pairs that can be deleted to maintain the mean of 4: (0,1), (0,2), (0,3), (1,2), (1,3), and (2,3).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where no pairs exist to maintain the mean.\n        if n < 3:\n            return 0  # If there are fewer than 3 elements, no pairs can be deleted.\n        (other code)\n\n    This additional code ensures that we do not attempt to find pairs in cases where it is not possible.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of elements that, when removed, maintain the same average. This involves understanding the mathematical properties of averages and efficiently iterating through pairs of elements in the array.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of elements that, when removed, do not change the average.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the solution is user-friendly and provides clear output for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the average of the array and then find pairs of elements that, when removed, maintain the same average. We will iterate through the array to find all possible pairs and check if their removal does not change the average. To optimize the solution for large inputs, we will use efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of elements divided by the number of elements\n    'pair removal': removing two specific elements from the array and checking if the average remains the same\n\n# [phrase showing quantity relationship]\n    'more than': used to specify the condition that the removed elements should not change the average\n\n# [degree adverb] \n    'exactly': emphasizes the requirement that the average should remain unchanged after removal\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, removing any two will change the average, so the result is 0.\n\n    Edge case 2: n = 4, array = [4, 4, 4, 4]\n    Expected output: 6\n    Explanation: All elements are the same, so removing any two elements will keep the average the same. There are 6 possible pairs: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4].\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    Expected output: 3\n    Explanation: The average of the array is (1+2+3+4+5)/5 = 3. Removing the elements at positions 1 and 3 (with values 2 and 3) or positions 2 and 4 (with values 3 and 4) will keep the average the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find pairs can be directly applied to these cases.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions to remove from an array such that the average remains unchanged. This requires understanding the mathematical mean and how removing elements affects it. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mathematical mean of the array.\n- Create a function to find pairs of positions to remove such that the average remains unchanged.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the solution provides clear and accurate results for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs of positions to remove such that the average of the remaining elements remains unchanged. We will first calculate the mean of the entire array and then iterate through all possible pairs of positions to check if removing them results in the mean of the remaining elements being equal to the original mean. We will optimize the solution by avoiding unnecessary calculations and ensuring it handles large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average value' (mathematical mean), 'sum', 'count'\n    The average value of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of elements to remove such that the average of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the average.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that meet the condition.\n\n# [code logic]\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements and check if the average of these remaining elements is equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: There are no pairs of elements that can be removed to keep the average unchanged since removing any two elements will change the average.\n    search([2, 2, 4, 4]) = 3\n    explanation: Possible pairs to remove are [0, 1], [0, 2], and [1, 2] to keep the average unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where no pairs can be found. This can be done by checking if no pairs meet the condition and returning 0 in such cases.\n\n    def search(lst):\n        mean = sum(lst) / len(lst)\n        count = 0\n        for i in range(len(lst)):\n            for j in range(i+1, len(lst)):\n                if (sum(lst[:i] + lst[i+1:j] + lst[j+1:]) / (len(lst) - 2)) == mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions to remove from the array such that the average remains unchanged. This involves summing the elements, calculating the mean, and then finding pairs that, when removed, keep the mean the same. The constraints are large inputs, so optimization is crucial.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Find pairs of positions to remove such that the mean remains unchanged.\n- Optimize the solution for large inputs.\n- Ensure the solution is user-friendly and handles edge cases.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find pairs of positions that, when removed, keep the average of the remaining elements unchanged. We will calculate the mean of the array and then iterate through all possible pairs to check if removing them keeps the mean the same. Given the constraints, we need to ensure our solution is optimized for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average value' (mathematical mean), 'sum', 'count'\n    The average value of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of elements that, when removed, do not change the average of the remaining elements.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the new sum and new count after removing the elements at positions i and j.\n    4. Check if the new average is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, array = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, removing any two elements will change the average. Therefore, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, array = [4, 4, 4, 4]\n    Explanation: The mean of the array is 4. Removing any two elements from [4, 4, 4, 4] will still result in an average of 4. There are 6 possible pairs: [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4].\n    Edge case 3:\n    Input: n = 5, array = [1, 2, 3, 4, 5]\n    Explanation: The mean of the array is 3. Removing the pair [2, 3] will result in a new average of 3, which is the same as the original mean. There are 2 such pairs: [1, 4] and [1, 5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can be used to solve all test cases.\n", "requirement analysis:\nThe primary requirement is to find the number of pairs [i, j] where deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. The solution must handle large inputs efficiently and consider cases where no such pairs exist or the array cannot be modified. The input consists of multiple test cases, and each test case must be processed separately.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] where deleting elements at these positions keeps the mean unchanged.\n- Ensure the solution can handle large inputs efficiently.\n- Implement error handling for cases where no such pairs exist or the array cannot be modified.\n- Optimize the code for performance and memory usage.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array for each test case, then iterating through pairs of indices to check if deleting the elements at these positions keeps the mean of the remaining elements unchanged. We will use a nested loop to check all possible pairs and ensure the solution is optimized for performance and memory usage.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the arithmetic mean, which is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find pairs where deleting the elements at these positions keeps the mean of the remaining elements unchanged.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest possible pairs that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution efficiently, we need to:\n    1. Calculate the mean of the entire array.\n    2. Use nested loops to iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j keeps the mean of the remaining elements unchanged.\n    4. Count the number of such pairs and return the count.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, array = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, it is impossible to delete any two elements and still have a mean of the remaining elements equal to the original mean. Therefore, the expected output is 0.\n\n    Edge case 2:\n    Input: n = 4, array = [1, 3, 2, 4]\n    Explanation: The mean of the array is (1+3+2+4)/4 = 2.5. The pairs [1, 2] and [2, 3] both result in a mean of 2.5 for the remaining elements. Therefore, the expected output is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array cannot be modified.\n        if n < 3:\n            return 0\n        (other code)\n\n    This additional code ensures that the function does not attempt to find pairs if the array has fewer than 3 elements, as it is impossible to delete any two elements in such cases.\n", "requirement analysis:\nThe primary requirement is to find pairs of indices in an array such that deleting the elements at these indices keeps the mean of the remaining elements unchanged. The solution must be efficient to handle large inputs efficiently. The output should be clear and accurate, providing the number of such pairs or indicating if no such pairs exist.\nrequirement pool:\n- Implement an efficient algorithm to find the required pairs.\n- Handle edge cases where no pairs exist or the array cannot be modified.\n- Ensure the solution is optimized for handling large inputs.\n- Provide clear and accurate output as specified in the requirements.\nTo efficiently solve this problem, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of indices to check if deleting them maintains the mean. We will use a two-pass algorithm to ensure efficiency, even with large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' (mean): The average (mean) of a set of numbers is the sum of the numbers divided by the count of the numbers. In this problem, we need to find pairs of indices whose deletion does not change the mean of the remaining elements.\n    Explanation: The mean (average) of an array is calculated by summing all the elements and dividing by the number of elements. We need to find pairs of indices whose deletion does not affect the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where deleting two elements keeps the mean unchanged.\n    'at least as many times': Indicates that the number of times an element appears should be considered in the context of its value.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that appears at least as many times as itself.\n    'shortest': Indicates that we need to find the shortest path or solution.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of indices (i, j) where i < j.\n    3. Check if deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to delete any two elements and still have a mean of k.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 6]\n    Expected output: 1\n    Explanation: The mean of the array is 3. Deleting the elements at indices 1 and 2 (values 2 and 3) leaves the mean as 3, which is the same as the original mean.\n\n    Edge case 3: n = 5, array = [1, 1, 1, 1, 1]\n    Expected output: 10\n    Explanation: All elements are the same, so deleting any two elements will keep the mean unchanged. There are 10 possible pairs to delete.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3. In this case, we should return 0 because it's impossible to delete two elements and maintain the mean.\n        if n == 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe task requires finding pairs of indices in an array such that deleting the elements at these indices keeps the mean of the remaining elements unchanged. This involves calculating the mean of the entire array and then checking pairs of elements to see if their deletion does not affect the mean. The solution must be efficient to handle large inputs efficiently and consider all edge cases.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices where deletion does not change the mean.\n- Ensure the solution handles large inputs efficiently.\n- Include error handling for cases where no such pairs exist or the array cannot be modified.\n- Provide clear and accurate output as specified in the requirements.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to iterate through all possible pairs of indices in the array and check if their deletion maintains the mean. We will calculate the mean of the entire array and then for each pair, calculate the mean of the remaining elements to check if it equals the original mean. This approach will ensure that we handle large inputs efficiently and consider all edge cases.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average' (mean)\n    In the requirement, it refers to the arithmetic mean of the elements in the array, calculated by summing all elements and dividing by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find pairs where the deletion of elements results in the mean of the remaining elements being equal to the original mean.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest number of pairs that maintain the mean after deletion.\n\n# [code logic]\n    To implement the solution efficiently, we can follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the mean of the remaining elements after deletion.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n    6. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3], t = 1\n    Explanation: The mean of the array is (1+2+3)/3 = 2. There are no pairs that can be deleted to keep the mean unchanged.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [4, 4, 4], t = 1\n    Explanation: The mean of the array is (4+4+4)/3 = 4. Any pair of deletions will change the mean. For example, deleting the first and second elements results in [4], whose mean is 4, but there are no valid pairs.\n    Expected output: 0\n\n    Edge case 3:\n    Input: [1, 3, 2, 4], t = 2\n    Explanation: The mean of the array is (1+3+2+4)/4 = 2.5. The pairs [1, 2] and [2, 3] can be deleted to keep the mean unchanged.\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no valid pairs exist or the array cannot be modified.\n    For example, if the array has only one unique element or the array length is less than 3, we should return 0 immediately.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. The solution must be efficient to handle large inputs and must correctly handle edge cases where no such pairs exist.\nrequirement pool:\n- Implement a solution that calculates the mean of the array and checks pairs of positions to see if deleting them results in the mean remaining unchanged.\n- Ensure the solution can handle large inputs efficiently, even for the upper limit of the problem constraints.\n- Provide clear and accurate output for each test case, indicating whether a pair exists or not.\nTo efficiently solve this problem, we will use Python due to its performance and ease of use. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to the original mean. We will use a nested loop to check each pair of indices. This method ensures that we consider all possible pairs and check their effect on the mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean' (average): the sum of all elements divided by the number of elements.\n    Explanation: The mean of an array is calculated by summing all its elements and then dividing by the number of elements. Monocarp wants to delete two elements to ensure the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the mean.\n    'at least as many times': implies that the number of pairs should be counted where the removal of two elements does not alter the mean.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs, not individual elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at these indices results in the mean of the remaining elements being equal to the original mean.\n    4. Count such pairs and return the count.\n\n# [edge case] \n    Edge case 1: Array with all elements equal to the mean.\n    search([2, 2, 2]) = 1\n    Explanation: The mean is 2. Removing any two elements will change the mean. The only pair is [0, 1] which results in [2], and the mean is still 2.\n\n    Edge case 2: Array with no elements that can be removed to maintain the mean.\n    search([1, 2, 3]) = 0\n    Explanation: The mean is 2. There are no pairs that can be removed to keep the mean as 2.\n\n    Edge case 3: Large array with a single unique element.\n    search([5, 5, 5, 5]) = 6\n    Explanation: The mean is 5. We can remove any two elements from the four, and the mean remains 5. The pairs are [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array cannot be modified to meet the condition.\n    For example, if all elements are the same and equal to the mean, we should return a specific count indicating no pairs can be removed.\n"], "scores": [], "pass_results": [false, false, true, false, true, false, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 384, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 255}
