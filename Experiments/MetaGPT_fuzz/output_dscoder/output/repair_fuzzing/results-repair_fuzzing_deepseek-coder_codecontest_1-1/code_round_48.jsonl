{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to organize their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n. Each title has a length of m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly. Meanwhile, the even-indexed characters will be compared descendingly.\n\nA string a comes before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following is valid:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to organize their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n. Each title has a length of m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly. Meanwhile, the even-indexed characters will be compared descendingly.\n\nA string a comes before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following is valid:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nWrite a main() function and use input() function to read input from stdin", " Andi and Budi were given an assignment to organize their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n. Each title has a length of m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly. Meanwhile, the even-indexed characters will be compared descendingly.\n\nA string a comes before a string b in asc\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nWrite a main() function and use input() function to read input from stdin", " Andi and Budi were given an assignment to organize their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n. Each title has a length of m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly. Meanwhile, the even-indexed characters will be compared descendingly.\n\nA string a comes before a string b in asc\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef custom_sort(books: List[str], n: int, m: int) -> List[int]:\n    # Define the custom key function for sorting\n    def custom_key(book: str) -> tuple:\n        odd_chars = [book[i] for i in range(0, m, 2)]\n        even_chars = [book[i] for i in range(1, m, 2)]\n        return (''.join(sorted(odd_chars)), ''.join(sorted(even_chars, reverse=True)))\n    \n    # Create a list of tuples (custom_key, index)\n    indexed_books = [(custom_key(book), index + 1) for index, book in enumerate(books)]\n    \n    # Sort the list of tuples based on the custom key\n    indexed_books.sort(key=lambda x: (x[0][0], x[0][1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for _, index in indexed_books]\n    \n    return sorted_indices\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function\nresult = custom_sort(books, n, m)\n\n# Output the sorted indices\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\n## main.py\n\ndef custom_sort_key(s: str) -> tuple:\n    \"\"\"\n    Returns a tuple where the first element is the comparison for even indexed characters in descending order,\n    and the second element is the comparison for odd indexed characters in ascending order.\n    \"\"\"\n    even_comparison = tuple(ord(s[i]) for i in range(0, len(s), 2))[::-1]\n    odd_comparison = tuple(ord(s[i]) for i in range(1, len(s), 2))\n    return (even_comparison, odd_comparison)\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Sort books using the custom key\nsorted_indices = sorted(range(n), key=lambda i: custom_sort_key(books[i]))\n\n# Output the sorted indices\nresult = [str(index + 1) for index in sorted_indices]\nprint(' '.join(result))\n", "from typing import List\nfrom typing import List\n\ndef custom_sort(books: List[str], n: int, m: int) -> List[int]:\n    def sort_key(book: str) -> tuple:\n        odd_sorted = ''.join(sorted(book[1::2]))\n        even_sorted = ''.join(sorted(book[0::2], reverse=True))\n        return (odd_sorted, even_sorted)\n    \n    indexed_books = list(zip(books, range(1, n + 1)))\n    indexed_books.sort(key=lambda x: (sort_key(x[0]), x[1]))\n    \n    return [index for _, index in indexed_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function\nresult = custom_sort(books, n, m)\n\n# Output the result\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    def custom_key(book: str) -> tuple:\n        odd_indexed = [book[i] for i in range(0, m, 2)]\n        even_indexed = [book[i] for i in range(1, m, 2)]\n        return (''.join(sorted(odd_indexed)), ''.join(sorted(even_indexed, reverse=True)))\n    \n    indexed_books = [(book, index) for index, book in enumerate(books)]\n    sorted_books = sorted(indexed_books, key=lambda x: custom_key(x[0]))\n    return [index + 1 for book, index in sorted_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nresult = sort_books(n, m, books)\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    def custom_key(title: str) -> List[str]:\n        odd_sorted = sorted([title[i] for i in range(0, m, 2)])\n        even_sorted = sorted([title[i] for i in range(1, m, 2)], reverse=True)\n        return odd_sorted + even_sorted\n\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: custom_key(x[1]))\n    return [index for index, _ in indexed_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Sort books and output indices\nresult = sort_books(n, m, books)\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    def custom_key(book: str) -> List[str]:\n        odd_indexed = ''.join(sorted([book[i] for i in range(0, m, 2)]))\n        even_indexed = ''.join(sorted([book[i] for i in range(1, m, 2)], reverse=True))\n        return odd_indexed + even_indexed\n    \n    sorted_books = sorted(range(1, n + 1), key=lambda x: custom_key(books[x - 1]))\n    return sorted_books\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Sort books and output indices\nresult = sort_books(n, m, books)\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    # Define a custom sorting key function\n    def custom_sort_key(book: str) -> tuple:\n        odd_indexed_chars = [book[i] for i in range(0, m, 2)]\n        even_indexed_chars = [book[i] for i in range(1, m, 2)]\n        return (''.join(sorted(odd_indexed_chars)), ''.join(sorted(even_indexed_chars, reverse=True)))\n    \n    # Create a list of tuples (book, index)\n    books_with_index = [(book, index + 1) for index, book in enumerate(books)]\n    \n    # Sort the list of tuples using the custom key\n    sorted_books = sorted(books_with_index, key=lambda x: custom_sort_key(x[0]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for book, index in sorted_books]\n    \n    return sorted_indices\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nresult = sort_books(n, m, books)\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef custom_sort(n: int, m: int, books: List[str]) -> List[int]:\n    # Create a list of tuples where each tuple contains the original index and the book title\n    indexed_books = [(i + 1, book) for i, book in enumerate(books)]\n    \n    # Sort the list of tuples based on the custom sorting logic\n    sorted_books = sorted(indexed_books, key=lambda x: (\n        ''.join([char for i, char in enumerate(x[1]) if i % 2 == 0]),  # Ascending for even indices\n        ''.join([char for i, char in enumerate(x[1]) if i % 2 != 0])[::-1]  # Descending for odd indices\n    ))\n    \n    # Extract the sorted indices\n    sorted_indices = [book[0] for book in sorted_books]\n    \n    return sorted_indices\n\n# Read input from standard input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function and print the result\nresult = custom_sort(n, m, books)\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef custom_sort(n: int, m: int, books: List[str]) -> List[int]:\n    def custom_key(book: str) -> List[str]:\n        odd_indexed = ''.join(sorted([book[i] for i in range(0, m, 2)]))\n        even_indexed = ''.join(sorted([book[i] for i in range(1, m, 2)], reverse=True))\n        return odd_indexed + even_indexed\n    \n    indexed_books = list(zip(books, range(1, n + 1)))\n    indexed_books.sort(key=lambda x: custom_key(x[0]))\n    return [index for _, index in indexed_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function\nresult = custom_sort(n, m, books)\n\n# Output the sorted indices\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef custom_sort(n: int, m: int, books: List[str]) -> List[int]:\n    def custom_key(book: str) -> List[str]:\n        odd_chars = [book[i] for i in range(0, m, 2)]\n        even_chars = [book[i] for i in range(1, m, 2)]\n        return [''.join(sorted(odd_chars)), ''.join(sorted(even_chars, reverse=True))]\n    \n    sorted_books = sorted(range(n), key=lambda i: custom_key(books[i]))\n    return [index + 1 for index in sorted_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function\nresult = custom_sort(n, m, books)\n\n# Print the sorted indices\nfor index in result:\n    print(index, end=' ')\n"], "plans": ["requirement analysis:\nThe requirements specify a need for a sorting algorithm that can handle custom ordering rules, specifically for odd and even indexed characters. The algorithm should be efficient and able to handle large inputs. The output should be in the form of indices corresponding to the original input order.\nrequirement pool:\n- Implement a custom sorting algorithm that meets the specified asc-desc-ending order criteria.\n- Ensure the algorithm is efficient and can handle large inputs efficiently.\n- Provide clear and concise output in the form of indices.\n- Allow user to input the number of books and the length of each book title.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the unique asc-desc-ending order criteria by differentiating between odd and even indexed characters. We will use the `sorted()` function with a lambda function as the key to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character in the string is compared one by one from left to right.\n    'ascending order': This is a general term for arranging numbers or strings in increasing order.\n    'descending order': This is a general term for arranging numbers or strings in decreasing order.\n    'odd and even positions': These refer to the positions of characters in a string, starting from 1 for the first character.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted()` function with a custom key. The key will be a lambda function that:\n    1. Compares characters at odd positions in ascending order.\n    2. Compares characters at even positions in descending order.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCC\n    Output:\n    1 2 3\n    Explanation:\n    Since all strings are the same length and have unique characters, they will be sorted by their lexicographical order, which is the same as their index in the input.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation:\n    The strings differ at the first position (odd), where 'A' comes before 'B' in ascending order. At the second position (even), 'B' comes after 'A' in descending order.\n\n    Edge case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n    Output:\n    4 3 2 1\n    Explanation:\n    Since each string consists of a single character, the sorting is determined by the order of characters in the alphabet, with 'Z' being the last in ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic should work for all given constraints. The custom key function in the `sorted()` function will naturally handle the sorting based on the specified criteria.\n", "requirement analysis:\nThe requirements specify a unique sorting method that combines both ascending and descending order criteria based on the position of characters in the strings. This requires a custom sorting algorithm that can handle both ascending and descending comparisons based on the position of characters. The input is a list of strings, and the output is a list of indices representing the sorted order of the strings according to the specified criteria.\nrequirement pool:\n- Implement a custom sorting algorithm that can handle the asc-desc-ending criteria.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Provide clear and user-friendly output format.\n- Test and validate the algorithm with various test cases.\nTo implement the custom sorting algorithm that meets the asc-desc-ending criteria, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison logic for both odd and even indexed characters separately, ensuring the strings are compared according to the specified rules.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n    'ascending order': This refers to the order from smallest to largest.\n    'descending order': This refers to the order from largest to smallest.\n    'odd-indexed and even-indexed characters': These refer to the characters in a string that are at positions 1, 3, 5, etc., and 2, 4, 6, etc., respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we can use Python's `sorted` function with a custom key. The key function will compare characters at odd and even positions separately according to the rules provided.\n\n    ```python\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    def custom_sort_key(s):\n        odd_part = ''.join(s[i] for i in range(0, m, 2))\n        even_part = ''.join(s[i] for i in range(1, m, 2))\n        return (odd_part, even_part[::-1])\n\n    sorted_indices = sorted(range(n), key=lambda i: custom_sort_key(books[i]))\n    print(' '.join(str(index + 1) for index in sorted_indices))\n    ```\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCC\n\n    Output:\n    1 2 3\n\n    Explanation:\n    Since all strings are the same length and have the same characters in each position, they are already sorted in asc-desc-ending order by default.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n\n    Output:\n    1 2\n\n    Explanation:\n    In the first position, 'A' comes before 'B' (odd position, ascending order). In the second position, 'B' comes before 'A' (even position, descending order).\n\n    Edge case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n\n    Output:\n    4 3 2 1\n\n    Explanation:\n    Since each character is a single letter and there's only one position, the order is determined solely by the characters themselves in descending order for even positions and ascending order for odd positions.\n\n# [extra code for edge case]\n    No extra code is needed for the given edge cases as the provided logic already handles them. However, if there were more complex rules or additional edge cases, additional code would be required to handle those specific scenarios.\n", "requirement analysis:\nThe requirements specify a custom sorting method that combines both ascending and descending order criteria based on the position of characters in the strings. The sorting should be done in a way that odd-indexed characters are compared ascendingly, while even-indexed characters are compared descendingly. The output should be the indices of the strings after they are sorted according to these rules.\nrequirement pool:\n- Implement a custom sorting algorithm that meets the specified criteria.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Provide clear and user-friendly output with sorted indices.\n- Allow for easy input of book titles and their lengths.\n- Ensure the product is scalable and can handle various input sizes.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities, customizing the key function to handle the specific sorting rules. The key function will be designed to sort odd-indexed characters in ascending order and even-indexed characters in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character in the string is compared one by one from left to right.\n    'ascending order': This means arranging elements from smallest to largest.\n    'descending order': This means arranging elements from largest to smallest.\n    'odd-indexed and even-indexed characters': In a string, characters are indexed starting from 0. Odd-indexed characters are at positions 1, 3, 5, etc., and even-indexed characters are at positions 0, 2, 4, etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted` function with a custom key. The key will be a tuple where the first element is the result of joining the characters at odd positions in ascending order, and the second element is the result of joining the characters at even positions in descending order.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCC\n\n    Output:\n    1 2 3\n\n    Explanation:\n    Since there are no odd or even positions with different characters, the order is determined solely by the lexicographical order of the strings.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n\n    Output:\n    1 2\n\n    Explanation:\n    For the strings \"AB\" and \"BA\":\n    - At position 0 (even index), 'A' comes before 'B' in descending order.\n    - At position 1 (odd index), 'B' comes before 'A' in ascending order.\n    Therefore, \"AB\" comes before \"BA\" in the asc-desc-ending order.\n\n    Edge case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n\n    Output:\n    4 3 2 1\n\n    Explanation:\n    Since there's only one character in each string, the order is determined by the lexicographical order of the characters.\n\n# [extra code for edge case]\n    No extra code is needed for the given edge cases as the provided logic already handles them. However, if there were more complex rules or additional constraints, additional code would be required to handle those specific edge cases.\n", "requirement analysis:\nThe primary requirement is to implement a sorting algorithm that sorts the book titles in an asc-desc-ending order, where odd-indexed characters are compared ascendingly and even-indexed characters are compared descendingly. The solution must be efficient and handle large inputs within reasonable time constraints.\nrequirement pool:\n- Implement a sorting algorithm that supports asc-desc-ending order.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Provide clear and user-friendly output format.\n- Test and optimize the algorithm for performance.\nTo implement the required sorting algorithm, we will use Python's built-in sorting capabilities along with custom key functions for handling the asc-desc-ending order. The key function will be designed to sort odd-indexed characters ascendingly and even-indexed characters descendingly.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': Characters in a string are indexed starting from 0. Odd-indexed characters are at positions 1, 3, 5, etc., while even-indexed characters are at positions 0, 2, 4, etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the sorting algorithm, we will use Python's built-in sorting capabilities along with a custom key function. The key function will sort odd-indexed characters ascendingly and even-indexed characters descendingly.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    AAB\n    BBB\n\n    Output:\n    1 2 3\n\n    Explanation:\n    Since there are no odd or even indexed characters to sort differently, the strings are sorted lexicographically ascendingly by default.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n\n    Output:\n    1 2\n\n    Explanation:\n    The strings are sorted based on the custom key function. For \"AB\", the odd-indexed character 'B' comes before 'A' in ascending order, and the even-indexed character 'A' comes before 'B' in descending order. For \"BA\", the odd-indexed character 'A' comes before 'B' in ascending order, and the even-indexed character 'B' comes before 'A' in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the default sorting behavior in Python should suffice for the given requirements. The custom key function will handle the sorting based on the specified conditions.\n", "requirement analysis:\nThe requirements specify a need for a sorting algorithm that sorts book titles in a specific order, combining aspects of both lexicographical ascending and descending order, with odd-indexed characters sorted ascendingly and even-indexed characters sorted descendingly. The solution must be able to handle large inputs efficiently, ensuring scalability and performance.\nrequirement pool:\n- Implement a sorting algorithm that can handle the specified order of sorting.\n- Ensure the solution is efficient and can handle large inputs.\n- Provide a clear and user-friendly output format.\n- Test and validate the solution against multiple test cases.\nTo implement the sorting algorithm that meets the specific requirements of Andi and Budi, we will use Python's built-in sorting capabilities along with custom key functions to sort the book titles based on the given criteria. The key function will handle the sorting of odd-indexed characters in ascending order and even-indexed characters in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': These refer to the characters in a string that are at positions 1, 3, 5, etc. (odd positions) and 2, 4, 6, etc. (even positions), respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the sorting algorithm, we will use Python's `sorted` function with a custom key. The key will be a function that:\n    1. Sorts odd-indexed characters in ascending order.\n    2. Sorts even-indexed characters in descending order.\n\n    Here's a step-by-step breakdown of the logic:\n    1. Read the input values for n (number of books) and m (length of book titles).\n    2. Read the book titles into a list.\n    3. Define a custom key function for sorting:\n        - For odd-indexed characters, sort them in ascending order.\n        - For even-indexed characters, sort them in descending order.\n    4. Use the `sorted` function with the custom key to sort the book titles based on the criteria.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one book, it doesn't matter how it's sorted. The index 1 is the only index.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: Both titles are two characters long. Since there's no odd or even index distinction, they are sorted lexicographically. \"AB\" comes before \"BA\", so the indices are 1 and 2.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    ABC\n    Output:\n    3 1 2\n    Explanation: The titles are sorted based on the specified criteria. \"CBA\" comes first because its first character (C) is greater than 'B' and 'A', the second character (B) is less than 'C' and 'A', and the third character (A) is less than 'B' and 'C'. \"BAC\" comes next, and \"ABC\" is last.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers the basic and edge cases effectively.\n", "requirement analysis:\nThe requirements specify a need for a sorting algorithm that sorts book titles in a specific order, combining both lexicographical ascending and descending criteria for odd and even indexed characters. The solution must be efficient and capable of handling large inputs, providing clear and user-friendly output.\nrequirement pool:\n- Implement a sorting algorithm that meets the asc-desc-ending criteria.\n- Ensure the solution is scalable and can handle large inputs efficiently.\n- Provide a clear and user-friendly output format.\n- Test the solution with various datasets to ensure it performs well under different conditions.\n- Optimize the code for better performance and readability.\nTo implement the sorting algorithm that meets the asc-desc-ending criteria, we will use Python's built-in sorting capabilities along with custom key functions for handling the specific sorting order for odd and even indexed characters. We will ensure scalability by optimizing the algorithm to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': These refer to the characters in a string that are at positions 0, 2, 4, etc. (even indices) and 1, 3, 5, etc. (odd indices).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the sorting algorithm, we will follow these steps:\n    1. Read the input values for n and m.\n    2. Store the book titles in a list.\n    3. Define a custom key function for sorting:\n        - For odd-indexed characters, sort them in ascending order.\n        - For even-indexed characters, sort them in descending order.\n    4. Use Python's `sorted` function with the custom key to sort the list of book titles based on the defined criteria.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one book, it will be at index 1 after sorting.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: The titles are already in ascending order for odd indices and descending order for even indices, so their original indices are maintained.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    ABC\n    Output:\n    3 1 2\n    Explanation: The sorted order is determined by the custom key function:\n        - For the first character: C > B > A (ascending)\n        - For the second character: B < A < C (descending)\n        - For the third character: A < A < B (ascending)\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the provided logic already covers single and multiple book titles. The custom key function ensures that the sorting is done according to the specified criteria for both odd and even indexed characters.\n", "requirement analysis:\nThe requirements involve sorting book titles in a specific order, which includes comparing odd-indexed characters ascendingly and even-indexed characters descendingly. The system must handle a large number of inputs efficiently, ensuring that it can process up to 10^6 characters without performance issues. The output should be a list of indices corresponding to the sorted book titles.\nrequirement pool:\n- Implement a sorting algorithm that can handle the specified order of comparison for characters.\n- Ensure the system can process up to 10^6 characters efficiently.\n- Provide clear and concise output in the form of indices.\n- Include user-friendly input/output mechanisms.\n- Offer competitive pricing and a balance between features and cost.\nTo implement the sorting algorithm efficiently, we will use Python's built-in sorting capabilities, taking advantage of its performance and ease of use. The algorithm will compare characters at odd and even indices separately, following the specified lexicographical orders.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': The order in which words are listed in a dictionary, where each character is compared in order.\n    'ascending': Increasing order.\n    'descending': Decreasing order.\n    'odd-indexed characters': Characters at positions 1, 3, 5, etc.\n    'even-indexed characters': Characters at positions 2, 4, 6, etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the sorting algorithm, we will follow these steps:\n    1. Read the input values for n and m.\n    2. Store the book titles in a list.\n    3. Define a custom sorting key function that will sort the titles based on the specified rules for odd and even indices.\n    4. Use Python's sorted function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one book, it will be the only item in the sorted list, and its index is 1.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: Both titles have the same characters at odd indices, but 'AB' comes before 'BA' at even indices, so 'AB' is placed first.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    ACB\n    Output:\n    2 3 1\n    Explanation: The titles are sorted based on the specified rules. 'CBA' comes before 'BAC' because 'C' is less than 'B' at the first position, and so on.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic should work for all inputs within the given constraints.\n", "requirement analysis:\nThe requirements involve creating a custom sorting algorithm that combines ascending and descending lexicographical order based on the positions of characters in the strings. The algorithm must be efficient enough to handle large inputs and provide clear and concise output.\nrequirement pool:\n- Implement a custom sorting algorithm that sorts strings in asc-desc-ending order.\n- Ensure the algorithm can handle large datasets efficiently.\n- Provide clear and easy-to-read output of sorted indices.\n- Allow user to input the number of books and the length of each book title.\n- Ensure the program is user-friendly and can handle various inputs.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the asc-desc-ending sorting logic by differentiating between odd and even indices of characters in the strings.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one.\n    'asc-desc-endingly': This means sorting based on the specified order for odd and even indexed characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted` function with a custom key. The key will be a function that rearranges the characters based on their index (odd or even).\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCA\n    Output:\n    1 2 3\n    Explanation:\n    Since there are no mixed indices, the sorting is straightforward lexicographical order.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation:\n    The strings are compared based on the custom sorting rules. 'AB' comes before 'BA' because the first character 'A' comes before 'B' in ascending order, and the second character 'B' comes after 'A' in descending order.\n\n    Edge case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n    Output:\n    1 2 3 4\n    Explanation:\n    Since each character is a single character, the sorting is again straightforward lexicographical order.\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the provided logic already covers single character strings and straightforward lexicographical comparisons.\n", "requirement analysis:\nThe requirements specify a need for a custom sorting algorithm that combines both ascending and descending lexicographical order for odd and even indexed characters respectively. The solution must be able to handle large inputs efficiently, ensuring scalability and performance.\nrequirement pool:\n- Implement a custom sorting algorithm that meets the specified requirements.\n- Ensure the solution can handle large inputs efficiently.\n- Provide a clear and user-friendly output format.\n- Test and validate the solution with various test cases.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting functions along with custom key functions to handle the specific sorting requirements. The key functions will be designed to sort the strings based on odd-indexed characters in ascending order and even-indexed characters in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': These refer to the characters in a string at positions 1, 3, 5, etc., and 2, 4, 6, etc., respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted` function with a custom key. The key will be a function that rearranges the characters based on the specified rules for odd and even indices.\n\n    Here's a step-by-step breakdown of the logic:\n    1. Read the input values for n and m.\n    2. Read the book titles and store them in a list.\n    3. Define a custom key function for sorting:\n        - For odd-indexed characters, sort them in ascending order.\n        - For even-indexed characters, sort them in descending order.\n    4. Use the `sorted` function with the custom key to sort the list of book titles based on the indices.\n    5. Output the sorted indices.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one book, it doesn't matter how it's sorted. The output is the index of the single book.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: Both strings have the same length, and sorting by custom rules would result in the order they appear in the input.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    ACB\n    Output:\n    2 3 1\n    Explanation: The custom sorting rules will sort the strings based on the specified odd and even index character orders.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic in the plan is sufficient to handle all test cases, including the edge cases.\n", "requirement analysis:\nThe requirements specify a need for a custom sorting algorithm that sorts strings based on the specified asc-desc-ending order. The algorithm must be efficient enough to handle large inputs and provide clear output indices. The solution should be simple and easy to understand, ensuring it meets the needs of both Andi and Budi.\nrequirement pool:\n- Implement a custom sorting algorithm that sorts strings based on the asc-desc-ending order.\n- Ensure the algorithm is efficient and can handle large inputs efficiently.\n- Provide clear and concise output in the form of indices.\n- Test and validate the algorithm with various inputs to ensure it meets all requirements.\nTo implement the custom sorting algorithm as described, we will use Python's built-in sorting capabilities, customizing the key function to handle the asc-desc-ending order for both odd and even indexed characters. We will ensure efficiency by using Python's efficient list processing capabilities.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending order': This means arranging elements from smallest to largest.\n    'descending order': This means arranging elements from largest to smallest.\n    'odd-even indexing': This refers to the positions of characters in a string where positions are numbered starting from 1. Odd positions are 1, 3, 5, etc., and even positions are 2, 4, 6, etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted` function with a custom key. This key will handle the sorting logic based on the given conditions for odd and even indexed characters.\n\n    Here's a step-by-step breakdown of the logic:\n    1. Read the input values for n (number of books) and m (length of book titles).\n    2. Store the book titles in a list.\n    3. Define a custom key function for sorting:\n        - For odd-indexed characters, compare the characters based on their alphabetical order.\n        - For even-indexed characters, compare the characters based on their reverse alphabetical order.\n    4. Use the `sorted` function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCC\n    Output:\n    1 2 3\n    Explanation:\n    Since there are no odd or even indexed characters to compare based on the given conditions, the books are sorted lexicographically ascendingly by default.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation:\n    The strings \"AB\" and \"BA\" differ at the first position (odd index) where 'A' comes before 'B' in ascending order. The even index comparison does not apply since both strings have only two characters.\n\n    Edge case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n    Output:\n    1 2 3 4\n    Explanation:\n    Since each book title has only one character, the sorting is based solely on alphabetical order, resulting in the original order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the given conditions do not require any special handling for the provided edge cases. The default sorting behavior suffices.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 48, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "expand_one2two", "parent_index": 48}
