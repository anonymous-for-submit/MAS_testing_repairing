{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is laid out on a plane, and he plans to construct a housing complex there. There are several telephone poles scattered across the city, indicated by a grid of size (n + 1) \u00d7 (m + 1) where a telephone pole is located at (x, y) if a_{x, y} = 1. The project supervisor needs to know the sum of the squares of the Euclidean distances from each point (x, y) to the nearest telephone pole. This distance, S(x, y), is calculated as the square of the Euclidean distance between the points (x\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is represented as a plane with a grid of size (n + 1) \u00d7 (m + 1), and there are telephone poles at points (x, y) where a_{x, y} = 1. Define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). The project supervisor asks for the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help by calculating \u2211_{x=0}^{n} {\u2211\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    # Initialize the sum of distances\n    sum_of_distances = 0\n    \n    # Precompute the minimum distance to a pole for each point\n    min_distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Use BFS to find the minimum distance to a pole for each point\n    from collections import deque\n    \n    def bfs(start_x, start_y):\n        visited = [[False] * (m + 1) for _ in range(n + 1)]\n        queue = deque([(start_x, start_y, 0)])  # (x, y, distance)\n        visited[start_x][start_y] = True\n        \n        while queue:\n            x, y, dist = queue.popleft()\n            if grid[x][y] == 1:\n                min_distance_grid[start_x][start_y] = dist\n                return\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= n and 0 <= ny <= m and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny, dist + 1))\n    \n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                min_distance_grid[x][y] = 0\n            else:\n                bfs(x, y)\n    \n    # Calculate the sum of distances\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_distances += min_distance_grid[x][y] ** 2\n    \n    return sum_of_distances\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate the result\nresult = calculate_sum_of_distances(n, m, grid)\n\n# Output the result\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_sum_of_distances(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the sum of squares of Euclidean distances from each point in a grid to the nearest telephone pole.\n\n    Args:\n        grid (List[List[int]]): A 2D list representing the grid with telephone poles marked as 1.\n\n    Returns:\n        int: The sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole.\n    \"\"\"\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    sum_of_distances = 0\n\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            sum_of_distances += min_distance_squared\n\n    return sum_of_distances\n\n# Read input\nn, m = map(int, input().split())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# Calculate and print the result\nresult = calculate_sum_of_distances(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    def bfs(start_x, start_y):\n        visited = [[False] * (m + 1) for _ in range(n + 1)]\n        queue = deque([(start_x, start_y, 0)])  # (x, y, distance)\n        visited[start_x][start_y] = True\n        min_distance = float('inf')\n        \n        while queue:\n            x, y, dist = queue.popleft()\n            if grid[x][y] == 1:\n                min_distance = dist\n                break\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= n and 0 <= ny <= m and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny, dist + 1))\n        \n        return min_distance ** 2\n    \n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += bfs(i, j)\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\nimport numpy as np\n\ndef calculate_distance_sum(grid: np.ndarray) -> int:\n    n, m = grid.shape\n    distance_sum = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == 1:\n                distance_sum += 0  # Distance to self is 0\n            else:\n                min_distance_squared = float('inf')\n                for x in range(n):\n                    for y in range(m):\n                        if grid[x, y] == 1:\n                            distance_squared = (i - x) ** 2 + (j - y) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                distance_sum += min_distance_squared\n\n    return distance_sum\n\n# Read input\nn, m = map(int, input().split())\ngrid = np.zeros((n + 1, m + 1), dtype=int)\nfor i in range(n + 1):\n    grid[i] = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Function to perform BFS and find the shortest distance to the nearest telephone pole\n    def bfs(start_x, start_y):\n        visited = [[False] * (m + 1) for _ in range(n + 1)]\n        queue = deque([(start_x, start_y, 0)])  # (x, y, distance)\n        visited[start_x][start_y] = True\n        \n        while queue:\n            x, y, dist = queue.popleft()\n            \n            if grid[x][y] == 1:\n                return dist\n            \n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= n and 0 <= ny <= m and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny, dist + 1))\n        \n        return float('inf')\n    \n    # Calculate the sum of squares of Euclidean distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            distance = bfs(i, j)\n            sum_of_squares += distance ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().strip()))\n    grid.append(row)\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\nimport numpy as np\nfrom collections import deque\n\ndef calculate_distance_sum(grid: np.ndarray) -> int:\n    n, m = grid.shape\n    distances = np.full((n, m), np.inf)\n    queue = deque()\n\n    # Initialize the queue with positions of telephone poles\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == 1:\n                distances[i, j] = 0\n                queue.append((i, j))\n\n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Perform BFS to calculate distances\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and distances[nx, ny] > distances[x, y] + 1:\n                distances[nx, ny] = distances[x, y] + 1\n                queue.append((nx, ny))\n\n    # Calculate the sum of squares of Euclidean distances\n    sum_of_squares = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == 0:\n                sum_of_squares += distances[i, j] ** 2\n\n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = np.zeros((n + 1, m + 1), dtype=int)\nfor i in range(n + 1):\n    row = input().split()\n    for j in range(m + 1):\n        grid[i, j] = int(row[j])\n\n# Calculate and print the result\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\nimport heapq\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the sum of squares of Euclidean distances to the nearest telephone pole in a grid.\n\n    Args:\n        grid (List[List[int]]): A 2D list representing the grid, where 1 indicates the presence of a telephone pole and 0 indicates no pole.\n\n    Returns:\n        int: The sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole.\n    \"\"\"\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Function to calculate Euclidean distance between two points\n    def euclidean_distance(x1, y1, x2, y2):\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\n    \n    # Initialize a 2D list to store the minimum distance to the nearest pole for each point\n    dist = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    pq = []\n    \n    # Precompute the distances for each point in the grid using BFS\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                dist[i][j] = 0\n                heapq.heappush(pq, (0, i, j))\n    \n    # Directions for BFS\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # BFS to find the nearest pole for each point\n    while pq:\n        d, x, y = heapq.heappop(pq)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and d + 1 < dist[nx][ny]:\n                dist[nx][ny] = d + 1\n                heapq.heappush(pq, (d + 1, nx, ny))\n    \n    # Calculate the sum of squares of the distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += dist[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input from stdin\nn, m = map(int, sys.stdin.readline().split())\ngrid = [list(map(int, sys.stdin.readline().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Function to calculate Euclidean distance squared\n    def euclidean_distance_squared(x1, y1, x2, y2):\n        return (x2 - x1) ** 2 + (y2 - y1) ** 2\n    \n    # Initialize the sum of squares\n    sum_of_squares = 0\n    \n    # Iterate over each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = sys.maxsize\n            # Find the nearest pole for the current point\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = euclidean_distance_squared(x, y, i, j)\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Add the square of the minimum distance to the sum\n            sum_of_squares += min_distance_squared\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\nimport sys\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    sum_of_squares = 0\n\n    # Precompute the distances using BFS\n    from collections import deque\n\n    def bfs(start):\n        visited = [[False] * (m + 1) for _ in range(n + 1)]\n        queue = deque([(start[0], start[1], 0)])  # (x, y, distance)\n        visited[start[0]][start[1]] = True\n        min_distance = float('inf')\n\n        while queue:\n            x, y, dist = queue.popleft()\n            if grid[x][y] == 1:\n                min_distance = dist\n                break\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= n and 0 <= ny <= m and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny, dist + 1))\n        return min_distance ** 2\n\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 0:\n                distance_squared = bfs((x, y))\n                sum_of_squares += distance_squared\n\n    return sum_of_squares\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\ngrid = [list(map(int, sys.stdin.readline().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_sum_of_s(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    total_sum = 0\n\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                distance_squared = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            min_distance_squared = min(min_distance_squared, distance_squared)\n                distance_squared = min_distance_squared\n            total_sum += distance_squared\n\n    return total_sum\n\n# Read input from stdin\nn, m = map(int, input().split())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\nresult = calculate_sum_of_s(grid)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole. This involves identifying the nearest pole for each point and computing the distance, then summing these distances. The tool should be able to handle grids up to 2000x2000, which requires an efficient algorithm to ensure performance.\nrequirement pool:\n- Implement an algorithm to calculate the nearest pole for each point in the grid.\n- Ensure the tool can handle grids up to 2000x2000.\n- Develop a user-friendly interface for easy input and output.\n- Optimize the performance for large grids to ensure quick results.\n- Provide clear and concise instructions and feedback to the user.\nTo solve this problem, we will use Python, leveraging its efficient handling of large grids and numerical operations. The approach involves creating a 2D grid to represent the positions of telephone poles and then iterating through each point in the grid to calculate the square of the Euclidean distance to the nearest pole. We will use a brute-force method for simplicity, which involves checking the distance to all poles for each point. This method is straightforward and ensures accuracy, even though it may not be the most efficient for very large grids.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the formula sqrt((x2 - x1)^2 + (y2 - y1)^2). In this problem, we are calculating the square of the Euclidean distance, which simplifies the computation by removing the square root.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input to get the size of the grid (n and m) and the grid itself.\n    2. Initialize a 2D list to store the sum of the square distances for each point in the grid.\n    3. Iterate through each point in the grid and calculate the square distance to the nearest pole.\n    4. Sum up all the square distances to get the final result.\n\n# [edge case] \n    Edge case 1: Small grid with one pole\n    Input: \n    1 1\n    1\n    1\n    Output: \n    2\n    Explanation: There is only one point (0,0) and one pole at (0,0). The distance is 0, but since it's the only point, the sum is 0.\n\n    Edge case 2: Large grid with multiple poles\n    Input: \n    3 3\n    101\n    000\n    000\n    Output: \n    18\n    Explanation: The nearest pole for each point in the grid is at (0,0). The sum of distances is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Edge case 3: Grid with poles at the corners\n    Input: \n    1 1\n    1\n    0\n    Output: \n    1\n    Explanation: The nearest pole for each point is at (0,0). The sum of distances is (0 + 1) + (1 + 0) = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the brute-force method is simple and directly handles the edge cases by checking the nearest pole for each point.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances from each point in a grid to the nearest telephone pole. This involves identifying the nearest pole for each point and computing the distance, then summing these distances. The solution should be efficient enough to handle grids up to 2000x2000, which requires optimization in both algorithm and implementation.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop an algorithm to find the nearest telephone pole for each point in the grid.\n- Ensure the solution is optimized for large grids by using efficient data structures and algorithms.\n- Provide a user-friendly interface for easy input and output of grid data.\n- Include features for scalability and performance testing to handle larger grids.\nTo solve this problem, we will use Python, leveraging its efficient handling of large datasets and numerical computations. The approach involves creating a function that calculates the sum of squares of Euclidean distances from each point in a grid to the nearest telephone pole. We will use a grid traversal method to efficiently find the nearest pole for each point. This method will be optimized to handle grids up to 2000x2000 by utilizing efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': This refers to the squared distance between two points, calculated as (x2 - x1)^2 + (y2 - y1)^2.\n\n# [degree adverb] \n    'nearest': This means the smallest Euclidean distance to any telephone pole in the grid.\n\n# [code logic]\n    To calculate the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m, we can use a brute-force approach by iterating through each point in the grid and calculating the distance to the nearest telephone pole. This approach is straightforward but may not be the most efficient for large grids.\n\n    A more efficient approach would involve preprocessing the grid to store the minimum distance to a telephone pole for each point. This can be achieved using dynamic programming or a sweep line algorithm, but given the constraints (0 \u2264 n, m < 2000), a brute-force approach is feasible.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    1\n    1\n    Output:\n    2\n    Explanation: There is only one point (0,0) and one telephone pole at (0,0). The distance is 0, and the square of the distance is 0. There are no other points, so the sum is 0 + 0 = 2.\n\n    Edge case 2:\n    Input:\n    2 2\n    111\n    111\n    111\n    Output:\n    18\n    Explanation: All points have a nearest telephone pole at (0,0). The distance to (0,0) is 0, and the square of the distance is 0. For the other points, the distance is 1, and the square of the distance is 1. The sum is 6 * 0 + 6 * 1 = 6.\n\n    Edge case 3:\n    Input:\n    0 0\n    1\n    Output:\n    0\n    Explanation: There is only one point (0,0) and one telephone pole at (0,0). The distance is 0, and the square of the distance is 0. There are no other points, so the sum is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute-force approach is sufficient to calculate the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances to the nearest telephone pole for each point in the grid. This involves identifying the nearest pole for each point and computing the Euclidean distance squared. The solution should be efficient and handle large grids within the given constraints.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance squared between two points.\n- Develop a method to find the nearest telephone pole for each point in the grid.\n- Ensure the solution is optimized to handle large grids efficiently.\n- Provide clear and concise output for the given input.\n- Test the solution with various grid sizes to ensure scalability.\nTo solve this problem efficiently, we will use Python's built-in libraries and optimize the distance calculation using a Breadth-First Search (BFS) approach. The BFS will help us find the nearest pole by exploring all possible paths from each point to the nearest pole. This method is efficient and suitable for handling large grids.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is calculated using the formula (x2 - x1)^2 + (y2 - y1)^2.\n    'Sum of squares': The sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem efficiently, we will use Python's built-in libraries and optimize the distance calculation using a Breadth-First Search (BFS) approach. The BFS will help us find the nearest pole by exploring all possible paths from each point to the nearest pole. This method is efficient and suitable for handling large grids.\n\n# [edge case] \n    Input:\n    2 2\n    101\n    000\n    000\n\n    Output:\n    18\n\n    Explanation:\n    The nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input:\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n\n    Output:\n    36\n\n    Explanation:\n    The nearest telephone pole for the points (0,0), (1,0), (2,0), (3,0), (4,0), (5,0), (0,1), (1,1), (2,1), (3,1), (4,1), (5,1), (0,2), (1,2), (2,2), (3,2), (4,2), (5,2), (0,3), (1,3), (2,3), (3,3), (4,3), (5,3), (0,4), (1,4), (2,4), (3,4), (4,4), (5,4) are calculated using BFS. The sum of all S(x, y) gives the output.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The BFS approach inherently handles all possible grid sizes and pole positions.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of the squares of the Euclidean distances from each point to the nearest telephone pole. This involves reading a grid, identifying pole positions, and computing distances efficiently. The system should handle grids up to 2000x2000, which requires optimization to avoid performance issues.\nrequirement pool:\n- Implement a function to read the grid and identify pole positions.\n- Develop a function to calculate the Euclidean distance from each point to the nearest pole.\n- Ensure the system can handle grids up to 2000x2000.\n- Optimize the distance calculation for efficiency.\n- Provide a user-friendly interface for input and output.\nTo solve this problem, we will use Python, leveraging its powerful libraries for handling large grids efficiently. We will use the NumPy library to handle the grid data structure and perform numerical operations, which will be essential for calculating Euclidean distances. The approach involves reading the grid, identifying pole positions, and then computing the sum of the squares of the Euclidean distances from each point to the nearest pole. We will optimize the distance calculation using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Read the grid size and the grid itself.\n    2. Identify the positions of all telephone poles.\n    3. For each point in the grid, calculate the Euclidean distance to the nearest telephone pole.\n    4. Sum the squares of these distances.\n\n# [edge case] \n    Edge case 1: Small grid with one pole\n    Input: \n    1 1\n    1\n    1\n    Output: \n    0\n    Explanation: There is only one point and one pole, so the distance is 0.\n\n    Edge case 2: Grid with poles at the corners\n    Input: \n    1 1\n    10\n    01\n    Output: \n    2\n    Explanation: The nearest pole to (0,0) and (1,1) is at (0,1) and (1,0) respectively, so the distances are 1 each, and their squares sum to 2.\n\n    Edge case 3: Large grid with multiple poles\n    Input: \n    3 3\n    1001\n    0000\n    0000\n    0001\n    Output: \n    20\n    Explanation: The nearest pole to each point is calculated, and the sum of their squares is 20.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle all cases by calculating the distance to the nearest pole for each point.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. The solution should be scalable and efficient, capable of handling grids up to 2000x2000 in size. The output should be an integer representing the total sum of these distances.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop a method to find the nearest telephone pole for each point in the grid.\n- Ensure the solution is optimized for large grids.\n- Create a user-friendly interface for input and output.\n- Provide detailed documentation and testing to ensure reliability.\nTo solve this problem, we will use a combination of breadth-first search (BFS) and dynamic programming to efficiently calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. BFS will be used to find the shortest distance to the nearest telephone pole for each point, and dynamic programming will be used to optimize the calculation for large grids.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula: \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n    'Sum of squares': The sum of squares is the sum of the squares of each value in a set of numbers. For example, the sum of squares of the numbers 1, 2, and 3 is 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14.\n\n    Explanation: The task requires calculating the sum of the squares of the Euclidean distances from each point (x, y) in a grid to the nearest telephone pole. This involves finding the shortest distance to a telephone pole for each point and then summing the squares of these distances.\n\n# [phrase showing quantity relationship]\n    'squares of the Euclidean distances': means that we need to calculate the square of the distance between each point and the nearest telephone pole.\n\n# [degree adverb] \n    'nearest': means that we need to find the closest telephone pole to each point.\n\n# [code logic]\n    To implement this, we can use a BFS approach to find the shortest path from each point to the nearest telephone pole. We will initialize a queue with all the positions of the telephone poles and perform a BFS to find the shortest distance to any telephone pole for each point in the grid. We will then square these distances and sum them up.\n\n# [edge case] \n    Edge case 1: Grid with only one row or one column.\n    Input: \n    3\n    1\n    0\n    1\n    Output: 1\n    Explanation: If the grid is a single row or column, the nearest telephone pole is the only one, and the distance is 0.\n\n# [extra code for edge case]\n    We need extra code to handle grids with only one row or one column. In such cases, we can directly calculate the distance to the nearest telephone pole without using BFS.\n\n    Example code for handling edge case:\n    if n == 0 or m == 0:\n        return sum(grid[0]) if n == 0 else sum(row[0] for row in grid)\n    (rest of the code)\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. The solution should be efficient and capable of handling grids up to 2000x2000 in size. The output should be an integer representing the total sum of these distances.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop a method to find the nearest telephone pole for each point in the grid.\n- Create a function to sum the squares of these distances.\n- Optimize the algorithm for large grids to ensure it runs efficiently within reasonable time limits.\n- Design a user-friendly interface for easy input and output of grid data.\nTo solve this problem, we will use Python due to its extensive libraries and ease of use. The main challenge is to efficiently calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. We will leverage the power of NumPy for efficient array operations and a Breadth-First Search (BFS) approach to find the nearest telephone pole for each point.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula: \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n    'Sum of squares of Euclidean distances': This is the sum of the squares of the distances from each point in the grid to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input to get the size of the grid and the positions of the telephone poles.\n    2. Create a grid to store the distances from each point to the nearest telephone pole.\n    3. Use a BFS approach to find the nearest telephone pole for each point in the grid.\n    4. Calculate the sum of the squares of the distances from each point to the nearest telephone pole.\n    5. Output the result.\n\n# [edge case] \n    Edge case 1: Small grid with one telephone pole\n    Input:\n    1 1\n    1\n    1\n    Output:\n    0\n    Explanation: There is only one point, and it is the telephone pole itself. The distance is 0.\n\n    Edge case 2: Large grid with multiple telephone poles\n    Input:\n    1000 1000\n    1s (1000 times)\n    0s (999 times)\n    ...\n    0s (1000 times)\n    Output:\n    A large number, as the grid is large and the BFS will need to cover many points.\n    Explanation: The grid is large, and the BFS will need to explore many points to find the nearest telephone pole.\n\n    Edge case 3: Grid with telephone poles at the corners\n    Input:\n    2 2\n    100\n    000\n    000\n    Output:\n    6\n    Explanation: The nearest telephone pole for each point is at (0, 0). The distances are (0 + 1 + 4) for all points.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach will naturally handle all cases, including the smallest and largest grids.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. The grid size can be up to 2000x2000, and there must be at least one telephone pole in the grid. The solution should be efficient and capable of handling large grids without performance issues.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a loop to iterate through each point in the grid and calculate S(x, y).\n- Ensure the solution is optimized for large grids.\n- Add input validation to handle invalid grid sizes.\n- Include detailed documentation and comments for easier understanding and maintenance.\nTo efficiently calculate the sum of squares of Euclidean distances to the nearest telephone pole in a grid, we will use Python's built-in libraries and optimize the solution using efficient algorithms. The grid size can be up to 2000x2000, and there must be at least one telephone pole in the grid. We will implement a function to calculate the Euclidean distance between two points and create a loop to iterate through each point in the grid to calculate S(x, y). The solution will be optimized for large grids by leveraging efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    'sum of squares of Euclidean distances': The sum of the squares of the distances from each point in the grid to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently calculate the sum of squares of Euclidean distances, we can use dynamic programming to precompute the distances for each point in the grid. This involves creating a 2D array to store the minimum distance to the nearest pole for each point. Then, we iterate through the grid to calculate the sum of squares of these distances.\n\n# [edge case] \n    Edge case 1: Small grid with one pole\n    Input: 1 1\n           1\n    Expected output: 2\n    Explanation: There is only one point (0,0) in the grid, and the nearest pole is at (0,0). The distance is 0, and the square of the distance is 0. The sum of squares of distances is 0 + 0 = 2.\n\n    Edge case 2: Grid with poles at the corners\n    Input: 2 2\n           100\n           000\n           000\n    Expected output: 18\n    Explanation: The nearest pole for each point in the grid is at (0,0). The distances are (0,1,2,1,2,3,2,3,4), and the sum of squares of distances is 18.\n\n    Edge case 3: Large grid with multiple poles\n    Input: 3 3\n           1000\n           0000\n           0000\n           0001\n    Expected output: 40\n    Explanation: The nearest poles for each point in the grid are at (0,0), (3,3), and (3,0). The distances are calculated accordingly, and the sum of squares of distances is 40.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle all cases, including the edge cases mentioned above.\n", "requirement analysis:\nThe requirements specify the need to calculate the sum of squares of Euclidean distances to the nearest telephone pole in a grid. The grid size can be up to 2000x2000, and the input includes the grid itself with telephone poles marked by '1'. The output is the sum of all S(x, y) values for the entire grid.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop a method to find the nearest telephone pole for each point in the grid.\n- Create a function to compute the square of the Euclidean distance.\n- Sum all S(x, y) values for the entire grid.\n- Ensure the solution is optimized for large grids up to 2000x2000.\nTo efficiently calculate the sum of squares of Euclidean distances to the nearest telephone pole in a grid, we will use Python due to its performance and readability. We will employ a two-step approach: first, identify the nearest telephone pole for each point in the grid, and then compute the square of the Euclidean distance for each point. We will optimize the solution for large grids by leveraging efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where d = sqrt((x2 - x1)^2 + (y2 - y1)^2).\n    'sum of squares': The sum of the squares of the distances.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently calculate the sum of squares of Euclidean distances to the nearest telephone pole in a grid, we will use a two-step approach:\n    1. Identify the nearest telephone pole for each point in the grid.\n    2. Compute the square of the Euclidean distance for each point.\n    We will optimize the solution for large grids by leveraging efficient data structures and algorithms.\n\n# [edge case] \n    Edge case 1: Small grid with one pole\n    Input: 1 1\n           1\n    Expected Output: 2\n    Explanation: There is only one point (0,0) and the nearest pole is at (0,0). The distance is sqrt((0-0)^2 + (0-0)^2) = 0, and the square of the distance is 0.\n\n    Edge case 2: Large grid with multiple poles\n    Input: 3 3\n           101\n           000\n           000\n    Expected Output: 30\n    Explanation: The nearest pole for each point is calculated as follows:\n    - (0,0) -> (0,0) -> 0\n    - (1,0) -> (0,0) -> 1\n    - (2,0) -> (0,0) -> 4\n    - (0,1) -> (0,0) -> 1\n    - (1,1) -> (0,0) -> 2\n    - (2,1) -> (0,0) -> 5\n    - (0,2) -> (0,0) -> 4\n    - (1,2) -> (0,0) -> 5\n    - (2,2) -> (0,0) -> 8\n    Sum of squares = 0 + 1 + 4 + 1 + 2 + 5 + 4 + 5 + 8 = 30.\n\n    Edge case 3: Grid with poles only at the corners\n    Input: 2 2\n           100\n           001\n    Expected Output: 8\n    Explanation: The nearest pole for each point is calculated as follows:\n    - (0,0) -> (0,0) -> 0\n    - (1,0) -> (0,0) -> 1\n    - (2,0) -> (0,0) -> 4\n    - (0,1) -> (0,0) -> 1\n    - (1,1) -> (0,1) -> 1\n    - (2,1) -> (0,1) -> 2\n    - (0,2) -> (0,0) -> 4\n    - (1,2) -> (0,1) -> 1\n    - (2,2) -> (0,1) -> 4\n    Sum of squares = 0 + 1 + 4 + 1 + 1 + 2 + 4 + 1 + 4 = 18.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by considering the nearest pole for each point in the grid.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances to the nearest telephone pole in a given grid. The grid size can be up to 2000x2000, and there must be at least one telephone pole in the grid. The solution should be efficient and capable of handling large grids.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop a method to find the nearest telephone pole for each point in the grid.\n- Create a function to compute the sum of squares of these distances.\n- Optimize the algorithm for large grids to ensure it runs efficiently within the given constraints.\n- Design a user-friendly interface for input and output of the grid and result.\nTo solve this problem efficiently, we will use Python's built-in libraries and optimize the calculation using efficient data structures. We will first identify the positions of all telephone poles in the grid. For each point in the grid, we will calculate the Euclidean distance to the nearest pole using a brute-force approach for simplicity, which is efficient enough given the constraints. We will then square these distances and sum them up for the entire grid.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    'sum of squares': The sum of the squares of the distances from each point to the nearest pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No edge cases provided in the plan\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the plan does not specify any edge cases.\n\n# [core concept]\n    'grid': A two-dimensional array of points, where each point can be represented by its coordinates (x, y).\n\n# [phrase showing quantity relationship]\n    'size': Refers to the dimensions of the grid, specifically (n + 1) \u00d7 (m + 1).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No edge cases provided in the plan\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the plan does not specify any edge cases.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of S(x, y) for each point in the grid. S(x, y) is the square of the Euclidean distance to the nearest pole. The solution should be efficient and handle large grids up to 2000x2000. The input includes the grid size and the positions of the poles, and the output is the sum of S(x, y) for all points in the grid.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance to the nearest pole for each point.\n- Optimize the algorithm to handle large grids efficiently.\n- Ensure the output matches the given examples and is accurate.\n- Provide a user-friendly interface for inputting grid size and pole positions.\n- Include error handling for invalid inputs.\nTo solve this problem efficiently, we will use Python's built-in data structures and algorithms. The main challenge is to calculate the Euclidean distance to the nearest pole for each point in the grid, which can be done using a brute-force approach for smaller grids but may need optimization for larger grids. We will use a 2D list to represent the grid and iterate through each point to calculate the distance to the nearest pole.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem efficiently, we will use Python's built-in data structures and algorithms. The main challenge is to calculate the Euclidean distance to the nearest pole for each point in the grid, which can be done using a brute-force approach for smaller grids but may need optimization for larger grids. We will use a 2D list to represent the grid and iterate through each point to calculate the distance to the nearest pole.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    1\n    1\n    Output:\n    2\n    Explanation: There is only one point (0,0) and the nearest pole is at (0,0) itself. So, S(0,0) = 0.\n\n    Edge case 2:\n    Input:\n    2 2\n    000\n    000\n    000\n    Output:\n    0\n    Explanation: There are no poles in the grid. The distance to the nearest pole for any point is considered infinite, which translates to a sum of 0.\n\n    Edge case 3:\n    Input:\n    3 3\n    100\n    000\n    001\n    Output:\n    14\n    Explanation: The nearest pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0,0) and (2,2). The sum of distances for each point is calculated as follows:\n    S(0,0) = 1, S(1,0) = 1, S(2,0) = 1\n    S(0,1) = 1, S(1,1) = 2, S(2,1) = 1\n    S(0,2) = 4, S(1,2) = 1, S(2,2) = 1\n    The total sum is 1+1+1+1+2+1+4+1+1 = 14.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle all cases, including the edge cases mentioned above.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 4, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "condense_two2one", "parent_index": 4}
