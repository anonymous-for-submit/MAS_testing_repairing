{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis enjoys sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a problem involving a sequence composed only of special numbers. We will define a special number as one that can be expressed as the sum of different non-negative powers of n. For instance, with n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, whereas 9 is not. Theofanis needs your help to determine the k-th special number in this sequence, sorted in increasing order\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence consisting of special numbers. A number is special if it can be written as a sum of different non-negative powers of n. Theofanis asks you to help him find the k-th special number in increasing order, considering the number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence generated by summing different non-negative powers of a given base number n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n    \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    MOD = 10**9 + 7\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number for a given base number n modulo 10^9+7.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    if k == 1:\n        return 1  # The first special number is always 1 for any base n.\n    \n    powers = []\n    power = 1\n    while power <= k:\n        powers.append(power)\n        power *= n\n    \n    # Use a set to store the unique sums of powers\n    unique_sums = set()\n    for i in range(len(powers)):\n        for j in range(i, len(powers)):\n            sum_of_powers = powers[i] + powers[j]\n            unique_sums.add(sum_of_powers)\n    \n    # Convert the set to a sorted list\n    unique_sums_list = sorted(unique_sums)\n    \n    # Return the k-th special number, if it exists\n    if k <= len(unique_sums_list):\n        return unique_sums_list[k - 1] % MOD\n    else:\n        return -1  # If k is larger than the number of unique sums, return -1\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    # Initialize a list to store special numbers\n    special_numbers = []\n    \n    # Generate special numbers by summing powers of n\n    power = 0\n    while True:\n        value = n ** power\n        if value > k:\n            break\n        if value not in special_numbers:\n            special_numbers.append(value)\n        power += 1\n    \n    # Sort the list of special numbers\n    special_numbers.sort()\n    \n    # Check if k is within the range of generated special numbers\n    if k > len(special_numbers):\n        return -1\n    \n    # Return the k-th special number\n    return special_numbers[k - 1]\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    special_numbers = set()\n    power = 0\n    \n    while True:\n        value = n ** power\n        if value > k:\n            break\n        for i in range(power + 1):\n            for j in range(i + 1):\n                special_number = value * (n ** j)\n                special_numbers.add(special_number)\n        power += 1\n    \n    special_numbers_list = list(special_numbers)\n    special_numbers_list.sort()\n    \n    if k > len(special_numbers_list):\n        return -1\n    \n    return special_numbers_list[k - 1]\n\n# Interface\ninput_data = sys.stdin.read().splitlines()\nt = int(input_data[0])\nfor i in range(1, t + 1):\n    n, k = map(int, input_data[i].split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport math\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    def generate_special_numbers(base: int, limit: int) -> list:\n        special_numbers = set()\n        power = 0\n        while len(special_numbers) < limit:\n            current_power = base ** power\n            for _ in range(len(special_numbers) + 1):\n                if current_power not in special_numbers:\n                    special_numbers.add(current_power)\n                current_power *= base\n            power += 1\n        return sorted(special_numbers)\n\n    # Generate the sequence of special numbers up to the k-th special number\n    sequence = generate_special_numbers(n, k)\n\n    # Return the k-th special number, or -1 if k is out of range\n    return sequence[k - 1] if k <= len(sequence) else -1\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + pow(n, power, MOD)) % MOD\n        k //= 2\n        power += 1\n    \n    return result\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence generated by powers of n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n    \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in increasing order for a given base n.\n    \n    Args:\n        n (int): The base of the special numbers.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read input for number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number for a given base number n modulo 10^9+7.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    if k == 1:\n        return 1  # The first special number is always 1 for any base n.\n    \n    powers = []\n    power = 1\n    while power <= k:\n        powers.append(power)\n        power *= n\n    \n    # Use a set to store the unique sums of powers\n    unique_sums = set()\n    for i in range(len(powers)):\n        for j in range(i, len(powers)):\n            sum_of_powers = powers[i] + powers[j]\n            unique_sums.add(sum_of_powers)\n    \n    # Convert the set to a sorted list\n    unique_sums_list = sorted(unique_sums)\n    \n    # Return the k-th special number, if it exists\n    if k <= len(unique_sums_list):\n        return unique_sums_list[k - 1] % MOD\n    else:\n        return -1  # If k is larger than the number of unique sums, return -1\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement involves creating a program that can find the k-th special number in a sequence generated by summing different non-negative powers of a given base number n. The program should be able to handle multiple test cases efficiently and output the result modulo 10^9+7. The base number n can be as large as 10^9, and the position k in the sequence can also be as large as 10^9. Therefore, the program must be optimized for performance and memory usage.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large inputs efficiently.\n- Implement a modulo operation to keep the numbers within the specified range.\n- Add support for multiple test cases.\n- Optimize the program for performance and memory usage.\nTo solve the problem of finding the k-th special number in a sequence generated by summing different non-negative powers of a given base number n, we will use a mathematical approach to generate the sequence efficiently. We will leverage the properties of binary representation to generate the sequence, as each special number can be represented as a sum of different non-negative powers of n, which is similar to binary representation but with base n instead of base 2. This approach will allow us to handle large inputs efficiently without generating unnecessary numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': A number that can be written as a sum of different non-negative powers of a base number n.\n    Explanation: In this context, a special number is a number that can be expressed as the sum of distinct non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the numbers we generate are greater than zero.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest special number.\n    Explanation: The requirement asks for the k-th special number in increasing order, so we need to find the largest special number that is less than or equal to the k-th special number.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the k-th special number, we can use the binary representation analogy but with base n. We will generate numbers by summing different non-negative powers of n until we reach the k-th special number.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 5\n    Explanation: In this case, the largest number in the list is 5, which is the 5th special number.\n    search([2, 3, 4, 5, 6]) = -1\n    Explanation: In this case, there is no number in the list that appears as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        for num in lst:\n            if lst.count(num) >= num:\n                return num\n        return -1\n\n# [core concept]\n    'sum of different non-negative powers of n': A number that can be expressed as the sum of distinct non-negative powers of a base number n.\n    Explanation: In this context, a special number is a number that can be expressed as the sum of distinct non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the numbers we generate are greater than zero.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest special number.\n    Explanation: The requirement asks for the k-th special number in increasing order, so we need to find the largest special number that is less than or equal to the k-th special number.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the k-th special number, we can use the binary representation analogy but with base n. We will generate numbers by summing different non-negative powers of n until we reach the k-th special number.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 5\n    Explanation: In this case, the largest number in the list is 5, which is the 5th special number.\n    search([2, 3, 4, 5, 6]) = -1\n    Explanation: In this case, there is no number in the list that appears as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        for num in lst:\n            if lst.count(num) >= num:\n                return num\n        return -1\n", "requirement analysis:\nThe requirement involves finding the k-th special number in a sequence defined by the sum of different non-negative powers of a given base number n. The sequence must be generated efficiently due to the potential size of k. The output should be modulo 10^9+7 to handle large numbers.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large inputs efficiently.\n- Implement the modulo operation to handle large numbers.\n- Provide a user-friendly interface for input and output.\n- Test the application with various inputs to ensure accuracy and robustness.\nTo solve this problem, we will use a mathematical approach to generate the sequence of special numbers. The sequence is defined as the sum of different non-negative powers of a given base number n. Given the constraints, we need to ensure our solution is efficient and can handle large inputs. We will use Python for this implementation, leveraging its built-in capabilities to handle large integers and perform modulo operations efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of a base number n.\n    Explanation: In the context of the problem, a special number is one that can be expressed as the sum of distinct powers of n, where n is a positive integer. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a mathematical approach. We need to find the k-th special number in increasing order for each test case. This involves generating powers of n and summing them up to find special numbers. Since the numbers can be very large, we will take the result modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Read the number of test cases.\n    2. For each test case, read the values of n and k.\n    3. Generate the sequence of special numbers in increasing order.\n    4. Output the k-th special number modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe primary requirement is to determine the k-th special number for a given n. The application should be able to handle multiple test cases efficiently. The user interface should be intuitive and provide clear explanations for the concept of special numbers.\nrequirement pool:\n- Implement a function to calculate special numbers\n- Create a user-friendly interface for input and output\n- Optimize the algorithm for large inputs\n- Include explanations for special numbers\n- Ensure the application is responsive and handles multiple test cases\nTo implement the solution, we will use Python due to its simplicity and efficiency. The main challenge is to efficiently calculate the k-th special number for a given n, especially for large values of k. We will use a mathematical approach to generate the sequence of special numbers and then find the k-th one. The application will be optimized to handle multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as the sum of different non-negative powers of n.\n    Explanation: This means that for a given base number n, a special number can be represented as a sum of distinct powers of n (e.g., n^0, n^1, n^2, etc.).\n\n# [phrase showing quantity relationship]\n    'more than': means that the number must be greater than zero.\n    Explanation: In the context of special numbers, we are only interested in positive integers.\n\n# [degree adverb] \n    'largest': means the highest or greatest in value.\n    Explanation: In the context of special numbers, we are looking for the largest special number that is less than or equal to the k-th special number.\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a mathematical approach. For each power of n starting from 0, we add the result to a set to ensure all numbers are unique. We then sort the set and iterate through it to find the k-th special number.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a mathematical approach. For each power of n starting from 0, we add the result to a set to ensure all numbers are unique. We then sort the set and iterate through it to find the k-th special number.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n", "requirement analysis:\nThe primary requirement is to determine the k-th special number in a sequence defined by the sum of different non-negative powers of n. The output should be in increasing order and modulo 10^9+7. The application must handle multiple test cases efficiently. Clarity in user input and output format is crucial for user experience.\nrequirement pool:\n- Implement a function to calculate special numbers based on user input of n and k.\n- Ensure the application can handle up to 10^4 test cases.\n- Provide the k-th special number in increasing order.\n- Output results modulo 10^9+7.\n- Optimize the algorithm to handle large values of n and k efficiently.\nTo solve the problem of finding the k-th special number in a sequence defined by the sum of different non-negative powers of n, we will use Python due to its simplicity and efficiency. The approach involves generating the sequence of special numbers and then retrieving the k-th element. We will use a brute-force method to generate the sequence up to the maximum possible value for k, ensuring that the sequence is generated correctly and efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as the sum of different non-negative powers of n.\n    Explanation: In this problem, a special number is defined as a number that can be represented as the sum of distinct non-negative powers of a base number n. For example, with n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers greater than a certain value.\n    Explanation: In the context of this problem, \"more than\" is used to specify that we are looking for the k-th special number in a sequence, where k is greater than 1.\n\n# [degree adverb] \n    'increasing order': means that the sequence of special numbers should be sorted in ascending order.\n    Explanation: The degree adverb \"increasing order\" indicates that the sequence of special numbers should be sorted from the smallest to the largest.\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a brute-force approach. We will start with the smallest power of n (0) and incrementally add higher powers of n until we reach the k-th special number. This approach ensures that we generate the sequence correctly and efficiently.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: The sequence contains numbers that appear more than or equal to their value, and the smallest number that meets this condition is 3.\n    search([5, 5, 4, 4, 4]) = -1\n    Explanation: Numbers 5 and 4 appear more than or equal to their value, but 3 does not appear at all, so the function returns -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the list is empty.\n        if not lst:\n            return -1\n        (other code)\n", "requirement analysis:\nThe primary requirement is to determine the k-th special number in a sequence defined by the sum of different non-negative powers of n. The application must handle multiple test cases efficiently, and the results must be output in increasing order modulo 10^9+7. The user interface should be intuitive and user-friendly, allowing for easy input and clear output.\nrequirement pool:\n- Implement a function to calculate the k-th special number efficiently.\n- Ensure the application can handle multiple test cases.\n- Design a user-friendly interface for input and output.\n- Optimize the application for large inputs and ensure performance.\n- Include error handling to manage unexpected inputs.\nTo efficiently determine the k-th special number in a sequence defined by the sum of different non-negative powers of n, we will use a mathematical approach to generate the sequence. Given the constraints of n and k, we will generate the sequence up to the k-th special number and return the k-th element. The sequence generation will be optimized to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as the sum of different non-negative powers of n.\n    Explanation: This means that for a given base number n, a special number can be represented as a sum of distinct powers of n (e.g., n^0, n^1, n^2, etc.).\n\n# [phrase showing quantity relationship]\n    'different non-negative powers': means that each power of n used in the sum must be unique.\n    Explanation: For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, where 4^0 and 4^2 are different powers of 4.\n\n# [degree adverb] \n    'increasing order': means that the sequence of special numbers should be sorted in ascending order.\n    Explanation: This implies that as we generate special numbers, they should be placed in a list and sorted to ensure the sequence is in increasing order.\n\n# [code logic]\n    To generate the k-th special number, we need to consider the sequence of sums of different non-negative powers of n. We can use a set to keep track of the unique sums and then convert this set to a sorted list. The k-th element in this sorted list will be our answer.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [code logic]\n    To generate the k-th special number, we can use a set to keep track of the unique sums of different non-negative powers of n. We start with n^0 and iteratively add n^i (where i is the next power) to the sums, ensuring we only add unique sums. We continue this process until we have generated enough special numbers to reach the k-th one. The k-th special number in the sorted list of unique sums is our answer.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n", "requirement analysis:\nThe requirements involve understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given integer n. The challenge lies in handling large numbers and ensuring the output is given modulo 10^9+7. The application should be able to process multiple test cases efficiently.\nrequirement pool:\n- Implement a function to calculate the k-th special number based on the given n and k.\n- Ensure the function can handle large inputs and perform modulo operations.\n- Develop a user interface for inputting test cases and displaying results.\n- Implement error handling for invalid inputs.\n- Optimize the algorithm to ensure it can process multiple test cases efficiently.\nTo solve the problem of finding the k-th special number based on the given n and k, we will use a mathematical approach that leverages the properties of binary representation. Each special number can be represented as a sum of different non-negative powers of n, which can be mapped to binary numbers where each bit represents whether a particular power of n is included in the sum. This approach allows us to efficiently compute the k-th special number by converting k to its binary form and then summing the corresponding powers of n. Given the constraint of handling large numbers and performing modulo operations, we will use Python's built-in support for large integers and modulo operations to ensure accuracy and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum of different non-negative powers of n': This means that each special number can be represented as a sum of unique powers of n, similar to how binary numbers represent sums of powers of 2.\n    Explanation: In this problem, we are dealing with sequences where each number is a sum of distinct powers of a base number n. This is akin to representing numbers in a base-n positional system, but instead of digits, we use powers of n.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we can use the following approach:\n    1. Convert k to its binary representation.\n    2. For each bit in the binary representation, if the bit is set (i.e., it is 1), add the corresponding power of n to the result.\n    3. Since the numbers can be very large, take the result modulo 10^9+7 at each step to prevent overflow and to meet the problem's output requirements.\n\n# [edge case] \n    test_cases = 1\n    n = 2, k = 3\n    expected_output = 3\n    Explanation: The binary representation of 3 is 11. This means we take the first power of 2 (2^1) and the second power of 2 (2^2), which sums to 2 + 4 = 6. However, since we need the result modulo 10^9+7, we take 6 modulo 10^9+7, which is still 6.\n\n    test_cases = 1\n    n = 3, k = 5\n    expected_output = 13\n    Explanation: The binary representation of 5 is 101. This means we take the first power of 3 (3^1), skip the second power (3^2), and take the third power of 3 (3^3), which sums to 3 + 27 = 30. Taking modulo 10^9+7, we get 30 % 10^9+7 = 13.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the modulo operation is inherently part of the calculation. The given approach already ensures that the result does not exceed 10^9+7, and we only need to consider the binary representation of k to determine which powers of n to sum.\n", "requirement analysis:\nThe requirements involve understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given integer n. The challenge lies in handling large numbers and ensuring the output is given modulo 10^9+7. The application should be able to process multiple test cases efficiently.\nrequirement pool:\n- Implement a function to calculate the k-th special number based on the given n and k.\n- Ensure the function can handle large numbers and apply modulo 10^9+7.\n- Allow the application to process multiple test cases efficiently.\n- Develop a user-friendly interface for easy input and output.\n- Optimize the algorithm to handle large inputs without performance issues.\nTo solve the problem of finding the k-th special number based on the given n and k, we will use a mathematical approach that leverages the properties of binary representation. Each special number can be represented as a sum of different non-negative powers of n, which can be mapped to binary numbers where each bit represents whether a particular power of n is included in the sum. This approach allows us to efficiently compute the k-th special number by converting k to its binary form and mapping each bit to the corresponding power of n. We will also ensure that the results are given modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of a base number (n)\n    'binary representation': a way to represent numbers using only the digits 0 and 1\n\n    Explanation: In this problem, we need to find the k-th special number in a sequence where each number can be expressed as a sum of different non-negative powers of n. This can be approached by considering the binary representation of k, where each bit indicates whether a particular power of n is included in the sum.\n\n# [phrase showing quantity relationship]\n    'modulo': means the remainder after division\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, we need to:\n    1. Read the values of n and k.\n    2. Initialize a variable to store the result.\n    3. Use a loop to iterate through the binary representation of k.\n    4. For each bit in the binary representation, if the bit is set, add the corresponding power of n to the result.\n    5. After processing all bits, take the result modulo 10^9+7.\n    6. Output the result.\n\n# [edge case] \n    n = 2, k = 1\n    expected output: 1\n    Explanation: The binary representation of 1 is '1' (no bits set), so the special number is 2^0 = 1.\n\n    n = 3, k = 2\n    expected output: 2\n    Explanation: The binary representation of 2 is '10' (only the second bit is set), so the special number is 2^1 = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the smallest values of k.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 0, as 0 cannot be represented as a sum of non-negative powers of n. We should add a check to ensure k is not 0 before proceeding with the calculation.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence generated by powers of n. The numbers can be very large, so the solution must handle large inputs efficiently and output the result modulo 10^9+7. The application should be user-friendly and provide clear, accurate results.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large inputs efficiently.\n- Output the result modulo 10^9+7.\n- Develop a user-friendly interface for easy input and output.\n- Test the application thoroughly to ensure accuracy and reliability.\nTo solve the problem of finding the k-th special number in a sequence generated by powers of n, we will use Python due to its efficiency and ease of handling large numbers. The approach involves understanding that each special number can be represented as a sum of different non-negative powers of n, which can be efficiently computed using bit manipulation. We will use the modulo operation to ensure the numbers do not grow too large.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of n.\n    Explanation: In this context, a special number is a result of adding distinct powers of n together. For example, if n = 2, then special numbers could be 1 (2^0), 2 (2^1), 3 (2^0 + 2^1), 4 (2^2), etc.\n\n# [phrase showing quantity relationship]\n    'more than': means that the number must be greater than zero.\n    Explanation: In the context of special numbers, we are only interested in positive integers.\n\n# [degree adverb] \n    'increasing order': means that the numbers should be listed from smallest to largest.\n    Explanation: This is crucial for finding the k-th special number in the sequence.\n\n# [code logic]\n    To find the k-th special number, we can use the binary representation of k. Each bit in the binary representation of k corresponds to a power of n. If a bit is set (i.e., it is 1), we include the corresponding power of n in the sum. We will use a loop to iterate through the bits of k and compute the sum of the corresponding powers of n, taking the result modulo 10^9+7 to prevent overflow.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [edge case] \n    search([5, 5, 4, 4, 4]) = -1\n    Explanation: Number 5 appears two times, number 4 appears three times, but no number appears more than or equal to its value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirement involves understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given base. The user needs to input the base and the position in the sequence to find the k-th special number. The output should be the k-th special number modulo 10^9+7. The application should be efficient and capable of handling a large number of test cases.\nrequirement pool:\n- Implement a function to calculate special numbers.\n- Ensure the application can handle large inputs efficiently.\n- Provide the k-th special number modulo 10^9+7.\n- Create a user-friendly interface for input and output.\n- Test the application with a variety of test cases to ensure robustness.\nTo solve this problem, we will use a mathematical approach to generate the k-th special number based on the given base n. The special numbers can be represented as sums of different non-negative powers of n, which can be efficiently computed using bit manipulation. We will use Python's built-in functions and libraries to handle large numbers and ensure the result is modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of a base n.\n    Explanation: In this problem, a special number is defined as a number that can be expressed as the sum of distinct non-negative powers of a given base n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to generate the k-th special number in increasing order for a given base n. This can be achieved using a mathematical approach where we represent the special numbers as sums of different non-negative powers of n. We will use Python's built-in functions and libraries to handle large numbers and ensure the result is modulo 10^9+7.\n\n# [edge case] \n    For n = 3 and k = 4, the expected output is 9.\n    Explanation: The sequence of special numbers for n = 3 is [1, 3, 4, 9, ...]. The 4th special number in this sequence is 9.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan should be sufficient to generate the k-th special number for any given n and k.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is larger than the number of special numbers that can be generated for a given n. In such cases, we should return a message indicating that the k-th special number exceeds the range.\n", "requirement analysis:\nThe requirement involves finding the k-th special number in a sequence defined by the sum of different non-negative powers of a given base number n. The sequence must be generated efficiently due to the potential size of k. The output should be modulo 10^9+7 to handle large numbers.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large inputs efficiently.\n- Implement the modulo operation to handle large numbers.\n- Provide a user-friendly interface for input and output.\n- Test the application with various inputs to ensure accuracy and robustness.\nTo solve this problem, we will use a mathematical approach to generate the sequence of special numbers. The sequence is defined as the sum of different non-negative powers of a given base number n. Given the constraints, we need to ensure our solution is efficient and can handle large inputs. We will use Python for this implementation, leveraging its built-in capabilities to handle large integers and perform modulo operations efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of a base number n.\n    Explanation: In the context of the problem, a special number is one that can be expressed as the sum of distinct powers of n, where n is a positive integer. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a mathematical approach. We need to find the k-th special number in increasing order for each test case. This involves generating powers of n and summing them up to find special numbers. Since the numbers can be very large, we will take the result modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Read the number of test cases.\n    2. For each test case, read the values of n and k.\n    3. Generate the sequence of special numbers in increasing order.\n    4. Output the k-th special number modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n"], "scores": [], "pass_results": [true, false, true, false, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 152, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "condense_two2one", "parent_index": 9}
