{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematical mean of these elements (note that it's possible that k is not an integer). \n\nTo find the mean of an array of n items, you sum all the items and divide by the count of those items (i.e. sum divided by n).\n\nMonocarp wants to remove exactly two elements from a so that the mathematical mean of the remaining (n - 2) elements still equals k.\n\nYour task is to determine the number of pairs of positions [i, j] (i < j) such that if the elements at these positions are removed, the mean of the (n - 2) leftover elements is k, which is the same as the mean of n elements from the original array a. Consider special cases where the array has fewer than three elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematical mean of these elements (note that it's possible that k is not an integer). \n\nTo find the mean of an array of n items, you sum all the items and divide by the count of those items (i.e. sum divided by n).\n\nMonocarp wants to remove exactly two elements from a so that the mathematical mean of the remaining (n - 2) elements still equals k.\n\nYour task is to determine the number of pairs of positions [i, j] (i < j) such that if the elements at these positions are removed, the mean of the (n - 2) leftover elements is k, which is the same as the mean of n elements from the original array a. Consider special cases where the array has fewer than three elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has acquired an array a consisting of n integers. Let's denote k as the average of these elements. To find the average of an array of n items, you sum all the items and divide by the count of those items (i.e., sum divided by n).\n\nMonocarp wants to remove exactly two elements from a so that the average of the remaining (n - 2) elements is still equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the mean of these elements. He wants to remove two elements from a so that the mean of the remaining (n - 2) elements is still k. Determine the number of pairs [i, j] (i < j) such that removing the elements at these positions keeps the mean of the leftover elements equal to k. Consider cases with fewer than three elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == mean:\n                    count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n, arr):\n    \"\"\"\n    Calculate the number of pairs of indices [i, j] (i < j) such that if the elements at these indices are removed,\n    the mean of the remaining (n - 2) elements is still equal to the mean of the original array.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs of indices [i, j] that can be removed to maintain the mean.\n    \"\"\"\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n\n    # Initialize the count of pairs\n    count = 0\n\n    # Iterate through all possible pairs of indices [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if removing elements at indices i and j maintains the mean\n            if (sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])) / (n - 2) == mean_value:\n                count += 1\n\n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(n, arr):\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Remove the elements at positions i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            \n            # Check if the mean of the remaining elements is still equal to the original mean\n            if sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Call the function and print the result\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nimport sys\nfrom collections import defaultdict\n\ndef find_pairs_to_remove(arr: list, avg: float) -> int:\n    n = len(arr)\n    count = 0\n    total_sum = sum(arr)\n    freq = defaultdict(int)\n    \n    # Count the frequency of each element\n    for num in arr:\n        freq[num] += 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new frequency after removing two elements\n            new_sum = total_sum - arr[i] - arr[j]\n            new_freq = freq.copy()\n            new_freq[arr[i]] -= 1\n            new_freq[arr[j]] -= 1\n            \n            # Check if the new average is equal to the original average\n            if new_sum / (n - 2) == avg:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the average of the array\navg = sum(arr) / n\n\n# Find and print the result\nresult = find_pairs_to_remove(arr, avg)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_average_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the average of the array\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    # Initialize a counter for valid pairs\n    valid_pairs_count = 0\n    \n    # Iterate through all possible pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the pair (i, j)\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new average\n            new_average = new_sum / (n - 2)\n            # Check if the new average is exactly equal to the original average\n            if new_average == average:\n                valid_pairs_count += 1\n    \n    return valid_pairs_count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = calculate_average_pairs(n, arr)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_pairs_to_remove(n: int, arr: list[int]) -> int:\n    total_sum = sum(arr)\n    average = total_sum / n\n    \n    # Dictionary to count occurrences of each difference from the average\n    diff_count = {}\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the sum of the remaining elements after removing the pair (i, j)\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            remaining_average = remaining_sum / remaining_count\n            \n            # Calculate the difference from the average for the remaining elements\n            diff = remaining_average - average\n            diff = round(diff, 9)  # To avoid floating point precision issues\n            \n            # Increment the count of this difference\n            if diff in diff_count:\n                diff_count[diff] += 1\n            else:\n                diff_count[diff] = 1\n    \n    # The number of pairs that can be removed to maintain the average\n    pairs_count = 0\n    \n    # Count pairs that can be removed to maintain the average\n    for count in diff_count.values():\n        if count > 1:\n            pairs_count += count * (count - 1) // 2\n    \n    return pairs_count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nimport sys\n\ndef count_valid_pairs(n, arr):\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Use a hash map to store the counts of the differences\n    diff_count = {}\n    \n    for i in range(n):\n        # Calculate the difference for the current element\n        diff = arr[i] - mean\n        if diff in diff_count:\n            count += diff_count[diff]\n            diff_count[diff] += 1\n        else:\n            diff_count[diff] = 1\n    \n    return count\n\n# Read the number of test cases\nt = int(sys.stdin.readline())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(sys.stdin.readline())\n    # Read the array elements\n    arr = list(map(int, sys.stdin.readline().split()))\n    # Get the result for the current test case\n    result = count_valid_pairs(n, arr)\n    # Print the result\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs_to_remove(n, arr):\n    total_sum = sum(arr)\n    mean_value = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == mean_value:\n                count += 1\n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = calculate_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    mean_value = sum(arr) / n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr: list, mean_value: float) -> int:\n    \"\"\"\n    This function finds the number of pairs of positions [i, j] (i < j) such that if the elements at these positions are removed,\n    the mean of the remaining elements is still equal to the original mean.\n    \n    Args:\n        arr (list): The list of integers.\n        mean_value (float): The mean value of the original array.\n    \n    Returns:\n        int: The number of pairs that maintain the mean after removal.\n    \"\"\"\n    n = len(arr)\n    if n < 3:\n        return 0\n    \n    count = 0\n    \n    # Precompute the sum of all elements\n    total_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            # Check if the mean of the remaining elements is still equal to the original mean\n            if remaining_sum / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read input from standard input\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs(arr, sum(arr) / n)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the mean of the array and then find pairs of positions that, when removed, maintain the same mean. Special attention should be given to handling large inputs efficiently. The solution should be clear and concise, ensuring that it meets the performance criteria set by the user.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a method to find pairs of positions that, when removed, do not change the mean.\n- Ensure the solution is scalable and can handle large inputs efficiently.\n- Test the solution with various edge cases and special scenarios.\n- Optimize the code for better performance and readability.\nTo solve this problem, we will use Python due to its efficiency and ease of use. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing them maintains the mean. We will use a simple and efficient algorithm to ensure scalability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then check if removing any two elements still results in the same mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In the requirement, we need to find pairs of positions [i, j] such that removing the elements at these positions does not change the mean of the remaining elements.\n\n# [degree adverb] \n    'exactly': means that the condition must be met without any deviation.\n    Explanation: We need to find pairs of positions [i, j] such that exactly two elements are removed, and the mean of the remaining elements is still equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, remove the elements at positions i and j and check if the mean of the remaining elements is still equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to remove any two elements and still have the mean of the remaining elements equal to the original mean.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: There is only one pair [0, 1] that can be removed to maintain the mean. Removing elements at positions 0 and 1 (1 and 2) results in a mean of 2.5, which is the same as the original mean of 2.5.\n\n    Edge case 3: n = 5, array = [1, 3, 2, 4, 5]\n    Expected output: 2\n    Explanation: There are two pairs [0, 1] and [1, 2] that can be removed to maintain the mean. Removing elements at positions 0 and 1 (1 and 3) results in a mean of 3, which is the same as the original mean of 3. Similarly, removing elements at positions 1 and 2 (3 and 2) also results in a mean of 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions maintains the mean of the array. The input consists of multiple test cases, and the output should reflect the number of such pairs for each test case. Special cases include arrays with fewer than three elements.\nrequirement pool:\n- Implement the function to calculate the mean of an array.\n- Develop a method to find pairs of positions [i, j] for removal.\n- Ensure the solution handles large inputs efficiently.\n- Add support for handling edge cases, such as arrays with fewer than three elements.\n- Optimize the algorithm for performance and readability.\nTo solve this problem, we will use Python due to its efficiency and ease of use with large datasets. The approach involves calculating the mean of the array and then finding pairs of indices that, when removed, maintain the mean. We will optimize the solution to handle large inputs efficiently by avoiding unnecessary computations and leveraging Python's built-in functions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean of the array.\n    Explanation: We need to find pairs [i, j] such that (sum of array - a[i] - a[j]) / (n - 2) = mean of the array.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs that maintain the mean after removal.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. Check if removing elements at these indices maintains the mean.\n    4. Count such pairs.\n\n# [edge case] \n    Edge case 1: search([1, 2, 3]) = 0\n    Explanation: With only three elements, there are no pairs to remove, so the output is 0.\n    Edge case 2: search([4, 4, 4]) = 3\n    Explanation: All elements are the same, so removing any two elements will maintain the mean. There are three pairs: [0, 1], [0, 2], and [1, 2].\n    Edge case 3: search([1, 3, 2]) = 0\n    Explanation: No pair of elements can be removed to maintain the mean, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided can handle all cases, including those with fewer than three elements.\n", "requirement analysis:\nThe primary requirement is to calculate the mean of the array and then find pairs of positions that, when removed, maintain the same mean. The challenge lies in handling large inputs efficiently. The solution should be optimized to avoid performance bottlenecks, especially with large datasets.\nrequirement pool:\n- Implement the mean calculation and pair position finding algorithm.\n- Optimize the algorithm for large inputs.\n- Ensure the user interface is clean and easy to use.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing them maintains the mean. We will use a brute-force method initially to ensure correctness, and then we can optimize it further if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements in a set.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n    Explanation: For example, if we have a list [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. We need to find pairs [i, j] such that removing a_i and a_j does not change the mean to 2.5.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs that maintain the mean.\n    Explanation: In the context of pairs, 'largest' refers to finding the pairs with the highest values that, when removed, do not change the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we can follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, remove the elements at positions i and j and check if the mean of the remaining elements is still equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    search([1, 2, 3]) = 0\n    Explanation: With only three elements, there are no pairs to remove, so the output is 0.\n    Edge case 2: n = 4, a = [1, 2, 3, 4]\n    search([1, 2, 3, 4]) = 1\n    Explanation: The only pair [0, 3] (0-indexed) removes elements 1 and 4, leaving [2, 3] with a mean of 2.5, which is the same as the original mean.\n    Edge case 3: n = 5, a = [1, 1, 1, 1, 1]\n    search([1, 1, 1, 1, 1]) = 10\n    Explanation: There are 10 possible pairs, and removing any pair will keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n        (other code)\n\n    This extra code ensures that we do not attempt to find pairs for arrays with only three elements, as there are none.\n", "requirement analysis:\nThe primary requirement is to calculate the average of the array and determine the number of pairs of positions that, when removed, maintain the original average. This involves summing the elements, calculating the average, and then finding pairs that, when removed, do not change the average. The constraints are high due to the potential size of the input, requiring efficient algorithms to handle large datasets.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find pairs of positions to remove.\n- Ensure the solution is optimized for large inputs.\n- Include user feedback mechanisms for continuous improvement.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair finding. We will calculate the average of the array in a straightforward manner and then use a nested loop to find all possible pairs of indices to remove. This approach ensures that we can handle large datasets efficiently by leveraging Python's performance in array operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in a set.\n    Explanation: The average (k) of an array is calculated by summing all its elements and dividing by the number of elements (n). Monocarp wants to remove two elements from the array such that the average of the remaining elements is still equal to k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In the requirement, \"more than\" is used to compare the value of an element with its frequency in the array.\n\n# [degree adverb] \n    'largest': indicates the greatest degree or extent of a quality.\n    Explanation: In the requirement, \"largest\" is used to describe the goal of finding the largest integer that appears at least as many times as itself in the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the average (k) of the array.\n    2. Iterate through all possible pairs of indices in the array.\n    3. For each pair, calculate the new average of the remaining elements.\n    4. Count the number of pairs that result in the new average being equal to k.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: With only three elements, removing any two elements will change the average, so the expected output is 0.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The average is (2+2+4+4)/4 = 3. Removing any pair that sums to 6 (e.g., [0, 3] or [1, 2]) will keep the average at 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for calculating the number of pairs can be applied directly to any valid input size.\n\n# [core concept]\n    'sum': the total of all elements in a set.\n    Explanation: The sum of elements in an array is used to calculate the average and to check if removing two elements maintains the same average.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    Explanation: In the requirement, \"more than\" is used to compare the value of an element with its frequency in the array.\n\n# [degree adverb] \n    'largest': indicates the greatest degree or extent of a quality.\n    Explanation: In the requirement, \"largest\" is used to describe the goal of finding the largest integer that appears at least as many times as itself in the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the sum of the array.\n    2. Iterate through all possible pairs of indices in the array.\n    3. For each pair, calculate the new sum of the remaining elements.\n    4. Calculate the new average of the remaining elements.\n    5. Count the number of pairs that result in the new average being equal to the original average.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: With only three elements, removing any two elements will change the average, so the expected output is 0.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The average is (2+2+4+4)/4 = 3. Removing any pair that sums to 6 (e.g., [0, 3] or [1, 2]) will keep the average at 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for calculating the number of pairs can be applied directly to any valid input size.\n", "requirement analysis:\nThe primary requirement is to calculate the average of the array and determine the number of pairs of positions that, when removed, maintain the original average. The constraints include a maximum of 10^4 test cases with a combined maximum of 2 * 10^5 elements. The solution must be efficient to handle large datasets within reasonable time limits.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find pairs of positions to remove for maintaining the average.\n- Ensure the solution is optimized for large datasets.\n- Include user-friendly output for better understanding.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the average of the array and then finding pairs of elements whose removal maintains this average. We will use a brute-force method initially to ensure correctness and then optimize it for better performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in a list.\n    Explanation: The average (k) of an array is calculated by summing all its elements and dividing by the number of elements (n). Monocarp wants to remove two elements from the array such that the average of the remaining elements is still equal to k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the average.\n    Explanation: The phrase \"more than\" is used to specify that the removal of two elements should not affect the average of the remaining elements.\n\n# [degree adverb] \n    'exactly': means that the removal of two elements should result in the average of the remaining elements being exactly equal to k.\n    Explanation: The adverb \"exactly\" implies that the average of the remaining elements after removing two should match the original average k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the average (k) of the array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new average of the remaining elements.\n    4. Count the number of pairs that result in the new average being equal to k.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, removing any two will change the average, so the output is 0.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The average k is (1+2+3+6)/4 = 3. Removing the elements at positions 1 and 3 (0-indexed) leaves [1, 3], which has an average of 2, not equal to k. No other pairs result in the average being k.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    expected output: 2\n    Explanation: The average k is (1+2+3+4+5)/5 = 3. The pairs [0, 3] and [1, 2] both result in the average of the remaining elements being 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 3:\n            return 0\n        # Additional code to handle other edge cases and the main logic\n\n    This code checks for the smallest possible array size and returns 0 if the array cannot maintain the average after removal of two elements. For larger arrays, it continues with the main logic to find the number of valid pairs.\n", "requirement analysis:\nThe primary requirement is to calculate the average of the array and determine the number of pairs of positions that, when removed, maintain the original average. The constraints include handling up to 2 * 10^5 test cases with sums of n not exceeding 2 * 10^5. The solution must be efficient to handle large datasets.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find pairs of positions to remove.\n- Ensure the solution is optimized for large datasets.\n- Provide clear and concise output for each test case.\nTo solve this problem efficiently, we will use Python due to its robust standard library and ability to handle large datasets. The approach involves calculating the average of the array and then finding pairs of elements whose removal does not alter this average. We will use a dictionary to count occurrences of each difference from the average, which simplifies the calculation of pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in a list.\n    Explanation: The average (k) of an array is calculated by summing all its elements and dividing by the number of elements (n). Monocarp wants to remove two elements from the array such that the average of the remaining elements is still equal to k.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the average.\n    Explanation: The phrase \"more than\" is used to specify that we are looking for pairs of elements whose removal does not affect the average of the remaining elements.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs of elements to remove.\n    Explanation: The degree adverb \"largest\" suggests that we should consider the largest elements in the array when looking for pairs to remove, as this might affect the average more significantly.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the average of the array.\n    2. For each pair of elements in the array, check if removing them results in the average of the remaining elements being equal to the original average.\n    3. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3]\n    Expected output: 0\n    Explanation: The average of [1, 2, 3] is 2. Removing any pair of elements will change the average, so there are no valid pairs to remove.\n    Edge case 2: [4, 4, 4, 4]\n    Expected output: 6\n    Explanation: The average of [4, 4, 4, 4] is 4. There are 6 possible pairs to remove: (0,1), (0,2), (0,3), (1,2), (1,3), and (2,3), all of which will keep the average at 4.\n    Edge case 3: [1, 3, 5, 7, 9]\n    Expected output: 10\n    Explanation: The average of [1, 3, 5, 7, 9] is 5. There are 10 possible pairs to remove: (0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), and (3,4), all of which will keep the average at 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle all cases efficiently.\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that removing the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves iterating through the array, calculating the mean, and then counting the valid pairs. The constraints are high, with up to 2 * 10^5 elements, so the solution must be optimized for performance.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to count the number of valid pairs [i, j].\n- Ensure the solution is efficient and can handle large inputs.\n- Optimize the algorithm for time complexity.\n- Ensure the solution is memory efficient.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of indices to count how many pairs can be removed without changing the mean. We will use a brute-force method initially for simplicity, which involves checking each possible pair of indices. Later, we can optimize this by using more advanced techniques like prefix sums or hash maps if the performance is not satisfactory.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices where removing the elements at these positions will not change the mean of the remaining elements.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that appears more than a certain number of times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using a brute-force method to iterate through each pair of indices and check if removing the elements at these positions keeps the mean unchanged. This can be implemented by:\n    1. Calculating the mean of the array.\n    2. Iterating through all possible pairs of indices (i, j) where i < j.\n    3. Checking if removing the elements at positions i and j keeps the mean unchanged.\n    4. Counting the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one pair [0, 1] that can be removed to keep the mean unchanged.\n    search([2, 2, 2, 2]) = 6\n    explanation: There are 6 pairs that can be removed to keep the mean unchanged: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than three elements. In such cases, no pairs can be removed, so the result should be 0.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then determining how many pairs of elements can be removed to maintain the same mean. This involves a straightforward calculation of the mean and then iterating through pairs to check if their removal maintains the mean. The constraints are high, requiring the solution to be efficient and scalable.\nrequirement pool:\n- Calculate the mean of the array\n- Iterate through pairs of elements\n- Check if removing the pair maintains the mean\n- Optimize the calculation of the mean\n- Ensure the solution is efficient for large inputs\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to calculate the mean and then find all pairs of elements whose removal does not change the mean. We will use a brute-force approach to iterate through all possible pairs and check the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array elements is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases.\n    2. For each test case, read the number of elements and the array elements.\n    3. Calculate the mean of the array elements.\n    4. Iterate through all possible pairs of indices (i, j) where i < j.\n    5. For each pair, check if removing the elements at these positions keeps the mean of the remaining elements equal to the mean of the original array.\n    6. Count and return the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    explanation: With only three elements, there are no pairs to remove, so the expected output is 0.\n    search([1, 1, 1]) = 3\n    explanation: All pairs (0, 1), (0, 2), and (1, 2) will result in the mean of the remaining elements being 1, which is the same as the mean of the original array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for finding pairs can be directly applied to the edge case.\n", "requirement analysis:\nThe problem requires calculating the mean of an array and determining the number of pairs of indices that, when removed, maintain the mean of the remaining elements unchanged. This involves understanding the properties of means and efficiently iterating through pairs of indices in the array. The constraints are high, requiring the solution to handle up to 2 * 10^5 elements across multiple test cases, which necessitates an efficient approach.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all pairs of indices and check the mean condition.\n- Optimize the iteration process to handle the upper limit of the constraints.\n- Ensure the solution is clear and easy to understand, with proper documentation.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all pairs of indices to check if removing them maintains the mean. We will optimize the iteration process using mathematical calculations to avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to the element itself.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing more than or equal to itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at these positions keeps the mean of the remaining elements equal to the mean of the original array.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element that appears more than or equal to itself, which is 1. There is only one pair [0, 1] that can be removed to keep the mean unchanged.\n    search([2, 2, 3, 3, 3]) = 4\n    explanation: Both 2 and 3 appear more than or equal to themselves. The pairs [0, 2], [0, 3], [1, 2], and [1, 3] can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases with fewer than three elements by directly checking the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the mean of the array and then find pairs of positions that, when removed, maintain the same mean. The challenge lies in handling large inputs efficiently. Special cases include arrays with fewer than three elements, which should be handled separately.\nrequirement pool:\n- Implement the mean calculation and pair position removal logic.\n- Optimize the algorithm for handling large inputs.\n- Handle edge cases where the array has fewer than three elements.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing them maintains the mean. We will optimize this by avoiding unnecessary calculations and leveraging Python's built-in functions for efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of elements in the array such that after removing them, the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of elements whose removal does not change the mean.\n    'at least as many times': not explicitly mentioned in the requirement, but implied by the need to maintain the mean.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for pairs that maintain the mean, not the largest individual elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. Check if removing each pair maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: search([1, 2, 3])\n    Expected output: 0\n    Explanation: With only three elements, there are no pairs to remove, so the output is 0.\n\n    Edge case 2: search([2, 2, 4, 4])\n    Expected output: 2\n    Explanation: The mean is 3. Removing any pair of elements that are not equal to 3 (e.g., (0, 2) or (1, 3)) will change the mean. The only pairs that maintain the mean are (2, 4) and (4, 4), giving us 2 pairs.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than three elements.\n        if n < 3:\n            return 0\n        (other code)\n\nPlease note that the code logic and edge cases provided here are based on the assumption that the problem statement and plan are correctly interpreted. The actual implementation details may vary based on the specific requirements and constraints of the problem.\n"], "scores": [], "pass_results": [false, true, true, false, true, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 671, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 561}
