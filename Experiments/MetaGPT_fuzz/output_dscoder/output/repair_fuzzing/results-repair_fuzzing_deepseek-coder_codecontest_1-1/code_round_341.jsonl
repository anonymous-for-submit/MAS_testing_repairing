{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis is fascinated by sequences of positive integers, so his teacher, Yeltsa Kcir, assigned him a task involving a sequence composed only of special numbers. A number is considered special if it can be expressed as the sum of different non-negative powers of a given number \\( n \\). For instance, with \\( n = 4 \\), the number 17 is special because it can be written as \\( 4^0 + 4^2 = 1 + 16 = 17 \\), whereas 9 is not. Theofanis needs your help to determine the \\( k \\)-th\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis is interested in sequences of special numbers, which can be written as sums of different non-negative powers of n. Yeltsa Kcir gave him a problem about a sequence consisting only of special numbers. A number is considered special if it can be expressed as a sum of distinct non-negative powers of n. Theofanis needs help finding the k-th special number in increasing order, considering the numbers modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result += power\n            result %= MOD\n        power *= n\n        power %= MOD\n        k //= 2\n    \n    return result\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence generated by powers of n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number for a given base n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    MOD = 10**9 + 7\n    result = 0\n    power = 1\n    \n    # Convert k to binary and process each bit\n    while k > 0:\n        if k & 1:  # Check if the least significant bit is set\n            result = (result + pow(n, power, MOD)) % MOD\n        k >>= 1\n        power += 1\n    \n    return result\n\n# Read input and process each test case\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    return result\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        print(find_kth_special_number(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport math\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1  # The smallest special number is 1 for any n.\n    \n    special_numbers = []\n    i = 0\n    while len(special_numbers) < k:\n        power = n ** i\n        if power not in special_numbers:\n            special_numbers.append(power)\n        i += 1\n    \n    return special_numbers[-1] % (10**9 + 7)\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 0\n    while k > 0:\n        if k % 2 == 1:\n            result += pow(n, power, MOD)\n            result %= MOD\n        k //= 2\n        power += 1\n    return result\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        print(find_kth_special_number(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence defined by the sum of distinct non-negative powers of a given base n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base of the powers.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number in increasing order modulo 10^9+7.\n    \"\"\"\n    MOD = 10**9 + 7\n    special_numbers = set()\n    i = 0\n    while True:\n        power_of_n = n**i\n        if power_of_n > k:\n            break\n        current_sum = power_of_n\n        if current_sum not in special_numbers:\n            special_numbers.add(current_sum)\n        for j in range(len(special_numbers)):\n            new_sum = current_sum + list(special_numbers)[j]\n            if new_sum <= k and new_sum not in special_numbers:\n                special_numbers.add(new_sum)\n        i += 1\n    special_numbers_list = list(special_numbers)\n    special_numbers_list.sort()\n    return special_numbers_list[k - 1] % MOD\n\n# Read input and output results\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k <= 0:\n        return \"Invalid input: k must be a positive integer\"\n    \n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\ndef find_kth_special_number(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % mod\n        power = (power * n) % mod\n        k //= 2\n    return result\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence generated by summing different non-negative powers of a given base number n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n    \n    Returns:\n        int: The k-th special number.\n    \"\"\"\n    # Initialize the sequence with the smallest power of n (n^0)\n    sequence = [1]\n    \n    # Generate the sequence of special numbers\n    current_power = n\n    while current_power <= k:\n        sequence.append(current_power)\n        current_power *= n\n    \n    # If k is greater than the length of the sequence, return -1\n    if k > len(sequence):\n        return -1\n    \n    # Return the k-th special number\n    return sequence[k - 1]\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement involves understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given base. The user needs to find the k-th special number in the sequence, which can be very large. The output should be given modulo 10^9+7 to handle large numbers efficiently. The application should be able to process multiple test cases efficiently.\nrequirement pool:\n- Implement a function to calculate special numbers based on given base and position.\n- Ensure the application can handle large inputs and compute results modulo 10^9+7.\n- Develop a user interface to input the base and position and display the result.\n- Implement error handling for invalid inputs.\n- Optimize the algorithm to handle multiple test cases efficiently.\nTo solve this problem, we will use a mathematical approach to generate the k-th special number based on the given base n. The special numbers can be represented as sums of different non-negative powers of n, which can be efficiently computed using bit manipulation. We will use Python's built-in functions and libraries to handle large numbers and perform modulo operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special numbers': numbers that can be written as a sum of different non-negative powers of a given base n.\n    Explanation: These numbers are generated by summing up distinct powers of n, which can be represented as binary numbers where each bit represents whether a particular power of n is included in the sum.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we need to:\n    1. Understand that each special number can be represented as a sum of different non-negative powers of n, which can be mapped to binary numbers.\n    2. Generate the k-th smallest number in the sequence of special numbers by converting k to its binary representation and mapping each bit to a power of n.\n    3. Since the numbers can be very large, we need to output the result modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [code logic]\n    To find the k-th special number, we need to:\n    1. Understand that each special number can be represented as a sum of different non-negative powers of n, which can be mapped to binary numbers.\n    2. Generate the k-th smallest number in the sequence of special numbers by converting k to its binary representation and mapping each bit to a power of n.\n    3. Since the numbers can be very large, we need to output the result modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirement involves finding the k-th special number in a sequence generated by powers of n. The special number is defined as a sum of different non-negative powers of n. The output should be modulo 10^9+7 to handle large numbers. The solution should be efficient and capable of handling up to 10^4 test cases with n and k values up to 10^9.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large inputs efficiently.\n- Implement modulo 10^9+7 for large number handling.\n- Test the solution with up to 10^4 test cases.\n- Optimize the algorithm for large values of n and k.\nTo efficiently find the k-th special number in a sequence generated by powers of n, we will use a mathematical approach based on the properties of binary numbers. Each special number can be represented as a sum of different non-negative powers of n, which is similar to representing numbers in a binary system where each bit represents a power of n. We will use this insight to generate the sequence and find the k-th special number. To handle large numbers modulo 10^9+7, we will use Python's built-in support for large integers and modulo operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of n.\n    Explanation: In this context, a special number is akin to a number that can be expressed using a sum of distinct powers of a base number n. This is similar to how numbers can be represented in a binary system, where each bit represents a power of 2.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find numbers greater than a certain value.\n    'at least as many times': means that the frequency of a number in the sequence should be at least equal to its value.\n\n# [degree adverb] \n    'largest': indicates that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach similar to binary representation. We will generate the sequence by summing different powers of n and use a loop to find the k-th special number. To handle large numbers modulo 10^9+7, we will use Python's built-in support for large integers and modulo operations.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: In this case, the sequence is [1, 2, 3, 4, 5], and the largest number that appears at least as many times as itself is 3, as it appears once, which is equal to its value.\n    search([1, 1, 2, 2, 3, 3]) = -1\n    Explanation: Here, the sequence is [1, 1, 2, 2, 3, 3], and no number appears more than or equal to its value. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can simply iterate through the list and check for the condition. If no such number is found, we return -1.\n", "requirement analysis:\nThe requirement involves creating a program that can find the k-th special number in a sequence defined by the sum of different non-negative powers of a given base number n. The program should be able to handle multiple test cases efficiently and output the result modulo 10^9+7. The base number n can be as large as 10^9, and the position k in the sequence can also be as large as 10^9. Therefore, the program must be optimized for performance and memory usage.\nrequirement pool:\n- Implement a function to calculate the k-th special number.\n- Ensure the program can handle large inputs efficiently.\n- Implement the modulo operation to prevent overflow.\n- Add support for multiple test cases.\n- Optimize the algorithm for better performance.\nTo solve this problem, we will use a mathematical approach to generate the k-th special number. The sequence of special numbers for a given base n can be generated using the binary representation of the number k. Each bit in the binary representation of k corresponds to a power of n. For example, if n = 4, the binary representation of 5 (which is 101 in binary) corresponds to the special number 4^2 + 4^0 = 16 + 1 = 17. We will use this approach to generate the k-th special number efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special numbers': numbers that can be written as a sum of different non-negative powers of a base number n.\n    Explanation: These numbers are generated using the binary representation of a given number k, where each bit in the binary representation corresponds to a power of n.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the numbers must be greater than zero.\n    Explanation: Since the numbers are positive integers, we need to ensure that the sum of the powers of n results in a positive number.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest special number.\n    Explanation: The requirement asks for the k-th special number in increasing order, but does not specify a need to find the largest one. Therefore, this degree adverb is not applicable in this context.\n\n# [code logic]\n    To generate the k-th special number, we can use the binary representation of k. For each bit in the binary representation of k, if the bit is set, we add the corresponding power of n to the sum. The result is the k-th special number.\n\n# [edge case] \n    k = 1, n = 2 = 1\n    Explanation: When k is 1, the binary representation is also 1, which means we only consider the smallest power of n, which is n^0 = 1.\n    k = 2, n = 3 = 3\n    Explanation: When k is 2, the binary representation is 10, which means we consider n^1 = 3.\n    k = 5, n = 4 = 17\n    Explanation: When k is 5, the binary representation is 101, which means we consider n^2 + n^0 = 16 + 1 = 17.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to generate the k-th special number for any valid input.\n", "requirement analysis:\nThe primary requirement is to determine the k-th special number for a given base n. The special numbers are sums of different non-negative powers of n. The user inputs the number of test cases and the values of n and k for each case. The output should be the k-th special number in increasing order modulo 10^9+7. The system must handle a large number of test cases efficiently.\nrequirement pool:\n- Implement a function to calculate the k-th special number for a given base n.\n- Ensure the system can handle multiple test cases efficiently.\n- Implement input/output handling to read from stdin and write to stdout.\n- Add user interface elements for input and output display.\n- Include a feature to display the sequence of special numbers for a given base n.\nTo solve this problem, we will use a mathematical approach to generate the k-th special number for a given base n. The special numbers are sums of different non-negative powers of n, which can be represented as a geometric series. We will use modular arithmetic to ensure the results are within the required range modulo 10^9+7. The function will be designed to handle multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as the sum of different non-negative powers of a given number n.\n    Explanation: In this context, a special number is derived from the sum of powers of a base number n, where each power is used only once. This concept involves understanding the mathematical properties of exponents and sums.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers greater than zero.\n    'different non-negative powers': means that each power of n is unique and non-negative.\n\n# [degree adverb] \n    'increasing order': means that the special numbers are listed in ascending numerical order.\n\n# [code logic]\n    To generate the k-th special number for a given base n, we can use the following approach:\n    1. Understand that a special number can be represented as a sum of different powers of n.\n    2. Use the formula for the sum of a geometric series to find the k-th special number.\n    3. Apply modular arithmetic to ensure the result is within the range of 10^9+7.\n    4. Handle multiple test cases efficiently by iterating through each case and applying the logic.\n\n# [edge case] \n    search([1, 3, 4, 9, 10]) = 10\n    Explanation: The sequence includes numbers that can be expressed as sums of different powers of n. The number 10 is a special number because it can be written as 1 + 9 = 10.\n    search([1, 3, 4, 9, 10, 13]) = 13\n    Explanation: The sequence includes numbers that can be expressed as sums of different powers of n. The number 13 is a special number because it can be written as 4 + 9 = 13.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The sequence generation logic inherently handles the inclusion of all special numbers in increasing order.\n\n# [code logic]\n    To implement the solution, we can use a loop to generate the k-th special number for each test case. Here's a simplified version of the code:\n\n    ```python\n    MOD = 10**9 + 7\n\n    def find_kth_special_number(n, k):\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        return result\n\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n, k = map(int, input().split())\n            print(find_kth_special_number(n, k))\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n    This code reads the number of test cases and then iterates through each case, calculating the k-th special number for the given base n.\n", "requirement analysis:\nThe primary requirement is to determine the k-th special number for a given base n, which is the sum of different non-negative powers of n. The output should be in increasing order and modulo 10^9+7. The system should handle multiple test cases efficiently. The user should be able to input the values of n and k, and the system should provide the k-th special number as output.\nrequirement pool:\n- Implement a function to calculate the k-th special number for a given base n.\n- Ensure the system can handle multiple test cases efficiently.\n- Implement the modulo operation to keep the numbers within the specified range.\n- Develop a user-friendly interface for inputting values of n and k.\n- Provide clear and concise output for the k-th special number.\nTo implement the solution, we will use Python due to its simplicity and efficiency. The main challenge is to calculate the k-th special number efficiently, especially for large values of n and k. We will use a mathematical approach to generate the sequence of special numbers and then find the k-th element. The modulo operation will be applied to ensure the numbers stay within the specified range. The system will handle multiple test cases efficiently by using a loop to process each case.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as the sum of different non-negative powers of a given number n.\n    Explanation: In the context of the problem, a special number is one that can be represented as a sum of distinct powers of a base number n. For example, if n = 4, then 17 is a special number because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers greater than zero.\n    'at least as many times': means that we need to find the special number whose count is greater than or equal to its value.\n\n# [degree adverb] \n    'largest': means that we need the biggest special number that appears greater or equal to its value.\n\n# [code logic]\n    To generate the k-th special number in increasing order modulo 10^9+7, we can use a mathematical approach. We need to consider that each special number can be represented as a sum of distinct powers of n. We can use a loop to generate these numbers and keep track of the count to find the k-th special number.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 are special numbers because they can be expressed as sums of distinct powers of a given number. In this case, 3 appears more than or equal to its value.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: None of the numbers 2, 3, or 4 can be expressed as sums of distinct powers of a given number in a way that they appear at least as many times as themselves. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest special number that meets the need.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if k == 1:\n            return 1  # The smallest special number is 1 for any n.\n        special_numbers = []\n        i = 0\n        while len(special_numbers) < k:\n            power = n ** i\n            if power not in special_numbers:\n                special_numbers.append(power)\n            i += 1\n        return special_numbers[-1] % (10**9 + 7)\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if k == 1:\n            return 1  # The smallest special number is 1 for any n.\n        special_numbers = []\n        i = 0\n        while len(special_numbers) < k:\n            power = n ** i\n            if power not in special_numbers:\n                special_numbers.append(power)\n            i += 1\n        return special_numbers[-1] % (10**9 + 7)\n", "requirement analysis:\nThe requirements involve creating a program that can generate the k-th special number for a given base n. The special numbers are sums of different non-negative powers of n. The program should be able to handle multiple test cases efficiently. The output should be printed modulo 10^9+7 to ensure the numbers remain within the integer limit. The user should be able to input the values of n and k through standard input.\nrequirement pool:\n- Implement a function to determine the k-th special number for a given base n.\n- Ensure the program can handle multiple test cases efficiently.\n- Output the result modulo 10^9+7 to handle large numbers.\n- Provide a user-friendly interface for inputting values of n and k.\n- Optimize the program for large inputs to ensure fast execution.\nTo implement the solution, we will use Python due to its simplicity and efficiency. The main challenge is to generate the k-th special number for a given base n, which involves summing different non-negative powers of n. We will use a mathematical approach to generate these numbers efficiently. The output will be modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as the sum of different non-negative powers of a given number n.\n    Explanation: In this context, a special number is derived from summing distinct powers of a base number n. For example, if n = 4, then 17 is a special number because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that the number must be greater than zero.\n    Explanation: In the requirement, we are dealing with positive integers, so we need to ensure that the numbers we generate are greater than zero.\n\n# [degree adverb] \n    'largest': not applicable in this context as the requirement does not specify a need to find the largest special number.\n\n# [code logic]\n    To generate the k-th special number for a given base n, we can use a mathematical approach to sum different non-negative powers of n. The sequence of special numbers can be generated iteratively by summing powers of n until we reach the k-th number. The result should be modulo 10^9+7 to handle large numbers.\n\n# [edge case] \n    search([1], 1) = 1\n    Explanation: The sequence starts with 1, which is the first special number. Since we are looking for the first special number, the expected output is 1.\n    search([2], 1) = -1\n    Explanation: For n = 2, the sequence starts with [1, 2], but since we are looking for the first special number and there are no special numbers in this sequence, the expected output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle the case where there are no special numbers by returning -1.\n\n# [code logic]\n    To implement the solution, we can use a loop to generate the k-th special number for a given base n. We will use a mathematical approach to sum different non-negative powers of n until we reach the k-th number. The result should be modulo 10^9+7 to handle large numbers.\n\n    ```python\n    MOD = 10**9 + 7\n\n    def find_kth_special_number(n, k):\n        result = 0\n        power = 0\n        while k > 0:\n            if k % 2 == 1:\n                result += pow(n, power, MOD)\n                result %= MOD\n            k //= 2\n            power += 1\n        return result\n\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n, k = map(int, input().split())\n            print(find_kth_special_number(n, k))\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n    This code reads the number of test cases and for each test case, it reads the base n and the position k. It then calculates the k-th special number using the `find_kth_special_number` function and prints the result.\n", "requirement analysis:\nThe requirements involve creating a program that can compute the k-th special number in a sequence defined by the sum of distinct non-negative powers of a given base n, modulo 10^9+7. The program should be able to handle multiple test cases efficiently. The user interface should be simple and intuitive, allowing users to input the base and the position in the sequence to find the special number.\nrequirement pool:\n- The main code should efficiently compute the k-th special number for each test case.\n- The program should handle large values of n and k without crashing.\n- The user interface should be intuitive and easy to use.\n- The program should be optimized for performance to handle multiple test cases.\n- The output should be accurate and in the correct format as specified.\nTo create a Python application that efficiently computes the k-th special number in a sequence defined by the sum of distinct non-negative powers of a given base n, modulo 10^9+7, we will use a mathematical approach to generate the sequence and then find the k-th element. We will leverage Python's efficient handling of large integers and modular arithmetic to ensure the application can handle large inputs without crashing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special numbers': numbers that can be expressed as sums of different non-negative powers of a base n.\n    Explanation: These numbers are generated by summing distinct powers of n, where each power is a non-negative integer. The result is considered a special number.\n\n# [phrase showing quantity relationship]\n    'different non-negative powers': means that each power of n used in the sum must be unique.\n    Explanation: This phrase indicates that the powers of n used in the sum should not repeat, ensuring that each term in the sum is distinct.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending numerical order.\n    Explanation: This phrase specifies the order in which the special numbers should be presented, ensuring that the sequence is sorted from smallest to largest.\n\n# [code logic]\n(check if there are steps should be considered simultaneously)\nTo generate the k-th special number in increasing order modulo 10^9+7, we need to:\n1. Understand the mathematical representation of special numbers.\n2. Generate these numbers in ascending order.\n3. Ensure the numbers are computed modulo 10^9+7 to handle large values.\n4. Find the k-th special number in the sequence.\n\n# [edge case] \n    n = 2, k = 1\n    expected output = 1\n    Explanation: For n = 2, the first special number is 1, which is 2^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case. The base case of n = 2 and k = 1 is straightforward and does not require additional logic beyond the core concept of special numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The base case of n = 2 and k = 1 is straightforward and does not require additional logic beyond the core concept of special numbers.\n", "requirement analysis:\nThe requirements involve creating a program that can compute the k-th special number in a sequence defined by the sum of distinct non-negative powers of a given base n, modulo 10^9+7. The program should be able to handle multiple test cases efficiently. The user interface should be simple and intuitive, allowing users to input the base and the position in the sequence to find the special number.\nrequirement pool:\n- The main code should efficiently compute the k-th special number for each test case.\n- The program should handle large values of n and k without crashing.\n- The user interface should be intuitive and easy to use.\n- The program should be able to handle multiple test cases efficiently.\n- The output should be given modulo 10^9+7.\nTo create a Python application that efficiently computes the k-th special number in a sequence defined by the sum of distinct non-negative powers of a given base n, modulo 10^9+7, we will use a mathematical approach to generate the sequence and then find the k-th element. We will leverage Python's efficient handling of large integers and modular arithmetic to ensure the application can handle large inputs without crashing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special numbers': numbers that can be expressed as sums of distinct non-negative powers of a base n.\n    Explanation: These numbers are generated by summing up different powers of n, ensuring that each power is used only once. The result is considered modulo 10^9+7 to handle large numbers efficiently.\n\n# [phrase showing quantity relationship]\n    'distinct non-negative powers': means that each power of n used in the sum must be unique.\n    Explanation: This phrase indicates that the sequence consists of unique combinations of powers of n, ensuring that no power is repeated in the sum.\n\n# [degree adverb] \n    'increasing order': means that the sequence is sorted in ascending order.\n    Explanation: This adverb indicates that the sequence should be generated and presented in a sorted manner, starting from the smallest special number.\n\n# [code logic]\n    To generate the k-th special number, we need to consider the binary representation of k. Each bit in the binary representation of k corresponds to a power of n that is included in the sum. For example, if k is 5 in binary (101), it means the special number includes n^2 and n^0.\n\n    Steps:\n    1. Convert k to its binary representation.\n    2. For each bit in the binary representation, if the bit is set, include the corresponding power of n in the sum.\n    3. Compute the sum modulo 10^9+7.\n    4. Return the computed sum as the k-th special number.\n\n# [edge case] \n    n = 2, k = 1 = 1 (binary)\n    Explanation: The binary representation of 1 is 1, which means the special number is n^0. For n = 2, this is 1.\n    Expected output: 1\n\n    n = 3, k = 2 = 2 (binary)\n    Explanation: The binary representation of 2 is 10, which means the special number includes n^1. For n = 3, this is 3.\n    Expected output: 3\n\n# [extra code for edge case]\n    No extra code is needed for the main logic, but we should handle cases where k is 0 or negative, as these are not valid inputs for finding a k-th special number.\n    if k <= 0:\n        return \"Invalid input: k must be a positive integer\"\n", "requirement analysis:\nThe requirement involves understanding the concept of special numbers that can be expressed as sums of distinct non-negative powers of a given base number n. The task is to find the k-th special number in increasing order, considering the numbers modulo 10^9+7. The input consists of multiple test cases, each with a base number n and a position k. The output should be the k-th special number for each test case, modulo 10^9+7.\nrequirement pool:\n- Implement a function to calculate the k-th special number for given n and k.\n- Ensure the function can handle large values of n and k efficiently.\n- Implement input reading for multiple test cases.\n- Ensure the output is given in the required format, including modulo operation.\n- Test the application with various inputs to ensure accuracy and performance.\nTo implement the function that finds the k-th special number, we will use a mathematical approach to generate the sequence of special numbers. Given the constraints of large values for n and k, we will use a bit manipulation technique to efficiently generate the sequence. The function will read input for multiple test cases, compute the k-th special number for each case, and print the result modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special numbers': numbers that can be expressed as sums of different non-negative powers of a base number n.\n    Explanation: These numbers are generated by summing up distinct powers of n, which can be represented as a binary representation where each bit represents whether a particular power of n is included in the sum.\n\n# [phrase showing quantity relationship]\n    'different non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n    Explanation: This phrase indicates that we need to consider only distinct powers of n, ensuring that each power is used only once in the sum.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending order based on their numerical value.\n    Explanation: This phrase specifies the order in which the special numbers should be output, ensuring that the sequence is sorted from smallest to largest.\n\n# [code logic]\n    To generate the k-th special number, we can use a bit manipulation approach:\n    1. Initialize a variable to store the current special number.\n    2. Use a loop to iterate through the bits of k, starting from the least significant bit.\n    3. For each bit, if the bit is set (i.e., it is 1), add the corresponding power of n to the current special number.\n    4. Continue this process until all bits of k have been processed.\n    5. Return the computed special number modulo 10^9+7.\n\n# [edge case] \n    n = 2, k = 1\n    expected output: 1\n    Explanation: The first special number for base 2 is 1, which is 2^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as the logic provided can directly compute the first special number for any base.\n\n# [code logic]\n    Here's a Python function to compute the k-th special number:\n\n    ```python\n    def find_kth_special_number(n, k):\n        mod = 10**9 + 7\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result + power) % mod\n            power = (power * n) % mod\n            k //= 2\n        return result\n\n    # Example usage:\n    print(find_kth_special_number(2, 1))  # Output: 1\n    ```\n\n    This function uses bit manipulation to efficiently compute the k-th special number for any given n and k.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence generated by summing different non-negative powers of a given base number n. The output should be modulo 10^9+7 to handle large numbers. The system should be able to process multiple test cases efficiently. The user interface should be simple and easy to use, allowing users to input the base number and the position in the sequence.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large inputs and perform modulo operation.\n- Develop a user-friendly interface for inputting the base number and position.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm to ensure efficient performance.\nTo solve the problem of finding the k-th special number in a sequence generated by summing different non-negative powers of a given base number n, we will use Python due to its powerful standard library and ability to handle large numbers efficiently. The approach involves generating the sequence of special numbers and then finding the k-th element in the sequence. We will use the modulo operation to handle large numbers as specified.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be written as a sum of different non-negative powers of a base number n.\n    Explanation: In the context of the problem, a special number is one that can be expressed as the sum of distinct non-negative powers of a given base number n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a dynamic programming approach where we keep track of the sum of different powers of n. We start with the smallest power (n^0) and iteratively add higher powers of n, ensuring that we only add distinct powers. The sequence will be generated in increasing order.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [code logic]\n    To generate the k-th special number, we can use a dynamic programming approach where we keep track of the sum of different powers of n. We start with the smallest power (n^0) and iteratively add higher powers of n, ensuring that we only add distinct powers. The sequence will be generated in increasing order.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n"], "scores": [], "pass_results": [true, true, true, false, true, false, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 341, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "condense_two2one", "parent_index": 9}
