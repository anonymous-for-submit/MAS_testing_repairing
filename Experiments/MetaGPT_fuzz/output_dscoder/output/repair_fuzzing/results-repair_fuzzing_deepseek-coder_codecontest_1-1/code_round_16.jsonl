{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider all possible operations and determine the best strategy to equalize the tower heights as much as possible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider all possible operations and determine the best strategy to equalize the tower heights as much as possible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\nWrite a main() function and use input() function to read input from stdin", " There are n block towers arranged in a row, each with a height of a_i. As part of a building crew, you aim to enhance the appearance of the structures. On any given day, you can execute the following operation:\n\n  * Select two indices i and j (with 1 \u2264 i, j \u2264 n and i \u2260 j) and transfer a block from tower i to tower j. This operation reduces the height of tower i by 1 and increases the height of tower j by 1.\n\nYou assess the visual appeal of the buildings by the disparity in their heights, defined\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\nWrite a main() function and use input() function to read input from stdin", " There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1. The ugliness of the buildings is defined as the height difference between the tallest and shortest buildings, max(a)-min(a). What\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the average height of the towers\n    average_height = sum(heights) / n\n    \n    # Determine the maximum and minimum tower heights\n    max_height = max(heights)\n    min_height = min(heights)\n    \n    # Compute the ugliness as the difference between the maximum and minimum tower heights\n    ugliness = max_height - min_height\n    \n    return ugliness\n\n# Provide the Interface\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the average height of the towers\n    average_height = sum(heights) / n\n    \n    # Determine the maximum and minimum tower heights\n    max_height = max(heights)\n    min_height = min(heights)\n    \n    # Compute the ugliness as the difference between the maximum and minimum tower heights\n    ugliness = max_height - min_height\n    \n    return ugliness\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_minimum_ugliness(n: int, heights: List[int]) -> int:\n    if n == 1:\n        return 0\n    \n    total_height = sum(heights)\n    average_height = total_height / n\n    \n    max_difference = max(heights) - average_height\n    min_difference = average_height - min(heights)\n    \n    return max(max_difference, min_difference)\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    result = calculate_minimum_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(tower_heights: List[int]) -> int:\n    if len(tower_heights) == 0:\n        return 0\n    \n    total_height = sum(tower_heights)\n    average_height = total_height / len(tower_heights)\n    \n    # Calculate the difference between each tower's height and the average height\n    height_differences = [height - average_height for height in tower_heights]\n    \n    # Calculate the total number of blocks to be moved\n    total_blocks_to_move = sum(height_differences)\n    \n    # If the total number of blocks to be moved is zero, the ugliness is zero\n    if total_blocks_to_move == 0:\n        return 0\n    \n    # Calculate the ugliness\n    max_height = max(tower_heights)\n    min_height = min(tower_heights)\n    ugliness = max_height - min_height\n    \n    return ugliness\n\n# Read input from stdin\nn = int(input())\ntower_heights = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_min_ugliness(tower_heights)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_minimum_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the average height of the towers\n    total_height = sum(heights)\n    average_height = total_height / n\n    \n    # If all towers already have the same height, the ugliness is 0\n    if all(height == average_height for height in heights):\n        return 0\n    \n    # Calculate the ugliness\n    operations = 0\n    while not all(height == average_height for height in heights):\n        max_height = max(heights)\n        min_height = min(heights)\n        if max_height > average_height:\n            for i in range(n):\n                if heights[i] < average_height:\n                    heights[i] += 1\n                    heights[heights.index(max_height)] -= 1\n                    operations += 1\n        else:\n            break\n    \n    max_height = max(heights)\n    min_height = min(heights)\n    ugliness = max_height - min_height\n    \n    return ugliness\n\n# Provide input interface using input(), DO NOT use stdin\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Provide output interface using print()\nresult = calculate_minimum_ugliness(n, heights)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    total_blocks = sum(heights)\n    average_height = total_blocks / n\n    \n    if average_height % 1 != 0:\n        return -1  # If the average height is not an integer, it's impossible to equalize the heights\n    \n    blocks_to_transfer = 0\n    for height in heights:\n        if height > average_height:\n            blocks_to_transfer += height - average_height\n    \n    return int(blocks_to_transfer)\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum possible ugliness of the block towers.\n\n    Args:\n        n (int): The number of block towers.\n        heights (List[int]): The heights of the block towers.\n\n    Returns:\n        int: The minimum possible ugliness of the block towers.\n    \"\"\"\n    if n == 1:\n        return 0\n    \n    total_height = sum(heights)\n    average_height = total_height / n\n    \n    # Calculate the initial ugliness\n    max_height = max(heights)\n    min_height = min(heights)\n    initial_ugliness = max_height - min_height\n    \n    # If the heights are already equal, no transfers are needed\n    if initial_ugliness == 0:\n        return 0\n    \n    # Find the towers that need to transfer blocks to others to equalize the heights\n    transfers = 0\n    while max_height > average_height:\n        # Find the tower with the maximum height\n        max_index = heights.index(max_height)\n        # Transfer a block from the tallest tower to the shortest tower\n        for i in range(n):\n            if heights[i] < average_height:\n                heights[max_index] -= 1\n                heights[i] += 1\n                transfers += 1\n                break\n        # Recalculate the maximum and minimum heights\n        max_height = max(heights)\n        min_height = min(heights)\n        # Recalculate the ugliness\n        current_ugliness = max_height - min_height\n        # If the ugliness does not decrease, break the loop\n        if current_ugliness >= initial_ugliness:\n            break\n        initial_ugliness = current_ugliness\n    \n    return transfers\n\n# Read input from stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_minimum_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the average height of all towers\n    total_height = sum(heights)\n    average_height = total_height / n\n    \n    # Determine the number of blocks to move for each tower to reach the average height\n    blocks_to_move = [height - average_height for height in heights]\n    \n    # Calculate the total number of blocks moved, which will be the minimum possible ugliness\n    max_blocks_moved = max(blocks_to_move)\n    min_blocks_moved = min(blocks_to_move)\n    \n    return int(max_blocks_moved - min_blocks_moved)\n\n# Read input\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_minimum_ugliness(n, heights)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the initial ugliness\n    max_height = max(heights)\n    min_height = min(heights)\n    initial_ugliness = max_height - min_height\n    \n    # If the initial ugliness is already zero, return immediately\n    if initial_ugliness == 0:\n        return 0\n    \n    # Calculate the average height\n    total_height = sum(heights)\n    average_height = total_height / n\n    \n    # Redistribute blocks to balance the heights\n    while True:\n        # Find the tallest and shortest towers\n        max_height_index = heights.index(max(heights))\n        min_height_index = heights.index(min(heights))\n        \n        # If the tallest and shortest towers are already balanced, break the loop\n        if heights[max_height_index] == average_height and heights[min_height_index] == average_height:\n            break\n        \n        # Move one block from the tallest tower to the shortest tower\n        heights[max_height_index] -= 1\n        heights[min_height_index] += 1\n    \n    # Recalculate the ugliness after balancing\n    max_height = max(heights)\n    min_height = min(heights)\n    final_ugliness = max_height - min_height\n    \n    return final_ugliness\n\n# Read input from the user\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_min_ugliness(n, heights)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the average height of all towers\n    average_height = sum(heights) / n\n    \n    # Adjust each tower's height to match the average height\n    adjusted_heights = [int(average_height) for _ in range(n)]\n    \n    # Calculate the ugliness as the difference between the maximum and minimum heights after adjustment\n    max_height = max(adjusted_heights)\n    min_height = min(adjusted_heights)\n    \n    return max_height - min_height\n\n# Provide the Interface\nn = int(input())\nheights = list(map(int, input().split()))\nresult = calculate_min_ugliness(n, heights)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_minimum_ugliness(n: int, heights: List[int]) -> int:\n    if n == 0:\n        raise ValueError(\"Number of towers must be greater than zero\")\n    \n    # Calculate the average height of the towers\n    average_height = sum(heights) / n\n    \n    # Determine the maximum difference between the tower heights and the average height\n    max_difference = max(heights) - min(heights)\n    \n    return max_difference\n\n# Read input\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Calculate and print the minimum possible ugliness\nresult = calculate_minimum_ugliness(n, heights)\nprint(result)\n"], "plans": ["requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing any number of operations. The ugliness is defined as the difference between the maximum and minimum tower heights. The optimal strategy is to equalize all tower heights to the average height, which can be achieved by moving blocks from the tallest towers to the shortest ones. This will minimize the height difference.\nrequirement pool:\n- Implement the logic to calculate the minimum possible ugliness for each test case.\n- Ensure the solution is efficient enough to handle up to 1000 test cases within the given constraints.\n- Develop a user interface to input the number of test cases and tower heights.\n- Provide a clear output displaying the minimum possible ugliness for each test case.\n- Optimize the code for performance to handle large inputs efficiently.\nTo solve the problem of minimizing the ugliness of block towers, we will follow a straightforward approach. The ugliness is defined as the difference between the maximum and minimum tower heights. The optimal strategy is to equalize all tower heights to the average height. This can be achieved by moving blocks from the tallest towers to the shortest ones. We will iterate through each test case, calculate the average height, and then determine the maximum and minimum tower heights to compute the ugliness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower manipulation': involves moving blocks between towers to equalize their heights.\n    'ugliness': the difference between the maximum and minimum tower heights.\n\n# [phrase showing quantity relationship]\n    'more than': used to compare the heights of towers to find the maximum and minimum.\n\n# [degree adverb] \n    'largest': refers to the tower with the maximum height.\n    'shortest': refers to the tower with the minimum height.\n\n# [code logic]\n    (1) For each test case, calculate the average height of the towers.\n    (2) Determine the maximum and minimum tower heights.\n    (3) Compute the ugliness as the difference between the maximum and minimum tower heights.\n\n# [edge case] \n    n = 2\n    heights = [1, 10000000]\n    expected output = 9999999\n    Explanation:\n    With only two towers, the best strategy is to move all blocks from the taller tower to the shorter one, resulting in both towers having a height of 5000000.5. The ugliness is then 10000000 - 5000000.5 = 4999999.5, but since the result must be an integer, the actual output is 9999999.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 2. In this scenario, the ugliness is simply the difference between the two tower heights, and no additional blocks need to be moved.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing any number of operations. The operations allowed are moving a block from one tower to another. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The goal is to equalize the heights of the towers as much as possible to minimize this difference.\nrequirement pool:\n- Implement a function to calculate the minimum possible ugliness\n- Ensure the function can handle multiple test cases\n- Optimize the algorithm to handle large inputs efficiently\n- Add user interface elements for input and output\n- Implement responsive design for better user experience on mobile devices\nTo solve the problem of minimizing the ugliness of the block towers, we will use a straightforward approach. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The optimal strategy is to equalize all towers to the average height. We will calculate the average height and then determine the maximum difference between the tower heights and the average height.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block towers', 'height', 'ugliness', 'equalization'\n    Explanation: Block towers are represented by their heights, and ugliness is the difference between the tallest and shortest towers. The goal is to minimize this ugliness by equalizing the heights of the towers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case:\n    1. Calculate the average height of the towers.\n    2. Determine the maximum difference between the tower heights and the average height.\n    3. Output the maximum difference as the minimum possible ugliness.\n\n# [edge case] \n    search([1, 2, 3]) = 2\n    Explanation: The average height is (1+2+3)/3 = 2. The difference between the maximum height (3) and the minimum height (1) is 2.\n    search([10, 10, 10]) = 0\n    Explanation: All towers have the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all cases.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after any number of operations. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The goal is to equalize the heights of all towers by moving blocks between them. The solution involves finding the average height and ensuring all towers reach this average height.\nrequirement pool:\n- The main code should read the input correctly and process each test case.\n- The code should calculate the minimum possible ugliness for each test case.\n- The output should be printed for each test case.\nTo solve the problem of minimizing the ugliness of the block towers, we will use a straightforward approach that involves calculating the average height of the towers and then adjusting the heights to match this average. This can be efficiently achieved by moving blocks between towers, which will not change the overall average height. The ugliness is then the difference between the maximum and minimum heights of the towers after this adjustment.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block towers', 'height adjustment', 'ugliness'\n    Explanation: Block towers are represented by a list of heights, and the ugliness is defined as the difference between the maximum and minimum heights in the list. The goal is to minimize this ugliness by moving blocks between towers.\n\n# [phrase showing quantity relationship]\n    'more than': means that the value of the block tower i is greater than the value of block tower j.\n    'at least as many times': means that the frequency of a block tower i is greater than or equal to its height.\n\n# [degree adverb] \n    'largest': means that the value of the block tower i is the largest in the list.\n    'shortest': means that the value of the block tower i is the smallest in the list.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To minimize the ugliness, we need to:\n    1. Calculate the average height of all towers.\n    2. Adjust the heights of the towers to match this average height by moving blocks between towers.\n    3. Calculate the ugliness as the difference between the maximum and minimum heights after the adjustment.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 4\n    Explanation: The average height is 3. By moving blocks, we can make all towers have a height of 3, resulting in an ugliness of 3 (max height) - 3 (min height) = 0.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers already have the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided can handle the edge case where all towers have the same height.\n\n# [core concept]\n    'block towers', 'height adjustment', 'ugliness'\n    Explanation: Block towers are represented by a list of heights, and the ugliness is defined as the difference between the maximum and minimum heights in the list. The goal is to minimize this ugliness by moving blocks between towers.\n\n# [phrase showing quantity relationship]\n    'more than': means that the value of the block tower i is greater than the value of block tower j.\n    'at least as many times': means that the frequency of a block tower i is greater than or equal to its height.\n\n# [degree adverb] \n    'largest': means that the value of the block tower i is the largest in the list.\n    'shortest': means that the value of the block tower i is the smallest in the list.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To minimize the ugliness, we need to:\n    1. Calculate the average height of all towers.\n    2. Adjust the heights of the towers to match this average height by moving blocks between towers.\n    3. Calculate the ugliness as the difference between the maximum and minimum heights after the adjustment.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 4\n    Explanation: The average height is 3. By moving blocks, we can make all towers have a height of 3, resulting in an ugliness of 3 (max height) - 3 (min height) = 0.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers already have the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided can handle the edge case where all towers have the same height.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing the block transfer operations. The ugliness is defined as the maximum height of the buildings minus the minimum height of the buildings. The goal is to minimize this disparity by transferring blocks between towers.\nrequirement pool:\n- Implement a function to read input from standard input\n- Implement a function to calculate the minimum possible ugliness\n- Implement a function to output the result to standard output\n- Optimize the block transfer operations to achieve the minimum ugliness\n- Ensure the solution is efficient enough to handle up to 1000 test cases\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach that involves calculating the average height of the towers and then determining the minimum number of operations required to make all towers have the same height. This will be achieved by transferring blocks from the taller towers to the shorter ones until they all have the same height. The ugliness will then be the difference between the maximum and minimum heights of the towers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower heights': The core concept here is the manipulation of block tower heights by transferring blocks between towers to achieve uniformity.\n    Explanation: The problem involves adjusting the heights of multiple towers by moving blocks from one tower to another to minimize the disparity between their heights. This is crucial for enhancing the visual appeal of the structures.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that one value is greater than another.\n    'at least as many times': Indicates that a value appears a certain number of times or more.\n\n# [degree adverb] \n    'minimum possible': Indicates the goal is to find the smallest possible value of a given quantity.\n\n# [code logic]\n    For each test case:\n    1. Calculate the average height of the towers.\n    2. Determine the number of operations needed to make all towers have the same height.\n    3. Calculate the ugliness as the difference between the maximum and minimum heights after the operations.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 4\n    Explanation: The ugliness is 4 because the maximum height is 5 and the minimum height is 1, and the difference is 4.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers already have the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases, including when all towers already have the same height.\n", "requirement analysis:\nThe requirements specify the need to calculate the minimum possible ugliness of block towers after transferring blocks between them. The input includes the number of test cases, the number of buildings, and the heights of each building. The output should be the minimum possible ugliness for each test case. The solution should be efficient and handle up to 100 test cases with up to 100 buildings each.\nrequirement pool:\n- Implement the function to calculate the minimum ugliness for each test case.\n- Ensure the program can handle multiple test cases efficiently.\n- Provide clear and concise output for each test case.\n- Add user input for the number of test cases to prepare for the input.\n- Include error handling for invalid inputs.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to minimize the disparity between the heights of the towers by transferring blocks optimally. We will use a greedy approach to achieve this. The steps include calculating the average height, determining the number of blocks to be transferred, and then finding the minimum possible ugliness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block transfer': the process of moving blocks from one tower to another to equalize or minimize the height disparity among towers.\n    Explanation: In this problem, we need to minimize the difference in heights between adjacent towers by transferring blocks. This is crucial for enhancing the visual appeal of the buildings.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find a relationship where one value is greater than another.\n    'at least as many times': suggests that we need to consider values where one quantity is at least as large as another.\n\n# [degree adverb] \n    'minimum': emphasizes the need to find the smallest possible value of the given quantity.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the average height of the towers.\n    2. Determine the total number of blocks that need to be transferred to achieve the average height.\n    3. Use a greedy approach to minimize the ugliness by transferring blocks between towers.\n    4. Calculate the minimum possible ugliness by considering the total number of blocks to be transferred and dividing by the number of towers.\n\n# [edge case] \n    Test case: [1, 2, 3, 1, 5]\n    Expected output: 1\n    Explanation:\n    - The initial ugliness is 3 (since the heights are 1, 2, 3, 1, 5).\n    - By transferring blocks optimally, we can achieve a configuration where the ugliness is minimized to 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan should be sufficient to handle any given test case.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing the block transfer operations. The ugliness is defined as the maximum height of the buildings minus the minimum height of the buildings. The goal is to minimize this disparity by transferring blocks between towers.\nrequirement pool:\n- Implement a function to read input from standard input\n- Implement a function to calculate the minimum possible ugliness\n- Implement a function to output the result to standard output\n- Optimize the block transfer operations to achieve the minimum ugliness\n- Ensure the solution is efficient enough to handle up to 1000 test cases\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach. The ugliness is defined as the difference between the maximum and minimum heights of the towers. Our strategy involves calculating the average height and then determining the number of towers that need to be adjusted to achieve equal heights. This will be done by transferring blocks from taller towers to shorter ones. The process will be repeated for each test case to ensure all scenarios are covered.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower heights': The core concept here is the manipulation of block tower heights to minimize the disparity between them.\n    Explanation: The ugliness of the buildings is defined by the difference between the maximum and minimum heights of the towers. Our goal is to minimize this difference through strategic block transfers.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find towers that are taller than the average height to transfer blocks from them.\n    Explanation: For example, if the average height of the towers is 5, and a tower has a height of 7, we can transfer blocks from this tower to others to equalize the heights.\n\n# [degree adverb] \n    'minimum possible': This adverb tells us that our goal is to find the smallest possible ugliness after the block transfers.\n    Explanation: We need to ensure that the number of transfers is minimal to achieve the lowest possible ugliness.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case, we need to:\n    1. Calculate the average height of the towers.\n    2. Identify towers that need to transfer blocks to others to equalize the heights.\n    3. Calculate the number of transfers required to achieve the minimum possible ugliness.\n\n# [edge case] \n    Edge case 1: All towers have the same height.\n    Expected output: 0\n    Explanation: If the heights are already equal, no transfers are needed, and the ugliness is 0.\n\n    Edge case 2: Only two towers with different heights.\n    Expected output: 0\n    Explanation: If there are only two towers with different heights, transferring a block from the taller tower to the shorter one will make them equal, resulting in an ugliness of 0.\n\n    Edge case 3: Large number of towers with varying heights.\n    Expected output: 1\n    Explanation: In this case, we need to perform multiple transfers to equalize the heights. For example, if the heights are [1, 2, 3, 1, 5], we can perform transfers to achieve [2, 2, 2, 1, 5], then [2, 2, 2, 2, 4], and finally [2, 2, 3, 2, 3], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle these cases by calculating the average height and performing necessary transfers.\n", "requirement analysis:\nThe requirement analysis involves understanding the problem of minimizing the ugliness of block towers by moving blocks between towers. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The solution involves finding the optimal distribution of blocks to achieve the minimum possible ugliness.\nrequirement pool:\n- Implement the logic to calculate the minimum possible ugliness for each test case\n- Ensure the solution is efficient enough to handle up to 1000 test cases with n up to 100\n- Optimize the code to handle large values of a_i up to 10^7\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The optimal solution involves balancing the blocks between towers. The key idea is to move blocks from the tallest tower to the shortest tower until all towers have the same height. This can be efficiently achieved by calculating the average height of the towers and then determining the number of blocks to move for each tower to reach this average height.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower balancing':\n    The core concept involves adjusting the heights of multiple block towers by moving blocks between them to achieve a uniform height, thereby minimizing the difference between the maximum and minimum heights.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we need to follow these steps:\n    1. Calculate the average height of all towers.\n    2. Determine the number of blocks to move from each tower to reach the average height.\n    3. Sum the total number of blocks moved, which will be the minimum possible ugliness.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The tallest tower is 5 and the shortest is 1. To balance the towers, we can move 4 blocks from the tallest (tower 5) to the shortest (tower 1), making all towers have a height of 3. The ugliness is then 4 - 3 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already ensures that we find the minimum possible ugliness by balancing the towers.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after moving blocks optimally. The ugliness is defined as the difference between the maximum and minimum heights of the buildings. Each test case involves a number of buildings and their respective heights. The goal is to output the minimum possible ugliness for each test case.\nrequirement pool:\n- Implement a function to calculate the minimum ugliness\n- Ensure the function works efficiently for large inputs\n- Handle edge cases such as minimum and maximum number of buildings\n- Ensure the function is robust against input errors\n- Optimize the algorithm for performance\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach. The ugliness is defined as the difference between the maximum and minimum heights of the buildings. The optimal strategy is to balance the heights of all towers by moving blocks from the tallest tower to the shortest tower. This can be achieved by calculating the average height and ensuring all towers have this average height. The minimum possible ugliness will be zero if the initial tower heights are already balanced.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower balancing':\n    The core concept is to balance the heights of multiple block towers by redistributing blocks from taller to shorter towers, thereby minimizing the difference between the maximum and minimum heights.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the plan involves:\n    1. Calculating the average height of all towers.\n    2. Redistributing blocks from towers that are taller than the average to towers that are shorter than the average until all towers have the same height.\n    3. The minimum possible ugliness will be the difference between the maximum and minimum heights after balancing, which will be zero if the initial heights are already balanced.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 4\n    Explanation: The initial ugliness is 4 (5 - 1). By moving blocks from the tallest tower (5) to the shortest tower (1), we can balance the towers to have heights of 2 each, resulting in an ugliness of 0.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers are already at the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where all towers are already balanced.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after moving blocks optimally. The ugliness is defined as the difference between the maximum and minimum heights of the buildings. Each test case involves a number of buildings and their respective heights. The goal is to output the minimum possible ugliness for each test case.\nrequirement pool:\n- Implement a function to calculate the minimum ugliness\n- Ensure the function works efficiently for large inputs\n- Handle edge cases where all buildings are already of the same height\n- Ensure the function can handle up to 100 buildings and heights up to 10^7\n- Optimize the function for performance to handle up to 1000 test cases\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach. The ugliness is defined as the difference between the maximum and minimum heights of the buildings. The optimal strategy is to balance the heights of all towers by moving blocks from the tallest tower to the shortest tower. This can be achieved by calculating the average height and adjusting each tower's height to match this average. The minimum possible ugliness will be the absolute difference between the maximum and minimum heights after this adjustment.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower balancing':\n    The core concept is to balance the heights of multiple block towers by redistributing blocks from taller to shorter towers, thereby minimizing the difference between the maximum and minimum tower heights.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the plan involves:\n    1. Calculating the average height of all towers.\n    2. Adjusting each tower's height to match the average height.\n    3. Calculating the ugliness as the difference between the maximum and minimum heights after adjustment.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 4\n    Explanation: The average height is 3. Adjusting the towers to have height 3 results in [3, 3, 3, 3, 3], making the ugliness 0.\n    search([5, 4, 3, 2, 1]) = 4\n    Explanation: Similar to the previous edge case, the average height is 3. Adjusting the towers to have height 3 results in [3, 3, 3, 3, 3], making the ugliness 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to calculate the minimum possible ugliness.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing any number of operations. The operations allowed are moving a block from one tower to another. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The goal is to equalize the heights of the towers as much as possible to minimize this difference.\nrequirement pool:\n- Implement the logic to calculate the minimum possible ugliness for each test case.\n- Ensure the solution is efficient enough to handle up to 1000 test cases with n up to 100.\n- Develop a user interface for input and output.\n- Optimize the code for performance to handle large inputs efficiently.\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The optimal strategy is to equalize all towers to the average height. We will calculate the average height and then determine the maximum difference between the tower heights and the average height.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block towers', 'height', 'ugliness', 'equalization'\n    Explanation: Block towers are represented by their heights, and ugliness is the difference between the tallest and shortest towers. The goal is to minimize this ugliness by equalizing the heights of the towers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case:\n    1. Calculate the average height of the towers.\n    2. Determine the maximum difference between the tower heights and the average height.\n    3. Output the maximum difference as the minimum possible ugliness.\n\n# [edge case] \n    search([1, 2, 3]) = 2\n    Explanation: The average height is (1+2+3)/3 = 2. The difference between the maximum height (3) and the minimum height (1) is 2.\n    search([10, 10, 10]) = 0\n    Explanation: All towers have the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for any number of towers.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 16, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "add_1_sentence_at_end", "parent_index": 16}
