{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has an array a consisting of n integers, and k is the mathematic mean of these elements (note that it's possible that k is not an integer). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your solution efficiently handles arrays of up to 10^5 elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has an array a consisting of n integers, and k is the mathematic mean of these elements (note that it's possible that k is not an integer). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your solution efficiently handles arrays of up to 10^5 elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array \\( a \\) consisting of \\( n \\) integers, and \\( k \\) is the arithmetic mean of these elements (note that it's possible that \\( k \\) is not an integer). Monocarp wants to delete exactly two elements from \\( a \\) so that the arithmetic mean of the remaining \\( n - 2 \\) elements is still equal to \\( k \\). Your task is to calculate the number of pairs of positions \\([i, j]\\) (where \\( i < j \\)) such that if the elements on these positions are deleted, the arithmetic mean of \\( n - 2 \\) remaining elements\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the arithmetic mean of these elements. He wants to delete exactly two elements from a so that the arithmetic mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. The solution should efficiently handle arrays of up to 10^5 elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # If the array has only three elements, return 0 as removing any two elements will change the mean\n    if n == 3:\n        return 0\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new mean of the remaining elements after removing the elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            \n            # Check if the new mean equals the original mean\n            if new_mean == original_mean:\n                count += 1\n    \n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs_to_maintain_mean(n, arr):\n    \"\"\"\n    Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mean of the remaining (n - 2) elements is still equal to the mean of the original array.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers representing the array.\n        \n    Returns:\n        int: The number of pairs of positions [i, j] that maintain the mean.\n    \"\"\"\n    # Calculate the mean of the entire array\n    original_mean = sum(arr) / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Create a set to store the sum of the remaining elements\n    sum_set = set()\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing elements at indices i and j\n            remaining_sum = arr[0:i] + arr[i+1:j] + arr[j+1:]\n            sum_set.add(remaining_sum)\n    \n    # Check if the mean of the remaining elements is equal to the original mean\n    for remaining_sum in sum_set:\n        if remaining_sum / (n - 2) == original_mean:\n            count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Calculate and print the result\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nimport sys\n\ndef calculate_pairs(n, arr):\n    original_mean = sum(arr) / n\n    count = 0\n    total_sum = sum(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == original_mean:\n                count += 1\n\n    return count\n\n# Read input\ninput_lines = sys.stdin.readlines()\nt = int(input_lines[0])\nline_index = 1\nfor _ in range(t):\n    n = int(input_lines[line_index].strip())\n    arr = list(map(int, input_lines[line_index + 1].strip().split()))\n    line_index += 2\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr):\n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_excluding_ij = sum(arr[:i] + arr[i+1:j] + arr[j+1:])\n            if (n - 2) * mean == sum_excluding_ij:\n                count += 1\n    \n    return count\n\n# Example usage:\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n        \n    Returns:\n        int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            remaining_sum = total_sum - arr[i] - arr[j]\n            if remaining_sum % (n - 2) == 0 and remaining_sum // (n - 2) == k:\n                count += 1\n    return count\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef count_valid_pairs(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    original_mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = arr[0:i] + arr[i+1:j] + arr[j+1:]\n                new_n = n - 2\n                if new_sum / new_n == original_mean:\n                    count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_of_positions(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # If the array has only three elements, return 0 as removing any two elements will change the mean\n    if n == 3:\n        return 0\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new mean of the remaining elements after removing the elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            \n            # Check if the new mean equals the original mean\n            if new_mean == original_mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_of_positions(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # If the array has only three elements, return 0 as removing any two elements will change the mean\n    if n == 3:\n        return 0\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new mean of the remaining elements after removing the elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            \n            # Check if the new mean equals the original mean\n            if new_mean == original_mean:\n                count += 1\n    \n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef count_valid_pairs(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    original_mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = arr[0:i] + arr[i+1:j] + arr[j+1:]\n                new_n = n - 2\n                if new_sum / new_n == original_mean:\n                    count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr):\n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_excluding_ij = sum(arr[:i] + arr[i+1:j] + arr[j+1:])\n            if (n - 2) * mean == sum_excluding_ij:\n                count += 1\n    \n    return count\n\n# Example usage:\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe task requires calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion maintains the mean. The constraints are high, with up to 2 * 10^5 elements, so efficiency is crucial.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs that can be deleted to maintain the mean.\n- Ensure the solution can handle up to 2 * 10^5 elements efficiently.\n- Provide accurate results that meet the requirements.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to the original mean. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. In this case, the mean of the array elements before and after removing two elements should be the same.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To implement the solution, we need to follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean equals the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs that can be removed to keep the mean unchanged.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 5, 7]\n    Explanation: The original mean is (1+3+5+7)/4 = 4. The pair [1, 2] (removing elements at indices 1 and 2) results in the mean of the remaining elements being 4.\n    Expected output: 1\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, as removing any two elements will change the mean.\n    if n == 3:\n        return 0\n\n    (rest of the code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must be efficient enough to handle up to 10^5 elements, making it suitable for large inputs.\nrequirement pool:\n- Implement a solution to calculate the number of pairs [i, j] that maintain the mean after deletion.\n- Ensure the solution is optimized for handling large arrays efficiently.\n- Provide clear and concise output for the number of such pairs.\nTo efficiently solve this problem, we will use Python due to its strong support for handling large datasets and numerical operations. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing those elements would still result in the same mean. We will use a nested loop to iterate through all pairs and a set to quickly check if the mean remains unchanged after removal.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. In this case, the mean of the array elements before and after removing two elements should be the same.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To efficiently solve this problem, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Use a nested loop to iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The only possible pair is [0, 1] since i < j. Removing elements at indices 0 and 1 results in the mean of the remaining element [2] being equal to the original mean [2].\n    Expected output: 1\n\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The pairs are [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]. Removing elements at indices 0 and 1 results in the mean of the remaining elements [3, 4] being equal to the original mean [2.5].\n    Expected output: 6\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle the edge case where n = 3. For larger values of n, the plan ensures that we iterate through all possible pairs and check the condition efficiently.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires efficient handling of large arrays and accurate mean calculation.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs.\n- Ensure the solution handles up to 2 * 10^5 elements.\n- Accurately calculate the mean of the remaining elements.\n- Optimize the code for performance.\n- Provide clear and concise output.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. We will iterate through all possible pairs and check if deleting the elements at these positions maintains the mean. To handle large arrays, we will ensure our solution is optimized for performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of all elements divided by the number of elements\n    'deleting elements': removing specific elements from a list\n    'pairs of positions': selecting two distinct positions in a list to remove elements from\n\n    Explanation: The task requires finding pairs of positions in an array where removing the elements at these positions does not change the mean of the remaining elements. The mean is calculated as the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': specifically removing two elements from the array\n\n# [degree adverb] \n    'largest': not directly applicable in this context, as we are looking for pairs that maintain the mean, not the largest individual elements.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at positions i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n    6. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs that can be removed to maintain the mean of 2 since removing any two elements will change the mean.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 5, 7]\n    Explanation: The original mean is (1+3+5+7)/4 = 4. Removing the elements at positions 1 and 3 (0-indexed) leaves [1, 5], which has a mean of (1+5)/2 = 3, which is not equal to the original mean. Removing any other pair will also change the mean.\n    Expected output: 0\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where no pair can maintain the mean. This can be done by checking if the mean of any pair is equal to the original mean and incrementing a counter accordingly.\n\n    def count_pairs(a, mean):\n        count = 0\n        n = len(a)\n        for i in range(n):\n            for j in range(i+1, n):\n                new_array = a[:i] + a[i+1:j] + a[j+1:]\n                if sum(new_array) / (n - 2) == mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. This requires a thorough understanding of arithmetic mean calculations and efficient iteration through the array to find the required pairs.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Develop a function to iterate through the array and find pairs [i, j] that meet the criteria.\n- Ensure the solution is optimized to handle up to 2 * 10^5 elements efficiently.\n- Add error handling to manage unexpected input scenarios.\n- Include unit tests to verify the correctness and robustness of the solution.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the arithmetic mean of the array and then iterate through the array to find pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. The solution will be optimized to handle up to 2 * 10^5 elements efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that after removing the elements at these indices, the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the sum of the elements at the indices is greater than the original mean multiplied by the number of remaining elements.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest possible pairs that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the sum of the remaining elements is equal to the arithmetic mean multiplied by (n - 2).\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 6\n    Explanation: In this case, the arithmetic mean is 1, and there are 6 pairs that can be removed to keep the mean unchanged.\n    search([2, 2, 2, 2]) = 6\n    Explanation: Similar to the previous edge case, the arithmetic mean is 2, and there are 6 pairs that can be removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases.\n\n# [code logic]\n    Here's the Python code to implement the logic described:\n\n    ```python\n    def count_pairs(n, arr):\n        mean = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean:\n                    count += 1\n        return count\n\n    # Example usage:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(count_pairs(n, arr))\n    ```\n\n    This code will read the number of test cases and then for each test case, it will read the number of elements and the elements themselves. It will then calculate the number of valid pairs and print the result.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. This requires a thorough understanding of arithmetic mean calculations and efficient data handling to manage large inputs.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Develop a method to iterate through all possible pairs [i, j] and check the condition.\n- Optimize the algorithm to handle up to 2 * 10^5 elements efficiently.\n- Ensure the solution is clear and well-documented for easy understanding and maintenance.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the input and output efficiently. The main challenge is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. We will iterate through the array to find all possible pairs and check the condition. To optimize the solution for large inputs, we will ensure that the algorithm runs in linear time.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    'deleting elements': Removing specific elements from the array to calculate the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of elements being removed is two.\n    'at least as many times': Indicates that the remaining elements should still have the same mean as the original array.\n\n# [degree adverb] \n    'exactly': Specifies that only two elements should be deleted.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to iterate through all possible pairs [i, j] where i < j, and check if deleting the elements at these positions keeps the mean of the remaining elements equal to k. We can calculate the mean of the original array and then for each pair, calculate the mean of the remaining elements to check if it equals k.\n\n# [edge case] \n    search([1, 1, 1, 1], k=1) = 6\n    Explanation: In this case, all elements are the same, and deleting any two elements will keep the mean of the remaining elements equal to k. There are 6 possible pairs: [0,1], [0,2], [0,3], [1,2], [1,3], [2,3].\n    search([2, 2, 3, 3, 3], k=3) = 0\n    Explanation: In this case, the element 2 does not appear at least as many times as itself, so no pairs will satisfy the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where all elements are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where all elements are the same.\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. This involves calculating the mean of the entire array and then checking each pair of elements to see if their deletion maintains the mean. Given the constraints, a brute force approach is not feasible, so an efficient algorithm is necessary.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of valid pairs\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements\n- Optimize the solution for performance\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if their deletion maintains the mean. Given the constraints, we need to ensure our solution is optimized for performance, handling up to 2 \u22c5 10^5 elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not directly used in the requirement, but the concept of mean implies a comparison of quantities.\n\n# [degree adverb] \n    'largest': This phrase is not directly used in the requirement, but the concept of mean implies a comparison of quantities.\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after deleting the elements at positions i and j.\n    4. Count the number of pairs that maintain the original mean.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, deleting any two elements will leave us with a single element, which cannot have the original mean. Thus, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. There are two pairs [1, 2] and [2, 3] that can be deleted to maintain the mean of 2.5. Thus, the expected output is 2.\n    Edge case 3:\n    Input: n = 5, a = [1, 3, 2, 4, 5]\n    Explanation: The original mean is (1+3+2+4+5)/5 = 3. There are no pairs that can be deleted to maintain the mean of 3, as all elements are distinct and cannot be removed without changing the mean. Thus, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only 3 elements, as described in edge case 1.\n    def count_pairs(n, a):\n        if n == 3:\n            return 0\n        # Continue with the main logic for larger arrays\n        mean = sum(a) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                new_sum = sum(a[:i]) + sum(a[i+1:j]) + sum(a[j+1:])\n                new_n = n - 2\n                if new_sum / new_n == mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires a solution that can handle large arrays efficiently and accurately. The solution should be optimized for performance to ensure it can handle up to 2 * 10^5 elements.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs of positions [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle arrays of up to 2 * 10^5 elements.\n- Optimize the algorithm for performance to handle large data sets efficiently.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to the original mean. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. In this case, the mean of the array elements before and after removing two elements should be the same.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To implement the solution, we need to follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean equals the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs that can be removed to keep the mean unchanged since any two elements will change the mean.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 1, 3]\n    Explanation: The original mean is (1+3+1+3)/4 = 2. The pairs [1, 2] and [2, 3] can be removed to keep the mean unchanged.\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, as removing any two elements will change the mean.\n    if n == 3:\n        return 0\n\n    (rest of the code)\n", "requirement analysis:\nThe task requires calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion maintains the mean. The constraints are high, with up to 2 * 10^5 elements, so efficiency is crucial.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs that can be deleted to maintain the mean.\n- Ensure the solution can handle up to 2 * 10^5 elements efficiently.\n- Provide accurate results that meet the requirements.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing these elements results in the mean of the remaining elements being equal to the original mean. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. In this case, the mean of the array elements before and after removing two elements should be the same.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To implement the solution, we need to follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs where the new mean equals the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. There are no pairs that can be removed to keep the mean unchanged.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 5, 7]\n    Explanation: The original mean is (1+3+5+7)/4 = 4. The pair [1, 2] (removing elements at indices 1 and 2) results in the mean of the remaining elements being 4.\n    Expected output: 1\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, as removing any two elements will change the mean.\n    if n == 3:\n        return 0\n\n    (rest of the code)\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. This involves calculating the mean of the entire array and then checking each pair of elements to see if their deletion maintains the mean. Given the constraints, a brute force approach is not feasible, so an efficient algorithm is necessary.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of valid pairs\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements\n- Optimize the solution for performance\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if their deletion maintains the mean. Given the constraints, we need to ensure our solution is optimized for performance, handling up to 2 \u22c5 10^5 elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not directly used in the requirement, but the concept of mean implies a comparison of quantities.\n\n# [degree adverb] \n    'largest': This phrase is not directly used in the requirement, but the concept of mean implies a comparison of quantities.\n\n# [code logic]\n    To solve this problem, we need to follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after deleting the elements at positions i and j.\n    4. Count the number of pairs that maintain the original mean.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: Since the array has only 3 elements, deleting any two elements will leave us with a single element, which cannot have the original mean. Thus, the expected output is 0.\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. There are two pairs [1, 2] and [2, 3] that can be deleted to maintain the mean of 2.5. Thus, the expected output is 2.\n    Edge case 3:\n    Input: n = 5, a = [1, 3, 2, 4, 5]\n    Explanation: The original mean is (1+3+2+4+5)/5 = 3. There are no pairs that can be deleted to maintain the mean of 3, as all elements are distinct and cannot be removed without changing the mean. Thus, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only 3 elements, as described in edge case 1.\n    def count_pairs(n, a):\n        if n == 3:\n            return 0\n        # Continue with the main logic for larger arrays\n        mean = sum(a) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                new_sum = sum(a[:i]) + sum(a[i+1:j]) + sum(a[j+1:])\n                new_n = n - 2\n                if new_sum / new_n == mean:\n                    count += 1\n        return count\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. This requires a thorough understanding of arithmetic mean calculations and efficient iteration through the array to find the required pairs.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Develop a function to iterate through the array and find pairs [i, j] that meet the criteria.\n- Ensure the solution is optimized to handle up to 2 * 10^5 elements efficiently.\n- Add error handling to manage unexpected input scenarios.\n- Include unit tests to verify the correctness and robustness of the solution.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the arithmetic mean of the array and then iterate through the array to find pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k. The solution will be optimized to handle up to 2 * 10^5 elements efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that after removing the elements at these indices, the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the sum of the elements at the indices is greater than the original mean multiplied by the number of remaining elements.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest possible pairs that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the sum of the remaining elements is equal to the arithmetic mean multiplied by (n - 2).\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 6\n    Explanation: In this case, the arithmetic mean is 1, and there are 6 pairs that can be removed to keep the mean unchanged.\n    search([2, 2, 2, 2]) = 6\n    Explanation: Similar to the previous edge case, the arithmetic mean is 2, and there are 6 pairs that can be removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases.\n\n# [code logic]\n    Here's the Python code to implement the logic described:\n\n    ```python\n    def count_pairs(n, arr):\n        mean = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean:\n                    count += 1\n        return count\n\n    # Example usage:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(count_pairs(n, arr))\n    ```\n\n    This code will read the number of test cases and then for each test case, it will read the number of elements and the elements themselves. It will then calculate the number of valid pairs and print the result.\n"], "scores": [], "pass_results": [true, false, false, true, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 566, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 451}
