{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4,\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4,\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef eversion_count(arr: List[int]) -> int:\n    def stable_partition(arr: List[int], pivot: int) -> List[int]:\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def is_stable(arr: List[int], arr_next: List[int]) -> bool:\n        return all(arr[i] == arr_next[i] for i in range(len(arr)))\n\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    pivot = arr[-1]\n    arr_next = stable_partition(arr, pivot)\n    count = 1\n\n    while not is_stable(arr, arr_next):\n        arr = arr_next\n        pivot = arr_next[-1]\n        arr_next = stable_partition(arr, pivot)\n        count += 1\n\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef func(n: int, a: List[int]) -> int:\n    def eversion(arr: List[int]) -> List[int]:\n        x = arr[-1]\n        left = [el for el in arr if el <= x]\n        right = [el for el in arr if el > x]\n        return left + right\n\n    count = 0\n    while True:\n        original_array = a.copy()\n        a = eversion(a)\n        if a == original_array:\n            break\n        count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = func(n, a)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_eversions(n: int, arr: List[int]) -> int:\n    def stable_partition(arr: List[int], pivot: int) -> List[int]:\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def is_stable_partition(arr: List[int]) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i-1] > arr[i]:\n                return False\n        return True\n\n    k = 0\n    while not is_stable_partition(arr):\n        pivot = arr[-1]\n        arr = stable_partition(arr, pivot)\n        k += 1\n    return k\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_min_eversions(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> int:\n    def partition(arr, pivot):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def stable_partition(arr, pivot):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def find_largest_element(arr):\n        return max(arr)\n\n    eversion_count = 0\n    while True:\n        largest_element = find_largest_element(arr)\n        arr = stable_partition(arr, largest_element)\n        eversion_count += 1\n        if arr == stable_partition(arr, largest_element):\n            break\n    return eversion_count\n\n# Provide the Interface\narr_input = input().split()\narr_input = [int(num) for num in arr_input]\nresult = eversion_operation(arr_input)\nprint(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot element\n    and then concatenating the partitions while maintaining stability. The pivot\n    element is the last element of the array.\n    \n    Args:\n        arr (list): The input array to perform the eversion operation on.\n        \n    Returns:\n        list: The array after performing the eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = arr[-1]\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return left + right\n\ndef main():\n    arr_input = input()\n    arr = list(map(int, arr_input.split()))\n    result = eversion_operation(arr)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> int:\n    def partition(arr, pivot):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def is_stable_partition(arr):\n        for i in range(len(arr)):\n            if arr[i] != arr[i - 1]:\n                return False\n        return True\n\n    count = 0\n    while not is_stable_partition(arr):\n        pivot = arr[-1]\n        left, right = partition(arr, pivot)\n        arr = left + right\n        count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef eversion_count(arr: list) -> int:\n    def partition(sub_arr):\n        pivot = sub_arr[-1]\n        left = [x for x in sub_arr[:-1] if x <= pivot]\n        right = [x for x in sub_arr[:-1] if x > pivot]\n        return left, right, pivot\n\n    def is_stable(arr, next_arr):\n        return arr == next_arr\n\n    count = 0\n    while True:\n        left, right, pivot = partition(arr)\n        next_arr = left + [pivot] + right\n        count += 1\n        if is_stable(arr, next_arr):\n            break\n        arr = next_arr\n\n    return count\n\n# Interface\ninput = sys.stdin.read\nn = int(input().strip())\nfor _ in range(n):\n    arr_len = int(input().strip())\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\nfrom itertools import stable_partition\n\ndef eversion_operation(arr: List[int]) -> int:\n    def partition(arr, pivot):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    pivot = arr[-1]\n    left, right = partition(arr, pivot)\n    iterations = 0\n\n    while not is_sorted(left + right):\n        left, right = partition(left + right, pivot)\n        iterations += 1\n\n    return iterations\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    a = list(map(int, input().split()))\n    result = eversion_operation(a)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef eversion_operation(arr: list) -> int:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    original_arr = arr[:]\n    eversion_count = 0\n\n    while True:\n        quick_sort(arr, 0, n - 1)\n        if arr == original_arr:\n            break\n        arr = original_arr\n        eversion_count += 1\n\n    return eversion_count\n\n# Provide the Interface\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\nresult = eversion_operation(arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_eversion(arr: List[int]) -> int:\n    def stable_partition(sub_arr: List[int], pivot: int) -> (List[int], List[int]):\n        left = [x for x in sub_arr if x <= pivot]\n        right = [x for x in sub_arr if x > pivot]\n        return left, right\n\n    def eversion(arr: List[int]) -> List[int]:\n        if not arr:\n            return arr\n        pivot = arr[-1]\n        left, right = stable_partition(arr[:-1], pivot)\n        return left + [pivot] + right\n\n    count = 0\n    while True:\n        new_arr = eversion(arr)\n        if new_arr == arr:\n            break\n        arr = new_arr\n        count += 1\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr_len = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_eversion(arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires an algorithm that can handle multiple test cases efficiently. The input size can be large, so the solution must be optimized for performance. The output should be accurate and match the expected result for each test case. The solution should be clear and easy to understand.\nrequirement pool:\n- Implement the eversion operation and ensure it is stable.\n- Optimize the algorithm for large inputs.\n- Ensure the output is accurate for each test case.\n- Provide a user-friendly interface for input and output.\n- Include error handling for invalid inputs.\nTo solve this problem, we will implement a function that performs the eversion operation on an array and counts the number of iterations until the array stops changing. We will use Python, which is well-suited for handling large inputs efficiently. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. We will use a stable sorting algorithm to partition the array efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability.\n    Explanation: The eversion operation splits the array into two parts based on a chosen pivot (the last element in this case), where the left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. This operation is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This indicates that we need to find elements greater than a certain value.\n    Explanation: In the context of the eversion operation, this phrase is used to define the right partition of the array, which contains elements strictly greater than the pivot.\n\n# [degree adverb] \n    'largest': This indicates that we need to find the largest element in the array.\n    Explanation: In the context of the eversion operation, finding the largest element helps in determining the pivot for the next iteration.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Identify the pivot (the last element of the array).\n    2. Partition the array into two parts based on the pivot.\n    3. Concatenate the two parts while maintaining stability.\n    4. Repeat the process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array does not change after the first eversion since all elements are equal. Therefore, the number of eversions is 0.\n    Edge case 2: [2, 1, 3, 4, 5] = 2\n    Explanation: The array changes after the first eversion to [1, 2, 3, 4, 5], and then it stops changing after the second eversion.\n    Edge case 3: [5, 4, 3, 2, 1] = 1\n    Explanation: The array changes after the first eversion to [4, 3, 2, 1, 5], and then it stops changing after the second eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle arrays that do not change after the first eversion, as well as arrays that change after multiple eversions.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and its effect on the array's stability. The solution should be able to handle multiple test cases efficiently, which implies the need for an optimized algorithm. The input size can be large, so the solution should be designed with scalability in mind.\nrequirement pool:\n- Implement the eversion operation and ensure it is applied correctly to determine stability.\n- Develop an algorithm that can handle multiple test cases efficiently.\n- Ensure the solution is optimized for large inputs and handles edge cases effectively.\n- Provide clear and accurate output for each test case.\n- Test the solution against various inputs to verify its correctness and robustness.\nTo solve this problem, we will use a stable partitioning technique to simulate the eversion operation. The key is to repeatedly apply the eversion operation until the array no longer changes. We will use Python's built-in list operations to efficiently partition and concatenate the array. The algorithm will be designed to handle multiple test cases efficiently, ensuring it meets the performance requirements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'stable partitioning': This is the process of dividing an array into two parts based on a pivot element, where the order of elements in each part is preserved. The eversion operation in this problem is a specific application of this concept.\n    Explanation: The eversion operation involves partitioning the array into two parts based on a pivot element (in this case, the last element of the array), where the left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. This partitioning is stable, meaning the relative order of elements in each part is maintained.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an element in the array that appears more than once.\n    Explanation: In the requirement, we need to find the largest integer that appears at least as many times as the integer itself. This implies that we need to check the frequency of each element in the array and find the one that meets this condition.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: The requirement asks for the largest integer that satisfies the condition of appearing at least as many times as itself. This means we need to compare the frequencies of all elements in the array and find the one with the highest value that meets the specified condition.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. For each test case, perform the eversion operation repeatedly until the array no longer changes.\n    3. Count the number of eversions performed to reach the stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 1, 1] = 0\n    Explanation: The array already stops changing after the first eversion because all elements are the same. The array [1, 1, 1] becomes [1, 1, 1] after the first eversion, so the number of eversions is 0.\n    Edge case 2: [2, 2, 3, 3, 3] = 0\n    Explanation: The array already stops changing after the first eversion because all elements are the same. The array [2, 2, 3, 3, 3] becomes [2, 2, 3, 3, 3] after the first eversion, so the number of eversions is 0.\n    Edge case 3: [5, 5, 4, 4, 4] = 0\n    Explanation: The array already stops changing after the first eversion because all elements are the same. The array [5, 5, 4, 4, 4] becomes [4, 4, 4, 5, 5] after the first eversion, so the number of eversions is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic is sufficient to determine if the array stops changing after the first eversion.\n", "requirement analysis:\nThe problem requires the implementation of an algorithm that can perform eversions on an array until it stops changing. The input consists of multiple test cases, each with a different array length and elements. The output should be the minimum number of eversions for each test case. The solution must be efficient to handle large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation and ensure the array stops changing.\n- Handle multiple test cases efficiently.\n- Optimize the solution for large inputs.\n- Ensure the output is clear and accurate for each test case.\n- Provide a user-friendly interface for input and output.\nTo solve this problem, we will implement a function that performs eversions on an array until it stops changing. The function will iterate through the array, partitioning it into left and right parts based on a pivot element, and then concatenate these parts back together. We will use a stable partition algorithm to ensure the order of elements in each part is preserved. The function will count the number of eversions required for the array to stop changing, which is determined when the array no longer changes after an eversion. We will optimize the solution for large inputs by using efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array into two parts based on a pivot element and then concatenating these parts back together, maintaining the order of elements within each part. The process is repeated until the array no longer changes.\n    Explanation: The eversion operation is a transformation applied to an array that splits it into two subarrays based on a chosen pivot element, ensuring the order of elements within each subarray is preserved. This process is repeated iteratively until the array stabilizes, meaning no further changes occur.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value in the array.\n    Explanation: For example, if the array is [5, 5, 4, 4, 4], the number 2 does not appear more than twice, while numbers 3 and 4 appear more than their respective values (3 times and 4 times, respectively).\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer that meets the condition of appearing more than its value.\n    Explanation: For instance, in the array [4, 1, 2, 2, 3, 1], the number 2 is the largest integer that appears more than twice.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Iterate through the array to find the pivot element for each eversion.\n    2. Partition the array into left and right parts based on the pivot.\n    3. Concatenate the left and right parts to form the new array.\n    4. Repeat the process until the array no longer changes.\n    5. Count the number of eversions performed.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 1\n    Explanation: All elements are the same, so after the first eversion, the array becomes [1, 1, 1, 1], which does not change.\n    search([2, 2, 1, 1]) = -1\n    Explanation: The number 2 appears twice, which is more than its value, but the number 1 also appears twice, which is more than its value. Since no single integer appears more than its value, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the largest integer that appears more than its value is already included in the main code logic.\n\n## Prompt 3:\n[requirement]\nYou are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput Each test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows. The first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5). The second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9). It is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput For each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n------- Important Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample Input 3 5 2 4 1 5 3 5 5 3 2 4 1 4 1 1 1 1 Output 1 2 0 Note Consider the fist example. The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. Consider the second example. The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2.\n\n[plan]\nTo solve this problem, we will implement a function that performs eversions on an array until it stops changing. The function will iterate through the array, partitioning it into left and right parts based on a pivot element, and then concatenate these parts back together. We will use a stable partition algorithm to ensure the order of elements in each part is preserved. The function will count the number of eversions required for the array to stop changing, which is determined when the array no longer changes after an eversion. We will optimize the solution for large inputs by using efficient data structures and algorithms.\n\n## Answer 3:\n\n# [core concept]\n    'eversion operation': This involves partitioning an array into two parts based on a pivot element and then concatenating these parts back together, maintaining the order of elements within each part. The process is repeated until the array stabilizes, meaning no further changes occur.\n    Explanation: The eversion operation is a transformation applied to an array that splits it into two subarrays based on a chosen pivot element, ensuring the order of elements within each subarray is preserved. This process is repeated iteratively until the array stabilizes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value in the array.\n    Explanation: For example, if the array is [5, 5, 4, 4, 4], the number 2 does not appear more than twice, while numbers 3 and 4 appear more than their respective values (3 times and 4 times, respectively).\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer that meets the condition of appearing more than its value.\n    Explanation: For instance, in the array [4, 1, 2, 2, 3, 1], the number 2 is the largest integer that appears more than twice.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Iterate through the array to find the pivot element for each eversion.\n    2. Partition the array into left and right parts based on the pivot.\n    3. Concatenate the left and right parts to form the new array.\n    4. Repeat the process until the array no longer changes.\n    5. Count the number of eversions performed.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 1\n    Explanation: All elements are the same, so after the first eversion, the array becomes [1, 1, 1, 1], which does not change.\n    search([2, 2, 1, 1]) = -1\n    Explanation: The number 2 appears twice, which is more than its value, but the number 1 also appears twice, which is more than its value. Since no single integer appears more than its value, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the largest integer that appears more than its value is already included in the main code logic.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array as described. The operation involves partitioning the array based on a pivot element and then reassembling the array. The challenge lies in efficiently handling the partitioning and reassembling process, especially given the constraint on the size of the array.\nrequirement pool:\n- Implement the eversion operation on an array.\n- Ensure the array partitioning is stable.\n- Provide a clear and user-friendly interface to display the array after each eversion.\n- Allow users to input the size and elements of the array.\n- Optimize the algorithm to handle large arrays efficiently.\nTo implement the eversion operation on an array in Python, we will use a stable partition algorithm to ensure the order of elements in each part is maintained. We will define a function that takes an array and performs the eversion operation, returning the number of eversions required for the array to stop changing. The function will also print the array after each eversion for user visibility.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element (x), and then concatenating the partitioned parts back together. The partitioning is stable, meaning the relative order of elements in each part is preserved.\n    Explanation: The eversion operation is a specific way to rearrange the elements of an array by repeatedly partitioning it around a pivot element and then concatenating the parts. The goal is to determine how many such operations are needed for the array to reach a stable state where further operations do not change the array.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element (x) must be greater than the elements in the left part and less than the elements in the right part.\n    'at least as many times': Refers to the number of times a pivot element appears in the array, which must be at least as many as the value of the pivot itself.\n\n# [degree adverb] \n    'largest': The pivot element (x) should be the largest element in the array to ensure a meaningful partition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Find the largest element in the array to use as the pivot.\n    2. Partition the array into two parts based on the pivot.\n    3. Concatenate the left and right parts and update the array.\n    4. Repeat the process until the array no longer changes.\n    5. Return the number of eversions performed.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The array is already sorted in ascending order. The first eversion will partition it into [1, 2, 3] and [4, 5], and no further eversions are needed as the array does not change.\n    search([5, 4, 3, 2, 1]) = 1\n    Explanation: The array is sorted in descending order. The first eversion will partition it into [1, 4, 3, 2] and [5], and no further eversions are needed as the array does not change.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the largest element and perform the partition is sufficient to determine the number of eversions.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array, which involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. The secondary requirement is to provide a clear and user-friendly interface for displaying the array state after each eversion operation.\nrequirement pool:\n- Implement the eversion operation on an array.\n- Ensure the array partition is stable.\n- Provide a user interface to display the array state after each eversion operation.\n- Handle large arrays efficiently.\n- Allow users to visualize the eversion process.\nTo implement the eversion operation on an array, we will use Python's built-in data structures and list operations. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. We will use the stable partition feature of Python's list comprehension to achieve this. The primary challenge is to ensure that the partition is stable and to provide a clear user interface for displaying the array state after each eversion operation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. The pivot element is the last element of the array in this case.\n    Explanation: The eversion operation splits the array into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. This operation is repeated until the array no longer changes, indicating the number of eversions needed.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the number of times the array needs to be everted to reach a stable state.\n    Explanation: The phrase 'more than' is used to determine the number of eversions required to reach a stable state.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the number of eversions needed to reach the largest stable state.\n    Explanation: The degree adverb 'largest' is used to find the maximum number of eversions that can be performed on the array to reach a stable state.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to follow these steps:\n    1. Identify the pivot element, which is the last element of the array.\n    2. Partition the array into two parts: elements less than or equal to the pivot and elements greater than the pivot.\n    3. Concatenate the two partitions while maintaining stability.\n    4. Repeat the process until the array no longer changes.\n    5. Count the number of eversions performed.\n\n# [edge case] \n    eversion([1, 2, 3, 4, 5]) = 0\n    Explanation: The array is already in a stable state, so no eversions are needed.\n    eversion([5, 4, 3, 2, 1]) = 4\n    Explanation: The array needs to be everted 4 times to reach a stable state: [1, 4, 3, 2, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5].\n    eversion([1, 3, 2, 4, 5]) = 2\n    Explanation: The array needs to be everted 2 times to reach a stable state: [1, 2, 3, 4, 5], [1, 2, 3, 4, 5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle the edge cases by checking if the array is already stable or not.\n", "requirement analysis:\nThe requirements specify the need for a function that can perform eversion operations on an array and output the number of eversions after which the array stops changing. The function should be able to handle multiple test cases efficiently. The input is provided through standard input, and the output should be printed to standard output.\nrequirement pool:\n- Implement the eversion operation on the array.\n- Handle multiple test cases efficiently.\n- Ensure the output includes the number of eversions after which the array stops changing.\n- Provide a user-friendly interface for input and output.\nWe will implement the eversion operation using Python's built-in data structures and list operations. The function will iterate through the array, partitioning it into two parts based on the pivot element, and then concatenate these parts. This process will be repeated until the array stops changing. The function will count the number of iterations required to reach this state and return this count.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element and then concatenating the partitioned parts. The partitioning is stable, meaning the order of elements in each part remains the same as before the operation.\n    Explanation: The eversion operation is a specific way to rearrange the elements of an array, focusing on how often a particular element (pivot) can act as a dividing point.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find an element that appears more times than its value in the array.\n    Explanation: For example, in the array [2, 2, 3, 3, 3], the number 3 appears more than three times, which is more than its value.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest element that meets the condition of appearing more times than its value.\n    Explanation: For instance, in the array [3, 3, 2, 4, 4, 4], the number 4 is the largest element that appears more than four times, which is more than its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Identify the pivot element (x).\n    2. Partition the array into two parts: left (\u2264 x) and right (> x).\n    3. Concatenate the left and right parts.\n    4. Repeat the process until the array stops changing.\n    5. Count the number of iterations required to reach this state.\n\n# [edge case] \n    search([1, 1, 1, 2, 2]) = 1\n    Explanation: The number 1 appears more than once, which is more than its value.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The number 3 appears more than three times, which is more than its value.\n    search([4, 4, 4, 4, 3]) = -1\n    Explanation: No number appears more than its value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle cases where no element meets the condition by returning -1.\n", "requirement analysis:\nThe primary requirement is to determine the number of eversions required for an array to stabilize. The array is partitioned based on a pivot element, and the partitioning is stable. The goal is to find the number of iterations after which the array no longer changes. This requires implementing a loop that continues until the array remains unchanged after an eversion operation.\nrequirement pool:\n- Implement the eversion operation to partition the array.\n- Create a loop to repeatedly apply the eversion operation until the array stabilizes.\n- Count the number of iterations until the array stops changing.\n- Optimize the algorithm to handle large arrays efficiently.\n- Ensure the application is user-friendly and provides clear results.\nTo implement the eversion operation and determine the number of iterations required for an array to stabilize, we will use Python's built-in data structures and standard library functions. The eversion operation involves partitioning the array based on a pivot element, which will be the last element of the array for simplicity. We will use list comprehensions for partitioning, which are efficient and straightforward. The main challenge is to ensure the algorithm is efficient enough to handle large arrays up to 2 * 10^5 elements. We will optimize the partitioning process and count the iterations until the array stops changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is the last element of the array. The array is then split into two parts: one containing elements not greater than the pivot and the other containing elements strictly greater than the pivot. The order of elements in each part is preserved.\n    Explanation: The eversion operation is a transformation applied to an array where a pivot element (the last element of the array) is used to divide the array into two subarrays. The left subarray contains elements not greater than the pivot, and the right subarray contains elements strictly greater than the pivot. This operation is applied iteratively until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements in the array that are strictly greater than a certain value.\n    Explanation: In the context of the eversion operation, 'more than' is used to define the elements that will be placed in the right subarray. These are the elements that are strictly greater than the pivot element.\n\n# [degree adverb] \n    'largest': This adverb suggests that we are looking for the largest element in the array to use as the pivot.\n    Explanation: In the eversion operation, the largest element is chosen as the pivot because it helps to ensure that the array is divided into two parts more effectively, with the left part containing smaller elements and the right part containing larger elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to follow these steps:\n    1. Identify the pivot element, which is the last element of the array.\n    2. Partition the array into two parts based on the pivot element.\n    3. Concatenate the left and right parts to form the new array.\n    4. Repeat the process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] = 1\n    Explanation: The array is already sorted in ascending order, so the first eversion operation will partition it into [1, 2, 3, 4] and [5], and the array stops changing after one iteration.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The array is sorted in descending order, so the first eversion operation will partition it into [5, 4, 3, 2] and [1], and the array stops changing after one iteration.\n    Edge case 3: [2, 2, 2, 2, 2] = 1\n    Explanation: All elements in the array are the same, so the first eversion operation will partition it into [2, 2, 2, 2] and [2], and the array stops changing after one iteration.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work correctly for arrays with all identical elements, as well as for sorted arrays in either ascending or descending order.\n", "requirement analysis:\nThe requirements specify the need for a program that can analyze an array and determine the number of eversions required for the array to stop changing. The program should be able to handle large inputs efficiently and provide clear, accurate output. The user interface should be intuitive and user-friendly, making it easy for users to understand the results and interact with the program.\nrequirement pool:\n- The main code should efficiently handle the eversion operation and partition of the array.\n- The program should provide clear and accurate output for the number of eversions.\n- The user interface should be intuitive and easy to use.\n- The program should handle large inputs without slowing down or freezing.\nTo implement the eversion operation and partition of the array efficiently, we will use Python's built-in data structures and algorithms. The main challenge is to ensure that the partitioning is stable and the program handles large inputs without performance issues. We will use the 'stable_partition' function from Python's 'itertools' module to maintain the stability of the partition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partition': the process of dividing a list into two parts based on a condition.\n    Explanation: In the requirement, the array is divided into two parts: left (elements \u2264 x) and right (elements > x). This is crucial for the eversion operation to maintain the order of elements within each part.\n\n# [phrase showing quantity relationship]\n    'more than': means that the elements in the right part are strictly greater than x.\n    'at least as many times': means that the frequency of an element in the array is greater than or equal to the element itself.\n\n# [degree adverb] \n    'largest': means that the integer in the right part is the biggest among those that are strictly greater than x.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we need to:\n    1. Identify the pivot element x as the last element of the array.\n    2. Partition the array into two parts based on the pivot.\n    3. Check if the array has changed after the partition. If it has, repeat the process with the new partitioned array.\n    4. Count the number of iterations until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so it does not change after the first partition.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is sorted in descending order, so it becomes [3, 2, 1, 5, 4] after the first partition and stops changing afterward.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly count the number of iterations for these cases.\n", "requirement analysis:\nThe requirement involves understanding and implementing the eversion operation on an array. The operation involves partitioning the array based on a pivot element and then reassembling the array with the partitioned parts. The challenge lies in efficiently handling the partitioning and reassembling process, especially given the constraint of the array length being up to 2 * 10^5.\nrequirement pool:\n- Implement the eversion operation as described.\n- Ensure the partitioning process is stable and maintains the order of elements.\n- Handle the input and output as specified in the problem statement.\n- Optimize the code to handle large inputs efficiently.\n- Include user feedback mechanisms to continuously improve the product.\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and list comprehensions for partitioning. The eversion operation involves repeatedly partitioning the array based on a pivot element and reassembling the array. We will ensure that the partitioning is stable and maintain the order of elements. The main challenge is to handle large inputs efficiently, which Python's dynamic typing and list operations can manage effectively.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element and reassembling the array while maintaining the order of elements. The pivot element is the last element of the array in this case.\n    Explanation: The eversion operation splits the array into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. This operation is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will follow these steps:\n    1. Identify the pivot element, which is the last element of the array.\n    2. Partition the array into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot.\n    3. Reassemble the array with the partitioned parts.\n    4. Repeat the process until the array no longer changes.\n    5. Count the number of eversions performed.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted, so only one eversion is needed to sort it back to its original state.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 4\n    Explanation: The array is in reverse order, so it takes 4 eversions to sort it into its original state.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: The array requires 2 eversions to reach its sorted state.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic can handle them by counting the number of eversions required to sort the array.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and implementing a stable partition algorithm. The solution should be efficient enough to handle large inputs within the given constraints. The output should be accurate for each test case, providing the minimum number of eversions after which the array stops changing.\nrequirement pool:\n- Implement the eversion operation and stable partition algorithm.\n- Ensure the solution is optimized for large inputs.\n- Provide accurate output for each test case.\n- Handle edge cases and ensure the solution is robust.\n- Improve user interface for easy input and output.\nTo solve the problem of determining the number of eversions for a given array, we will implement a function that performs the eversion operation iteratively until the array stops changing. We will use Python's built-in data structures and list operations to ensure efficiency and simplicity. The eversion operation involves partitioning the array based on a pivot element, which will be the last element of the array in this implementation. We will use a stable partition algorithm to maintain the order of elements in each part. The function will return the number of iterations required for the array to stabilize.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitioned parts. The order of elements in each part is kept the same.\n    Explanation: The eversion operation is a transformation of the array where the array is split into two parts based on a pivot (the last element of the array), and then these parts are concatenated back together in a sorted order. This process is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more times than its value.\n    'at least as many times': This phrase indicates that we need to find an integer whose frequency is greater than or equal to its value.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more times than its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Identify the pivot element (the last element of the array).\n    2. Partition the array into two parts based on the pivot element.\n    3. Concatenate the two parts in a stable manner.\n    4. Repeat the process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already stops changing after the first eversion since all elements are the same.\n    Edge case 2: [2, 1, 3, 3, 2] = 1\n    Explanation: The first eversion will result in [1, 2, 2, 3, 3], and the array stops changing after this eversion.\n    Edge case 3: [5, 4, 3, 2, 1] = 5\n    Explanation: The array will need to be everted 5 times to reach [1, 2, 3, 4, 5], where it stops changing.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already stable or has all identical elements.\n    For example, if the array is [1, 1, 1], we can immediately return 0 as the array does not change.\n    If the array is [1, 2, 3, 4, 5], we can immediately return the length of the array minus 1 as the array will stabilize after that many eversions.\n"], "scores": [], "pass_results": [false, false, false, true, false, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 85, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "expand_one2two", "parent_index": 8}
