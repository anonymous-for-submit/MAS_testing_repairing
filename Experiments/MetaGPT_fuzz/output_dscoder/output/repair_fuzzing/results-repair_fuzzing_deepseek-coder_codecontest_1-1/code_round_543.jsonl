{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. It is important to note that k might not be an integer, although it is a possibility. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array has fewer elements or all elements are equal.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. It is important to note that k might not be an integer, although it is a possibility. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array has fewer elements or all elements are equal.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a with n integers. The mean, k, of these elements is calculated by dividing the sum of the elements by the number of elements (n). It's important to note that k might not be an integer. The task is to find the number of pairs of positions [i, j] (where i < j) in the array such that removing the elements at these positions results in the mean of the remaining (n - 2) elements being equal to k. This means the mean of the original array and the mean of the remaining elements should be the same. Consider scenarios where the array has\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers. The mean k of these elements might not be an integer. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. Consider cases with fewer elements or all elements equal.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Count the occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Initialize the count of pairs\n    pair_count = 0\n    \n    # Iterate through all possible pairs of elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting the pair (i, j)\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of the remaining elements is still equal to the original mean\n            if remaining_sum / remaining_count == mean:\n                pair_count += 1\n    \n    return pair_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], mean: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum after removing the elements at indices i and j\n            new_sum = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Check if the new mean is still equal to the original mean\n            if sum(new_sum) / (n - 2) == mean:\n                count += 1\n    \n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean = sum(arr) / n\n    result = calculate_pairs(arr, mean)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr, mean_value):\n    \"\"\"\n    This function calculates the number of pairs of positions [i, j] (where i < j) in the array\n    such that removing the elements at these positions results in the mean of the remaining\n    (n - 2) elements being equal to the mean of the original array.\n\n    Args:\n        arr (list): A list of integers representing the array.\n        mean_value (float): The mean of the original array.\n\n    Returns:\n        int: The number of pairs of positions [i, j] that satisfy the condition.\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    # Check if the array has only 3 elements\n    if n == 3:\n        return 0\n\n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return (n * (n - 1)) // 2\n\n    # Iterate through all possible pairs of positions (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the mean of the remaining elements after removing elements at positions i and j\n            remaining_elements = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(remaining_elements) >= 2:\n                remaining_mean = sum(remaining_elements) / len(remaining_elements)\n                if remaining_mean == mean_value:\n                    count += 1\n\n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nmean_value = sum(arr) / n\n\n# Calculate and print the result\nresult = find_pairs(arr, mean_value)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_of_positions(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    if n == 3:\n        return 0\n    if all(element == arr[0] for element in arr):\n        return (n * (n - 1)) // 2\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_of_positions(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr and sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the mean of the array\nmean_value = sum(arr) / n\n\n# Find and print the number of valid pairs\nresult = find_pairs(arr, mean_value)\nprint(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Use a hash table to store the counts of the differences\n    diff_count = {}\n    \n    # Iterate through all possible pairs [i, j] (i < j) in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Calculate the difference from the mean\n            diff = remaining_sum - (remaining_count * mean)\n            \n            # Increment the count of this difference in the hash table\n            if diff in diff_count:\n                diff_count[diff] += 1\n            else:\n                diff_count[diff] = 1\n    \n    # Count the number of pairs that result in the same difference\n    for diff, freq in diff_count.items():\n        count += freq * (freq - 1) // 2\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # If all elements are the same, handle the edge case\n    if all(element == arr[0] for element in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for element in arr:\n        element_count[element] = element_count.get(element, 0) + 1\n    \n    # Iterate through the dictionary to find valid pairs\n    for element_i, count_i in element_count.items():\n        for element_j, count_j in element_count.items():\n            if element_i < element_j:\n                new_sum = total_sum - element_i - element_j\n                if new_sum / (n - 2) == mean:\n                    count += count_i * count_j\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs [i, j] (i < j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after deleting arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            \n            # Check if the mean of the remaining elements is equal to the mean of the original array\n            if remaining_sum / remaining_count == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0  # It's impossible to delete two elements from fewer than 3 elements\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = calculate_pairs(n, arr)\nprint(result)\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the original mean of the array. The input consists of multiple test cases, each with a specific number of elements and their values. The output should be the count of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices [i, j] to delete.\n- Ensure the solution is optimized for large inputs.\n- Handle edge cases where the array has fewer elements or all elements are equal.\n- Provide clear and concise output for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to find pairs of indices [i, j] such that deleting the elements at these positions maintains the original mean of the array. We will first calculate the mean of the array and then iterate through all possible pairs of indices to check if deleting them maintains the mean. We will optimize the solution to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers. It is calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a certain condition must be met by a certain quantity.\n\n# [degree adverb] \n    'largest': Indicates the maximum or best possible value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. Check if deleting the elements at these positions maintains the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with fewer elements\n    search([1, 2]) = 0\n    Explanation: With only two elements, there are no pairs to delete, so the result is 0.\n\n    Edge case 2: All elements are equal\n    search([3, 3, 3]) = 1\n    Explanation: There is only one pair [0, 1] to delete, which will maintain the mean.\n\n    Edge case 3: Array with all zeros\n    search([0, 0, 0]) = 3\n    Explanation: All pairs [i, j] where i < j are valid, so the result is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    To handle edge cases where the array has fewer elements or all elements are equal, we can add specific checks:\n    if n < 3:\n        return 0\n    if all(x == a[0] for x in a):\n        return n * (n - 1) // 2\n\n    (other code)\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions to delete from an array such that the mean remains unchanged. This requires summing the elements, calculating the mean, and then checking pairs of elements to see if their deletion maintains the same mean. The constraints are large inputs, so optimization is crucial.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through pairs of positions and check if deleting them maintains the mean.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the solution is user-friendly and can handle edge cases, such as all elements being equal.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the mean of the array and then find pairs of elements whose deletion does not change the mean. We will use a dictionary to count the occurrences of each element to avoid recalculating the sum for each pair. This approach ensures that the solution is optimized for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of elements in an array such that the mean of the remaining elements remains the same after their deletion. This involves calculating the mean of the entire array and then checking if the mean of any subset of the array (excluding two elements) equals this value.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the deletion of two elements does not change the mean.\n    Explanation: We need to ensure that the sum of the remaining elements divided by their count equals the original mean.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest possible pairs that meet the condition.\n    Explanation: This suggests that we should consider pairs with the highest values first to optimize the solution.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we can follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Use a dictionary to count the occurrences of each element.\n    3. Iterate through all possible pairs of elements and check if their deletion does not change the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with fewer elements\n    search([1, 2]) = 0\n    Explanation: With only two elements, there are no pairs to delete, so the result is 0.\n\n    Edge case 2: All elements are equal\n    search([5, 5, 5]) = 1\n    Explanation: Any two elements can be deleted, and the mean will remain the same. There is only one pair in this case.\n\n    Edge case 3: Array with all zeros\n    search([0, 0, 0]) = 3\n    Explanation: Any two elements can be deleted, and the mean will remain zero. There are three pairs in this case.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle these cases directly.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. The solution must handle edge cases and be efficient enough to process large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] that can be deleted to maintain the original mean.\n- Ensure the solution is optimized for large inputs and handles edge cases.\n- Provide clear and accurate results for each test case.\n- Implement input and output handling to meet the project's requirements.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. We will iterate through the array to find all possible pairs and check if deleting them maintains the mean. The solution will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average of all elements in the array\n    'delete elements': remove specific elements from the array to check the new mean\n\n# [phrase showing quantity relationship]\n    'exactly two elements': we need to remove two specific positions from the array\n\n# [degree adverb] \n    'equal to': the new mean after deletion should be the same as the original mean\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Calculate the original mean (k) of the array.\n    - Iterate through all possible pairs of indices (i, j) where i < j.\n    - For each pair, calculate the new sum after removing the elements at indices i and j.\n    - Check if the new mean is still equal to k.\n    - Count the number of such pairs.\n\n# [edge case] \n    n = 3, a = [1, 1, 1]\n    expected output = 1\n    Explanation:\n    - Original mean (k) = (1 + 1 + 1) / 3 = 1\n    - There is only one pair [0, 1] (0 < 1) which can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than 3 elements, as removing two elements would leave fewer than 3 elements, which is not allowed.\n    - If n < 3:\n        return 0\n\n    (other code)\n", "requirement analysis:\nThe task requires calculating the mean of the array and then finding pairs of positions that, when removed, result in the mean of the remaining elements being equal to the original mean. This involves summing the elements, calculating the mean, and then iterating through the array to find valid pairs. The constraints are such that the solution must be efficient to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when removed, result in the mean of the remaining elements being equal to the original mean.\n- Ensure the solution is efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\n- Provide clear and concise output for the number of such pairs.\nTo solve this problem, we will use Python due to its efficiency and ease of use with large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of positions that, when removed, result in the mean of the remaining elements being equal to the original mean. We will use a nested loop to check all possible pairs of positions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers; calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of positions in an array such that removing those positions results in the mean of the remaining elements being equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where removing two positions results in the mean of the remaining elements being equal to the original mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than a certain number of times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the mean of the remaining elements is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: With only 3 elements, it's impossible to remove any two elements and still have a mean of the remaining elements equal to the original mean.\n\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements are the same, removing any two different elements will not change the mean. The number of such pairs is given by the binomial coefficient (n choose 2).\n\n    Edge case 3: Array has one element significantly larger than the others\n    Expected output: 0\n    Explanation: If one element is much larger than the others, removing any two elements will likely change the mean. Thus, there will be no pairs that satisfy the condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n = 3 or all elements are the same.\n    For n = 3:\n        if n == 3:\n            return 0\n    For all elements being the same:\n        if all(x == a[0] for x in a):\n            return (n * (n - 1)) // 2\n\n    For the case where one element is significantly larger than the others, we can add a condition to check for this scenario and return 0 if true.\n", "requirement analysis:\nThe task requires calculating the mean of an array and then finding pairs of positions that, when removed, result in the mean of the remaining elements being equal to the original mean. This involves summing the elements, calculating the mean, and then iterating through pairs to check the condition. The constraints are high due to the potential size of the input, requiring efficient algorithms to handle large datasets.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when removed, result in the mean of the remaining elements being equal to the original mean.\n- Ensure the solution is optimized for large datasets.\n- Provide clear and concise output for the number of such pairs.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. We will calculate the mean of the array and then iterate through all possible pairs of positions to check if removing them results in the mean of the remaining elements being equal to the original mean. This approach will be optimized to handle large datasets by leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers\n    Explanation: The mean (or average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of positions in an array such that removing those positions results in the mean of the remaining elements being equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where removing two positions results in the mean of the remaining elements being equal to the original mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than a certain number of times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the mean of the remaining elements is equal to the original mean.\n    5. Return the count of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: If there are only three elements in the array, there are no pairs to remove, so the number of valid pairs is 0.\n\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements in the array are the same, any pair of elements can be removed, and the mean of the remaining elements will still be equal to the original mean. The number of such pairs is given by the binomial coefficient (n choose 2).\n\n    Edge case 3: Large array with no specific pattern\n    Expected output: A specific count based on the distribution of elements\n    Explanation: For a large array with no specific pattern, the number of valid pairs will depend on the distribution of the elements. The expected output will be a specific count based on the given constraints and the distribution of the elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n = 3 and where all elements are the same.\n    For n = 3:\n        if n == 3:\n            return 0\n    For all elements being the same:\n        if all(element == a[0] for element in a):\n            return (n * (n - 1)) // 2\n\n    These edge cases require special handling to ensure the function returns the correct number of pairs for each scenario.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions in an array that, when removed, result in the mean of the remaining elements being equal to the original mean. This requires summing the elements, calculating the mean, and then iterating through pairs to check the condition. The challenge lies in handling large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when removed, maintain the original mean.\n- Optimize the solution for large inputs to ensure it runs efficiently.\n- Ensure the output is clear and easy to understand.\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array, then iterating through pairs of positions to check if removing them maintains the mean. We will use a brute-force method initially to ensure correctness, then optimize for larger inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers\n    'pair': a combination of two elements from a set, where order does not matter\n    'removal': the act of taking out elements from a set\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another\n    'at least as many times': means the same or more than\n\n# [degree adverb] \n    'largest': refers to the biggest or greatest in value or size\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the mean of the remaining elements is equal to the mean of the original array.\n    5. Return the count of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    explanation: There are no pairs that can be removed to maintain the mean of the remaining elements equal to the mean of the original array since there are only three elements.\n    search([2, 2, 4, 4]) = 2\n    explanation: The mean of the array is 3. Removing the pairs (0, 1) and (2, 3) results in the mean of the remaining elements being 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient for small arrays. However, for larger arrays, we would need to optimize the approach to handle the constraints efficiently.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. This involves understanding the properties of the mean and how deleting two elements can still maintain the same mean. The solution should be efficient and handle large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a method to find pairs [i, j] such that deleting them maintains the mean.\n- Optimize the solution for large inputs.\n- Ensure the solution is user-friendly and easy to understand.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to find pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. We will first calculate the mean of the entire array and then iterate through all possible pairs to check if their deletion maintains the mean. This approach will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to the mean of the original array.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs [i, j] such that the sum of the remaining elements divided by (n - 2) equals the original mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than or equal to its value.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs [i, j] (i < j) in the array.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n    6. Return the count.\n\n# [edge case] \n    Edge case 1: When all elements in the array are the same.\n    search([5, 5, 5, 5]) = 6\n    Explanation: There are 6 possible pairs to delete to keep the mean unchanged.\n    Edge case 2: When the array has only three elements.\n    search([1, 2, 3]) = 0\n    Explanation: There are no pairs to delete since we need to delete two elements.\n    Edge case 3: When the array has fewer elements than required for deletion.\n    search([1]) = 0\n    Explanation: There are no pairs to delete since we cannot delete two elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can be extended to consider all possible edge cases by checking the number of elements and ensuring that we have at least two elements to delete.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. This involves understanding the mean calculation and iterating through pairs to find valid deletions. The constraints are high, so optimization is crucial.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all pairs [i, j] and check if deleting them keeps the mean unchanged.\n- Optimize the solution to handle large inputs efficiently.\n- Ensure the output is accurate for each test case.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all pairs [i, j] to check if deleting them keeps the mean unchanged. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the elements at these positions is significantly larger than the mean.\n    Explanation: This phrase is not directly used in the requirement, but understanding the relationship between the sum of elements and the mean is crucial for solving the problem.\n\n# [degree adverb] \n    'largest': means that we need to find the largest possible pairs that meet the condition.\n    Explanation: This phrase indicates that we should consider the largest possible pairs first, which helps in optimizing the solution.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all pairs [i, j] (i < j) and check if deleting the elements at these positions keeps the mean unchanged.\n    3. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to delete two elements and still have the mean unchanged.\n\n    Edge case 2: n = 4, array = [2, 2, 2, 2]\n    Expected output: 6\n    Explanation: All elements are the same, so deleting any two elements will keep the mean unchanged. There are 6 possible pairs to delete.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all(element == array[0] for element in array):\n            return n * (n - 1) // 2\n\n    This code calculates the number of pairs when all elements are identical, which is a specific edge case that needs to be handled separately.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. This involves summing the elements, calculating the mean, and then checking if removing two specific elements maintains the mean. The solution must be efficient and handle large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] that maintain the mean after deletion.\n- Ensure the solution is optimized for large inputs.\n- Add error handling for edge cases such as all elements being equal.\n- Provide clear and concise output for the number of valid pairs.\nTo efficiently solve the problem of calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the mean of the array, then iterating through all possible pairs [i, j] to check if their deletion maintains the mean. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to the mean of the original array.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the remaining elements divided by the count of the remaining elements equals the mean of the original array.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than or equal to its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs [i, j] (i < j) and check if deleting the elements at these positions keeps the mean of the remaining elements equal to the mean of the original array.\n    3. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 3\n    Explanation: The mean of the array is 3. The pairs [0, 1], [0, 2], and [1, 2] are the valid pairs because deleting the elements at these positions results in a mean of 3 for the remaining elements.\n    search([1, 1, 1, 1]) = 0\n    Explanation: The mean of the array is 1. There are no pairs [i, j] such that deleting the elements at these positions results in a mean of 1 for the remaining elements because all elements are equal, and deleting any two elements will change the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly check for pairs and count them based on the mean condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer elements or all elements are equal.\n        if n < 3:\n            return 0  # No pairs can be formed with fewer than 3 elements\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2  # All elements are the same, any pair works\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer elements or all elements are equal.\n        if n < 3:\n            return 0  # No pairs can be formed with fewer than 3 elements\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2  # All elements are the same, any pair works\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements unchanged. This involves summing the elements, calculating the mean, and then checking pairs to ensure their deletion does not alter the mean. The solution must handle edge cases and large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through pairs of positions and check if deleting them changes the mean.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Handle edge cases where all elements are equal or the array has fewer elements.\n- Ensure the solution is user-friendly and provides clear output for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to iterate through pairs of positions and check if deleting them changes the mean. We will calculate the mean of the array once and then iterate through pairs to check if their deletion maintains the mean. We will optimize the solution to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these indices results in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the deletion of elements results in the mean remaining unchanged.\n    Explanation: We need to ensure that after deleting two elements, the mean of the remaining elements is still equal to the original mean.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs that maintain the mean.\n    Explanation: This phrase is not directly applicable in the given plan, but it could be relevant if we need to consider the largest possible pairs for deletion.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements and compare it to the original mean.\n    4. Count the number of pairs that maintain the original mean after deletion.\n\n# [edge case] \n    Edge case 1: Array with fewer elements than required for deletion.\n    Edge case 2: All elements in the array are the same.\n    Edge case 3: The sum of the array is zero, making the mean zero.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array has fewer than 3 elements or all elements are the same.\n    Explanation:\n    - If the array has fewer than 3 elements, it's impossible to delete two elements and still have a mean.\n    - If all elements are the same, deleting any two elements will change the mean.\n\n    Example code to handle edge cases:\n    if n < 3:\n        return 0  # It's impossible to delete two elements from fewer than 3 elements\n    if all(x == a[0] for x in a):\n        return n * (n - 1) // 2  # All elements are the same, any two elements can be deleted\n\n    (other code)\n"], "scores": [], "pass_results": [true, true, false, false, false, false, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 543, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "parent_index": 394}
