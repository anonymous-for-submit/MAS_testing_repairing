{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. It's important to note that k is not necessarily an integer. \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your implementation considers edge cases for arrays with fewer than three elements where no valid pair can be formed.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. It's important to note that k is not necessarily an integer. \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your implementation considers edge cases for arrays with fewer than three elements where no valid pair can be formed.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers. The average, denoted as k, is calculated by dividing the sum of all elements by the number of elements. This average can be a non-integer value.\n\nMonocarp wants to remove exactly two elements from the array a, so that the average of the remaining (n - 2) elements remains the same as k.\n\nYour task is to find the number of pairs of indices [i, j] where i < j, and removing the elements at these positions keeps the average of the remaining elements equal to k. It's important to handle edge\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the mean of these elements. The mean is calculated as the sum of elements divided by the number of elements. Monocarp wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k, considering edge cases for arrays with fewer than three elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef calculate_pairs(n: int, arr: list) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    freq = {}\n    \n    # Count the frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == original_mean:\n                    # Check if the elements to be removed are unique\n                    if arr[i] == arr[j]:\n                        if freq[arr[i]] >= 3:\n                            count += 1\n                    else:\n                        count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that deleting the elements at these positions maintains the mean of the array.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] such that deleting the elements at these positions maintains the mean of the array.\n    \"\"\"\n    if n < 3:\n        return -1\n\n    total_sum = sum(arr)\n    mean = total_sum / n\n\n    if mean == 0:\n        # If the mean is 0, we can remove any two elements to maintain the mean\n        return n * (n - 1) // 2\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            if new_sum / new_n == mean:\n                count += 1\n\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_average = new_sum / (n - 2)\n                if new_average == original_average:\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    target_average = total_sum / n\n    \n    pairs_count = 0\n    # Use a dictionary to store the frequency of each possible sum after removing two elements\n    sum_frequency = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new average\n            new_average = new_sum / (n - 2)\n            if new_average == target_average:\n                # Increment the count for this new sum\n                sum_frequency[new_sum] = sum_frequency.get(new_sum, 0) + 1\n    \n    # The number of pairs is the number of unique sums that maintain the average\n    pairs_count = len(sum_frequency)\n    \n    return pairs_count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Call the function and print the result\nresult = find_pairs_to_remove(n, arr)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_remove(arr: List[int], avg: float) -> int:\n    n = len(arr)\n    total_sum = sum(arr)\n    pairs_count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            if new_sum / new_count == avg:\n                pairs_count += 1\n\n    return pairs_count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_remove(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == original_mean:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    if n == 3:\n        return 0\n    \n    mean_value = sum(arr) / n\n    count = 0\n    sum_arr = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                if (sum_arr - arr[i] - arr[j]) / (n - 2) == mean_value:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n    \n    Returns:\n        int: The number of pairs [i, j] that satisfy the condition.\n    \"\"\"\n    if n < 3:\n        return 0\n    \n    result = 0\n    total_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == total_sum / n:\n                result += 1\n    \n    return result\n\n# Read input from standard input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    result_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == original_mean:\n                    result_count += 1\n    \n    return result_count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. The solution must handle edge cases where the array has fewer than three elements and efficiently process large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] that can be deleted without changing the mean.\n- Ensure the solution is optimized for large inputs and handles edge cases.\n- Add input validation to handle incorrect or unexpected inputs.\n- Include detailed documentation and comments for easier understanding.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair calculations. We will iterate through the array to calculate the mean and then find pairs of indices that, when removed, maintain the original mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the remaining elements still have the same mean.\n\n# [phrase showing quantity relationship]\n    'divided by': indicates the operation of division.\n    Explanation: For example, \"sum divided by n\" means the sum of the elements divided by the number of elements in the array.\n\n# [degree adverb] \n    'exactly': means that we need to remove exactly two elements from the array.\n    Explanation: This phrase specifies that we are looking for pairs of positions [i, j] where i < j, and we are removing exactly two elements at these positions.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean of the remaining elements after removing the elements at indices i and j.\n    4. Count the number of pairs that result in the same mean as the original array.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: If there are exactly three elements in the array, there are no pairs to remove, so the number of valid pairs is 0.\n\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements in the array are the same, any pair of elements can be removed, and the mean of the remaining elements will still be the same. The number of such pairs is given by the binomial coefficient (n choose 2).\n\n    Edge case 3: No pair can result in the same mean\n    Expected output: 0\n    Explanation: If no pair of elements can be removed to maintain the original mean, the number of valid pairs is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    For the other edge cases, we can implement the main logic without additional code, as the main logic already covers these cases implicitly.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The solution must handle up to 2\u22c510^5 elements efficiently. The output should be accurate and easy to interpret for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Identify pairs of positions [i, j] that can be deleted without changing the mean\n- Optimize the solution for large inputs\n- Ensure the output is clear and concise for each test case\nTo efficiently calculate the number of pairs [i, j] such that deleting the elements at these positions maintains the mean of the array, we will use Python's built-in functions and libraries. The approach involves calculating the mean of the array and then iterating through all possible pairs to check if their deletion maintains the mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the remaining elements still have the same mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets the condition.\n    Explanation: We need to find the largest integer in the array that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. For each pair, check if removing the elements at positions i and j results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with fewer than three elements.\n    search([1, 2]) = -1\n    Explanation: Since there are fewer than three elements, no valid pair can be formed, so the expected output is -1.\n\n    Edge case 2: Array where no element can be removed to maintain the mean.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: No element can be removed to maintain the mean, so the expected output is -1.\n\n    Edge case 3: Array where all elements are the same.\n    search([2, 2, 2]) = -1\n    Explanation: Any two elements can be removed, but the remaining mean will not be equal to the original mean, so the expected output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle these cases.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being the same as the original mean. This requires a good understanding of mean calculations and efficient ways to iterate through pairs of positions in an array.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Iterate through all pairs of positions in the array\n- Check if deleting the elements at these positions results in the same mean\n- Optimize the solution for large inputs\n- Handle edge cases where no valid pairs exist\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and mean calculations. We will iterate through all possible pairs of positions in the array and check if deleting the elements at these positions results in the same mean as the original array. To optimize the solution for large inputs, we will ensure that our approach avoids redundant calculations and uses efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that the mean of the remaining elements after removing the elements at these indices is equal to the mean of the entire array.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the mean of the remaining elements is still greater than the original mean.\n    Explanation: This phrase is not directly used in the requirement but is a general understanding of the concept of \"more than\" in mathematical terms.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest possible pairs that meet the condition.\n    Explanation: This phrase is not directly used in the requirement but is a general understanding of the concept of \"largest\" in mathematical terms.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with fewer than three elements.\n    Edge case 2: Array with all elements being the same.\n    Edge case 3: Array with a single element that is the mean.\n\n    Edge case 1: No valid pair can be formed.\n    Explanation: If the array has fewer than three elements, there are no valid pairs [i, j] where i < j.\n\n    Edge case 2: All elements are the same.\n    Edge case 3: The array has a single element that is equal to the mean.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array has fewer than three elements.\n        if n < 3:\n            return 0\n\n    For edge cases 2 and 3, we need to check if the array has all elements the same or if there's a single element equal to the mean. This can be done using a set or by iterating through the array.\n", "requirement analysis:\nThe requirement involves calculating the average of an array and finding pairs of indices to remove elements such that the average remains unchanged. This requires a balance between computational efficiency and memory usage, especially with the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Develop a method to find pairs of indices to remove elements.\n- Ensure the solution is optimized for handling large inputs.\n- Design a user-friendly interface for easy interaction.\nTo solve this problem efficiently, we will use Python's built-in functions and data structures. The main challenge is to calculate the average of the array and find pairs of indices to remove elements such that the average remains unchanged. We will iterate through the array to calculate the sum and count the occurrences of each element to determine the number of pairs that can be removed.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'remove elements': reducing the array size by two elements while keeping the average unchanged\n\n# [phrase showing quantity relationship]\n    'exactly two elements': specifically removing two elements from the array\n\n# [degree adverb] \n    'same as': ensuring the new average is equal to the original average\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original average (k) of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new sum after removing the elements at indices i and j.\n    4. Check if the new average (new_sum / (n - 2)) is equal to the original average (k).\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    explanation: With only three elements, removing any two elements will change the average, so the expected output is 0.\n    search([2, 2, 4, 4]) = 4\n    explanation: Possible pairs to remove are [0, 2], [0, 3], [1, 2], and [1, 3]. Removing these pairs will keep the average unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where the array has only three elements.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of indices that, when removed, maintain the same average. This involves a two-step process: first, calculate the average, and then iterate through pairs of indices to check if their removal maintains the average. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of indices that can be removed without changing the average.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the solution handles edge cases and provides accurate results.\nTo solve this problem efficiently, we will use Python's built-in data structures and arithmetic operations. The main challenge is to calculate the average and then find pairs of indices that, when removed, maintain the same average. We will iterate through the array to calculate the sum of all elements and then use this sum to find the average. After that, we will iterate through all possible pairs of indices to check if their removal maintains the average. This approach will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements in the array.\n    Explanation: The average (k) is a value that represents the central tendency of a set of numbers. It is calculated by dividing the sum of all elements in the array by the number of elements in the array.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of indices that, when removed, do not change the average of the remaining elements.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the sum of all elements in the array.\n    2. Calculate the average (k) by dividing the sum by the number of elements.\n    3. Iterate through all possible pairs of indices (i, j) where i < j.\n    4. For each pair, calculate the sum of the remaining elements after removing the pair.\n    5. Check if the new average of the remaining elements is equal to the original average (k).\n    6. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: [1, 2, 3]\n    Expected output: 0\n    Explanation: The average of the array is (1+2+3)/3 = 2. Removing any pair of elements will change the average.\n\n    Edge case 2: [4, 4, 4, 4]\n    Expected output: 6\n    Explanation: The average of the array is (4+4+4+4)/4 = 4. There are 6 pairs of indices that can be removed to keep the average the same: (0,1), (0,2), (0,3), (1,2), (1,3), and (2,3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle the edge case where all elements are the same.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of indices that, when removed, maintain the same average. This involves a two-step process: first, calculate the average, and second, find pairs of indices that can be removed without changing the average. The challenge lies in optimizing the second step for large inputs efficiently.\nrequirement pool:\n- Calculate the average of the array.\n- Find pairs of indices that can be removed without changing the average.\n- Optimize the solution for large inputs.\n- Ensure the solution handles edge cases effectively.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries. The key steps involve calculating the average of the array and then finding pairs of indices that, when removed, maintain the same average. We will optimize the solution by avoiding recalculating the sum and count of elements each time, which would be computationally expensive for large arrays. Instead, we will use a more efficient approach that leverages the properties of the array and the average.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'remove elements': the operation of deleting specific elements from the array\n    'maintain the same average': the condition that the average of the remaining elements should be equal to the original average after the removal of two elements\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove two specific elements from the array\n\n# [degree adverb] \n    'exactly': means that the number of pairs [i, j] should be exactly the number of ways to remove two elements from the array\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the original average (k) of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new sum and new count after removing the elements at indices i and j.\n    4. Check if the new average is equal to the original average (k).\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3], t = 1\n    Explanation: The original average (k) is (1 + 2 + 3) / 3 = 2. There are no pairs [i, j] where i < j that can be removed to keep the average the same.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [4, 5, 6, 7], t = 1\n    Explanation: The original average (k) is (4 + 5 + 6 + 7) / 4 = 5.5. We can remove the elements at indices 1 and 2 (5 and 6) to get a new average of 4 + 7 / 2 = 5.5.\n    Expected output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can be used to solve the problem for all test cases.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. The solution should handle edge cases and be optimized for large inputs. The input consists of multiple test cases, and the output should be the number of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] such that deleting them maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Handle edge cases for arrays with fewer than three elements.\n- Provide clear and accurate results for each test case.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of indices to check if deleting them maintains the mean. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the elements at these positions is significantly larger than the mean.\n    Explanation: This phrase is not directly used in the requirement, but understanding the concept of 'more than' is crucial for calculating the sum of elements at specific positions.\n\n# [degree adverb] \n    'largest': means that we need to find the largest numbers in the array.\n    Explanation: This phrase is not directly used in the requirement, but understanding the concept of 'largest' helps in identifying the numbers that should be considered for deletion.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements after deleting the elements at positions i and j.\n    4. Check if the new mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: If there are exactly three elements, there are no pairs to delete, so the output is 0.\n\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements are the same, any pair of elements can be deleted to maintain the mean. The number of such pairs is given by the binomial coefficient (n choose 2).\n\n    Edge case 3: Array with only positive integers\n    Expected output: The number of pairs that maintain the mean\n    Explanation: This edge case checks the general functionality of the solution for a typical scenario with positive integers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by checking the number of elements and ensuring that the mean remains unchanged after deletion.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k. The input consists of multiple test cases, each with a specific number of elements and their values. The output should be the number of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all pairs [i, j] where i < j.\n- Ensure the function checks if deleting the elements at positions i and j maintains the mean.\n- Optimize the solution for large inputs to handle up to 2 * 10^5 elements.\n- Provide clear and accurate results for each test case.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if deleting the elements at these positions maintains the mean. We will optimize this by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, the mean (average) of the array elements is given and we need to find pairs of indices whose deletion does not change the mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the elements at those positions is significantly larger than the mean, ensuring that their deletion does not alter the mean.\n    Explanation: For example, if the mean is 5, we need to find pairs where the sum of the elements at those positions is greater than 10 (since deleting two elements should not change the mean significantly).\n\n# [degree adverb] \n    'exactly': means that we need to find pairs where the sum of the elements at those positions matches the mean exactly, ensuring that their deletion does not alter the mean.\n    Explanation: For instance, if the mean is 5, we need to find pairs where the sum of the elements at those positions is exactly 10 (since deleting two elements should not change the mean significantly).\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Input: [1, 2, 3]\n    Explanation: Since there are only three elements, there are no pairs to delete, so the output should be 0.\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Input: [1, 2, 3, 4]\n    Explanation: The mean is 2.5. The only pair is [0, 1] (deleting elements at indices 0 and 1 results in the remaining elements having a mean of 3).\n    Edge case 3: n = 5, array = [5, 5, 5, 5, 5]\n    Input: [5, 5, 5, 5, 5]\n    Explanation: The mean is 5. Any pair of elements can be deleted, and the mean remains 5, so the output should be the number of pairs, which is 10.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k. The solution should handle edge cases and be efficient for large inputs. The input consists of multiple test cases, and the output should match the expected results for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] such that deleting elements at these positions keeps the mean unchanged.\n- Ensure the solution is optimized for large inputs and handles edge cases.\n- Test the solution with multiple test cases to ensure accuracy and efficiency.\n- Provide clear and accurate results for each test case.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find pairs [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to k. We will iterate through the array to find all possible pairs and check the condition. The solution will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. It is calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n\n# [degree adverb] \n    'largest': refers to the biggest or greatest value in a set of numbers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2]) = 0\n    explanation: With only two elements, there are no pairs [i, j] to delete, so the expected output is 0.\n    search([1, 1, 1]) = 3\n    explanation: There are three pairs [i, j] to delete: [0, 1], [0, 2], and [1, 2], so the expected output is 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly return 0 for arrays with fewer than three elements.\n\nPlease note that the code logic and edge cases are not provided in the initial response due to the constraints of the format. The focus was on identifying the core concepts, phrases showing quantity relationships, degree adverbs, and edge cases based on the given requirement and plan. For the actual implementation of the code logic, please refer to the plan provided in the prompt.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This requires a good understanding of mean calculations and efficient ways to iterate through pairs of positions in an array.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all possible pairs of positions [i, j] and check the condition\n- Optimize the solution to handle large inputs efficiently\n- Add error handling for edge cases where no valid pairs exist\n- Enhance user interface for better usability\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions [i, j] to check if deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. We will optimize this by avoiding unnecessary calculations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': the sum of elements divided by the number of these elements\n\n    Explanation: The mathematical mean (average) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the remaining elements divided by the count of the remaining elements equals the original mean.\n\n# [degree adverb] \n    'equal to': means that the remaining elements' mean should match the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    n = 3, array = [1, 2, 3]\n    expected output = 0\n    Explanation: With only three elements, there are no pairs [i, j] where deleting two elements results in the mean of the remaining element being equal to the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n < 3.\n        if n < 3:\n            return 0\n\n    This ensures that we do not attempt to find pairs of positions for arrays with fewer than three elements, which cannot have a valid pair.\n"], "scores": [], "pass_results": [false, false, false, true, true, false, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 495, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 400}
