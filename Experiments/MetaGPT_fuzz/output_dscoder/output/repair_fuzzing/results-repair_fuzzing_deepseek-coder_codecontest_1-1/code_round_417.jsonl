{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has obtained an array a composed of n numbers, and let's define k as the average of these numbers (note that it's possible that k is not an integer). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your solution is efficient enough to handle large inputs within the provided constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has obtained an array a composed of n numbers, and let's define k as the average of these numbers (note that it's possible that k is not an integer). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure your solution is efficient enough to handle large inputs within the provided constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has obtained an array a composed of n numbers, and let's define k as the average of these numbers. It's important to note that k might not be an integer. Monocarp wants to remove exactly two elements from the array a so that the arithmetic mean of the remaining (n - 2) elements is still equal to k. The task is to determine the number of pairs of positions [i, j] (where i < j) such that if the elements at these positions are removed, the arithmetic mean of the remaining (n - 2) elements is still k, which is the same\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n numbers, and k is the average of these numbers. He wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. The solution should be efficient for large inputs within the given constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    original_average = total_sum / n\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == original_average:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef func(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    results = []\n    for n, a in test_cases:\n        original_sum = sum(a)\n        k = original_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (original_sum - a[i] - a[j]) / (n - 2) == k:\n                    count += 1\n        results.append(count)\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append((n, a))\n\n# Call the function and print results\nresult = func(t, test_cases)\nfor r in result:\n    print(r)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                if new_sum / (n - 2) == mean:\n                    count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr: list[float], avg: float) -> int:\n    n = len(arr)\n    if n == 2:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == avg:\n                count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(float, input().split()))\nresult = find_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], avg: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == avg:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr: list, mean_value: float) -> int:\n    n = len(arr)\n    if n < 2:\n        return 0\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            remaining_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            remaining_count = n - 2\n            if remaining_sum / remaining_count == mean_value:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs_to_delete(n, arr):\n    mean_value = sum(arr) / n\n    count = 0\n    element_count = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            remaining_sum = sum(arr[:i] + arr[i+1:j] + arr[j+1:])\n            remaining_count = n - 2\n            if remaining_sum / remaining_count == mean_value:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    total_sum = sum(arr)\n    expected_mean = total_sum / n\n\n    if n < 3:\n        return 0\n\n    freq = {}\n    for num in arr:\n        diff = num - expected_mean\n        freq[diff] = freq.get(diff, 0) + 1\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                diff_i = arr[i] - expected_mean\n                diff_j = arr[j] - expected_mean\n                combined_diff = diff_i + diff_j\n                if combined_diff in freq:\n                    count += freq[combined_diff]\n\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_valid_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    initial_mean = total_sum / n\n    \n    valid_pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == initial_mean:\n                valid_pairs_count += 1\n    \n    return valid_pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_valid_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    if n == 3:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == mean:\n                count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_maintain_mean(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the average of the remaining elements being equal to the original average. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of valid pairs.\n- Ensure the solution can handle large inputs without performance degradation.\n- Provide clear and concise output as specified in the problem statement.\n- Optimize the code for readability and maintainability.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large inputs. The approach involves calculating the average of the array and then iterating through all possible pairs of indices to check if removing those elements results in the average of the remaining elements being equal to the original average. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: The average (mean) of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this problem, we need to find pairs of indices to delete such that the average of the remaining elements is still equal to the original average.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices where removing two elements results in the average of the remaining elements being equal to the original average.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs of indices that meet the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution efficiently, we can follow these steps:\n    1. Calculate the original average (k) of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at indices i and j.\n    4. Check if the sum of the remaining elements divided by (n - 2) equals the original average (k).\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have the average of the remaining element equal to the original average.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 6]\n    Expected output: 1\n    Explanation: The original average is (1+2+3+6)/4 = 3. Removing the elements at indices 1 and 3 (values 2 and 6) leaves [1, 3], which has an average of 2, not equal to 3. There are no other pairs that can be removed to maintain the average.\n\n    Edge case 3: n = 5, array = [1, 3, 2, 4, 3]\n    Expected output: 3\n    Explanation: The original average is (1+3+2+4+3)/5 = 2.8. Removing the elements at indices 1 and 3 (values 3 and 4) leaves [1, 2, 3, 3], which has an average of 2.5, not equal to 2.8. There are no other pairs that can be removed to maintain the average.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same average as the original array. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a solution that calculates the average of the array.\n- Iterate through all possible pairs of positions [i, j] and check if deleting the elements at these positions maintains the average.\n- Optimize the solution to handle large inputs efficiently.\n- Ensure the solution is user-friendly and provides clear output.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the average of the array and then iterating through all possible pairs of positions [i, j] to check if deleting the elements at these positions maintains the average. We will optimize this by using a hash set to quickly check if the remaining elements have the same average.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements.\n    Explanation: In this problem, we need to find pairs of positions [i, j] such that after removing the elements at these positions, the average of the remaining elements is still equal to the original average.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the sum of the remaining elements divided by the number of remaining elements equals the original average.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest integer that appears more than a certain number of times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this efficiently, we can follow these steps:\n    1. Calculate the original average k.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at positions i and j.\n    4. Check if the sum of the remaining elements divided by (n - 2) equals k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have the average of the remaining elements equal to the original average.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 6]\n    Expected output: 1\n    Explanation: The original average is (1+2+3+6)/4 = 3. Removing the elements at positions 1 and 3 (0-indexed) leaves [1, 3], which has an average of 2, not 3.\n\n    Edge case 3: n = 5, array = [1, 2, 3, 4, 5]\n    Expected output: 2\n    Explanation: The original average is (1+2+3+4+5)/5 = 3. Removing the elements at positions 0 and 3 (0-indexed) leaves [2, 3, 5], which has an average of 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        # Calculate the original average\n        original_sum = sum(a)\n        k = original_sum / n\n        # Count the number of valid pairs\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (original_sum - a[i] - a[j]) / (n - 2) == k:\n                    count += 1\n        return count\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. The solution must be efficient enough to handle up to 2 * 10^5 elements across multiple test cases.\nrequirement pool:\n- Implement a solution that calculates the mean of the array.\n- Calculate the number of pairs [i, j] where deleting elements at these positions maintains the original mean.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large inputs. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing the elements at these positions maintains the original mean. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the arithmetic mean, which is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'as many times': means the number of times a value appears in the array.\n\n# [degree adverb] \n    'largest': means the greatest value in the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem efficiently, we need to:\n    1. Calculate the average of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. Check if removing the elements at these positions maintains the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    n = 3, a = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and still have the remaining elements have the same mean as the original array.\n\n    n = 4, a = [1, 2, 3, 6]\n    expected output: 1\n    Explanation: The average of [1, 2, 3, 6] is 3. Removing the elements at positions 1 and 2 (0-indexed) leaves [1, 3], which also has an average of 3.\n\n    n = 5, a = [1, 2, 3, 4, 5]\n    expected output: 2\n    Explanation: The average of [1, 2, 3, 4, 5] is 3. Removing the elements at positions 0 and 3 (0-indexed) leaves [2, 3, 5], which also has an average of 3. Similarly, removing the elements at positions 0 and 4 also results in an average of 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for small inputs. However, for large inputs, further optimization may be necessary to ensure efficiency.\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of elements whose removal does not change this average. The solution should be efficient enough to handle up to 2 * 10^5 elements due to the constraints. The output should be the count of such pairs.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of elements whose removal does not change the average.\n- Ensure the solution is efficient and can handle the upper limit of input size.\n- Provide clear and accurate output for each test case.\n- Implement input reading and output formatting as specified.\nTo solve this problem, we will use Python's built-in data structures and arithmetic operations. The main challenge is to efficiently find pairs of elements whose removal does not change the average of the array. We will first calculate the average of the array and then iterate through all possible pairs of indices to check if removing these elements results in the same average.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'remove elements': the operation of excluding certain elements from a set or sequence\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the average (k) of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at indices i and j.\n    4. Check if the sum of the remaining elements divided by (n - 2) equals k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    edge_case1 = 0\n    Explanation:\n    If the array has only two elements, removing any pair will result in an empty array, which cannot have an average. Thus, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        if n == 2:\n            return 0\n        (other code)\n", "requirement analysis:\nThe problem requires calculating the average of the array and then finding pairs of elements whose removal does not change this average. This involves a straightforward approach of iterating through all possible pairs and checking the condition. The efficiency of the solution is crucial, especially given the constraints on the number of test cases and the size of the array.\nrequirement pool:\n- Implement a function to calculate the average of the array.\n- Create a function to find pairs of positions to remove.\n- Ensure the solution is efficient and can handle large inputs.\n- Provide clear and accurate output for each test case.\n- Test the solution with various edge cases to ensure robustness.\nTo solve this problem efficiently, we will use Python's built-in data structures and arithmetic operations. The main challenge is to find all pairs of positions that, when removed, do not change the average of the array. We will iterate through all possible pairs and check the condition, ensuring that the solution is efficient and can handle large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'remove elements': the process of taking out certain elements from a list\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to iterate through all possible pairs of indices in the array and check if removing those elements results in the average of the remaining elements being equal to the original average.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 1\n    explanation: There is only one pair [1, 2] that can be removed to keep the average unchanged.\n    search([5, 5, 5, 5]) = 6\n    explanation: All pairs can be removed to keep the average unchanged, resulting in 6 pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can iterate through all pairs and check the condition.\n\n# [code logic]\n    Here's a detailed logic to implement the code:\n    1. Calculate the original average `k` of the array.\n    2. Initialize a counter to keep track of the number of valid pairs.\n    3. Iterate through all possible pairs of indices `(i, j)` where `i < j`.\n    4. For each pair, calculate the sum of the remaining elements after removing the pair.\n    5. Check if the sum of the remaining elements divided by the number of remaining elements equals `k`.\n    6. If the condition is met, increment the counter.\n    7. Return the counter after checking all pairs.\n", "requirement analysis:\nThe requirement is to find pairs of positions [i, j] in an array such that removing these positions results in the arithmetic mean of the remaining elements being the same as the original mean. This involves calculating the mean, iterating through pairs, and checking the condition.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Iterate through all pairs of positions [i, j] where i < j.\n- Check if removing the elements at positions [i, j] results in the mean remaining unchanged.\n- Count and return the number of such pairs.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to calculate the arithmetic mean and iterate through pairs of positions in the array. We will avoid using complex data structures and algorithms to keep the solution simple and efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: In this problem, Monocarp wants to find pairs of positions [i, j] such that removing the elements at these positions results in the remaining elements having the same arithmetic mean as the original array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean (k) of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements after removing the elements at positions i and j.\n    4. Check if the sum of the remaining elements divided by (n - 2) equals k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    edge_case1 = ([1, 2, 3, 4], 3)\n    Explanation: The original array has an arithmetic mean of (1+2+3+4)/4 = 2.5. Removing any pair of elements will change the mean. For example, removing elements at positions 1 and 2 (2 and 3) results in the sum of the remaining elements being 1+3+4 = 8 or 1+2+4 = 7, which are not equal to 2.5 * 3 = 7.5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than 2 elements, as removing two elements is not possible.\n    if n < 2:\n        return 0\n    (other code)\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion maintains the mean. The challenge is to do this efficiently, especially given the constraints where n can be as large as 2 * 10^5.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all pairs [i, j] and check if the mean remains the same after deletion.\n- Optimize the function to handle large inputs efficiently.\n- Ensure the solution is easy to understand and maintain.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The approach involves calculating the mean of the array and then iterating through all possible pairs to check if their deletion maintains the mean. We will use a brute-force method initially for simplicity and optimize it later if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'pair': a combination of two elements from a list\n    'mean': the sum of elements divided by the number of elements\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where the deletion maintains the mean\n    'at least as many times': means the number of times an element appears should be greater than or equal to its value\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that appears at least as many times as itself\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element that appears more than or equal to its value, which is 1.\n    search([2, 2, 3, 3, 3]) = 4\n    explanation: Both 2 and 3 appear more than or equal to their values. There are 2 pairs for 2 and 2 pairs for 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly calculate the number of pairs based on the count of each element.\n\n# [code logic]\n    To implement the code, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. Check if deleting the elements at positions i and j maintains the mean.\n    4. Count the number of such pairs.\n    5. Return the count.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    explanation: There is only one element that appears more than or equal to its value, which is 1.\n    search([2, 2, 3, 3, 3]) = 4\n    explanation: Both 2 and 3 appear more than or equal to their values. There are 2 pairs for 2 and 2 pairs for 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly calculate the number of pairs based on the count of each element.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. The solution should be efficient and handle large inputs within the given constraints. The algorithm should be optimized to avoid timeouts and ensure fast execution.\nrequirement pool:\n- Implement an efficient algorithm to calculate the number of pairs [i, j] that can be deleted to maintain the mean.\n- Ensure the solution can handle large inputs efficiently.\n- Optimize the algorithm for better performance.\n- Provide clear and concise documentation for the code.\n- Include unit tests to verify the correctness of the solution.\nTo solve this problem efficiently, we will use a mathematical approach to avoid iterating through all possible pairs. The key idea is to calculate the total sum of the array and the expected sum of the remaining (n-2) elements. By comparing these sums, we can determine the number of valid pairs [i, j] that can be deleted to maintain the mean. We will use a dictionary to store the frequency of each possible difference between the sum of the array and the sum of the remaining elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the mean or average of a set of numbers is the sum of the numbers divided by the count of the numbers.\n    'deleting elements': removing elements from a list can change the average of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates a comparison where one quantity is greater than another.\n    'at least as many times': means the same or more occurrences of an element.\n\n# [degree adverb] \n    'largest': refers to the biggest value in a set of numbers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem efficiently, we will use a mathematical approach to avoid iterating through all possible pairs. The key idea is to calculate the total sum of the array and the expected sum of the remaining (n-2) elements. By comparing these sums, we can determine the number of valid pairs [i, j] that can be deleted to maintain the mean. We will use a dictionary to store the frequency of each possible difference between the sum of the array and the sum of the remaining elements.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need. \n\n# [edge case]\n    search([4, 1, 2, 2, 3, 1]) = 2\n    explanation: The number 2 appears twice, which is more than its value, and 3 appears three times, which is more than its value. The largest number that meets the condition is 2.\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: The number 3 appears three times, which is more than its value. The largest number that meets the condition is 3.\n    search([5, 5, 4, 4, 4]) = -1\n    explanation: No number appears more than or equal to its value. The function should return -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        if not lst:\n            return -1\n        freq = {}\n        for num in lst:\n            freq[num] = freq.get(num, 0) + 1\n        max_num = -1\n        for num, count in freq.items():\n            if num <= count:\n                max_num = max(max_num, num)\n        return max_num if max_num != -1 else -1\n", "requirement analysis:\nThe problem requires calculating the number of pairs [i, j] such that deleting the elements at these positions keeps the mean of (n - 2) elements equal to k. This is a combinatorial problem that needs to be solved efficiently due to the constraints on n.\nrequirement pool:\n- Implement a solution that calculates the number of valid pairs efficiently\n- Ensure the solution is clear and easy to understand\n- Optimize the solution for performance\nTo solve this problem efficiently, we will use a combination of mathematical calculations and data structures. The key idea is to calculate the total sum of the array and the initial mean. Then, for each pair of elements, we will check if removing these two elements results in the mean of the remaining elements being equal to the initial mean. This approach ensures that we only consider valid pairs and avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average': the sum of all elements divided by the number of elements\n    'deleting elements': removing specific elements from a list to calculate the new average\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs where removing two elements maintains the average\n\n# [degree adverb] \n    'exactly': means we need to find pairs where removing two elements results in the same average\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Calculate the initial sum of the array\n    - Calculate the initial mean of the array\n    - Iterate through all possible pairs of elements in the array\n    - For each pair, calculate the new sum after removing the elements\n    - Check if the new mean is equal to the initial mean\n    - Count the number of valid pairs\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The initial mean is 4, and the pairs [1, 2], [1, 3], and [2, 3] result in the mean of the remaining elements being 4.\n    search([1, 1, 1, 1]) = 6\n    explanation: The initial mean is 1, and all pairs (excluding the pair [0, 0] which is not valid) result in the mean of the remaining elements being 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if their deletion results in the same mean. The challenge lies in ensuring the solution is efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all pairs of positions [i, j] and check if their deletion results in the same mean.\n- Optimize the function to handle large inputs efficiently.\n- Ensure the solution is user-friendly and provides clear output.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions [i, j] to check if their deletion results in the same mean. We will optimize this process using mathematical properties to avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'average'\n    In the requirement, it refers to the arithmetic mean, which is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'as many times': This phrase indicates that the number of times a value appears in the array should be at least equal to the value itself.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    To implement the solution efficiently, we can follow these steps:\n    1. Calculate the mean (k) of the array.\n    2. Iterate through all possible pairs of positions [i, j] in the array.\n    3. For each pair, calculate the new sum of the array after removing the elements at positions i and j.\n    4. Check if the new sum divided by (n - 2) equals the mean k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The mean k is (1 + 2 + 3) / 3 = 2. There are no pairs [i, j] such that removing them results in the mean k, as the smallest sum after removing two elements would be 3 (if we remove the two smallest elements).\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 3, 2, 4]\n    Explanation: The mean k is (1 + 3 + 2 + 4) / 4 = 2.5. The pairs [i, j] that can be removed to maintain the mean k are [0, 1] (removing 1 and 3 results in a sum of 2 + 2 + 4 = 8, and 8 / 3 \u2260 2.5) and [1, 2] (removing 3 and 2 results in a sum of 1 + 2 + 4 = 7, and 7 / 3 \u2260 2.5).\n    Expected output: 1\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has only three elements, as removing any two elements will change the mean.\n    if n == 3:\n        return 0\n    (other code)\n"], "scores": [], "pass_results": [true, true, false, true, false, false, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 417, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 336}
