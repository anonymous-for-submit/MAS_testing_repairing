{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers, denoting k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. It is the sum divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers, denoting k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. It is the sum divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a with n integers, and he wants to find the mean k of these elements. The mean of an array is calculated by dividing the sum of its elements by the number of elements. Monocarp wants to remove exactly two elements from the array a so that the mean of the remaining (n - 2) elements is still k. Your task is to determine the number of pairs of indices [i, j] (where i is less than j) such that if the elements at these positions are deleted, the mean of the remaining elements is still k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the mean of these elements. He wants to remove two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) where removing elements at these positions keeps the mean of the array equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], mean: float) -> int:\n    n = len(arr)\n    if n == 2:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == mean:\n                count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nmean = sum(arr) / n\nresult = calculate_pairs(arr, mean)\nprint(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(arr, mean):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions\n    maintains the mean of the remaining elements equal to the original mean.\n    \n    Args:\n        arr (list): List of integers representing the array.\n        mean (float): The mean of the original array.\n    \n    Returns:\n        int: The number of valid pairs [i, j].\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    \n    count = 0\n    n = len(arr)\n    \n    # Use a hash map to store the counts of the differences\n    diff_count = {}\n    \n    for num in arr:\n        diff = num - mean\n        if diff in diff_count:\n            diff_count[diff] += 1\n        else:\n            diff_count[diff] = 1\n    \n    # Check for pairs that maintain the mean after deletion\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the difference for the pair (i, j)\n            diff_ij = arr[i] + arr[j] - 2 * mean\n            if diff_ij in diff_count and diff_count[diff_ij] > 0:\n                count += 1\n    \n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nmean = sum(arr) / n\nresult = calculate_pairs(arr, mean)\nprint(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(arr: list, mean_value: float) -> int:\n    n = len(arr)\n    if n < 2:\n        return 0\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) > 0 and sum(new_arr) / len(new_arr) == mean_value:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = calculate_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    mean_of_array = sum(arr) / n\n    \n    # Initialize the result counter\n    result = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a copy of the array to simulate removing elements at indices i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            \n            # Check if the mean of the remaining elements is still equal to the calculated mean\n            if sum(new_arr) / (n - 2) == mean_of_array:\n                result += 1\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    \n    # Read the array elements\n    arr = list(map(int, input().split()))\n    \n    # Get the result for the current test case\n    result = find_pairs_to_remove(n, arr)\n    \n    # Print the result\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == mean:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    original_mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) < 1:\n                continue\n            if sum(new_arr) / len(new_arr) == original_mean:\n                count += 1\n    \n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    mean_value = sum(arr) / n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] where removing elements at these positions keeps the mean of the array equal to k.\n    \n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n        \n    Returns:\n        int: The number of pairs [i, j] where removing elements at these positions keeps the mean of the array equal to k.\n    \"\"\"\n    total_sum = sum(arr)\n    mean = total_sum / n\n    count = 0\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                # Check if the elements to be removed are distinct and not the same as the mean\n                if arr[i] != arr[j] and element_count.get(arr[i], 0) > arr[i] and element_count.get(arr[j], 0) > arr[j]:\n                    count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Calculate and print the result\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that removing elements at these positions keeps the mean of the array equal to k.\n\n    Args:\n        n (int): The number of elements in the array.\n        arr (list): The list of integers.\n\n    Returns:\n        int: The number of pairs [i, j] such that removing elements at these positions keeps the mean of the array equal to k.\n    \"\"\"\n    original_mean = sum(arr) / n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements excluding arr[i] and arr[j]\n            remaining_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            if remaining_sum / (n - 2) == original_mean:\n                count += 1\n\n    return count\n\n# Read the number of test cases\nt = int(sys.stdin.readline())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(sys.stdin.readline())\n    \n    # Read the array elements\n    arr = list(map(int, sys.stdin.readline().split()))\n    \n    # Calculate and print the result for the current test case\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs_to_delete(array, mean):\n    \"\"\"\n    Calculate the number of pairs [i, j] such that deleting the elements at these positions\n    results in the remaining elements having the same mean as the original array.\n\n    Args:\n        array (list): A list of integers representing the array.\n        mean (float): The desired mean value.\n\n    Returns:\n        int: The number of pairs [i, j] that can be deleted to maintain the mean.\n    \"\"\"\n    n = len(array)\n    total_sum = sum(array)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - array[i] - array[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n\n    return count\n\n# Interface for the program\nn = int(input())\nfor _ in range(n):\n    input_line = input().split()\n    array_size = int(input_line[0])\n    array = list(map(int, input_line[1:]))\n    mean_value = float(input())\n    result = calculate_pairs_to_delete(array, mean_value)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same mean as the original array. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs to delete.\n- The solution should handle large inputs within the given constraints.\n- The output should be accurate and reliable for each test case.\n- Optimize the solution for performance.\n- Ensure the solution is user-friendly and easy to understand.\nTo solve this problem efficiently, we will use Python's built-in data structures and arithmetic operations. The main idea is to calculate the sum of the array and then find pairs of elements whose deletion does not change the mean. This can be done by checking if the sum of the remaining elements divided by the number of remaining elements equals the original mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, Monocarp wants to find pairs of elements in the array such that deleting these elements does not change the mean of the remaining elements. The mean of the original array is given, and we need to ensure that the mean of the remaining elements is also equal to this value.\n\n# [phrase showing quantity relationship]\n    'divided by': indicates the operation of division.\n    Explanation: For example, \"the sum of elements divided by the number of these elements\" means that we need to divide the total sum of the array elements by the number of elements in the array to find the mean.\n\n# [degree adverb] \n    'equal to': indicates that two values are the same.\n    Explanation: In the requirement, \"the mathematic mean of the remaining (n - 2) elements is still equal to k\" means that the mean of the remaining elements after deletion should be exactly the same as the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to follow these steps:\n    1. Calculate the sum of all elements in the array.\n    2. Calculate the original mean (k) as the sum of elements divided by the number of elements.\n    3. Iterate through all possible pairs of elements in the array.\n    4. For each pair, calculate the sum of the remaining elements after deletion.\n    5. Check if the mean of the remaining elements is still equal to k.\n    6. Count the number of such pairs.\n\n# [edge case] \n    edge_case1 = 0\n    Explanation: If the array has only two elements, there are no pairs to delete, so the expected output is 0.\n    edge_case2 = 1\n    Explanation: If there is exactly one pair of elements whose deletion does not change the mean, the expected output is 1.\n    edge_case3 = n * (n - 1) / 2\n    Explanation: If every possible pair of elements results in the mean remaining the same, the expected output is the total number of pairs in the array, which is n * (n - 1) / 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 2:\n            return 0\n        elif n == 3:\n            return 1\n        (other code)\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same mean as the original array. The input consists of multiple test cases, each with a specific array and mean. The output should provide the count of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all possible pairs of positions [i, j] and check if deleting them results in the mean remaining the same.\n- Optimize the solution to handle large inputs efficiently.\n- Ensure the solution is clear and easy to understand.\n- Test the solution with various edge cases to ensure accuracy.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to calculate the mean and iterate through the array. We will avoid using complex data structures and algorithms to keep the solution simple and optimized for large inputs.\nPlease read and understand the following inteperation before coding\n Based on the provided plan and requirement, it appears that the plan does not fully address the core concepts and details of the requirement. The plan is quite vague and does not provide a clear step-by-step approach to solving the problem. Therefore, the plan needs further interpretation.\n\n# [core concept]\n    'mathematic mean': The average value of a set of numbers. In this context, it refers to the average of all elements in the array after potentially removing two elements.\n    Explanation: The mathematic mean (average) of the array elements is calculated by summing all the elements and dividing by the number of elements. Monocarp wants to delete two elements to ensure the mean of the remaining elements remains the same.\n\n# [phrase showing quantity relationship]\n    'dividing by the number of these elements': This phrase indicates that the mean is calculated by dividing the sum of the remaining elements by the number of remaining elements after deletion.\n    Explanation: This phrase is crucial as it defines how the mean is calculated after deletion of elements.\n\n# [degree adverb] \n    'largest': This phrase is not directly applicable in the context of the requirement as it does not fit the need to find the largest integer that appears a specific number of times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan does not provide a clear logic for implementing the solution. It is essential to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the mean of the remaining elements after deletion.\n    4. Compare this mean with the original mean to check if they are equal.\n    5. Count the number of such pairs.\n\n# [edge case] \n    edge_case1 = 0\n    Explanation: If the array has only two elements, there are no pairs to delete, and the mean of the remaining elements will not be equal to the original mean. Thus, the expected output is 0.\n    edge_case2 = 1\n    Explanation: If there are exactly two pairs that, when deleted, result in the mean of the remaining elements being equal to the original mean, the expected output is 1.\n    edge_case3 = 0\n    Explanation: If the array has more than two elements but no pair can be deleted to maintain the original mean, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has fewer than two elements.\n        if len(a) < 2:\n            return 0\n        (other code)\n\nThis additional code ensures that the function does not attempt to find pairs of positions to delete when there aren't enough elements to form a pair.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions to delete from the array such that the mean of the remaining elements remains the same. This involves understanding the mathematical properties of the mean and iterating through pairs of positions to check the condition.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all pairs of positions and check if deleting the elements at these positions keeps the mean unchanged.\n- Optimize the solution to handle the upper limits of input constraints efficiently.\n- Ensure the solution provides clear and accurate results for each test case.\n- Create a user-friendly interface for easy input and output.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to calculate the mean and iterate through pairs of positions. We will avoid using complex data structures and algorithms to keep the solution simple and optimized.\nPlease read and understand the following inteperation before coding\n Based on the provided plan and requirement, it appears that the plan does not fully address the core concepts and details of the requirement. The plan is quite vague and does not provide a clear step-by-step approach to solving the problem. Therefore, the plan needs further interpretation.\n\n# [core concept]\n    'mathematic mean': The average value of a set of numbers. In this context, it refers to the sum of all elements in the array divided by the number of elements, n.\n    Explanation: The mathematic mean (average) of the array elements is calculated by dividing the sum of all elements by the number of elements, n. Monocarp wants to delete two elements from the array such that the average of the remaining elements remains the same.\n\n# [phrase showing quantity relationship]\n    'dividing by the number of these elements': This phrase indicates that the average of the remaining elements after deletion should still be equal to the original mean k.\n\n# [degree adverb] \n    'largest': This phrase is not directly applicable in the context of the requirement, as it does not fit the need to find the largest integer that appears a specific number of times.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Calculate the original mean k of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the sum of the remaining elements after deleting the elements at indices i and j.\n    4. Check if the mean of these remaining elements is still equal to k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    edge_case1 = ([1, 2, 3, 4], 1.5)\n    Explanation: The original array is [1, 2, 3, 4], and the mean k is 1.5. The pairs to check are (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). The sums of the remaining elements after deletion are:\n    - (0, 1): 3 (mean = 1.5)\n    - (0, 2): 4 (mean = 2)\n    - (0, 3): 5 (mean = 2.5)\n    - (1, 2): 2 (mean = 2.5)\n    - (1, 3): 1 (mean = 3)\n    - (2, 3): 0 (mean = 3.5)\n    Only the pair (0, 1) maintains the mean of 1.5, so the count is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than 2 elements, as deleting two elements is not possible.\n    if len(a) < 2:\n        return 0\n\n    (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices [i, j] such that removing the elements at these indices keeps the mean unchanged. This involves iterating through the array, calculating the mean, and checking if removing two specific elements results in the same mean. The challenge lies in optimizing this process for large inputs efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices [i, j] that can be removed without changing the mean.\n- Ensure the solution is optimized for large inputs and handles edge cases effectively.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of indices to check if removing them results in the same mean. We will use a brute-force method initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    'pairwise indices': combinations of two distinct indices from a list, representing positions of elements to be removed.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of elements remaining after removal should be greater than zero.\n    'at least as many times': means that the count of the removed elements should be less than or equal to the number of elements in the array.\n\n# [degree adverb] \n    'exactly': specifies that the number of times an element should appear in the array to be considered.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, remove the elements at indices i and j, and check if the mean of the remaining elements is still equal to the calculated mean.\n    4. Count the number of such pairs and output the count.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7], k=4) = 3\n    Explanation:\n    The mean of the array is 4. The pairs [1, 2], [1, 3], and [2, 3] when removed result in the mean of the remaining elements being 4.\n    search([1, 1, 1, 1], k=1) = 6\n    Explanation:\n    The mean of the array is 1. All pairs of indices can be removed, and the mean of the remaining elements will still be 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array contains only one unique element.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\n    This edge case ensures that we correctly handle situations where removing any pair of elements will not change the mean, which is not possible unless all elements are the same.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of indices [i, j] such that removing the elements at these indices keeps the mean of the remaining elements unchanged. This involves understanding the properties of the mean and how removing elements affects it. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find the number of pairs [i, j] that can be removed without changing the mean.\n- Optimize the algorithm for performance, especially for large inputs.\n- Ensure the solution is scalable and can handle the upper limits of the input constraints.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing them keeps the mean unchanged. We will optimize this by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of indices can be removed such that the mean of the remaining elements is still the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the mean.\n    Explanation: For example, if we have a list [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. We need to find pairs [i, j] such that removing a_i and a_j keeps the mean unchanged.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs that can be removed without changing the mean.\n    Explanation: In the given example, the largest pairs would be [3, 4] since removing them keeps the mean unchanged.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these indices keeps the mean unchanged.\n    4. Count the number of such pairs.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n\n# [core concept] \n    'positive': means that all integer in the list is > 0\n\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need. \n\n# [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of indices can be removed such that the mean of the remaining elements is still the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of indices whose removal does not change the mean.\n    Explanation: For example, if we have a list [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. We need to find pairs [i, j] such that removing a_i and a_j keeps the mean unchanged.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs that can be removed without changing the mean.\n    Explanation: In the given example, the largest pairs would be [3, 4] since removing them keeps the mean unchanged.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at these indices keeps the mean unchanged.\n    4. Count the number of such pairs.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n", "requirement analysis:\nThe requirement is to find the number of pairs of indices [i, j] such that removing the elements at these indices results in the mean of the remaining elements being the same as the original mean. This requires calculating the mean of the array and then checking each pair of indices to see if removing them results in the same mean. The solution should be efficient and handle large inputs efficiently.\nrequirement pool:\n- Calculate the mean of the array.\n- Check each pair of indices to see if removing them results in the same mean.\n- Optimize the solution for large inputs.\n- Ensure the solution is accurate and handles edge cases.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if removing them results in the same mean. We will optimize this by avoiding unnecessary calculations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of indices can be removed such that the mean of the remaining elements is still the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of indices that, when removed, do not change the mean of the array.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, check if removing the elements at indices i and j results in the mean of the remaining elements being equal to the original mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [1, 2, 3]\n    Explanation: The mean of the array is (1+2+3)/3 = 2. Removing any two elements will change the mean.\n    Expected output: 0\n\n    Edge case 2:\n    Input: n = 4, a = [1, 2, 3, 4]\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. Removing the elements at indices 1 and 3 (2 and 4) will result in the mean of the remaining elements being 2.5.\n    Expected output: 1\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        original_mean = sum(a) / n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (sum(a[:i] + a[i+1:j] + a[j+1:]) / (n - 2)) == original_mean:\n                    count += 1\n        return count\n\n    This code checks for all possible pairs of indices and counts those that, when removed, do not change the mean of the array.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] where removing elements at these positions keeps the mean of the array equal to k. This requires a good understanding of mean calculations and efficient iteration through the array. The solution should be able to handle a large number of test cases efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Iterate through all possible pairs [i, j] and check the mean condition\n- Optimize the iteration process to handle large datasets efficiently\n- Ensure the solution is user-friendly and easy to understand\nTo solve this problem efficiently, we will use Python due to its powerful standard library and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs [i, j] to check if removing these elements keeps the mean unchanged. We will optimize the iteration process using mathematical calculations to avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean of the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest possible value that, when removed, does not change the mean of the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. Check if removing elements at these positions keeps the mean of the array equal to k.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = 3\n    explanation: The mean of the array is 4. The pairs [i, j] that can be removed to keep the mean unchanged are [0, 4], [1, 5], and [2, 6].\n    search([1, 1, 1, 1]) = 6\n    explanation: The mean of the array is 1. All pairs can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] where removing elements at these positions keeps the mean of the array equal to k. This involves understanding the mean calculation and ensuring that the removal of two elements does not alter the mean. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a method to find pairs [i, j] where removing elements at these positions maintains the mean.\n- Optimize the solution for large inputs to ensure it runs efficiently within the given constraints.\n- Ensure the output is accurate and matches the expected result for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs [i, j] where removing elements at these positions keeps the mean of the array equal to k. We will iterate through the array to find all possible pairs and check if removing them maintains the mean. The solution will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. In this problem, we need to find pairs of elements that, when removed, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears should be greater than or equal to the element's value.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs (i, j) where i < j.\n    3. For each pair, calculate the new mean of the remaining elements.\n    4. Count the pairs where the new mean is equal to the original mean.\n\n# [edge case] \n    search([1, 1, 1]) = 1\n    Explanation: The array has three elements, all of which are 1. Removing any two elements will result in the remaining element being 1, which is equal to the mean of the original array. There is only one pair [0, 1].\n    search([2, 2, 3, 3, 3]) = 4\n    Explanation: The array has five elements. The mean is (2+2+3+3+3)/5 = 2.5. We need to find pairs [i, j] such that removing elements at these positions keeps the mean equal to 2.5. The pairs are [0, 1], [0, 2], [0, 3], and [0, 4].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for any given array.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] such that removing elements at these positions keeps the mean of the array equal to k. The solution must be efficient and scalable to handle large inputs within performance constraints. The output should be accurate and reliable for each test case.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs [i, j] such that removing elements at these positions keeps the mean of the array equal to k.\n- The solution should be scalable and capable of handling large inputs within performance constraints.\n- The output should be accurate and provide clear results for each test case.\nTo efficiently calculate the number of pairs [i, j] such that removing elements at these positions keeps the mean of the array equal to k, we will use Python's built-in functions and libraries. The approach involves iterating through the array to calculate the mean and then counting the valid pairs. We will use a simple and efficient algorithm to ensure scalability and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this case, the mean of the array is the sum of all elements divided by the number of elements.\n    Explanation: The requirement is to find pairs of indices [i, j] such that removing the elements at these indices keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the remaining elements divided by the number of remaining elements equals the original mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than or equal to its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements.\n    4. Check if the new mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 1\n    Explanation: The original mean is (1+2+3+4)/4 = 2.5. The only pair [i, j] that keeps the mean the same is [0, 3] (removing elements 1 and 4), leaving [2, 3] with a mean of 3.5.\n    search([5, 5, 5, 5]) = 6\n    Explanation: The original mean is (5+5+5+5)/4 = 5. There are 6 pairs that can be removed to keep the mean the same: [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], and [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to calculate the number of pairs for any given array.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same mean as the original array. The input consists of multiple test cases, each with a specific array and mean. The output should provide the count of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all possible pairs of positions [i, j] and check if deleting them results in the same mean.\n- Optimize the solution to handle large inputs efficiently.\n- Add support for reading multiple test cases.\n- Ensure the solution provides clear and accurate results for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to iterate through all possible pairs of positions [i, j] and check if deleting them results in the same mean. We will optimize this by calculating the mean once and then checking the condition for each pair. This approach will ensure that the solution is scalable and can handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': The average value of a set of numbers. In this case, the mean of the array elements should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'divided by the number of these elements': This phrase indicates that the mean is calculated by dividing the sum of the elements by the total number of elements.\n\n# [degree adverb] \n    'equal to': This adverb indicates that the mean of the remaining elements should match the mean of the original array elements.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the original array.\n    2. Iterate through all possible pairs of positions [i, j] in the array.\n    3. For each pair, calculate the new mean of the remaining elements.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    edge_case1 = 0\n    Explanation: If the array has only two elements, removing any two elements will result in a mean of 0, which is equal to the mean of the original array with two elements.\n    edge_case2 = n * (n - 1) / 2\n    Explanation: If the array has more than two elements, the number of pairs [i, j] such that removing them results in the same mean is given by the combination formula n * (n - 1) / 2, where n is the length of the array. This is because there are n choices for the first element and n-1 choices for the second element, and each pair is unique.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle all cases, including the edge cases where the array has only two elements or more.\n"], "scores": [], "pass_results": [false, true, false, false, true, false, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 688, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "parent_index": 502}
