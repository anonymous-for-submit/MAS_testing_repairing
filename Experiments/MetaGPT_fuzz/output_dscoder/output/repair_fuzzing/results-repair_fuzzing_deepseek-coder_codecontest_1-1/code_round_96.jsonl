{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. The stability ensures that the relative order of elements within the left and right parts doesn't change. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. The stability ensures that the relative order of elements within the left and right parts doesn't change. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. The stability ensures that the relative order of elements within the left and right parts doesn't change. Then the array is replaced with the concatenation of the\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " We are given an array a of length n. The eversion operation involves partitioning the array into two parts based on a pivot x = a_n, where the left part contains elements \u2264 x and the right part contains elements > x. The order within each part is stable. After performing eversions, we need to determine the minimum number k such that the array stops changing.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_min_eversions(arr: List[int]) -> int:\n    def partition(arr: List[int], low: int, high: int) -> int:\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr: List[int], low: int, high: int) -> None:\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    def is_stable(arr: List[int]) -> bool:\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n\n    original_arr = arr[:]\n    k = 0\n    while not is_stable(arr):\n        quick_sort(arr, 0, len(arr) - 1)\n        k += 1\n\n    return k\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = find_min_eversions(arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef eversion(arr: List[int]) -> List[int]:\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[-1]\n    sorted_arr = sorted(arr)\n    left = [x for x in sorted_arr if x <= pivot]\n    right = [x for x in sorted_arr if x > pivot]\n    return left + right\n\ndef count_eversions(arr: List[int]) -> int:\n    count = 0\n    while True:\n        new_arr = eversion(arr)\n        if new_arr == arr:\n            break\n        arr = new_arr\n        count += 1\n    return count\n\n# Main function to read input and output results\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        result = count_eversions(arr)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\n\ndef find_min_eversions(arr: List[int]) -> int:\n    def is_stable(arr: List[int]) -> bool:\n        for i in range(1, len(arr)):\n            if arr[i - 1] > arr[i]:\n                return False\n        return True\n\n    def merge_sort_and_count(arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        inversions = merge_sort_and_count(left) + merge_sort_and_count(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inversions += len(left) - i\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n        return inversions\n\n    eversions = 0\n    while not is_stable(arr):\n        eversions += 1\n        arr = merge_sort_and_count(arr)\n\n    return eversions\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_min_eversions(arr)\nprint(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> int:\n    def stable_partition(arr, pivot):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    eversions = 0\n    while not is_sorted(arr):\n        pivot = arr[len(arr) // 2]\n        arr = stable_partition(arr, pivot)\n        eversions += 1\n\n    return eversions\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    a = list(map(int, input().split()))\n    result = eversion_operation(a)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> int:\n    def stable_partition(arr: List[int], pivot: int) -> List[int]:\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def is_stable(arr: List[int]) -> bool:\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n\n    pivot = arr[-1]\n    while True:\n        arr = stable_partition(arr, pivot)\n        if is_stable(arr):\n            break\n    return arr.index(pivot) + 1\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef eversion_sort(arr: List[int]) -> int:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quicksort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quicksort(arr, low, pi - 1)\n            quicksort(arr, pi + 1, high)\n\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    original_arr = arr.copy()\n    quicksort(arr, 0, n - 1)\n\n    iterations = 0\n    while arr != original_arr:\n        iterations += 1\n        arr = original_arr.copy()\n        quicksort(arr, 0, n - 1)\n\n    return iterations\n\n# Read input\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = eversion_sort(a)\n    results.append(result)\n\n# Print results\nfor result in results:\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_sort(arr: List[int]) -> int:\n    def partition(sub_arr: List[int], low: int, high: int) -> int:\n        pivot = sub_arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if sub_arr[j] <= pivot:\n                i += 1\n                sub_arr[i], sub_arr[j] = sub_arr[j], sub_arr[i]\n        sub_arr[i + 1], sub_arr[high] = sub_arr[high], sub_arr[i + 1]\n        return i + 1\n\n    def quicksort(sub_arr: List[int], low: int, high: int) -> None:\n        if low < high:\n            pi = partition(sub_arr, low, high)\n            quicksort(sub_arr, low, pi - 1)\n            quicksort(sub_arr, pi + 1, high)\n\n    original_arr = arr.copy()\n    quicksort(arr, 0, len(arr) - 1)\n    eversion_count = 0\n\n    while arr != original_arr:\n        eversion_count += 1\n        arr = original_arr.copy()\n        quicksort(arr, 0, len(arr) - 1)\n\n    return eversion_count\n\n# Interface\nn = int(input())\na = list(map(int, input().split()))\nresult = eversion_sort(a)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_eversions(arr: List[int]) -> int:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    def is_stable(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n\n    n = len(arr)\n    eversions = 0\n    while not is_stable(arr):\n        quick_sort(arr, 0, n - 1)\n        eversions += 1\n    return eversions\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_min_eversions(arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_sort(arr: List[int]) -> int:\n    def partition(sub_arr: List[int], pivot: int) -> List[int]:\n        left = []\n        right = []\n        for num in sub_arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def quick_sort_eversion(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n        pivot = arr[-1]\n        partitioned = partition(arr[:-1], pivot)\n        return quick_sort_eversion(partitioned[:len(partitioned)//2]) + [pivot] + quick_sort_eversion(partitioned[len(partitioned)//2:])\n\n    eversion_count = 0\n    previous_arr = arr\n    current_arr = quick_sort_eversion(arr)\n\n    while previous_arr != current_arr:\n        previous_arr = current_arr\n        current_arr = quick_sort_eversion(current_arr)\n        eversion_count += 1\n\n    return eversion_count\n\n# Interface\nn = int(input())\na = list(map(int, input().split()))\nresult = eversion_sort(a)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef func(n: int, a: List[int]) -> int:\n    def is_stable(arr: List[int]) -> bool:\n        return arr == sorted(arr)\n\n    def eversion_operation(arr: List[int]) -> List[int]:\n        pivot = arr[-1]\n        left = []\n        right = []\n        for i in range(len(arr) - 1):\n            if arr[i] <= pivot:\n                left.append(arr[i])\n            else:\n                right.append(arr[i])\n        return left + [pivot] + right\n\n    eversion_count = 0\n    while not is_stable(a):\n        a = eversion_operation(a)\n        eversion_count += 1\n    return eversion_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = func(n, a)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires the implementation of the eversion operation on an array and the determination of the minimum number of eversions after which the array stops changing. The input consists of multiple test cases, each with a different array length and elements. The output should provide the number of eversions for each test case. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement the eversion operation on an array.\n- Determine the minimum number of eversions for each test case.\n- Ensure the solution is scalable to handle large inputs.\n- Optimize the algorithm to minimize computational overhead.\nTo implement the solution, we will use Python due to its simplicity and efficiency. The eversion operation can be efficiently handled using a stable partition algorithm, which ensures that the relative order of elements within the left and right parts does not change. We will use the built-in sorting functions to partition the array, which will help in maintaining the stability of the partition. The main challenge is to determine the minimum number of eversions after which the array stops changing, which can be achieved by repeatedly applying the eversion operation until the array no longer changes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element (x), where elements less than or equal to x go to the left, and elements greater than x go to the right. The order within each partition is preserved.\n    Explanation: The eversion operation is a way to rearrange the array by repeatedly partitioning it based on a pivot element until the array no longer changes. The goal is to find the minimum number of such operations needed to reach a stable state.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element (x) must be greater than the elements in the left partition and less than the elements in the right partition.\n    'at least as many times': Refers to the frequency of the pivot element in the array.\n\n# [degree adverb] \n    'minimum': Indicates the smallest number of operations required to reach a stable state.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. For each test case, perform eversion operations until the array no longer changes.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 1, 1] = 1\n    Explanation: The array already stops changing after the first eversion since all elements are the same.\n    Edge case 2: [2, 2, 3, 3, 3] = 1\n    Explanation: The array stops changing after one eversion because the most frequent element (3) appears more than once.\n    Edge case 3: [5, 5, 4, 4, 4] = 1\n    Explanation: The array stops changing after one eversion because the most frequent element (5) appears more than once.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle arrays where all elements are the same or where the most frequent element appears more than once.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and implementing a method to determine the minimum number of eversions after which the array stops changing. The input is given in a format where the first line specifies the number of test cases, and each subsequent line contains the array length and the array elements. The output should be the minimum number of eversions for each test case. The solution should be efficient enough to handle the upper limits of input size.\nrequirement pool:\n- Implement the eversion operation and determine the minimum number of eversions for each test case.\n- Ensure the solution is scalable and can handle large inputs efficiently.\n- Optimize the time complexity of the solution to ensure it performs well even for large inputs.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The eversion operation can be simulated by partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. The process will be repeated until the array no longer changes. We will use a function to perform the eversion operation and another function to count the number of eversions required to stabilize the array.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element and then concatenating the partitions while maintaining stability. The goal is to find the minimum number of eversions required to stabilize the array.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more than its value.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. Perform eversion operations on the array until it stops changing.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 4, 2, 5, 3]\n    Expected output: 1\n    Explanation: The first eversion operation partitions the array into [2, 4, 1, 5, 3] with pivot 3, resulting in [2, 1, 3] and [4, 5]. The next eversion operation with pivot 5 results in [2, 1, 3, 4, 5], which does not change. Thus, the array stabilizes after 1 eversion.\n\n    Edge case 2: [5, 3, 2, 4, 1]\n    Expected output: 2\n    Explanation: The first eversion operation with pivot 1 results in [1, 5, 3, 2, 4]. The second eversion operation with pivot 4 results in [1, 3, 2, 4, 5]. No further changes occur, so the array stabilizes after 2 eversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic already accounts for the possibility of the array not changing after a certain number of eversions.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and implementing it efficiently. The input can be large, so the solution must be optimized for performance. The output should be the minimum number of eversions after which the array stops changing, which can be determined by checking if the array remains the same after each eversion.\nrequirement pool:\n- Implement the eversion operation\n- Ensure the solution is efficient for large inputs\n- Calculate the minimum number of eversions\n- Handle edge cases for stability and efficiency\n- Optimize the algorithm for performance\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The eversion operation can be efficiently implemented using a stable sorting algorithm like MergeSort, which maintains the relative order of elements within the left and right parts. We will iterate through the array, performing eversions until the array no longer changes. The minimum number of eversions required to stabilize the array will be our output.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot element (x), where the left part contains elements not greater than x and the right part contains elements strictly greater than x. The array is then reconstructed by concatenating these two parts.\n    Explanation: The eversion operation is a way to rearrange the array by repeatedly partitioning it based on a pivot until the array no longer changes. The goal is to find the minimum number of such operations required to stabilize the array.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an element in the array that appears more times than its value.\n    Explanation: For example, in the array [2, 2, 3, 3, 3], the number 3 appears more than three times, which is more than its value.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer that meets the condition of appearing more times than its value.\n    Explanation: For instance, in the array [3, 3, 2, 4, 4, 4], the number 4 is the largest integer that appears more than four times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to iterate through the array, perform eversions, and check if the array stabilizes. We can use a loop to keep performing eversions until the array no longer changes.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: In this array, the number 3 appears more than three times, which is exactly its value. However, since we are looking for the largest integer that meets the condition, the answer is 3.\n    search([5, 5, 4, 4, 4]) = -1\n    Explanation: Here, the number 4 appears more than four times, but its value is 4, not greater. Therefore, no such integer exists, and the output is -1.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The number 3 appears more than three times, which is more than its value. Thus, the output is 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to determine the correct output for the given edge cases.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array and determining the number of iterations required for the array to stop changing. The operation partitions the array based on a pivot element and concatenates the parts while maintaining stability. The challenge is to implement this efficiently, especially for large arrays.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the algorithm is efficient and handles large inputs\n- Provide clear and concise output for each test case\n- Test the algorithm with various input sizes and edge cases\nTo implement the eversion operation efficiently, we will use Python's built-in list operations and leverage the stability of partition operations. The algorithm will iterate through the array, partitioning it based on a pivot until the array stops changing. We will use a stable partition method to ensure the relative order of elements within the left and right parts doesn't change.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot, ensuring the stability of the partition to maintain the relative order of elements within the left and right parts.\n    Explanation: The eversion operation is a specific type of partitioning where the array is split into two parts based on a chosen pivot. The left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. The stability of the partition ensures that the order of elements within each part remains unchanged.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in list operations and leverage the stability of partition operations. The algorithm will iterate through the array, partitioning it based on a pivot until the array stops changing. We will use a stable partition method to ensure the relative order of elements within the left and right parts doesn't change.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The array is already sorted, so no eversions occur. The array stops changing immediately.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [5, 4, 3, 2, 1]\n    Explanation: The array is in reverse order, so each partition will result in a new array with one element in the left part and the rest in the right part. The number of eversions required to sort the array is equal to the length of the array.\n    Expected output: n (length of the array)\n\n    Edge case 3:\n    Input: [3, 1, 2, 4, 3]\n    Explanation: The array contains duplicates and needs multiple eversions to reach a stable state. The number of eversions required will depend on the specific values and their positions in the array.\n    Expected output: The number of eversions required to reach a stable state.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will handle the edge cases by iterating through the array and partitioning it based on a pivot until the array stops changing.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array and determining the number of iterations required for the array to stop changing. The operation partitions the array based on a pivot element and concatenates the parts while maintaining stability. The challenge is to implement this efficiently, especially for large arrays.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the algorithm is efficient and handles large inputs\n- Provide clear and concise output for each test case\n- Test the algorithm with various input sizes and edge cases\nTo implement the eversion operation efficiently, we will use Python's built-in list operations and the concept of stable sorting. The eversion operation involves partitioning the array based on a pivot element and then concatenating the parts while maintaining stability. We will use a stable sorting algorithm to ensure the relative order of elements within the left and right parts doesn't change. The algorithm will iterate until the array stops changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the parts while maintaining stability. The stability ensures that the relative order of elements within the left and right parts doesn't change.\n    Explanation: The eversion operation is a specific way to rearrange the elements of an array based on a pivot. It partitions the array into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. The key aspect is maintaining the order of elements within each part, which is crucial for the stability of the operation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in list operations and the concept of stable sorting. The algorithm will iterate until the array stops changing.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The array is already sorted in ascending order. Since the pivot is the last element (5), the left part will be [1, 2, 3, 4] and the right part will be []. The array stops changing after the first eversion operation because there are no elements greater than 5 to partition further.\n    Expected output: 1\n\n    Edge case 2:\n    Input: [5, 4, 3, 2, 1]\n    Explanation: The array is sorted in descending order. The pivot is the first element (5). After the first eversion operation, the left part will be [5] and the right part will be [4, 3, 2, 1]. The array will continue to change with each subsequent eversion operation until all elements are in the left part.\n    Expected output: 5\n\n    Edge case 3:\n    Input: [3, 1, 2, 4, 5]\n    Explanation: The array is not sorted. The pivot is the last element (5). After the first eversion operation, the left part will be [3, 1, 2] and the right part will be [4]. The array will continue to change with each subsequent eversion operation until it reaches a stable state where no further changes occur.\n    Expected output: 3\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work for the given constraints and will naturally handle these edge cases by stopping when the array stops changing.\n", "requirement analysis:\nThe requirement involves creating a stable sorting algorithm that can handle large datasets efficiently. The eversion operation defines a specific way to partition the array, which is crucial for maintaining the stability of the sorting. The algorithm should be able to handle up to 2 * 10^5 elements, making it suitable for practical applications.\nrequirement pool:\n- Implement the eversion operation for stable partitioning\n- Ensure the algorithm can handle up to 2 * 10^5 elements\n- Optimize the partitioning process for better performance\n- Provide a clear output for the number of iterations until the array stops changing\nTo implement the eversion operation for stable partitioning, we will use Python's built-in list operations and the concept of stable sorting. The eversion operation involves partitioning the array based on a pivot element such that all elements less than or equal to the pivot are on the left, and all elements greater than the pivot are on the right. This partitioning is stable, meaning that the relative order of equal elements is preserved. We will use a modified version of the quicksort algorithm to efficiently partition the array while maintaining stability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'stable partitioning': This involves partitioning the array into two parts based on a pivot element while maintaining the relative order of equal elements in both parts.\n    Explanation: In the eversion operation, the array is divided into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. The stability of this partitioning ensures that the order of elements within each part remains the same as before the operation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation, we can use a modified quicksort algorithm. The algorithm involves selecting a pivot element, partitioning the array around the pivot while maintaining stability, and recursively applying the same process to the subarrays. The process continues until the array stops changing.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 3, 2, 4, 5]\n    Explanation: The pivot is 3. The array is partitioned into [1, 2] (elements \u2264 3) and [4, 5] (elements > 3). The array stops changing after the first eversion operation.\n    Expected output: 1\n\n    Edge case 2:\n    Input: [5, 4, 3, 2, 1]\n    Explanation: The pivot is 5. The array is partitioned into [4, 3, 2, 1] (elements \u2264 5) and [] (elements > 5). The array stops changing after the first eversion operation.\n    Expected output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic is sufficient to determine the number of eversions after which the array stops changing.\n", "requirement analysis:\nThe primary requirement is to determine the minimum number of eversions required to sort an array. The input consists of multiple test cases, each with a specified number of elements and their values. The output should reflect the number of eversions after which the array stops changing. The solution must be efficient and capable of handling large inputs efficiently.\nrequirement pool:\n- Implement the eversion operation to sort the array.\n- Ensure the solution is scalable and can handle up to 2 \u22c5 10^5 elements.\n- Optimize the number of eversions to reach a stable state.\n- Provide clear and accurate output for each test case.\n- Ensure the solution is user-friendly and easy to understand.\nTo implement the eversion operation for sorting an array efficiently, we will utilize Python's built-in data structures and algorithms. The eversion operation involves partitioning the array into two parts based on a pivot and then sorting each part independently. We will use the quicksort algorithm for partitioning and sorting, which is efficient and well-suited for handling large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot value.\n    Explanation: In the given requirement, the array is divided into two parts where the left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. This is a key concept for understanding the eversion operation.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the elements in the right part of the partition are greater than the pivot.\n    Explanation: This phrase is used to specify the condition for elements in the right partition.\n\n# [degree adverb] \n    'minimum': refers to the smallest number of eversions needed for the array to stop changing.\n    Explanation: This adverb is used to describe the goal of finding the minimum number of eversions required to achieve a stable array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Choose a pivot from the array.\n    2. Partition the array into two parts based on the pivot.\n    3. Recursively apply the same process to each partition until the array stops changing.\n    Steps should be considered simultaneously to ensure that the partitioning and sorting are done correctly for each subarray.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted, so no eversions are needed, and the array stops changing after the first eversion.\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array is in reverse order, so 5 eversions are needed to sort it, with each eversion reducing the array by one element.\n    Edge case 3: [3, 1, 2, 4, 3]\n    Expected output: 3\n    Explanation: The array requires 3 eversions to reach a stable state, where no further changes are made.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already sorted or in reverse order.\n    For edge case 1 and 2, no extra code is needed as the logic can be directly applied.\n    For edge case 3, we need to ensure that the algorithm can handle the pivot and the partitioning correctly to achieve the expected output.\n", "requirement analysis:\nThe requirement involves partitioning the array based on a pivot and ensuring the order within each part is stable. The goal is to determine the minimum number of eversions after which the array stops changing. This requires an efficient algorithm that can handle large inputs efficiently. The solution should be robust and scalable to handle up to 2 \u22c5 10^5 elements.\nrequirement pool:\n- Implement the eversion operation as described.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Optimize the solution for performance and scalability.\n- Test and validate the solution with multiple test cases.\n- Ensure the output matches the expected number of eversions.\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The key steps involve partitioning the array based on a pivot and ensuring the order within each part is stable. We will use a stable sorting algorithm to maintain the order within partitions. The algorithm will iterate over the array, performing eversions until the array stops changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': involves dividing the array into two parts based on a pivot, with elements in the left part being less than or equal to the pivot and elements in the right part being greater than the pivot.\n    'stable order': means that the relative order of elements within each partition is preserved.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves partitioning the array based on a pivot and ensuring the order within each part is stable. We will use a stable sorting algorithm to maintain the order within partitions. The algorithm will iterate over the array, performing eversions until the array stops changing.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The array is already sorted, so no eversions are needed. The array stops changing after 0 eversions.\n    Edge case 2:\n    Input: [5, 4, 3, 2, 1]\n    Explanation: The array is in reverse order, so one eversion will sort it. The array stops changing after 1 eversion.\n    Edge case 3:\n    Input: [3, 1, 2, 4, 3]\n    Explanation: The array will stabilize after 2 eversions. The first eversion will partition the array into [1, 2, 3] and [4, 3], and the second eversion will partition the array into [1, 2] and [3, 3, 4]. The array stops changing after 2 eversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will handle the edge cases by checking if the array has stabilized after each eversion.\n", "requirement analysis:\nThe primary requirement is to determine the minimum number of eversions required to sort an array based on the given partitioning and stability rules. The solution must be efficient and scalable to handle large inputs as specified.\nrequirement pool:\n- Implement the eversion operation to partition and sort the array.\n- Ensure the solution is efficient and can handle up to 2 \u22c5 10^5 elements.\n- Optimize the number of eversions to reach a stable state.\n- Provide clear and accurate output for each test case.\nTo implement the eversion operation efficiently, we will utilize Python's built-in data structures and algorithms. The key challenge is to ensure that the partitioning and stability requirements are met while minimizing the number of eversions. We will use the QuickSort algorithm as a base, adapting it to perform the eversion operation as described. The algorithm will partition the array based on a pivot and then recursively sort the partitions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot value.\n    'stability': maintaining the relative order of elements with equal values.\n    'eversion': the operation of performing partitioning and sorting on an array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the pivot value must be greater than some threshold.\n    'at least as many times': suggests that the pivot value must appear a minimum number of times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the above conditions.\n    'smallest': indicates the minimum number of eversions required for the array to stop changing.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will use a modified QuickSort algorithm:\n    1. Choose the last element as the pivot.\n    2. Partition the array into two parts: elements less than or equal to the pivot and elements greater than the pivot.\n    3. Recursively apply the same process to the two partitions.\n    4. Continue until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted, so no eversions are needed.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array is in reverse order, so 5 eversions are needed to sort it.\n\n    Edge case 3: [3, 1, 2, 4, 3, 5, 3] with pivot 3\n    Expected output: 3\n    Explanation: After the first eversion, the array becomes [1, 2, 3, 3, 3, 4, 5]. After the second eversion, it becomes [1, 2, 3, 3, 3, 4, 5]. The array stops changing after the third eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already ensures that the array stops changing after a finite number of eversions.\n", "requirement analysis:\nThe problem requires an algorithm that can handle multiple test cases efficiently, with each test case potentially containing a large number of elements. The solution should be able to partition the array and perform eversions until the array stops changing, outputting the minimum number of eversions required. The algorithm should be designed to handle large inputs within reasonable time constraints, making it suitable for practical applications.\nrequirement pool:\n- Implement the eversion operation and ensure it is stable.\n- Develop a loop to perform eversions until the array stops changing.\n- Ensure the algorithm can handle large inputs efficiently.\n- Optimize the partitioning process for better performance.\n- Provide clear and concise output for the number of eversions.\nTo implement the eversion operation and ensure it is stable, we will use Python's built-in data structures and list operations. The algorithm will involve partitioning the array based on a pivot element, which will be the last element of the array for simplicity. We will then iterate over the array, moving elements less than or equal to the pivot to the left and elements greater than the pivot to the right, maintaining the order within each partition. This process will be repeated until the array no longer changes, indicating that it has stabilized. The function will return the number of eversions required to reach this state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element and then concatenating the partitioned parts while maintaining the order within each part. The operation is repeated until the array stops changing.\n    Explanation: The eversion operation is a transformation applied to an array where the array is split into two parts based on a pivot element (the last element of the array in this case), with elements less than or equal to the pivot going to the left and elements greater than the pivot going to the right. This process is repeated iteratively until the array no longer changes, indicating that it has stabilized.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements in the array that are strictly greater than the pivot.\n    Explanation: For example, in the array [2, 4, 1, 5, 3], the pivot is 3. The left part will contain elements \u2264 3 (i.e., 2, 1, 3), and the right part will contain elements > 3 (i.e., 4, 5).\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest element in the array that is greater than the pivot.\n    Explanation: For example, in the array [2, 4, 1, 5, 3], the pivot is 3. The largest element in the right part is 5.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to follow these steps:\n    1. Identify the pivot element (the last element of the array).\n    2. Partition the array into two parts: left (elements \u2264 pivot) and right (elements > pivot).\n    3. Concatenate the left and right parts to form the new array.\n    4. Repeat the process until the array no longer changes.\n    5. Return the number of eversions performed.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need. \n\n# [edge case] \n    search([5, 5, 4, 4, 4]) = -1\n    Explanation: number 5 appears two times, number 4 appears three times, but no number appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need. \n\n# [edge case] \n    search([]) = -1\n    Explanation: The list is empty, so there are no integers to search for, so the function should return -1.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge case.\n        if not lst:\n            return -1\n        (other code)\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 96, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "expand_one2two", "parent_index": 87}
