{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Make sure to consider edge cases, such as when n is 1 or when k is very large. Be mindful of the computational complexity to ensure efficiency and accuracy in the result.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Make sure to consider edge cases, such as when n is 1 or when k is very large. Be mindful of the computational complexity to ensure efficiency and accuracy in the result.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of distinct non-negative powers of a given number n. For instance, with n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, whereas 9 is not.\n\nTheofanis needs your help to determine the k-th special number in\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be expressed as a sum of distinct non-negative powers of n. Theofanis asks you to help him find the k-th special number in increasing order, outputting it modulo 10^9+7. Consider edge cases and ensure efficiency and accuracy in the result.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if n == 1:\n        return 1\n    \n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result += pow(n, power, MOD)\n            result %= MOD\n        k //= 2\n        power += 1\n    \n    return result\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    MOD = 10**9 + 7\n    special_numbers = set([0])\n    power = 0\n    \n    while True:\n        current_power = n ** power\n        if current_power > k:\n            break\n        new_numbers = set()\n        for number in special_numbers:\n            new_number = number + current_power\n            if new_number <= k:\n                new_numbers.add(new_number)\n        special_numbers.update(new_numbers)\n        power += 1\n    \n    special_numbers_list = sorted(special_numbers)\n    return special_numbers_list[k - 1] % MOD\n\n# Read input\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result += power\n            result %= MOD\n        power *= n\n        power %= MOD\n        k //= 2\n    \n    return result\n\n# Read input from stdin\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\nimport math\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    def generate_special_numbers(base: int):\n        powers = [base**i for i in range(32)]  # 2^31 is larger than 10^9\n        special_numbers = set()\n        for i in range(32):\n            for j in range(i, 32):\n                current_sum = sum(powers[i:j+1])\n                if current_sum not in special_numbers:\n                    special_numbers.add(current_sum)\n        return sorted(special_numbers)\n\n    special_numbers = generate_special_numbers(n)\n    if k > len(special_numbers):\n        return -1\n    return special_numbers[k-1]\n\n# Provide the Interface\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    special_numbers = []\n    i = 0\n    while len(special_numbers) < k:\n        power_value = n ** i\n        if power_value not in special_numbers:\n            special_numbers.append(power_value)\n        i += 1\n    return special_numbers[-1]\n\n# Example usage:\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\nimport sys\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    special_numbers = []\n    i = 0\n    while len(special_numbers) < k:\n        value = n**i\n        if value not in special_numbers:\n            special_numbers.append(value)\n        i += 1\n    return special_numbers[k-1]\n\n# Main function to read input and call the function\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        result = find_kth_special_number(n, k)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result += power\n            result %= MOD\n        power *= n\n        k //= 2\n    \n    return result\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    MOD = 10**9 + 7\n\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n\n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number in a sequence defined by the sum of distinct non-negative powers of n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence.\n    \n    Returns:\n        int: The k-th special number modulo 10^9 + 7.\n    \"\"\"\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result += power\n        power *= n\n        k //= 2\n    return result % (10**9 + 7)\n\n# Read the number of test cases\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if n == 1:\n        return k\n    \n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence defined by the sum of distinct non-negative powers of n. The challenge lies in handling large values of n and k, ensuring the solution is efficient and accurate. Edge cases to consider include when n is 1 or when k is very large.\nrequirement pool:\n- Implement a function to calculate special numbers.\n- Ensure the function can handle large values of n and k.\n- Output the result modulo 10^9+7.\n- Optimize the algorithm for performance and accuracy.\n- Consider edge cases and ensure robustness.\nTo solve the problem of finding the k-th special number in a sequence defined by the sum of distinct non-negative powers of n, we will use a mathematical approach that leverages the properties of binary representation. This approach is efficient and can handle large values of n and k. The sequence of special numbers can be seen as a binary representation of numbers, where each bit represents whether a particular power of n is included in the sum. We will use Python's built-in capabilities to efficiently compute these numbers modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of n.\n    Explanation: In this context, a special number is a number that can be represented as a sum of different powers of a base number n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers greater than a certain value.\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending order.\n\n# [code logic]\n    To find the k-th special number in increasing order, we can use a mathematical approach based on the binary representation of numbers. Each bit in the binary representation can be mapped to a power of n. We will iterate through the bits of k and compute the corresponding special number by summing the appropriate powers of n. Since the result can be very large, we will take the result modulo 10^9+7 to ensure it fits within standard integer limits.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = -1\n    Explanation: In this case, the list contains only unique numbers, and no number appears as many times as its value. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n is 1. If n is 1, then the only special number is 1, as 1 can be expressed as 1^0.\n        if n == 1:\n            return 1\n        (other code)\n\n    Additionally, for very large values of k, the computation might take a long time. We can optimize the process by using bitwise operations to directly compute the k-th special number without generating all previous numbers.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence generated by summing distinct non-negative powers of n. The system must handle large numbers and ensure efficiency. Edge cases include when n is 1 or k is very large. The output should be modulo 10^9+7 to prevent overflow and ensure accuracy.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large values of n and k.\n- Implement a modulo operation to prevent overflow.\n- Test the system with edge cases to ensure robustness.\n- Optimize the algorithm for performance.\nTo efficiently find the k-th special number in a sequence generated by summing distinct non-negative powers of n, we will use a mathematical approach that leverages the properties of powers of n. The sequence of special numbers can be generated by considering all possible sums of distinct powers of n. Given the constraints of large values of n and k, we will implement the solution in Python and use modular arithmetic to handle large numbers and prevent overflow. The algorithm will be optimized to ensure efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a base number n.\n    Explanation: In the context of the problem, a special number is one that can be represented as the sum of different powers of a given base number n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than a certain value.\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number in the sequence.\n\n# [code logic]\n    To find the k-th special number, we need to generate the sequence of special numbers by summing distinct non-negative powers of n. This can be done using a loop to iterate through possible sums of powers of n. Since the result may be very large, we will use modular arithmetic to keep the numbers within manageable bounds.\n\n# [edge case] \n    search([1], 1) = 1\n    Explanation: If the list contains only the number 1, and k is 1, the first and only special number is 1.\n    search([1, 3, 4, 9], 5) = 9\n    Explanation: The sequence is [1, 3, 4, 9, ...]. The 5th special number is 9.\n    search([2, 2, 3, 3, 3], 3) = 3\n    Explanation: The sequence is [2, 3, ...]. The 3rd special number is 3, even though 2 appears more than once.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the k-th special number is straightforward and does not require additional complexity for edge cases.\n\n# [code logic]\n    To efficiently find the k-th special number, we can use a mathematical approach that leverages the properties of powers of n. The sequence of special numbers can be generated by considering all possible sums of distinct powers of n. Given the constraints of large values of n and k, we will implement the solution in Python and use modular arithmetic to handle large numbers and prevent overflow. The algorithm will be optimized to ensure efficiency.\n\n# [edge case] \n    search([1], 1) = 1\n    Explanation: If the list contains only the number 1, and k is 1, the first and only special number is 1.\n    search([1, 3, 4, 9], 5) = 9\n    Explanation: The sequence is [1, 3, 4, 9, ...]. The 5th special number is 9.\n    search([2, 2, 3, 3, 3], 3) = 3\n    Explanation: The sequence is [2, 3, ...]. The 3rd special number is 3, even though 2 appears more than once.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the k-th special number is straightforward and does not require additional complexity for edge cases.\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence of numbers that can be expressed as sums of distinct non-negative powers of n. The solution must be efficient and handle large inputs, including cases where n and k are very large. The output should be given modulo 10^9+7 to prevent overflow and ensure precision. The system should also handle edge cases, such as when n is 1.\nrequirement pool:\n- Implement an algorithm to find the k-th special number.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Output the result modulo 10^9+7.\n- Handle edge cases, including when n is 1.\n- Optimize the algorithm for performance and accuracy.\nTo efficiently find the k-th special number in a sequence that consists of numbers which can be expressed as sums of distinct non-negative powers of n, we will use a mathematical approach. The sequence of special numbers can be generated using the concept of binary numbers, where each bit represents whether a particular power of n is included in the sum. This approach allows us to generate the sequence without explicitly storing all numbers, making it efficient even for large values of n and k. The result will be computed modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of n.\n    Explanation: A special number is generated by summing up different powers of a base number n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'at least as many times': means that the frequency of the number in the sequence should be at least equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach where each bit in the binary representation of k represents whether a particular power of n is included in the sum. This approach allows us to generate the sequence without explicitly storing all numbers, making it efficient even for large values of n and k. The result will be computed modulo 10^9+7 to handle large numbers.\n\n# [edge case] \n    search([1]) = 1\n    Explanation: The sequence contains only the number 1, which is the smallest special number.\n    search([2, 3, 4, 5, 6, 7, 8, 9]) = -1\n    Explanation: None of the numbers in the sequence can be expressed as a sum of distinct non-negative powers of n, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly check if the sequence contains only the number 1 and return 1 if it does. For other cases, we can proceed with the main logic.\n", "requirement analysis:\nThe problem requires understanding the properties of special numbers and their sums. The solution needs to be efficient and handle large inputs, including large values of n and k. The output should be in increasing order and modulo 10^9+7. The solution should be robust and handle edge cases effectively.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number.\n- Handle large inputs and ensure the solution is optimized for performance.\n- Ensure the output is in increasing order modulo 10^9+7.\n- Implement robust handling of edge cases and large integers.\n- Design a user-friendly interface for input and output.\nTo efficiently find the k-th special number, we will use a mathematical approach based on the properties of powers of a given number n. The special numbers can be represented as sums of distinct non-negative powers of n. We will use a brute-force approach to generate these numbers until we reach the k-th special number. To handle large inputs, we will use Python's built-in support for large integers and modulo operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given number n.\n    Explanation: In this problem, we are dealing with sequences of numbers that can be represented as the sum of distinct powers of a base number n. This concept involves understanding the mathematical properties of exponents and sums.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers that are greater than zero.\n    'at least as many times': means that we need to find special numbers that can be represented as sums of distinct powers of n, and the number of times a special number appears is at least equal to its value.\n\n# [degree adverb] \n    'largest': means that we need to find the largest special number that appears at least as many times as its value.\n\n# [code logic]\n    To find the k-th special number, we need to generate numbers that are sums of distinct non-negative powers of n. We will use a brute-force approach to generate these numbers until we reach the k-th special number. We will use Python's built-in support for large integers and modulo operations to handle large inputs.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 are special numbers because they can be expressed as sums of distinct powers of n. However, 3 is the largest number among the special numbers that appears at least as many times as itself.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears once, number 3 appears twice, and number 4 appears three times. None of these numbers appear at least as many times as themselves, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest special number that meets the condition.\n\n# [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given number n.\n    Explanation: In this problem, we are dealing with sequences of numbers that can be represented as the sum of distinct powers of a base number n. This concept involves understanding the mathematical properties of exponents and sums.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find special numbers that are greater than zero.\n    'at least as many times': means that we need to find special numbers that can be represented as sums of distinct powers of n, and the number of times a special number appears is at least equal to its value.\n\n# [degree adverb] \n    'largest': means that we need to find the largest special number that appears at least as many times as its value.\n\n# [code logic]\n    To find the k-th special number, we need to generate numbers that are sums of distinct non-negative powers of n. We will use a brute-force approach to generate these numbers until we reach the k-th special number. We will use Python's built-in support for large integers and modulo operations to handle large inputs.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 are special numbers because they can be expressed as sums of distinct powers of n. However, 3 is the largest number among the special numbers that appears at least as many times as itself.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears once, number 3 appears twice, and number 4 appears three times. None of these numbers appear at least as many times as themselves, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest special number that meets the condition.\n", "requirement analysis:\nThe problem requires generating special numbers based on the given base number n and finding the k-th special number in the sequence. The solution should be efficient and handle large inputs within the given constraints. The modulo operation is necessary to ensure the results fit within the specified range.\nrequirement pool:\n- Implement a function to generate special numbers.\n- Ensure the function can handle large inputs efficiently.\n- Implement a modulo operation to handle large numbers.\n- Develop a user-friendly interface for easy input and output.\n- Optimize the algorithm for performance and scalability.\nTo efficiently generate the k-th special number for large values of n and k, we will use a mathematical approach to understand the properties of special numbers. We will leverage Python's capabilities to handle large integers and use a brute-force method to generate the sequence until we find the k-th special number. The modulo operation will be applied to ensure the results fit within the specified range of 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given number n.\n    Explanation: This means that for a given base number n, a special number can be represented as a sum of powers of n (e.g., n^0, n^1, n^2, etc.) where each power is used only once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To generate the k-th special number, we need to:\n    1. Understand that each special number can be represented as a sum of distinct powers of n.\n    2. Generate these sums until we reach the k-th special number.\n    3. Use a brute-force approach to generate the sequence, starting from the smallest special number (which is 1 for any base n) and incrementing until we reach k.\n\n# [edge case] \n    For n = 2 and k = 5:\n        The special numbers are [1, 2, 4, 8, 16]. The 5th special number is 16.\n    Explanation: The sequence starts with 1 (2^0), 2 (2^1), 4 (2^2), and so on. The 5th number in this sequence is 16.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute-force approach will naturally generate the sequence and find the k-th special number.\n\n# [code logic]\n    Here's a Python function to generate the k-th special number:\n\n    ```python\n    def find_kth_special_number(n, k):\n        special_numbers = []\n        i = 0\n        while len(special_numbers) < k:\n            power_value = n ** i\n            if power_value not in special_numbers:\n                special_numbers.append(power_value)\n            i += 1\n        return special_numbers[-1]\n\n    # Example usage:\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        print(find_kth_special_number(n, k))\n    ```\n\n    This function reads the number of test cases and then for each test case, it reads the values of n and k, and prints the k-th special number. The function uses a brute-force approach to generate the sequence of special numbers until it finds the k-th one.\n", "requirement analysis:\nThe requirement involves creating a program that can determine the k-th special number based on the given base number n. The special number is defined as a sum of distinct non-negative powers of n. The program should be able to handle multiple test cases efficiently. The output should be the k-th special number in increasing order modulo 10^9+7.\nrequirement pool:\n- Implement a function to calculate the k-th special number.\n- Ensure the function can handle large inputs and provide accurate results.\n- Develop a user-friendly interface for easy interaction.\n- Optimize the algorithm for performance and efficiency.\n- Include error handling and validation for user inputs.\nTo efficiently find the k-th special number, we will use a mathematical approach that leverages the properties of powers of the base number n. The special numbers can be represented as sums of distinct non-negative powers of n, which can be mapped to binary numbers where each bit represents whether a particular power of n is included in the sum. This allows us to use bit manipulation techniques to generate the sequence of special numbers in order. We will use Python's built-in functions and libraries to handle large numbers and ensure the solution is robust and efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of a given number n.\n    Explanation: In this problem, we need to identify numbers that can be formed by adding distinct powers of a base number n. This is similar to representing numbers in binary, where each bit can be thought of as a power of n being included or not.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are looking for the k-th special number in increasing order, not the largest.\n\n# [code logic]\n    To find the k-th special number, we can use a binary representation approach. Each bit in the binary representation can be mapped to a power of n. We start from the least significant bit (which corresponds to the smallest power of n) and keep adding powers until we reach k special numbers.\n\n# [edge case] \n    search([1], 1) = 1\n    Explanation: The sequence starts with 1, which is the first special number.\n    search([1, 3, 4, 9], 5) = -1\n    Explanation: The sequence provided does not include the 5th special number. The sequence needs to be extended to include the 5th special number.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the sequence does not provide the k-th special number. This could involve generating more special numbers until we reach the desired k-th number.\n\n# [code logic]\n    def find_kth_special_number(n, k):\n        special_numbers = []\n        i = 0\n        while len(special_numbers) < k:\n            value = n**i\n            if value not in special_numbers:\n                special_numbers.append(value)\n            i += 1\n        return special_numbers[k-1]\n\n    # Main function to read input and call the function\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n, k = map(int, input().split())\n            print(find_kth_special_number(n, k))\n\n    if __name__ == \"__main__\":\n        main()\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence where each number is a sum of distinct non-negative powers of n. The solution must be efficient and accurate, capable of handling large inputs within a reasonable time frame. Additionally, the user interface should be intuitive and easy to use.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number.\n- Ensure the solution is accurate and handles large inputs within reasonable time.\n- Create a user-friendly interface for easy input and output.\n- Test and handle edge cases to ensure robustness.\nTo solve the problem of finding the k-th special number in a sequence where each number is a sum of distinct non-negative powers of n, we will use a mathematical approach based on the properties of binary numbers. This approach is efficient and leverages the fact that the sequence of special numbers can be seen as a binary representation of numbers. Given the constraint that n must be between 2 and 10^9 and k must be between 1 and 10^9, we need to ensure our solution is scalable and can handle large inputs efficiently. We will use Python for implementation due to its performance and ease of handling large integers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct non-negative powers of n': This means that each number in the sequence is a sum of unique powers of n, similar to how each bit in a binary number represents a power of 2.\n    Explanation: In this context, a number is considered special if it can be expressed as the sum of distinct non-negative powers of n. This is akin to representing numbers in a base-n system where each digit (or power of n) is unique and non-negative.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we are looking for numbers greater than a certain value.\n    Explanation: In the context of this problem, we need to find the k-th special number, which means we are looking for the k-th smallest number that can be represented as a sum of distinct non-negative powers of n.\n\n# [degree adverb] \n    'increasing order': This implies that we need to output the numbers in a sorted manner, starting from the smallest special number.\n    Explanation: The requirement to find the k-th special number in increasing order means that we need to generate the sequence of special numbers and then select the k-th element from it.\n\n# [code logic]\n    To implement the solution, we can use a mathematical approach to convert the k-th special number into a base-n representation. Since each special number is a sum of distinct non-negative powers of n, we can think of it as a binary representation but in base-n. We will use a loop to find the k-th special number by converting k into base-n and then computing the corresponding number.\n\n# [edge case] \n    test_case = (3, 1) = 1\n    Explanation: In base-3, the number 1 is represented as 1 in base-10. Since 1 is a power of 3 (3^0), it is a special number.\n    test_case = (2, 5) = 11\n    Explanation: In base-2, the number 5 is represented as 101 in base-10. This corresponds to the sum of distinct non-negative powers of 2: 2^2 + 2^0 = 4 + 1 = 5.\n    test_case = (5, 10) = 120\n    Explanation: In base-5, the number 10 is represented as 20 in base-10. This corresponds to the sum of distinct non-negative powers of 5: 5^1 + 5^0 = 5 + 1 = 6. However, this edge case seems incorrect based on the problem statement, as the expected output should be a power of 5, not a sum of distinct non-negative powers of 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if k == 1:\n            return 1\n        MOD = 10**9 + 7\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result += power\n                result %= MOD\n            power *= n\n            k //= 2\n        return result\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence where each number is a sum of distinct non-negative powers of n. The solution must be efficient to handle large values of n and k, and the output must be given modulo 10^9+7 to avoid large number calculations. The user interface should be simple and straightforward for easy input and output.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number.\n- Ensure the solution handles large inputs within a reasonable time.\n- Provide the output modulo 10^9+7.\n- Create a user-friendly interface for easy input and output.\n- Test the solution with various edge cases to ensure accuracy.\nTo efficiently find the k-th special number in a sequence where each number is a sum of distinct non-negative powers of n, we will use a mathematical approach based on the properties of binary numbers. This approach will be efficient and suitable for handling large values of n and k. We will use Python's built-in capabilities to perform modulo operations, which will help in managing large numbers efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum of distinct non-negative powers of n': This means that each special number can be represented as a sum of unique powers of n, similar to how binary numbers are sums of distinct powers of 2.\n    Explanation: In this context, a special number is a sum of unique powers of n, which can be thought of as a binary representation where each bit represents a power of n. For example, if n = 2, then the sequence of special numbers would be 1, 2, 3 (1, 2^1, 2^1 + 1), 4, 5 (1 + 4), 6 (2 + 4), 7 (1 + 2 + 4), and so on.\n\n# [phrase showing quantity relationship]\n    'distinct non-negative powers': This phrase indicates that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'increasing order': This means that the special numbers should be listed in ascending order based on their values.\n\n# [code logic]\n    To find the k-th special number, we can use a mathematical approach similar to converting a number to binary. For a given n and k, we can find the k-th special number by considering the binary representation of k. Each bit in the binary representation of k corresponds to a power of n being included in the sum.\n\n    Here's a step-by-step approach:\n    1. Initialize a variable to store the result.\n    2. Loop through the bits of k.\n    3. For each bit that is set (i.e., is 1), add the corresponding power of n to the result.\n    4. Return the result modulo 10^9+7 at each step to keep the numbers manageable.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [edge case] \n    search([5, 5, 4, 4, 4]) = -1\n    Explanation: Number 4 appears three times, which is more than its value, but no number appears more than or equal to its value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: Number 3 appears three times, which is more than its value, and it is the largest number that meets the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to the largest integer that meets the need.\n\n# [edge case] \n    search([]) = -1\n    Explanation: The list is empty, so there are no numbers to consider, and the function should return -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        if not lst:\n            return -1\n        (other code)\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence defined by the sum of distinct non-negative powers of n. The solution must be efficient and handle large inputs within reasonable time limits. The output should be accurate and modulo 10^9+7 to avoid integer overflow. Edge cases such as large values of n and k should be considered to ensure the application does not crash or produce incorrect results.\nrequirement pool:\n- Implement an efficient algorithm to find the k-th special number in the sequence.\n- Ensure the solution handles large inputs and edge cases effectively.\n- Provide the result modulo 10^9+7 to avoid integer overflow.\n- Develop a user-friendly interface for easy input and output.\n- Optimize the algorithm for performance and scalability.\nTo efficiently find the k-th special number in a sequence defined by the sum of distinct non-negative powers of n, we will use a mathematical approach based on the properties of binary numbers. This approach is inspired by the fact that the sequence of special numbers can be represented in a similar way to how binary numbers represent all integers using distinct powers of 2. We will convert k to its binary representation and then map each '1' in the binary representation to a power of n, summing these powers to get the k-th special number. This method ensures that we efficiently find the k-th special number without generating all special numbers up to k, which is crucial for handling large values of k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct non-negative powers of n': means that each power of n is used only once in the sum.\n    Explanation: In this problem, a special number is defined as a sum of distinct non-negative powers of a base number n. This is similar to how binary numbers represent numbers using only the digits 0 and 1, where each digit represents a power of 2.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To find the k-th special number, we need to convert k to its binary representation and then map each '1' in the binary representation to a power of n. Finally, we sum these powers to get the k-th special number. This approach ensures that we efficiently find the k-th special number without generating all special numbers up to k.\n\n# [edge case] \n    n = 2, k = 1\n    expected output: 1\n    Explanation: The first special number in increasing order for n = 2 is 1, which is 2^0.\n\n    n = 3, k = 2\n    expected output: 2\n    Explanation: The second special number in increasing order for n = 3 is 2, which is 3^1.\n\n    n = 4, k = 5\n    expected output: 16\n    Explanation: The fifth special number in increasing order for n = 4 is 16, which is 4^2 (since 4^0 + 4^1 + 4^2 = 1 + 4 + 16 = 21, which is not the fifth special number).\n\n# [extra code for edge case]\n    No extra code is needed for the main logic, but we should consider the modulo operation to ensure the result is within the required range of 10^9+7.\n\n    def find_kth_special_number(n, k):\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result += power\n            power *= n\n            k //= 2\n        return result % (10**9 + 7)\n", "requirement analysis:\nThe primary requirement is to find the k-th special number in a sequence defined by powers of n. The challenge lies in handling large numbers and ensuring the solution is efficient. The modulo operation is crucial to manage large outputs. Edge cases include when n is 1 or when k is very large.\nrequirement pool:\n- Implement a function to find the k-th special number based on powers of n.\n- Ensure the solution is efficient and can handle large inputs and outputs modulo 10^9+7.\n- Include robust error handling for edge cases such as n=1 or very large k.\n- Optimize the algorithm to minimize computational complexity.\nTo solve the problem of finding the k-th special number based on powers of n, we will use a mathematical approach that leverages the properties of binary representation. Each special number can be represented as a sum of distinct non-negative powers of n, which is similar to binary numbers where each bit represents a power of 2. We will convert k to its binary form and then compute the corresponding special number by summing the appropriate powers of n. Given the constraints of large numbers and modulo operation, we will use Python's built-in support for large integers and perform all arithmetic operations modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of distinct non-negative powers of n.\n    Explanation: In this problem, a special number is defined as a number that can be represented as a sum of distinct non-negative powers of a base number n. This is akin to representing numbers in a mixed-radix system where each digit represents a power of n.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than a certain value.\n    'distinct non-negative powers': means that each power used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'largest': means that we need to find the largest special number.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To find the k-th special number, we can use the binary representation of k. For each bit in the binary representation of k, if the bit is set, it means we include the corresponding power of n in the sum. We will iterate through the bits of k, compute the corresponding power of n, and sum these values to get the k-th special number. Since the result can be very large, we will take the result modulo 10^9+7.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = -1\n    Explanation: In this case, the list contains only unique numbers, and no number appears as many times as its value. Therefore, the function should return -1.\n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears once, number 3 appears twice, and number 4 appears three times. None of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly implement the logic to find the k-th special number using the binary representation of k.\n"], "scores": [], "pass_results": [false, false, true, false, false, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 194, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "rephrase_one", "parent_index": 149}
