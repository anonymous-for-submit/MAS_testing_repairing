{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You have an array a of size n.\n\nLet's define the eversion operation. Let x = a_n, then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x), and the order of elements in each part is kept the same as before the operation, i.e. the partition is stable, then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You have an array a of size n.\n\nLet's define the eversion operation. Let x = a_n, then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x), and the order of elements in each part is kept the same as before the operation, i.e. the partition is stable, then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You have an array a of size n. Let's define the eversion operation. Let x = a_n, then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x), and the order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, \n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You have an array a of size n. Let's define the eversion operation. Let x = a_n, then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x), and the order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, \n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef func(n: int, a: List[int]) -> int:\n    def eversion_operation(arr: List[int]) -> List[int]:\n        max_val = max(arr)\n        left = [x for x in arr if x <= max_val]\n        right = [x for x in arr if x > max_val]\n        return left + right\n\n    count = 0\n    while True:\n        original_array = a.copy()\n        a = eversion_operation(a)\n        if a == original_array:\n            break\n        count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = func(n, a)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    if not arr:\n        return arr\n    pivot = max(arr)\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    return left + right\n\ndef is_stable(original_arr: List[int], new_arr: List[int]) -> bool:\n    return original_arr == new_arr\n\ndef determine_eversions(n: int, a: List[int]) -> int:\n    k = 0\n    while True:\n        new_arr = eversion_operation(a)\n        if is_stable(a, new_arr):\n            break\n        a = new_arr\n        k += 1\n    return k\n\n# Interface\nn = int(input())\na = list(map(int, input().split()))\nresult = determine_eversions(n, a)\nprint(result)\n", "from typing import List\n## main.py\n\ndef func(n: int) -> int:\n    # Read the array elements\n    array = list(map(int, input().split()))\n    \n    # Initialize the count of eversions\n    eversion_count = 0\n    \n    # Continue performing eversions until the array stops changing\n    while True:\n        # Find the pivot element (x) which is the last element of the array\n        pivot = array[-1]\n        \n        # Partition the array into left and right parts based on the pivot\n        left = [x for x in array if x <= pivot]\n        right = [x for x in array if x > pivot]\n        \n        # Check if the array has changed after this eversion\n        if left + right == array:\n            break\n        \n        # Update the array with the new left and right parts\n        array = left + right\n        \n        # Increment the eversion count\n        eversion_count += 1\n    \n    # Return the number of eversions performed\n    return eversion_count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the size of the array and the array elements\n    n = int(input())\n    result = func(n)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Perform the eversion operation on the input array.\n    \n    The eversion operation involves partitioning the array based on a pivot element,\n    which is the last element of the array. The array is divided into two parts:\n    one containing elements less than or equal to the pivot (left part) and the other\n    containing elements greater than the pivot (right part). This partitioning is stable,\n    meaning the order of elements in each part remains the same as before the operation.\n    \n    Args:\n        arr (list): The input array to be everted.\n        \n    Returns:\n        list: The array after one eversion operation.\n    \"\"\"\n    pivot = arr[-1]\n    left_part = [x for x in arr[:-1] if x <= pivot]\n    right_part = [x for x in arr[:-1] if x > pivot]\n    return left_part + [pivot] + right_part\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the size of the array and the elements of the array\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Initialize the iteration counter\n    iterations = 0\n    \n    # Perform the eversion operation iteratively until the array stops changing\n    while True:\n        new_arr = eversion_operation(arr)\n        iterations += 1\n        if new_arr == arr:\n            break\n        arr = new_arr\n    \n    # Output the number of iterations required for the array to stop changing\n    print(iterations)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot element,\n    which can be efficiently handled using list comprehensions and slicing.\n    The operation is repeated until the array stops changing.\n    \n    Args:\n        arr (list): The input array to be everted.\n    \n    Returns:\n        list: The array after the eversion operation has been performed.\n    \"\"\"\n    def partition(arr, pivot):\n        \"\"\"\n        Partition the array based on the pivot element, maintaining the order of elements.\n        \n        Args:\n            arr (list): The input array to be partitioned.\n            pivot (int): The pivot element around which the array will be partitioned.\n        \n        Returns:\n            tuple: A tuple containing two lists, the left part and the right part.\n        \"\"\"\n        left = []\n        right = []\n        for x in arr:\n            if x <= pivot:\n                left.append(x)\n            else:\n                right.append(x)\n        return left, right\n\n    pivot = arr[-1]\n    while True:\n        left, right = partition(arr, pivot)\n        if left + [pivot] + right == arr:\n            break\n        arr = left + [pivot] + right\n    return arr\n\n# Interface\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    def partition(sub_arr: List[int], pivot: int) -> List[int]:\n        left = [x for x in sub_arr if x <= pivot]\n        right = [x for x in sub_arr if x > pivot]\n        return left + [pivot] + right\n\n    if not arr:\n        return arr\n\n    pivot = arr[-1]\n    partitioned_arr = partition(arr[:-1], pivot)\n    eversion_count = 0\n\n    while partitioned_arr != arr:\n        arr = partitioned_arr\n        pivot = arr[-1]\n        partitioned_arr = partition(arr[:-1], pivot)\n        eversion_count += 1\n\n    return arr\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(len(result) - 1)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list[int]) -> int:\n    def partition(arr: list[int], low: int, high: int) -> int:\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr: list[int], low: int, high: int) -> None:\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    iterations = 0\n    while True:\n        quick_sort(arr, 0, n - 1)\n        if arr == sorted(arr):\n            break\n        iterations += 1\n\n    return iterations\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_inversions(arr: List[int]) -> int:\n    if len(arr) <= 1:\n        return 0\n    \n    def merge_and_count(left, right):\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inversions += len(left) - i\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n\n    mid = len(arr) // 2\n    left_half, left_inversions = count_inversions(arr[:mid])\n    right_half, right_inversions = count_inversions(arr[mid:])\n    merged_array, merge_inversions = merge_and_count(left_half, right_half)\n    return left_inversions + right_inversions + merge_inversions\n\ndef eversion_operation(arr: List[int]) -> int:\n    return count_inversions(arr)\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    _ = input()  # Skip the first line, as it's not needed for the array\n    a = list(map(int, input().split()))\n    result = eversion_operation(a)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot element,\n    which is the largest element in the array. The array is divided into two parts:\n    one containing elements less than or equal to the pivot (left part) and the other\n    containing elements greater than the pivot (right part).\n    \n    Args:\n        arr (list): The input array to be partitioned.\n        \n    Returns:\n        list: The partitioned array after one eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = max(arr)\n    left_part = [x for x in arr if x <= pivot]\n    right_part = [x for x in arr if x > pivot]\n    \n    return left_part + right_part\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the size of the array and the elements\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Initialize the iteration counter\n    k = 0\n    \n    # Apply the eversion operation iteratively until the array stops changing\n    result = arr\n    while result != arr:\n        arr = result\n        result = eversion_operation(arr)\n        k += 1\n    \n    # Output the count for each test case\n    print(k)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation partitions the array into two parts based on a pivot element,\n    where the left part contains elements less than or equal to the pivot, and the right part\n    contains elements greater than the pivot. The array is then reconstructed by concatenating\n    these two parts.\n    \n    Args:\n        arr (List[int]): The input array to perform the eversion operation on.\n        \n    Returns:\n        List[int]: The array after performing the eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = max(arr)\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return left + right\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = arr\n    eversion_count = 0\n    \n    while True:\n        new_result = eversion_operation(result)\n        eversion_count += 1\n        if new_result == result:\n            break\n        result = new_result\n    \n    print(eversion_count)\n"], "plans": ["requirement analysis:\nThe requirement involves creating an algorithm that can determine the number of eversions required for an array to stop changing. The eversion operation partitions the array into two parts based on a pivot element, and the process is repeated until the array no longer changes. The challenge lies in efficiently handling large inputs and ensuring the solution is accurate and optimized.\nrequirement pool:\n- Implement the eversion operation and determine the minimum number of eversions required for the array to stop changing.\n- Ensure the solution is optimized for large inputs and can handle up to 2 \u22c5 10^5 elements.\n- Provide clear and accurate output for each test case, ensuring the solution is user-friendly.\n- Test the solution with various test cases to verify its correctness and robustness.\n- Optimize the algorithm for efficiency and performance.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The eversion operation can be efficiently implemented using list operations. We will iterate through the array, partitioning it based on a pivot element, and continue this process until the array no longer changes. We will count the number of iterations required to reach this state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array into two parts based on a pivot element, where the left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. The array is then reconstructed by concatenating these two parts.\n    Explanation: The eversion operation is repeated until the array no longer changes, indicating a stable partition. The goal is to determine the number of such operations required to reach this stable state.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the pivot element that divides the array into two parts where the left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot.\n    Explanation: For example, in the array [2, 4, 1, 5, 3], the pivot element is 3. The left part is [2, 1, 3] and the right part is [4, 5].\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest element in the array to use as the pivot for the eversion operation.\n    Explanation: The largest element in the array will be the most effective pivot as it will help in quickly partitioning the array into two parts.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Find the largest element in the array to use as the pivot.\n    2. Partition the array into two parts based on this pivot.\n    3. Concatenate these two parts to form the new array.\n    4. Repeat the process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already represents a stable partition where all elements are equal. No eversions are needed, so the output is 0.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The largest element is 5. The first eversion will partition the array into [4, 3, 2, 1] and [5], resulting in a stable array [4, 3, 2, 1, 5] where no further eversions are needed.\n    Edge case 3: [2, 2, 3, 3, 4, 4] = 2\n    Explanation: The largest element is 4. The first eversion will partition the array into [2, 2, 3, 3] and [4, 4], and the second eversion will partition the array into [2, 2, 3] and [3, 4, 4], resulting in a stable array [2, 2, 3, 3, 4, 4] where no further eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the largest element and perform eversions is sufficient to solve the problem.\n", "requirement analysis:\nThe problem requires an efficient way to determine the number of eversions after which the array stops changing. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining the order of elements within each partition. The solution should be able to handle multiple test cases efficiently, with each test case containing up to 2 * 10^5 elements.\nrequirement pool:\n- Implement the eversion operation and determine the number of eversions required for the array to stop changing.\n- Optimize the solution to handle large inputs efficiently.\n- Ensure the output is accurate and clear for each test case.\n- Test the solution with various edge cases to ensure robustness.\n- Provide a user-friendly interface for easy input and output.\nTo solve this problem, we will use a simple and efficient approach that involves repeatedly applying the eversion operation to the array until it no longer changes. We will implement a function that performs the eversion operation and checks if the array has stabilized. The function will return the number of eversions required for the array to stop changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot value, where the left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. The array is then reconstructed by concatenating these two parts.\n    Explanation: The eversion operation helps in sorting the array by repeatedly partitioning it around a pivot until the array stops changing, indicating that it has reached a stable state.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more times than its value in the array.\n    Explanation: For example, if an integer appears 3 times, it must be greater than 2.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the integer with the maximum frequency that meets the condition of appearing more times than its value.\n    Explanation: We need to find the largest integer that appears more than twice as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Find the pivot value (the largest value in the array).\n    2. Partition the array into two parts based on the pivot value.\n    3. Concatenate the two parts and check if the array has stabilized (i.e., no further changes occur).\n    4. Repeat the process until the array stops changing.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: The array is already stable as all elements are the same. No eversions are needed.\n    search([2, 2, 3, 3, 3]) = 2\n    Explanation: The first eversion will result in [2, 2, 3], [3, 3], and the second eversion will result in [2, 2, 3, 3, 3], which does not change.\n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The first eversion will result in [1, 2, 3], [4, 5], and the second eversion will result in [1, 2, 3, 4, 5], which does not change.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle arrays that are already stable or have a single element.\n", "requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the minimum number of eversions after which the array stops changing. The input consists of multiple test cases, each with a specific array size and elements. The output should provide the number of eversions for each test case until the array stops changing. The solution must be efficient to handle large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation and determine the minimum number of eversions for each test case.\n- Ensure the solution is optimized for time complexity, especially for large inputs.\n- Provide clear and accurate output for each test case.\n- Handle multiple test cases efficiently.\n- Ensure the solution is robust and can handle edge cases.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The eversion operation can be efficiently implemented using a stable partition function from the Python `bisect` module, which allows us to maintain the order of elements in the left and right partitions. We will iterate through the array, performing eversions until the array no longer changes. We will count the number of iterations to determine the minimum number of eversions required to stop changing the array.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot element (x), where the left part contains elements less than or equal to x, and the right part contains elements greater than x. The array is then reconstructed by concatenating these two parts while maintaining their relative order.\n\n    Explanation: The eversion operation is a transformation applied to an array to achieve a specific order. It helps in sorting or reorganizing the array elements based on a chosen pivot.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an element in the array that appears more than once.\n    Explanation: In the context of the requirement, 'more than' is used to specify that the integer must appear more times than its value in the array.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more than itself.\n    Explanation: 'Largest' suggests that we should find the biggest integer that satisfies the criteria of appearing more times than its value in the array.\n\n# [code logic]\n    To implement the solution, we can follow these steps:\n    1. Read the input array.\n    2. Perform eversions iteratively until the array no longer changes.\n    3. Count the number of iterations (eversions) performed.\n    4. Output the count as the result.\n\n# [edge case] \n    Edge case 1: [1, 1, 1] = 0\n    Explanation: The array already satisfies the condition where each element appears at least as many times as its value. Therefore, no eversions are needed, and the result is 0.\n\n    Edge case 2: [2, 2, 3, 3, 3] = 2\n    Explanation: The array can be everted to [2, 2, 3, 3, 3] \u2192 [2, 2, 3, 3, 3] after two eversions, where the array stops changing.\n\n    Edge case 3: [5, 5, 4, 4, 4] = 1\n    Explanation: The array can be everted to [4, 4, 4, 5, 5] after one eversion, where the array stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan can handle these cases directly. The edge cases provided are already covered by the iterative eversion process described.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array and determine the number of iterations required for the array to stop changing. The array size can be large, up to 2 * 10^5, so the solution must be efficient and scalable. The output should be accurate and clear, indicating the number of eversions needed for the array to stabilize.\nrequirement pool:\n- Implement the eversion operation on an array.\n- Determine the number of iterations required for the array to stop changing.\n- Ensure the solution is efficient and scalable for large arrays.\n- Provide clear and accurate output indicating the number of eversions.\nTo implement the eversion operation on an array and determine the number of iterations required for the array to stop changing, we will use Python's built-in data structures and functions. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. We will iterate over the array, partitioning it into two parts based on the pivot, and then concatenate these parts. We will continue this process until the array stops changing. To ensure efficiency, we will use list comprehensions for partitioning.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot element.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). This partitioning is stable, meaning the order of elements in each part remains the same as before the operation.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than the pivot.\n    'less than or equal to': means that we need to find integers that are less than or equal to the pivot.\n\n# [degree adverb] \n    'largest': means that we need the largest integer in the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we will follow these steps:\n    1. For each test case, read the size of the array and the elements of the array.\n    2. Perform the eversion operation iteratively until the array stops changing.\n    3. Count the number of iterations required for the array to stop changing.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order. After the first eversion operation, the array becomes [1, 2, 3, 4, 5] itself, so it stops changing after 1 iteration.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array is sorted in descending order. After each eversion operation, the array partitions and rearranges itself, but it will take 5 iterations for the array to stop changing as it will eventually become [1, 2, 3, 4, 5] after 5 partitions.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion operation, the array becomes [1, 2, 3, 4, 5]. After the second eversion operation, the array becomes [1, 2, 3, 4, 5] itself, so it stops changing after 2 iterations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle these cases by simply iterating until the array stops changing.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array and determine the number of iterations required for the array to stop changing. The array size can be large, up to 2 * 10^5, so the solution must be efficient and scalable. The output should be accurate and clear for each test case.\nrequirement pool:\n- Implement the eversion operation on an array\n- Ensure the solution is efficient and scalable\n- Provide clear and accurate output for each test case\n- Handle large arrays without performance issues\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will iterate over the array, partitioning it at each step until the array stops changing. This approach ensures scalability and efficiency, suitable for handling up to 2 * 10^5 elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot element, maintaining the order of elements in each part.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). This partitioning is stable, meaning the order of elements in each part remains the same as before the operation.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than the pivot.\n    'less than or equal to': means that we need to find integers that are less than or equal to the pivot.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that is greater than the pivot.\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will iterate over the array, partitioning it at each step until the array stops changing. This approach ensures scalability and efficiency, suitable for handling up to 2 * 10^5 elements.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: In this case, the array is already sorted in ascending order. The pivot is the last element (5), and the array is not changed after the first eversion operation since the left part (1, 2, 3, 4) is already less than or equal to the pivot, and the right part ([5]) is already greater than the pivot.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: In this case, the array is sorted in descending order. The pivot is the first element (5), and the array is not changed after the first eversion operation since the left part ([5]) is already greater than the pivot, and the right part (4, 3, 2, 1) is already less than or equal to the pivot.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: In this case, the array is not sorted. The pivot is 3, and after the first eversion operation, the array becomes [1, 2, 3, 4, 5]. After the second eversion operation, the array stops changing since the left part (1, 2) is less than or equal to the pivot, and the right part (4, 5) is greater than the pivot.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is sufficient to handle the edge cases by checking if the array has changed after each eversion operation.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array, which partitions the array into two parts based on a pivot element. The operation is repeated until the array no longer changes. The challenge lies in efficiently handling large arrays and determining the number of iterations until the array stabilizes. The product must be designed to handle up to 2 * 10^5 elements, ensuring optimal performance and user experience.\nrequirement pool:\n- Implement the eversion operation on an array\n- Ensure the array manipulation is efficient and handles large inputs\n- Provide a clear and accurate output for the number of eversions\n- Optimize the algorithm for performance and scalability\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will iterate over the array, partitioning it at each step until the array no longer changes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot element, maintaining the order of elements in each part.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). This partitioning is stable, meaning the order of elements in each part remains the same as before the operation.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the elements in the right part are strictly greater than the pivot.\n    Explanation: For example, in the array [2, 4, 1, 5, 3], the pivot x = 3. The right part [4, 5] contains elements that are strictly greater than 3.\n\n# [degree adverb] \n    'largest': refers to the pivot element, which is the largest element in the left part.\n    Explanation: In the example [2, 4, 1, 5, 3], the pivot x = 3. The largest element in the left part [2, 1] is 2, which is less than or equal to 3.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will iterate over the array, partitioning it at each step until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in ascending order, so no eversion operation is needed, and the array does not change.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The array is sorted in descending order. After one eversion operation, the array becomes [4, 3, 5, 2, 1], and it stops changing.\n    Edge case 3: [3, 3, 3, 3, 3] = 1\n    Explanation: All elements are the same, so after one eversion operation, the array becomes [3, 3, 3, 3, 3], and it stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle these cases.\n", "requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the number of iterations required for the array to stop changing. The input is structured to handle multiple test cases efficiently, and the output should reflect the number of iterations needed for the array to reach a stable state.\nrequirement pool:\n- Implement the eversion operation on the array\n- Ensure the array is partitioned and stable\n- Calculate the number of iterations until the array stops changing\n- Handle large inputs efficiently\n- Provide clear and accurate output\nTo implement the eversion operation on an array and determine the number of iterations required for the array to stop changing, we will use Python's built-in data structures and functions. The eversion operation involves partitioning the array based on a pivot element, ensuring the partition is stable. We will iterate over the array, partitioning it each time, until the array stops changing. We will count the number of iterations to reach this stable state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list or array into two or more sub-lists based on a specific condition.\n    Explanation: In the requirement, the eversion operation involves partitioning the array into two parts: elements less than or equal to the pivot (x) and elements greater than the pivot. This partitioning is stable, meaning the order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find elements greater than the pivot.\n    'less than or equal to': indicates that we need to find elements that are less than or equal to the pivot.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest element in the array to use it as the pivot.\n\n# [code logic]\n    To implement the eversion operation, we will follow these steps:\n    1. For each test case, read the array size and elements.\n    2. Implement the eversion operation by partitioning the array based on a pivot.\n    3. Continue partitioning until the array stops changing.\n    4. Count the number of iterations required to reach the stable state.\n    5. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted in ascending order, so no partitioning is needed, and the array does not change.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is sorted in descending order. The first partitioning will result in [4, 3, 2, 1] and [5], and the array stops changing after one iteration.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: The array will partition into [1, 2] and [3, 4, 5] after the first iteration, and then into [1] and [2, 3, 4, 5] after the second iteration, and the array stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly count the number of iterations for the array to stop changing.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle multiple test cases efficiently, with each test case involving an array and the operation of eversion. The output should be the number of eversions after which the array stops changing. The constraints on the size of n and the sum of n over all test cases ensure that the program must be scalable and efficient.\nrequirement pool:\n- Implement the eversion operation on the array as described.\n- Ensure the program can handle multiple test cases efficiently.\n- Provide clear and accurate output for the number of eversions.\n- Optimize the program for large arrays to avoid performance issues.\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. This operation is similar to quicksort's partition step but without the sorting aspect. We will iterate over the array, partitioning it at each step until the array stops changing. This will involve creating stable partitions of the array based on the pivot.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list or array into two or more sub-lists based on a specific condition.\n    Explanation: In the requirement, the eversion operation involves partitioning the array into two parts: elements less than or equal to the pivot (last element of the array) and elements greater than the pivot. This partitioning is stable, meaning the order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than the pivot.\n    'less than or equal to': means that we need to find integers that are less than or equal to the pivot.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that is greater than the pivot.\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. This operation is similar to quicksort's partition step but without the sorting aspect. We will iterate over the array, partitioning it at each step until the array stops changing. This will involve creating stable partitions of the array based on the pivot.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted in ascending order, so no eversions are needed, and the array does not change.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The pivot is 1, and after the first eversion operation, the array becomes [4, 3, 2, 1, 5], which is a stable partition of the original array.\n\n    Edge case 3: [2, 2, 2, 2, 2]\n    Expected output: 0\n    Explanation: All elements are the same, so no eversions are needed, and the array does not change.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will work correctly for arrays with all identical elements.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array and determine the number of iterations required for the array to stop changing. The array size can be large, up to 2 * 10^5, so the solution must be efficient and scalable. The output should be accurate and clear for each test case.\nrequirement pool:\n- Implement the eversion operation on an array\n- Ensure the solution is efficient and scalable\n- Provide clear and accurate output for each test case\n- Handle large arrays without performance issues\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will iterate over the array, applying the eversion operation until the array stops changing. To ensure scalability, we will use efficient partitioning techniques and avoid unnecessary data copying.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': The process of dividing a list into two parts based on a pivot element, maintaining the order of elements in each part.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). This partitioning is crucial for the operation to work correctly.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the elements in the right part are strictly greater than the pivot.\n    Explanation: In the eversion operation, the right part of the array contains elements that are strictly greater than the pivot element, ensuring that the order of elements is preserved.\n\n# [degree adverb] \n    'largest': Indicates that the pivot element is the largest in the array, which is used to divide the array into two parts.\n    Explanation: The pivot element is chosen as the largest element in the array to ensure that the right part contains elements greater than it, maintaining the stability of the partition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will use the following steps:\n    1. For each test case, read the size of the array and the elements.\n    2. Apply the eversion operation iteratively until the array stops changing.\n    3. Count the number of iterations required to reach a stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted in ascending order, so no eversions are needed, and the array does not change.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is sorted in descending order. After one eversion operation, the array will be partitioned into [5, 4, 3] and [2, 1], and the array stops changing.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion operation, the array becomes [3, 1, 2] and [4, 5]. After the second eversion operation, the array becomes [2, 1] and [3, 4, 5], and the array stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is sufficient to determine the number of eversions required for the array to stop changing.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and how it affects the array's stability. The solution should be able to handle multiple test cases efficiently, which implies a need for optimization. The input size can be large, so the solution should be designed with scalability in mind. The output should be accurate and deterministic, providing the minimum number of eversions required for the array to reach a stable state.\nrequirement pool:\n- Implement the eversion operation and ensure it is stable.\n- Develop a method to determine the number of eversions needed for the array to reach a stable state.\n- Ensure the solution can handle multiple test cases efficiently.\n- Optimize the algorithm for performance and memory usage.\n- Implement error handling and edge case testing.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The eversion operation can be efficiently handled using a loop and partitioning the array based on the pivot element. We will use a stable partition algorithm to ensure the order of elements in each part is maintained. The main challenge is to determine the number of eversions required for the array to reach a stable state, which can be achieved by repeatedly applying the eversion operation until no further changes occur.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array into two parts based on a pivot element, where the left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. The array is then reconstructed by concatenating these two parts.\n    Explanation: The eversion operation is repeated until the array no longer changes, indicating that it has reached a stable state. The goal is to determine the number of such operations required to reach this stable state.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element must be greater than the elements in the left part.\n    Explanation: In the context of the requirement, 'more than' is used to define the boundary between the left and right parts of the array during the eversion operation.\n\n# [degree adverb] \n    'largest': Indicates that the pivot element should be the largest in the array to ensure the most elements are placed in the left part.\n    Explanation: The 'largest' adverb suggests that the pivot should be chosen to maximize the number of elements in the left part, which can help in determining the number of eversions more quickly.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Iterate through the array and perform the eversion operation.\n    2. Check if the array has reached a stable state (i.e., no further changes occur after an eversion).\n    3. Count the number of eversions performed.\n    4. Return the count as the result.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are the same. No eversions are needed.\n    Edge case 2: [2, 1, 3, 4, 5] = 1\n    Explanation: The array becomes stable after one eversion: [1, 2, 3, 4, 5].\n    Edge case 3: [5, 4, 3, 2, 1] = 5\n    Explanation: The array becomes stable after five eversions: [1, 2, 3, 4, 5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the number of eversions is straightforward and can be implemented within the main loop.\n"], "scores": [], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 72, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "condense_two2one", "parent_index": 68}
