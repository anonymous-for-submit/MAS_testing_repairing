{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nWrite a main() function and use input() function to read input from stdin", " Andi and Budi were given an assignment to tidy up their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nWrite a main() function and use input() function to read input from stdin", " Andi and Budi were given an assignment to tidy up their bookshelf of n books, each represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, where Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef custom_sort(strings: List[str], n: int, m: int) -> List[int]:\n    \"\"\"\n    Custom sorting function that sorts strings based on the specified odd and even index rules.\n    \n    Args:\n        strings (List[str]): List of strings to be sorted.\n        n (int): Number of strings.\n        m (int): Length of each string.\n        \n    Returns:\n        List[int]: List of indices of the strings after sorting.\n    \"\"\"\n    \n    # Define a custom key function for sorting\n    def custom_key(s: str) -> tuple:\n        \"\"\"\n        Custom key function to compare strings based on odd and even index rules.\n        \n        Args:\n            s (str): The string to be compared.\n            \n        Returns:\n            tuple: A tuple containing the comparison values for odd and even indexed characters.\n        \"\"\"\n        odd_comparison = [ord(s[i]) for i in range(0, m, 2)]\n        even_comparison = [ord(s[i]) for i in range(1, m, 2)]\n        \n        # Sort odd indexed characters in ascending order\n        odd_comparison.sort()\n        # Sort even indexed characters in descending order\n        even_comparison.sort(reverse=True)\n        \n        return tuple(odd_comparison + even_comparison)\n    \n    # Create a list of indices\n    indices = list(range(n))\n    \n    # Sort the indices based on the custom key function\n    indices.sort(key=lambda i: custom_key(strings[i]))\n    \n    return indices\n\n# Read input\nn, m = map(int, input().split())\nstrings = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function\nresult = custom_sort(strings, n, m)\n\n# Output the sorted indices\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\n## main.py\n\nimport sys\n\ndef custom_sort(strings, n, m):\n    def custom_key(s):\n        odd_chars = sorted([s[i] for i in range(0, m, 2)])\n        even_chars = sorted([s[i] for i in range(1, m, 2)], reverse=True)\n        return ''.join(odd_chars + even_chars)\n\n    indexed_strings = list(enumerate(strings, start=1))\n    sorted_indexed_strings = sorted(indexed_strings, key=lambda x: custom_key(x[1]))\n    return [index for index, _ in sorted_indexed_strings]\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nstrings = [sys.stdin.readline().strip() for _ in range(n)]\n\n# Call custom_sort function\nresult = custom_sort(strings, n, m)\n\n# Output the result\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef custom_sort(books: List[str], n: int, m: int) -> List[int]:\n    def custom_key(book: str, index: int) -> tuple:\n        odd_char = sorted([book[i] for i in range(0, m, 2)])\n        even_char = sorted([book[i] for i in range(1, m, 2)], reverse=True)\n        char_order = []\n        odd_index = 0\n        even_index = 0\n        for i in range(m):\n            if i % 2 == 0:\n                char_order.append(odd_char[odd_index])\n                odd_index += 1\n            else:\n                char_order.append(even_char[even_index])\n                even_index += 1\n        return tuple(char_order)\n\n    indexed_books = [(book, index) for index, book in enumerate(books)]\n    sorted_books = sorted(indexed_books, key=lambda x: custom_key(x[0], x[1]))\n    return [index + 1 for book, index in sorted_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call custom_sort function\nresult = custom_sort(books, n, m)\n\n# Output the result\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef custom_sort(books: List[str], n: int, m: int) -> List[int]:\n    def sort_key(book: str, index: int) -> tuple:\n        odd_chars = [book[i] for i in range(0, m, 2)]\n        even_chars = [book[i] for i in range(1, m, 2)]\n        return (''.join(sorted(odd_chars)), ''.join(sorted(even_chars, reverse=True)))\n\n    indexed_books = list(zip(books, range(1, n + 1)))\n    indexed_books.sort(key=lambda x: sort_key(x[0], x[1]))\n    return [index for book, index in indexed_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call custom_sort function\nresult = custom_sort(books, n, m)\n\n# Output sorted indices\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef custom_sort(books: List[str], n: int, m: int) -> List[int]:\n    def custom_key(book: str):\n        key = []\n        for i, char in enumerate(book):\n            if i % 2 == 0:  # Odd index\n                key.append(ord(char))\n            else:  # Even index\n                key.append(-ord(char))\n        return key\n\n    indexed_books = list(zip(books, range(1, n + 1)))\n    indexed_books.sort(key=lambda x: custom_key(x[0]))\n    return [index for book, index in indexed_books]\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the custom_sort function\nresult = custom_sort(books, n, m)\n\n# Output the result\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\n## main.py\n\ndef custom_sort(books: list[str], n: int, m: int) -> list[int]:\n    # Define a custom key function for sorting\n    def custom_key(book: str) -> tuple:\n        odd_chars = [book[i] for i in range(0, m, 2)]\n        even_chars = [book[i] for i in range(1, m, 2)]\n        # Sort odd-indexed characters in ascending order\n        odd_chars.sort()\n        # Sort even-indexed characters in descending order\n        even_chars.sort(reverse=True)\n        return tuple(odd_chars + even_chars)\n\n    # Create a list of tuples where each tuple contains the book and its index\n    books_with_index = [(book, index) for index, book in enumerate(books)]\n    # Sort the list of tuples using the custom key function\n    books_with_index.sort(key=lambda x: custom_key(x[0]))\n    # Extract the sorted indices\n    sorted_indices = [index + 1 for book, index in books_with_index]\n    return sorted_indices\n\n# Read input from standard input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n# Call the custom_sort function and get the sorted indices\nresult = custom_sort(books, n, m)\n# Output the sorted indices to standard output\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef custom_sort(books: List[str], n: int, m: int) -> List[int]:\n    def custom_sort_key(s: str) -> List[tuple]:\n        key = []\n        for i, char in enumerate(s):\n            if (i + 1) % 2 == 1:  # Odd index\n                key.append((ord(char), i))\n            else:  # Even index\n                key.append((-ord(char), i))\n        return key\n\n    sorted_indices = sorted(range(n), key=lambda i: custom_sort_key(books[i]))\n    return sorted_indices\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call custom_sort function\nresult = custom_sort(books, n, m)\n\n# Output sorted indices\nfor index in result:\n    print(index, end=' ')\n", "from typing import List\nfrom typing import List\n\ndef func(n: int, m: int, books: List[str]) -> List[int]:\n    # Define a custom key function for sorting\n    def custom_key(book: str) -> tuple:\n        odd_chars = [book[i] for i in range(0, m, 2)]\n        even_chars = [book[i] for i in range(1, m, 2)]\n        # Sort odd-indexed characters in ascending order\n        odd_chars.sort()\n        # Sort even-indexed characters in descending order\n        even_chars.sort(reverse=True)\n        return tuple(odd_chars + even_chars)\n\n    # Create a list of tuples where each tuple contains the book and its index\n    books_with_index = [(book, index) for index, book in enumerate(books)]\n    # Sort the list of tuples using the custom key function\n    books_with_index.sort(key=lambda x: custom_key(x[0]))\n    # Extract the sorted indices\n    sorted_indices = [index + 1 for book, index in books_with_index]\n    return sorted_indices\n\n# Read input from standard input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n# Call the function and print the result\nresult = func(n, m, books)\nfor r in result:\n    print(r, end=' ')\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef custom_key(s: str) -> List[int]:\n    key = []\n    for i in range(len(s)):\n        if i % 2 == 0:  # Odd index\n            key.append(ord(s[i]))  # Append ASCII value for ascending order\n        else:  # Even index\n            key.append(-ord(s[i]))  # Append negative ASCII value for descending order\n    return key\n\ndef func(n: int, m: int, books: List[str]) -> List[int]:\n    sorted_indices = sorted(range(n), key=lambda i: custom_key(books[i]))\n    return sorted_indices\n\n# Read input\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nresult = func(n, m, books)\nfor r in result:\n    print(r, end=' ')\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef custom_sort(titles: List[str], n: int, m: int) -> List[int]:\n    def custom_key(title: str) -> List[str]:\n        odd_sorted = sorted([title[i] for i in range(0, m, 2)])\n        even_sorted = sorted([title[i] for i in range(1, m, 2)], reverse=True)\n        return ''.join(odd_sorted + even_sorted)\n    \n    indexed_titles = list(enumerate(titles, start=1))\n    sorted_titles = sorted(indexed_titles, key=lambda x: custom_key(x[1]))\n    return [index for index, _ in sorted_titles]\n\n# Interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\nresult = custom_sort(titles, n, m)\nfor index in result:\n    print(index, end=' ')\n"], "plans": ["requirement analysis:\nThe requirements specify a need for a custom sorting algorithm that sorts strings based on the specified odd and even index rules. The algorithm should be efficient and able to handle large inputs. The output should be in the form of indices corresponding to the sorted order of the input strings.\nrequirement pool:\n- Implement a custom sorting algorithm that sorts strings based on odd and even index rules.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Provide clear and concise output in the form of indices corresponding to the sorted order.\n- Allow user input for the number of strings and their lengths.\n- Ensure the program is user-friendly and easy to understand.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison of strings based on the specified odd and even index rules. We will also ensure that the algorithm is efficient by handling large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n    'ascending/descending order': This refers to the arrangement of elements from smallest to largest/largest to smallest.\n    'odd/even index': This refers to the positions of characters in a string, starting from 0 (for the first character) being considered as an even position, and 1 (for the second character) being considered as an odd position.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison of strings based on the specified odd and even index rules. We will also ensure that the algorithm is efficient by handling large inputs efficiently.\n\n# [edge case] \n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The strings are sorted based on the custom rules:\n    - For odd positions (0 and 2), we sort in ascending order of the alphabet.\n    - For even positions (1 and 3), we sort in descending order of the alphabet.\n    The sorted order of the indices is 5 2 1 3 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic is sufficient to handle the input format and the custom sorting rules.\n", "requirement analysis:\nThe requirements specify a need for a custom sorting algorithm that sorts strings based on the specified odd and even index rules. The algorithm should be efficient and able to handle large inputs. The output should be in the form of indices corresponding to the sorted order of the input strings.\nrequirement pool:\n- Implement a custom sorting algorithm that sorts strings based on odd and even index rules.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Provide clear and concise output in the form of indices corresponding to the sorted order.\n- Allow user input for the number of strings and their lengths.\n- Ensure the program is user-friendly and easy to understand.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the sorting based on the specified rules for odd and even indexed characters. We will also ensure the algorithm is efficient by using Python's efficient list processing capabilities.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'odd-even index sorting': This involves sorting characters at odd positions in ascending order and characters at even positions in descending order.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted` function with a custom key. The key function will:\n    1. Split each string into two parts: odd-indexed and even-indexed characters.\n    2. Sort the odd-indexed characters in ascending order.\n    3. Sort the even-indexed characters in descending order.\n    4. Concatenate the sorted odd and even parts to form the key for sorting.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one string, it is trivially sorted.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: The strings differ at the first position (odd index), where 'A' comes before 'B' in ascending order. Since there are only two strings, they are sorted based on the first character.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    CAB\n    Output:\n    2 3 1\n    Explanation: The strings are sorted based on the custom rules:\n    - 'CBA' and 'BAC' differ at the first position ('C' and 'B' respectively). 'B' comes before 'C' in ascending order.\n    - 'BAC' and 'CAB' differ at the second position ('A' and 'A' respectively, but since it's an even index, we look at the reverse order of appearance in the alphabet). 'A' comes after 'A' in descending order, but since they are the same, we move to the next position.\n    - 'CBA' and 'CAB' differ at the third position ('A' and 'B' respectively). 'A' comes before 'B' in ascending order.\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the provided logic already covers single-character strings and cases where strings are identical up to the point of difference.\n", "requirement analysis:\nThe requirements specify a custom sorting method that sorts strings based on the positions of their characters in the alphabet, with odd positions sorted ascending and even positions sorted descending. This requires a flexible and efficient sorting algorithm that can handle large inputs and provide clear output indices. The algorithm must be designed to meet the specific needs of Andi and Budi, ensuring a balance between performance and customizability.\nrequirement pool:\n- Implement a custom sorting algorithm that sorts strings based on the specified odd/even index rules.\n- Ensure the algorithm is efficient and can handle large inputs efficiently.\n- Provide clear and easy-to-read output indices representing the original order of the books.\n- Allow for easy input of book titles and their lengths for sorting.\n- Ensure the product is user-friendly and provides clear instructions for use.\nTo implement the custom sorting algorithm as described, we will use Python's built-in sorting capabilities, leveraging its flexibility to define custom comparison functions. The algorithm will compare characters at odd and even positions differently, sorting odd positions in ascending order and even positions in descending order. This approach will be efficient and suitable for handling large inputs due to Python's efficient implementation of list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order'\n    In the requirement, it means the order based on alphabetical sequence.\n    'ascending' and 'descending' are used to specify the direction of the order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we need to define a key function that will be used by the sorting algorithm. This function will compare characters at odd and even positions differently:\n    - For odd positions, it will compare characters based on their alphabetical order (ascending).\n    - For even positions, it will compare characters based on their reverse alphabetical order (descending).\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCA\n\n    Output:\n    1 2 3\n\n    Explanation:\n    Since there are no differences in odd or even positions, the order is determined by the default lexicographical order, which is ascending.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n\n    Output:\n    1 2\n\n    Explanation:\n    In this case, the strings differ at the first position (odd), where 'A' comes before 'B' in ascending order. At the second position (even), 'B' comes after 'A' in descending order.\n\n    Edge case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n\n    Output:\n    4 3 2 1\n\n    Explanation:\n    Since there's only one character, the order is determined by the default lexicographical order, which is ascending.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic should be sufficient to handle the sorting based on the custom criteria.\n", "requirement analysis:\nThe requirements specify a custom sorting order that combines both ascending and descending comparisons based on the position of characters in the strings. The system must handle a large number of inputs efficiently and provide clear output indices. The solution must be robust to handle large datasets and provide a user-friendly output format.\nrequirement pool:\n- Implement a custom sorting algorithm that meets the asc-desc-ending criteria\n- Ensure the system can handle large inputs efficiently\n- Provide clear and easily understandable output\n- Add support for user customization of sorting order\n- Optimize the user interface for better user experience\nTo implement the custom sorting algorithm as described, we will use Python's built-in sorting capabilities, customizing the key function to handle the asc-desc-ending sorting order. This approach leverages Python's efficiency and ease of use, ensuring that the system can handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': These refer to the positions of characters in a string starting from 0 (first character is at index 0, which is odd), 1 (second character is at index 1, which is even), and so on.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we can use Python's `sorted` function with a custom key. The key will be a function that sorts characters at odd positions in ascending order and characters at even positions in descending order.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCC\n    Output:\n    1 2 3\n    Explanation:\n    Since all strings are the same length and have unique characters, they will be sorted by their lexicographical order, which is the default behavior of Python's `sorted` function.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation:\n    The strings differ at the first position (odd index), where 'A' comes before 'B' in ascending order. At the second position (even index), 'B' comes after 'A' in descending order.\n\n# [extra code for edge case]\n    No extra code is needed for the given edge cases as the default behavior of Python's `sorted` function handles them correctly. However, if the input constraints were different (e.g., different lengths of strings or non-unique characters), additional checks would be necessary.\n", "requirement analysis:\nThe requirements specify a custom sorting order that combines both ascending and descending lexicographical sorting based on the position of characters. The input is a list of book titles, and the output should be the indices of these titles sorted according to the specified order. The system must be efficient enough to handle large inputs.\nrequirement pool:\n- Implement a custom sorting algorithm that can handle the specified order.\n- Ensure the system can handle large inputs efficiently.\n- Provide clear and readable output.\n- Add support for user customization of sorting order.\n- Optimize the algorithm for performance on large datasets.\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison logic for both odd and even indexed characters separately, ensuring the sorting order as specified.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n    'ascending order': This means arranging elements from smallest to largest.\n    'descending order': This means arranging elements from largest to smallest.\n    'odd-even indexing': This refers to the positions of characters in a string where characters at odd positions (1, 3, 5, ...) are compared in ascending order and characters at even positions (2, 4, 6, ...) are compared in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we will use Python's `sorted` function with a custom key. The key will be a function that:\n    1. Compares characters at odd positions in ascending order.\n    2. Compares characters at even positions in descending order.\n\n    Here's a step-by-step breakdown of the logic:\n    1. Read the number of books (n) and the length of each book title (m).\n    2. Read the book titles and store them in a list.\n    3. Define a custom key function for sorting:\n        - For odd positions, compare characters based on their ASCII values in ascending order.\n        - For even positions, compare characters based on their ASCII values in descending order.\n    4. Use the `sorted` function with the custom key to sort the list of book titles.\n    5. Return the indices of the sorted book titles.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one book, it is trivially sorted, and its index is 1.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: The titles \"AB\" and \"BA\" differ at both positions. At the first (odd) position, 'A' comes before 'B' in ascending order. At the second (even) position, 'B' comes after 'A' in descending order. Thus, \"AB\" comes before \"BA\".\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    ABC\n    Output:\n    3 1 2\n    Explanation: The titles \"CBA\", \"BAC\", and \"ABC\" differ at the first position. 'C' comes before 'B' in ascending order, 'B' comes before 'A' in ascending order, and 'A' comes before 'C' in ascending order. At the second position, 'B' comes after 'A' in descending order, and 'A' comes after 'C' in descending order. At the third position, 'A' comes before 'B' in ascending order, 'C' comes before 'B' in ascending order, and 'B' comes before 'A' in ascending order. Thus, \"ABC\" comes before \"BAC\", which comes before \"CBA\".\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the provided logic already covers single-character titles and simple cases. The custom key function will naturally handle these cases correctly.\n", "requirement analysis:\nThe requirements specify the need for a custom sorting algorithm that sorts strings based on specific rules for odd and even indexed characters. The algorithm should be efficient and capable of handling large datasets. The output should be clear and easy to interpret.\nrequirement pool:\n- Implement a custom sorting algorithm\n- Ensure compatibility with large datasets\n- Provide clear and concise output\n- Optimize performance for large inputs\nTo implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison logic for odd and even indexed characters separately. We will also ensure that the algorithm is efficient by using Python's list comprehensions and generator expressions where appropriate.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n    'ascending order': This means arranging elements from smallest to largest.\n    'descending order': This means arranging elements from largest to smallest.\n    'odd-even indexing': This refers to the positions of characters in a string that are indexed starting from 0, where 0 is considered an even number.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting algorithm, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison logic for odd and even indexed characters separately. We will also ensure that the algorithm is efficient by using Python's list comprehensions and generator expressions where appropriate.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    3 3\n    AAA\n    BBB\n    CCC\n\n    Output:\n    1 2 3\n\n    Explanation:\n    Since there are no odd or even indexed characters to compare, the order is determined solely by the lexicographical order of the strings, which is ascending.\n\n    Edge Case 2:\n    Input:\n    2 2\n    AB\n    BA\n\n    Output:\n    1 2\n\n    Explanation:\n    In this case, the strings differ at the first position (even index), where 'A' comes before 'B' in ascending order. The second string 'BA' comes after 'AB' because at the first position (odd index), 'B' comes before 'A' in descending order.\n\n    Edge Case 3:\n    Input:\n    4 1\n    Z\n    X\n    Y\n    W\n\n    Output:\n    4 3 2 1\n\n    Explanation:\n    Here, the strings are single characters, so the comparison is straightforward. 'Z' comes before 'X' because 'Z' is earlier in the alphabet. The subsequent characters follow the same pattern.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is sufficient to handle all the given edge cases.\n", "requirement analysis:\nThe primary requirement is to sort the book titles based on a unique asc-desc-endingly criteria. This requires a custom sorting function that can handle both ascending and descending comparisons based on the index of the characters in the strings. The solution should be efficient and able to handle large inputs efficiently, as specified by the constraint that 1 \u2264 n \u22c5 m \u2264 10^6.\nrequirement pool:\n- Implement a custom sorting function that meets the asc-desc-endingly criteria.\n- Ensure the solution is scalable and can handle large inputs efficiently.\n- Provide a clear and user-friendly output format.\n- Test the solution with various inputs to ensure correctness and robustness.\n- Optimize the code for performance and memory usage.\nTo implement the custom sorting function that meets the asc-desc-endingly criteria, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison logic for both ascending and descending based on the index of the characters in the strings. We will also ensure the solution is scalable by optimizing the algorithm to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n    'ascending order': This means arranging elements from smallest to largest.\n    'descending order': This means arranging elements from largest to smallest.\n    'odd-even index': This refers to the position of characters in a string, where the first character is considered to be at position 1 (odd), the second character at position 2 (even), and so on.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting function, we can use Python's `sorted` function with a custom key. The key function will compare characters based on their positions (odd or even) and their order in the alphabet.\n\n    ```python\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    def custom_sort_key(s):\n        key = []\n        for i, char in enumerate(s):\n            if (i + 1) % 2 == 1:  # Odd index\n                key.append((ord(char), i))\n            else:  # Even index\n                key.append((-ord(char), i))\n        return key\n\n    sorted_indices = sorted(range(n), key=lambda i: custom_sort_key(books[i]))\n    print(' '.join(map(str, sorted_indices)))\n    ```\n\n# [edge case] \n    Example edge case:\n    Input:\n    3 3\n    CBA\n    CAB\n    BCA\n\n    Output:\n    2 3 1\n\n    Explanation:\n    The custom sorting key for each string would be:\n    - \"CBA\": [(67, 1), (66, 2), (65, 3)]\n    - \"CAB\": [(67, 1), (65, 2), (66, 3)]\n    - \"BCA\": [(66, 1), (67, 2), (65, 3)]\n\n    Sorting these keys lexicographically, we get:\n    - \"CBA\" (2)\n    - \"BCA\" (3)\n    - \"CAB\" (1)\n\n# [extra code for edge case]\n    The provided code already handles the edge case by considering the custom sorting logic for both odd and even indexed characters. No extra code is needed for handling edge cases.\n", "requirement analysis:\nThe requirements specify a need for a sorting algorithm that sorts book titles based on a custom lexicographical order. The order is defined such that odd-indexed characters are compared ascendingly and even-indexed characters are compared descendingly. This requires a flexible sorting mechanism that can handle the specific comparison logic. The solution should also be able to handle large inputs efficiently, as specified by the constraint on the product of n and m being up to 10^6.\nrequirement pool:\n- Implement a sorting algorithm that supports custom comparison logic for odd and even indexed characters.\n- Ensure the solution can handle inputs with up to 10^6 characters.\n- Provide clear and user-friendly output in the form of indices representing the sorted order.\n- Optimize the algorithm to handle large inputs efficiently without performance degradation.\nTo implement the sorting algorithm that meets the unique asc-desc-ending criteria, we will use Python's built-in sorting capabilities with a custom key function. The key function will handle the comparison logic for odd and even indexed characters separately.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': These refer to the positions of characters in a string starting from 0 (first character is at index 0, which is considered odd).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the sorting algorithm, we will use Python's built-in `sorted` function with a custom key. The key function will compare characters at odd and even positions differently:\n    1. For odd positions, we will sort characters in ascending order.\n    2. For even positions, we will sort characters in descending order.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one string, it will be at the first position regardless of sorting.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: The strings differ at the first position (odd), where 'A' comes before 'B' in ascending order. They are the same at the second position (even), so their order remains the same.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    CAB\n    BCA\n    Output:\n    2 3 1\n    Explanation: The strings differ at the first position (odd), where 'C' comes before 'B' in ascending order. At the second position (even), 'A' comes after 'B' in descending order. At the third position (odd), 'A' comes before 'A' in ascending order, so the order remains the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic should work for all inputs within the given constraints.\n", "requirement analysis:\nThe requirements specify a need for a sorting algorithm that sorts strings based on a combination of ascending and descending lexicographical order, with specific rules for odd and even indexed characters. The input is a list of book titles, and the output should be the indices of these titles in the sorted order. The solution must be efficient and scalable to handle large inputs.\nrequirement pool:\n- Implement a sorting algorithm that meets the asc-desc-ending criteria.\n- Ensure the solution can handle large inputs efficiently.\n- Provide clear and user-friendly output in the form of indices.\n- Test the solution against multiple test cases to ensure robustness.\n- Optimize the code for performance and readability.\nTo implement the sorting algorithm that meets the asc-desc-ending criteria, we will use Python's built-in sorting functions with custom key functions for handling the odd and even indexed character comparison rules.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'odd-indexed and even-indexed characters': These refer to the positions of characters in a string starting from 0 (first character is at an odd position if we start counting from 1).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the sorting algorithm, we will use Python's built-in `sorted` function with a custom key. The key will be a function that compares characters at odd and even positions differently.\n\n    def custom_key(s):\n        key = []\n        for i in range(len(s)):\n            if i % 2 == 0:  # Odd index\n                key.append(ord(s[i]))  # Append ASCII value for ascending order\n            else:  # Even index\n                key.append(-ord(s[i]))  # Append negative ASCII value for descending order\n        return key\n\n    sorted_indices = sorted(range(n), key=lambda i: custom_key(s[i]))\n\n# [edge case] \n    Example edge case:\n    Input:\n    3 3\n    CBA\n    BAC\n    ABC\n\n    Output:\n    3 1 2\n\n    Explanation:\n    The custom key function will generate keys for each string as follows:\n    - For \"CBA\": [67, -66, 65]\n    - For \"BAC\": [66, -65, 67]\n    - For \"ABC\": [65, -66, 67]\n    Sorting these keys gives us the order [3, 1, 2], which corresponds to the original indices of the strings.\n\n# [extra code for edge case]\n    No extra code is needed for this specific problem as the built-in sorting function with a custom key handles all edge cases by design.\n", "requirement analysis:\nThe requirements specify a custom sorting method that combines both ascending and descending order criteria for odd and even indexed characters. The input is a list of book titles, and the output should be the indices of these titles in the sorted order based on the specified criteria. The system must be able to handle large inputs efficiently, ensuring scalability.\nrequirement pool:\n- Implement a custom sorting algorithm that meets the specified criteria.\n- Ensure the system can handle large inputs efficiently.\n- Develop a user-friendly interface for input and output.\n- Test and validate the system with various test cases to ensure accuracy and reliability.\n- Optimize the code for performance and scalability.\nTo implement the custom sorting algorithm as described, we will use Python's built-in sorting capabilities, customizing the key function to handle the specific sorting criteria. We will also ensure that the implementation is efficient by leveraging Python's list operations and avoiding unnecessary data manipulations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    'ascending/descending order': These terms refer to the arrangement of elements from smallest to largest (ascending) and from largest to smallest (descending).\n    'odd/even index': These terms refer to the positions of characters in a string, starting from 0 (the first character) being considered even, and 1 (the second character) being considered odd.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the custom sorting, we can use Python's `sorted` function with a custom key. The key will be a function that sorts characters at odd positions in ascending order and characters at even positions in descending order.\n\n    Here's a step-by-step breakdown of the logic:\n    1. Read the input values for n and m.\n    2. Read the book titles and store them in a list.\n    3. Define a custom key function for sorting:\n        - For odd indices, sort the characters in ascending order.\n        - For even indices, sort the characters in descending order.\n    4. Use the `sorted` function with the custom key to sort the list of book titles based on the specified criteria.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    A\n    Output:\n    1\n    Explanation: Since there's only one book, it doesn't matter how it's sorted, and its index is 1.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation: Both strings are different only at the first character. 'A' comes before 'B' in ascending order, so the first string is sorted before the second.\n\n    Edge case 3:\n    Input:\n    3 3\n    CBA\n    BAC\n    ABC\n    Output:\n    3 1 2\n    Explanation: The strings differ at the first character. 'C' comes before 'B' and 'A' comes before 'C', so the third string is the smallest. The first and second strings are then compared based on the second character, and so on.\n\n# [extra code for edge case]\n    No extra code is needed for the given edge cases as the provided logic should handle them correctly. However, ensure that the input is read correctly and the output format is maintained.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 0, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "condense_two2one", "parent_index": 0}
