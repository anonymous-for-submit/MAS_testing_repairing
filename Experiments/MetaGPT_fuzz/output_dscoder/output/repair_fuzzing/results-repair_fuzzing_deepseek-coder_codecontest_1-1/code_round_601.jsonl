{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer).\n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In this case, it means sum divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Make sure to consider all edge cases and constraints when implementing your solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer).\n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In this case, it means sum divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Make sure to consider all edge cases and constraints when implementing your solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers. The mathematic mean of these elements is denoted as k, which is calculated by dividing the sum of all elements by the number of elements, n.\n\nThe mathematic mean of an array is found by summing all its elements and then dividing that sum by the number of elements in the array. Monocarp wants to remove exactly two elements from the array a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to find the number of pairs of positions [i, j] (where i is less than\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and k is the mean of these elements. The mean of an array is the sum of elements divided by the number of elements. Monocarp wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs of positions [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the array\n    mean_value = sum(arr) / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Use a set to store the sums of the remaining elements after removing each pair\n    remaining_sums = set()\n    \n    # Calculate the sum of all elements in the array\n    total_sum = sum(arr)\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing elements at indices i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            \n            # Check if the mean of the remaining elements is still equal to the original mean\n            if remaining_sum / (n - 2) == mean_value:\n                # Add the remaining sum to the set\n                remaining_sums.add((arr[i], arr[j]))\n    \n    # The number of pairs is the size of the set\n    return len(remaining_sums)\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            if new_sum / (n - 2) == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(arr: list, mean_val: float) -> int:\n    n = len(arr)\n    count = 0\n    total_sum = sum(arr)\n    \n    # Create a dictionary to store the counts of the differences\n    diff_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the difference when elements at positions i and j are deleted\n            diff = 2 * mean_val - arr[i] - arr[j]\n            \n            # Increment the count of this difference\n            if diff in diff_count:\n                count += diff_count[diff]\n            \n            # Increment the count of the current pair's difference\n            diff_pair = arr[i] + arr[j] - total_sum + mean_val\n            if diff_pair in diff_count:\n                diff_count[diff_pair] += 1\n            else:\n                diff_count[diff_pair] = 1\n    \n    return count\n\n# Read input from stdin\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the mean of the array\nmean_val = sum(arr) / n\n\n# Call the calculate_pairs function and print the result\nresult = calculate_pairs(arr, mean_val)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_remove(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = {}\n    for num in arr:\n        count[num] = count.get(num, 0) + 1\n    \n    pairs_to_remove = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == original_mean:\n                    pairs_to_remove += 1\n    \n    return pairs_to_remove\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_remove(n, arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == original_mean:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom collections import Counter\n\ndef find_pairs_to_remove(arr, mean) -> int:\n    n = len(arr)\n    total_sum = sum(arr)\n    count = 0\n    freq = Counter(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                # Check if removing arr[i] and arr[j] results in the same mean\n                if freq[arr[i]] > 1 and freq[arr[j]] > 1:\n                    count += 1\n                elif freq[arr[i]] == 1 and freq[arr[j]] == 1:\n                    count += 1\n\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean = sum(arr) / n\n    result = find_pairs_to_remove(arr, mean)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    original_mean = sum(arr) / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) > 0 and sum(new_arr) / len(new_arr) == original_mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_pairs(n, arr):\n    # Calculate the mean of the array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # If all elements are the same, return the number of pairs\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of pairs that maintain the mean\n    count = 0\n    \n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum and new mean if elements at positions i and j are removed\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            \n            # Check if the new mean is equal to the original mean\n            if new_mean == original_mean:\n                # Check if the elements to be removed are the same\n                if arr[i] == arr[j]:\n                    # If the elements are the same, use the combination formula to count pairs\n                    count += element_count[arr[i]] - 1\n                else:\n                    count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input().strip())\n    # Read the array elements\n    arr = list(map(int, input().strip().split()))\n    # Calculate and print the result\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef calculate_pairs(n, arr):\n    \"\"\"\n    Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.\n    \n    Args:\n    n (int): The number of elements in the array.\n    arr (list of int): The array of integers.\n    \n    Returns:\n    int: The number of pairs [i, j] that can be deleted to keep the mean unchanged.\n    \"\"\"\n    mean_original = sum(arr) / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            new_count = n - 2\n            if new_count > 0 and new_sum / new_count == mean_original:\n                count += 1\n    \n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements unchanged. This involves summing the elements, calculating the mean, and then checking pairs of elements to see if their deletion maintains the mean. The solution must handle multiple test cases efficiently, which requires optimization to avoid timeouts for large inputs.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through pairs of positions and check if deleting them maintains the mean.\n- Ensure the solution is optimized for large inputs within the given constraints.\n- Add error handling for invalid inputs.\n- Include user-friendly output messages for better user experience.\nTo solve this problem efficiently, we will use Python's built-in data structures and libraries. The main idea is to calculate the mean of the array and then iterate through all possible pairs of indices to check if removing these elements results in the mean remaining unchanged. We will use a list to store the array and a set to keep track of the sums of the remaining elements after removing each pair. This approach will help us avoid recalculating the mean for each pair, which is crucial for handling large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices to delete such that the mean of the remaining elements is the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the array.\n    Explanation: We need to identify and remove two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb] \n    'largest': not applicable in this context as we are not comparing sizes but rather removing elements to maintain the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this, we will:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, remove the elements at indices i and j.\n    4. Check if the mean of the remaining elements is still equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    explanation: There are no pairs that can be removed to keep the mean unchanged since all elements are distinct.\n    search([2, 2, 2, 2]) = 6\n    explanation: All elements are the same, so any two elements can be removed to keep the mean unchanged. There are 6 pairs (0-1, 0-2, 0-3, 1-2, 1-3, 2-3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all cases.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. The solution must handle multiple test cases efficiently, considering the constraints on the number of elements and test cases.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all pairs [i, j] and check if deleting them results in the mean remaining the same.\n- Optimize the solution to handle large inputs within the given constraints.\n- Ensure the code is well-documented and easy to understand.\n- Include error handling for invalid inputs.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to calculate the mean of the array and iterate through all pairs [i, j] to check if deleting them results in the mean remaining the same. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that a value must be greater than a specified amount.\n\n# [degree adverb] \n    'largest': indicates that a value is the greatest in a set of values.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No edge cases provided in the plan.\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the plan does not specify any specific edge cases.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the mean of the remaining elements being equal to the original mean. The solution must handle multiple test cases efficiently, considering the constraints on the number of elements and test cases.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to iterate through all pairs [i, j] and check if deleting the elements at these positions maintains the original mean.\n- Optimize the solution to handle large inputs within the given constraints.\n- Ensure the solution is user-friendly and provides clear output for each test case.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and calculations. The main challenge is to iterate through all possible pairs of positions [i, j] and check if deleting the elements at these positions maintains the original mean. We will optimize the solution by avoiding unnecessary calculations and leveraging Python's efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose deletion does not change the mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that maintain the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No specific edge case provided in the plan.\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the main logic is not provided.\n\nPlease provide the specific requirement and coding plan for a detailed analysis.\n", "requirement analysis:\nThe problem requires calculating the mean of the array and then finding pairs of elements that, when removed, maintain the same mean. This involves understanding the mathematical properties of the mean and applying them to a practical problem. The solution must be efficient to handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array\n- Create a function to find pairs of positions to remove\n- Ensure the solution is optimized for large inputs\n- Add user input handling for test cases\n- Implement error handling for invalid inputs\nTo efficiently solve the problem of finding pairs of positions to remove from an array such that the mean of the remaining elements remains unchanged, we will use Python's built-in functions and libraries. The key steps include calculating the mean of the array, iterating through possible pairs of indices, and checking if removing these elements maintains the original mean. We will optimize the solution for large inputs by leveraging efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: The mathematical mean (average) of an array is calculated by summing all its elements and then dividing that sum by the number of elements in the array. Monocarp wants to remove exactly two elements from the array so that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a number must be greater than another number.\n    'at least as many times': Indicates that a number must appear at least as frequently as another number.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set of numbers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs that can be removed to maintain the original mean because the array elements are all distinct.\n    search([2, 2, 4, 4]) = 3\n    Explanation: The original mean is (2+2+4+4)/4 = 3. We can remove the pairs (0, 2), (1, 2), and (1, 3) to maintain the mean of 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where the array elements are all distinct.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array elements are all the same or where removing any two elements does not change the mean.\n    Example:\n    if all elements are the same:\n        return n * (n - 1) // 2\n    if removing any two elements does not change the mean:\n        return 0\n", "requirement analysis:\nThe problem requires the user to find pairs of positions [i, j] in an array such that removing two elements from the array maintains the original mean. This involves calculating the mean, identifying pairs, and ensuring the constraints are met efficiently.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions [i, j] where i < j.\n- Ensure the function works efficiently for large inputs.\n- Add user input handling to allow for multiple test cases.\n- Optimize the code for better performance on large datasets.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the input and output, and we will iterate through the array to find the pairs of positions [i, j] where removing two elements maintains the original mean. We will ensure that the solution is optimized for large inputs by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematical mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In the requirement, the mathematical mean (average) of the array elements is calculated by dividing the sum of all elements by the number of elements (n). Monocarp wants to remove exactly two elements from the array so that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value of the number of elements after removal should be greater than zero.\n    Explanation: The requirement specifies that after removing two elements, the number of remaining elements should be greater than zero.\n\n# [degree adverb] \n    'exactly': Indicates that only two elements need to be removed to maintain the original mean.\n    Explanation: The requirement specifies that exactly two elements need to be removed to ensure the mean of the remaining elements is equal to the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean (k) of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new sum of the array after removing the elements at indices i and j.\n    4. Check if the new mean (new_sum / (n - 2)) is equal to the original mean (k).\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs of elements that can be removed to maintain the original mean because all elements are distinct and positive.\n    search([2, 2, 2, 2]) = 6\n    Explanation: All elements are the same, so removing any two elements will maintain the original mean. There are 6 possible pairs: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle all cases, including when all elements are the same.\n", "requirement analysis:\nThe problem requires calculating the mean of an array and finding pairs of positions to remove elements such that the mean remains unchanged. This involves understanding the mathematical properties of the mean and implementing an efficient algorithm to find the required pairs.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Create a function to find pairs of positions to remove elements\n- Ensure the solution is optimized for large inputs\n- Add user input handling for test cases\n- Implement error handling for invalid inputs\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the input and output, and we will iterate through the array to find the pairs of positions that can be removed to maintain the mean. The key is to ensure that the solution is optimized for large inputs, leveraging Python's ability to handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: The mathematic mean (average) of an array is found by summing all its elements and then dividing that sum by the number of elements in the array. Monocarp wants to remove exactly two elements from the array so that the mathematic mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value must be greater than a certain threshold.\n    'at least as many times': Indicates that the frequency of an element must be at least as much as its value.\n\n# [degree adverb] \n    'largest': Indicates that the value sought is the biggest in a set.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after removing the elements at indices i and j.\n    4. Count the number of pairs that result in the new mean being equal to the original mean.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs that can be removed to maintain the mean because all elements are distinct.\n    search([2, 2, 2, 2]) = 6\n    Explanation: All elements are the same, so removing any two elements will maintain the mean. There are 6 possible pairs (0-1, 0-2, 0-3, 1-2, 1-3, 2-3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to count pairs can be directly applied without modification for cases where all elements are the same.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            n = len(lst)\n            return n * (n - 1) // 2\n\nPlease note that the edge cases and extra code provided are hypothetical and may not directly apply to the specific problem statement. The actual implementation would depend on the details of the problem and the specific requirements.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean. This involves understanding the properties of means and efficiently iterating through pairs of elements in the array.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Iterate through all pairs of positions [i, j] and check if deleting the elements at these positions keeps the mean unchanged.\n- Optimize the solution to handle large inputs within reasonable time limits.\n- Ensure the output is clear and easy to understand.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The key steps include calculating the mean of the array, iterating through all pairs of positions [i, j], and checking if deleting the elements at these positions keeps the mean unchanged. We will optimize the solution to handle large inputs within reasonable time limits.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of positions [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the sum of the remaining elements divided by the count of the remaining elements equals the original mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than a certain number of times.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the sum of the remaining elements and their count.\n    4. Check if the new mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to delete two elements and still have a mean of k.\n\n    Edge case 2: n = 4, array = [1, 2, 3, 4]\n    Expected output: 1\n    Explanation: The only pair that can be deleted to keep the mean the same is [0, 3] (deleting the first and last elements).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    This ensures that the function immediately returns 0 for the edge case, as it's impossible to satisfy the condition with only three elements.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions to delete from an array such that the mean of the remaining elements remains unchanged. This involves understanding the properties of the mean and how deleting elements affects it. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions to delete.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and accurate output for each test case.\n- Ensure the interface is simple and easy to use.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of positions to check if deleting them maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be removed such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n    Explanation: For example, if we have a list [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. We need to find pairs [i, j] such that removing a_i and a_j keeps the mean unchanged.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest possible pairs that maintain the mean.\n    Explanation: In the given example, the largest pairs that can be removed to maintain the mean are those with the highest values, as removing smaller values has a lesser impact on the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean if these elements are removed.\n    4. Count the number of pairs that result in the same mean as the original array.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 3\n    Explanation: The pairs [1, 4], [2, 4], and [3, 4] all result in a mean of 2.5 when removed.\n    search([1, 1, 1, 1]) = 6\n    Explanation: All pairs result in the same mean, so there are 6 pairs.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return n * (n - 1) / 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return n * (n - 1) / 2\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions to delete from an array to maintain the mean. The solution should be efficient and handle large inputs within the given constraints. The output should be accurate and match the expected result for each test case.\nrequirement pool:\n- Implement a solution to calculate the number of pairs of positions to delete for maintaining the mean.\n- Optimize the solution for large inputs and ensure it runs within the given constraints.\n- Provide clear and accurate results for each test case.\n- Ensure the solution is user-friendly and easy to understand.\n- Compare and contrast with other solutions to identify strengths and weaknesses.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through pairs of elements to check if their deletion maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find the mean of the array and then determine how many pairs of elements can be deleted such that the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose deletion does not significantly alter the mean.\n    Explanation: For example, in the requirement, we need to find pairs [i, j] such that deleting elements at these positions keeps the mean of the remaining elements equal to k.\n\n# [degree adverb] \n    'exactly': specifies that we need to find pairs of positions where exactly two elements are deleted.\n    Explanation: This means we are looking for pairs [i, j] where i and j are distinct indices, and deleting the elements at these positions will leave us with n - 2 elements whose mean is still k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of indices [i, j] where i < j.\n    3. For each pair, calculate the new sum and new count after deleting the elements at positions i and j.\n    4. Check if the new mean is still equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 1, 1], 1) = 1\n    Explanation: In this case, the array has only three elements, and all elements are equal to the mean. Deleting any two elements will not change the mean. Thus, there is only one pair [0, 1] that can be deleted.\n    search([2, 2, 4], 2.6667) = 0\n    Explanation: The mean of the array is approximately 2.6667. There are no pairs of elements that can be deleted to keep the mean unchanged. Therefore, the expected output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already correctly handles arrays with fewer elements by checking all possible pairs.\n\nPlease note that the edge cases provided in the example are hypothetical and may not directly apply to the given problem statement. The actual edge cases should be derived from the constraints and requirements of the problem.\n", "requirement analysis:\nThe requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the mean of the array. The input consists of multiple test cases, each with a specific number of elements and their values. The output should be the count of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Identify pairs of positions [i, j] that can be deleted to maintain the mean.\n- Optimize the solution for large inputs within the given constraints.\n- Handle edge cases such as all elements being the same.\n- Ensure the solution is efficient and can handle up to 2 * 10^5 elements.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the mean of the array for each test case, then iterating through all possible pairs of indices to check if removing those elements would maintain the mean. We will optimize this by using a set to quickly check if removing two elements results in the same mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mathematic mean': the average value of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find pairs of elements whose removal does not change the mean.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest possible pairs that maintain the mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No specific edge case provided in the prompt.\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the logic provided is sufficient for the main problem.\n\nPlease provide the specific coding plan and requirement for further analysis.\n"], "scores": [], "pass_results": [true, false, true, false, true, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 601, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 495}
