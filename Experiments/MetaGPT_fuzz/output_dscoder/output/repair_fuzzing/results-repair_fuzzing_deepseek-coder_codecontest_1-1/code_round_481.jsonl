{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp wonders if there's a pattern to the possible pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp wonders if there's a pattern to the possible pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp is trying to figure out if there's a regular way to pick two positions [i, j] from a list so that the mean of the remaining elements stays the same.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp investigates whether there's a pattern in the possible pairs of positions [i, j] that can be removed to keep the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(arr: List[int], target_mean: float) -> int:\n    n = len(arr)\n    pair_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr and sum(new_arr) / (n - 2) == target_mean:\n                pair_count += 1\n    \n    return pair_count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\ntarget_mean = sum(arr) / n\n\n# Call the function and print the result\nresult = find_pairs_to_maintain_mean(arr, target_mean)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    if n == 3:\n        return -1\n    if all(x == arr[0] for x in arr):\n        return arr[0]\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                if sum(new_arr) / (n - 2) == mean_value:\n                    count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\na = list(map(int, input().split()))\nresult = find_pairs_to_maintain_mean(a, sum(a) / n)\nprint(result)\n", "from typing import List\ndef calculate_mean(arr: list) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (list): The list of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef find_pairs(arr: list, mean_value: float) -> int:\n    \"\"\"\n    Find all possible pairs of positions that, when deleted, maintain the same mean.\n    \n    Args:\n        arr (list): The list of integers.\n        mean_value (float): The mean value of the array.\n        \n    Returns:\n        int: The number of pairs that maintain the same mean.\n    \"\"\"\n    pairs_count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(temp_arr) > 0 and calculate_mean(temp_arr) == mean_value:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate mean\nmean_value = calculate_mean(arr)\n\n# Find pairs\npairs_count = find_pairs(arr, mean_value)\n\n# Output the result\nprint(pairs_count)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef find_pairs(n: int, arr: list) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            if new_n > 0 and new_sum / new_n == mean:\n                count += 1\n    return count\n\n# Provide input interface\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr and sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nmean_value = sum(arr) / n\n\n# Calculate and print the result\nresult = find_pairs(arr, mean_value)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_pairs(arr, mean_value):\n    \"\"\"\n    This function finds pairs of positions in the array such that deleting these positions does not change the mean of the remaining elements.\n    \n    Args:\n    arr (list of int): The input array of integers.\n    mean_value (float): The mean value of the entire array.\n    \n    Returns:\n    int: The number of pairs that can be deleted to maintain the mean.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            remaining_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            remaining_count = n - 2\n            \n            # Calculate the new mean\n            new_mean = remaining_sum / remaining_count\n            \n            # Check if the new mean is the same as the original mean\n            if new_mean == mean_value:\n                count += 1\n    \n    return count\n\n# Read input from stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean_value = sum(arr) / n\n    result = find_pairs(arr, mean_value)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int], k: float) -> int:\n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) > 0 and sum(new_arr) / len(new_arr) == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean = sum(arr) / n\n    result = find_pairs_to_maintain_mean(n, arr, mean)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through all possible pairs of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a new array excluding the elements at positions i and j\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            # Calculate the mean of the new array\n            new_sum = sum(new_arr)\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\nfrom math import comb\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    if all(x == arr[0] for x in arr):\n        return comb(n, 2)\n    \n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int], k: float) -> int:\n    if n < 3:\n        return -1  # If there are fewer than 3 elements, it's impossible to delete any pairs\n\n    # Initialize a counter for pairs\n    count = 0\n\n    # Iterate through the array to find pairs [i, j]\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new mean after deleting elements at positions i and j\n            new_mean = (sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])) / (n - 2)\n            if new_mean == k:\n                count += 1\n\n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nk = sum(arr) / n\n\n# Call the function and print the result\nresult = find_pairs_to_maintain_mean(n, arr, k)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that can be deleted to maintain the same mean in the array. This involves understanding the mathematical properties of means and how deleting elements affects the overall mean. The solution must be efficient and scalable to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a function to find all possible pairs of positions [i, j] where i < j.\n- Create a function to check if deleting the elements at positions [i, j] maintains the same mean.\n- Optimize the algorithm to ensure it can handle the upper limits of the input constraints.\n- Ensure the user interface is simple and intuitive for easy interaction.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs of positions that can be deleted to maintain the same mean in the array. We will first calculate the mean of the array, then iterate through all possible pairs of positions, check if deleting these positions maintains the same mean, and count such pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. The goal is to find pairs of positions that, when deleted, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array must be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that appears at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that meets the condition specified by the phrase 'appears at least as many times as itself'.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: In this case, the largest integer that appears at least as many times as itself is 3, as it appears 3 times.\n\n    Edge case 2:\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but the largest number that satisfies the condition is 3.\n\n    Edge case 3:\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: None of the numbers 2, 3, or 4 appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can be used to find the largest integer that meets the condition.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array that, when deleted, result in the mean of the remaining elements being the same as the original mean. This requires calculating the mean of the entire array and then checking each pair of positions to see if their deletion maintains the same mean. The solution must be efficient and scalable to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all possible pairs of positions.\n- Develop a check to verify if deleting a pair of positions maintains the same mean.\n- Ensure the solution is optimized for performance.\n- Include user-friendly error handling and feedback.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and pair checking. We will calculate the mean of the array once and then iterate through all possible pairs to check if their deletion maintains the same mean. The solution will be optimized to handle the upper limits of the input constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that deleting these positions results in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer should be at least as high as the integer itself.\n    Explanation: For example, if the integer is 3, it should appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: We need to identify the largest integer in the array that satisfies the condition of appearing at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, check if deleting the elements at positions i and j maintains the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    search([1, 2, 3]) = -1\n    Explanation: With only 3 elements, it's impossible to delete any two elements and maintain the same mean. The function should return -1.\n    Edge case 2: All elements are the same\n    search([5, 5, 5]) = 5\n    Explanation: If all elements are the same, deleting any two elements will not change the mean. The function should return the value of the element.\n    Edge case 3: Large array with no specific pattern\n    search([1, 3, 2, 4, 5]) = -1\n    Explanation: Without a specific pattern, it's unlikely to find pairs that can be deleted to maintain the same mean. The function should return -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has only 3 elements or all elements are the same.\n    For edge case 1:\n        if n == 3:\n            return -1\n    For edge case 2:\n        if all(x == a[0] for x in a):\n            return a[0]\n    These checks can be added to the initial part of the function to handle these specific scenarios.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array that, when deleted, result in the mean of the remaining elements being the same as the original mean. This requires calculating the mean of the entire array and then checking each pair of positions to see if their deletion maintains the same mean. The challenge lies in the scalability of the solution, as the input size can be up to 2 * 10^5 elements.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all possible pairs of positions.\n- Develop a check to verify if deleting a pair of positions maintains the same mean.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output for each test case.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the mean of the array and then check each pair of positions to see if their deletion maintains the same mean. We will use a function to calculate the mean and another function to find all possible pairs of positions. We will then check each pair to ensure the deletion maintains the same mean.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. The goal is to find pairs of positions that, when deleted, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array must be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: In the context of the requirement, we need to find the largest integer in the array that appears at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through the array to count the frequency of each element.\n    3. Check each pair of positions to see if their deletion maintains the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The number 3 appears three times, which is equal to its value. Therefore, deleting any two positions of 3 will maintain the same mean.\n    search([1, 1, 1, 2, 2, 3]) = 0\n    Explanation: No number appears as many times as its value. Therefore, no pairs can be deleted to maintain the same mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where no number appears as many times as its value by returning 0.\n\n# [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. The goal is to find pairs of positions that, when deleted, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array must be greater than or equal to the element's value.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: In the context of the requirement, we need to find the largest integer in the array that appears at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Iterate through the array to count the frequency of each element.\n    3. Check each pair of positions to see if their deletion maintains the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The number 3 appears three times, which is equal to its value. Therefore, deleting any two positions of 3 will maintain the same mean.\n    search([1, 1, 1, 2, 2, 3]) = 0\n    Explanation: No number appears as many times as its value. Therefore, no pairs can be deleted to maintain the same mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where no number appears as many times as its value by returning 0.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array such that the mean of the remaining elements remains the same after their deletion. This involves calculating the mean of the entire array and checking if the mean of the remaining elements (excluding the pair) equals this value. The solution should be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when deleted, do not change the mean of the remaining elements.\n- Ensure the solution is optimized to handle the upper limits of input size.\n- Add input validation to handle edge cases.\n- Include comments in the code for better understanding.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the mathematical operations and data structures. The main challenge is to find pairs of positions in the array that, when removed, do not change the mean of the remaining elements. We will iterate through the array, calculate the mean of the entire array, and then check for each pair if the mean of the remaining elements equals this value.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. For a set of numbers to remain unchanged when two elements are removed, the mean of the remaining elements must be equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs of positions where removing two elements results in the mean of the remaining elements being the same as the original mean.\n\n# [degree adverb] \n    'largest': not applicable in this context as it does not directly relate to the core concept or the phrases used in the requirement.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Count the number of pairs where the mean of the remaining elements is equal to the original mean.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    Explanation: The mean of the array [1, 2, 3, 4] is 2.5. There are no pairs [i, j] such that removing the elements at these positions results in the mean of the remaining elements being 2.5.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The mean of the array [2, 2, 4, 4] is 3. Removing any pair of elements that are the same will result in the mean of the remaining elements being 3. In this case, removing the pairs [0, 1] and [2, 3] both result in the mean of the remaining elements being 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array such that the mean of the remaining elements remains the same after their deletion. This involves calculating the mean of the entire array and checking if the mean of the remaining elements (excluding the pair) equals this value. The constraints are high, with up to 2 * 10^5 elements across multiple test cases, which makes the solution need to be efficient.\nrequirement pool:\n- Implement a function to calculate the mean of an array\n- Create a function to find pairs of positions that, when deleted, do not change the mean of the array\n- Ensure the solution is efficient enough to handle up to 2 * 10^5 elements\n- Add input reading functionality to handle multiple test cases\n- Implement error handling for invalid inputs\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing them results in the same mean. We will optimize this by avoiding recalculating the mean for each pair and instead use pre-computed values to speed up the process.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the entire array and the mean of the remaining elements after removing two positions.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. When we remove two positions, the mean of the remaining elements should be the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not explicitly mentioned in the requirement, but the concept of comparing means implies a relationship between the means of different subsets of the array.\n\n# [degree adverb] \n    'largest': This phrase is not explicitly mentioned in the requirement, but the concept of finding the largest number of pairs implies a need to consider the maximum possible pairs.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the pair.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3]\n    Explanation: The original mean is (1+2+3)/3 = 2. Removing any pair of positions will result in a mean different from 2. Therefore, there are no valid pairs.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [4, 4, 4, 4]\n    Explanation: The original mean is (4+4+4+4)/4 = 4. We can remove any pair of positions, and the mean of the remaining elements will still be 4. There are 6 possible pairs (0-1, 0-2, 0-3, 1-2, 1-3, 2-3).\n    Expected output: 6\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases with fewer elements or cases where all elements are the same.\n\nPlease note that the edge cases provided are simplified for illustrative purposes. The actual implementation should consider all possible pairs and ensure that the mean of the remaining elements matches the original mean.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array such that the mean of the remaining elements remains the same after their deletion. This involves calculating the mean of the entire array and checking if the mean of the remaining elements equals this value. The constraints are high, with up to 2 * 10^5 elements, so efficiency is crucial.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when deleted, do not change the mean of the array.\n- Ensure the code runs efficiently within the given constraints.\n- Provide clear and accurate output for each test case.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find pairs of positions that, when deleted, do not change the mean of the array. We will calculate the mean of the entire array and then iterate through all possible pairs to check if deleting them results in the same mean. This approach will be optimized to handle the large input constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. The problem requires finding pairs of positions whose deletion does not alter the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where deleting two elements does not change the mean.\n    'at least as many times': not directly applicable in this context, as we are looking for pairs that maintain the mean.\n\n# [degree adverb] \n    'largest': not directly applicable in this context, as we are looking for pairs that maintain the mean.\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. Check if deleting the elements at positions i and j results in the same mean for the remaining elements.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    Explanation: The mean of the entire array is (1+2+3+4)/4 = 2.5. There are no pairs (i, j) such that deleting them results in a mean of 2.5 for the remaining elements.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The mean of the entire array is (2+2+4+4)/4 = 3. There are two pairs (0, 2) and (1, 3) that can be deleted to maintain the mean of 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array that, when removed, do not change the mean of the remaining elements. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal maintains the same mean. The challenge lies in the scalability of the solution, as the number of test cases and the size of the arrays can be very large.\nrequirement pool:\n- Implement a function to calculate the mean of an array.\n- Create a function to find pairs of positions that, when removed, do not change the mean of the array.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output for each test case.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing them maintains the mean. We will use a brute-force method initially for simplicity, which can be optimized later if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that removing these positions does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: If there are multiple integers that meet the condition, we should return the largest one.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the pair.\n    4. Check if the calculated mean is equal to the original mean.\n    5. Count the number of such pairs.\n    6. Return the count.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: In this case, there are no pairs that can be removed to keep the mean the same because the array has only one possible pair (any two elements) that can be removed.\n    search([1, 1, 2, 2]) = 2\n    Explanation: There are two pairs (1, 1) and (2, 2) that can be removed to keep the mean the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute-force method will work for this problem as the constraints are not prohibitively large. However, if the constraints were larger, we would need to optimize the algorithm to handle larger inputs more efficiently.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array that, when removed, do not change the mean of the remaining elements. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal maintains the same mean. The challenge lies in the scalability of the solution, as the number of test cases and the size of the arrays can be very large.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that can be removed without changing the mean.\n- Ensure the solution is optimized for handling large inputs efficiently.\n- Develop a user-friendly interface for easy interaction.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array for each test case and then iterating through all possible pairs of positions to check if their removal maintains the same mean. We will use a brute-force method initially for simplicity, which is feasible given the constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that removing these positions results in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: This is important because we want to maximize the integer we return, ensuring we find the largest possible value that satisfies the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will:\n    1. Calculate the mean of the entire array for each test case.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, check if removing these positions results in the remaining elements having the same mean.\n    4. Count the number of such pairs and return the count.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: With only 3 elements, it's impossible to remove any pair and still have the mean of the remaining elements the same as the original array's mean.\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements are the same, any pair can be removed to maintain the mean. The number of such pairs is given by the combination formula (n choose 2).\n    Edge case 3: Large values in the array\n    Expected output: (n choose 2)\n    Explanation: Even if the array contains very large values, the logic remains the same. We need to check all pairs to ensure the mean remains unchanged after removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n        (other code)\n\n    For the other edge cases, the original logic can handle them without additional code.\n", "requirement analysis:\nThe requirement involves calculating the number of pairs of positions that can be removed to keep the mean unchanged. This requires understanding the mathematical properties of means and efficiently iterating through pairs of positions in the array. The input size can be large, so the solution must be optimized for performance.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all possible pairs of positions.\n- Develop a method to check if removing the pair maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output for the number of valid pairs.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. We will focus on calculating the mean of the array and iterating through all possible pairs of positions to check if removing them maintains the mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that removing these positions does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: If there are multiple integers that meet the condition, we should return the largest one.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, check if removing the elements at positions i and j maintains the mean.\n    4. Count the number of such pairs.\n    5. Return the count.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to remove any pair to keep the mean unchanged.\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements are the same, any pair can be removed to keep the mean unchanged. The number of such pairs is given by the combination formula (n choose 2).\n    Edge case 3: Large array with random values\n    Expected output: A specific count of pairs\n    Explanation: This edge case represents a typical scenario with a large array and varying values. The expected output will be the number of pairs that, when removed, maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all(x == a[0] for x in a):\n            return comb(n, 2)\n    This code calculates the number of pairs when all elements are identical using the combination formula.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] that can be deleted to maintain the same mean in the array. The solution should be efficient and handle the upper limits of the input constraints. The output should be accurate and match the expected result for each test case.\nrequirement pool:\n- Implement an efficient algorithm to find pairs that maintain the same mean.\n- Ensure the solution can handle large inputs efficiently.\n- Provide clear and concise output for each test case.\n- Enhance the user interface for better user experience.\n- Optimize performance to handle edge cases and large inputs.\nTo solve the problem of finding pairs [i, j] that can be deleted to maintain the same mean in the array, we will use a mathematical approach to calculate the mean and then determine the pairs. We will iterate through the array and use a set to keep track of the sums of subarrays. This approach will ensure efficiency and scalability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. The goal is to find pairs [i, j] such that deleting the elements at these positions results in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as high as the integer itself.\n    Explanation: For example, if the integer is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: If there are multiple integers that meet the condition, we need to return the largest one.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through the array and use a set to store the sums of all possible subarrays.\n    3. For each pair [i, j], check if deleting the elements at these positions results in the remaining elements having the same mean.\n    4. Count the number of such pairs and return the count.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. There are no pairs [i, j] such that deleting them results in the remaining elements having a mean of 2.5.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The mean of the array is (2+2+4+4)/4 = 3. The pairs [0, 2] and [1, 3] both result in the remaining elements having a mean of 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan should be sufficient to handle cases where no pairs exist that maintain the same mean after deletion.\n"], "scores": [], "pass_results": [true, true, false, true, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 481, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 388}
