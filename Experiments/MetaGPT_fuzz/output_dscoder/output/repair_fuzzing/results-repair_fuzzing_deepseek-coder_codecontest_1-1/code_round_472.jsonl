{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp wonders if there's a pattern to the possible pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp wonders if there's a pattern to the possible pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp is trying to figure out if there's a regular way to pick two positions [i, j] from a list so that the mean of the remaining elements stays the same.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp investigates whether there's a pattern in the possible pairs of positions [i, j] that can be removed to keep the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_mean(arr: List[int]) -> float:\n    \"\"\"\n    Calculate the mean of the array.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        \n    Returns:\n        float: The mean of the array.\n    \"\"\"\n    return sum(arr) / len(arr)\n\ndef find_pairs(arr: List[int], mean: float) -> int:\n    \"\"\"\n    Find all possible pairs [i, j] where i < j such that deleting the elements at these positions maintains the same mean.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        mean (float): The mean of the array.\n        \n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_maintain_mean(arr, i, j):\n                count += 1\n    return count\n\ndef can_maintain_mean(arr: List[int], i: int, j: int) -> bool:\n    \"\"\"\n    Check if deleting the elements at positions [i, j] maintains the same mean.\n    \n    Args:\n        arr (List[int]): The list of integers.\n        i (int): The index of the first element to delete.\n        j (int): The index of the second element to delete.\n        \n    Returns:\n        bool: True if deleting the elements maintains the same mean, False otherwise.\n    \"\"\"\n    new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n    new_mean = calculate_mean(new_arr)\n    original_mean = calculate_mean(arr)\n    return new_mean == original_mean\n\n# Provide the Interface\ndef main():\n    n = int(input())\n    for _ in range(n):\n        arr_length = int(input())\n        arr = list(map(int, input().split()))\n        mean = calculate_mean(arr)\n        result = find_pairs(arr, mean)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(arr: List[int], mean_val: float) -> int:\n    n = len(arr)\n    total_sum = sum(arr)\n    \n    # If the array has only one element, it's impossible to delete a pair\n    if n == 1:\n        return -1\n    \n    # Check all possible pairs to see if their deletion maintains the mean\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array after deleting the pair (i, j)\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            \n            # Check if the new mean is the same as the original mean\n            if new_n > 0 and new_sum / new_n == mean_val:\n                return n - 2\n    \n    return -1\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    count = 0\n    arr_sum = sum(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_sum = arr_sum - arr[i] - arr[j]\n            if temp_sum / (n - 2) == mean_value:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_maintain_mean(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_of_positions(n: int, arr: List[int]) -> int:\n    # Calculate the mean of the entire array\n    total_sum = sum(arr)\n    original_mean = total_sum / n\n    \n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return (n * (n - 1)) // 2\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through each pair of positions [i, j] where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing elements at positions i and j\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n            if remaining_count != 0:\n                new_mean = remaining_sum / remaining_count\n                if new_mean == original_mean:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_of_positions(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(arr: List[int], mean_val: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr and sum(new_arr) / (n - 2) == mean_val:\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nmean_val = sum(arr) / n\n\n# Calculate and print the result\nresult = find_pairs(arr, mean_val)\nprint(result)\n", "from typing import List\ndef find_pairs(arr, mean_value):\n    \"\"\"\n    This function finds the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mean of the remaining elements is equal to the original mean.\n    \n    Args:\n    arr (list of int): The list of integers.\n    mean_value (float): The mean value of the original array.\n    \n    Returns:\n    int: The number of pairs that, when removed, do not change the mean of the remaining elements.\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    # Check if all elements are the same\n    if all(x == arr[0] for x in arr):\n        return (n * (n - 1)) // 2\n\n    # Iterate through all possible pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the mean of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            remaining_count = n - 2\n            if remaining_sum / remaining_count == mean_value:\n                count += 1\n\n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nmean_value = sum(arr) / n\nresult = find_pairs(arr, mean_value)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(arr: List[int], mean_value: float) -> int:\n    if mean_value not in arr:\n        return 0\n    \n    mean_count = arr.count(mean_value)\n    pair_count = 0\n    \n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] != mean_value and arr[j] != mean_value:\n                arr[i], arr[j] = arr[j], arr[i]\n                new_mean = sum(arr) / (len(arr) - 2)\n                if new_mean == mean_value:\n                    pair_count += 1\n                arr[i], arr[j] = arr[j], arr[i]\n    \n    return pair_count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_pairs_to_maintain_mean(arr, sum(arr) / n)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_remove(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    pair_count = 0\n    \n    # Create a hash map to store the counts of the differences\n    diff_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the difference between the current element and the mean\n            diff = arr[i] + arr[j] - 2 * mean_value\n            if diff in diff_count:\n                pair_count += diff_count[diff]\n                diff_count[diff] += 1\n            else:\n                diff_count[diff] = 1\n    \n    return pair_count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean_value = sum(arr) / n\n    result = find_pairs_to_remove(arr, mean_value)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef count_pairs_to_keep_mean(arr: List[int], k: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if new_arr:\n                if sum(new_arr) / (n - 2) == k:\n                    count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    k = sum(arr) / n\n    result = count_pairs_to_keep_mean(arr, k)\n    print(result)\n", "from typing import List\nfrom typing import List, Tuple\n\ndef find_pairs(arr: List[int], target_mean: float) -> List[Tuple[int, int]]:\n    pairs = []\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Create a copy of the array to simulate deletion of the pair (i, j)\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if len(new_arr) > 0 and sum(new_arr) / len(new_arr) == target_mean:\n                pairs.append((i, j))\n    \n    return pairs\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\ntarget_mean = sum(arr) / n\nresult = find_pairs(arr, target_mean)\nfor pair in result:\n    print(pair)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that can be deleted to maintain the same mean in the remaining elements. This involves understanding the mathematical properties of means and how deleting elements affects the overall mean. The solution should be efficient and scalable to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find all possible pairs of positions [i, j] where i < j.\n- Develop a function to check if deleting the elements at positions [i, j] maintains the same mean.\n- Optimize the algorithm to ensure it can handle the upper limits of the input constraints.\n- Ensure the solution is user-friendly and provides clear output.\nTo solve this problem, we will use Python due to its efficiency and ease of use. The main challenge is to efficiently calculate the number of pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements. We will break down the problem into smaller functions: calculating the mean, finding all possible pairs, and checking if deleting the elements at positions [i, j] maintains the same mean. We will optimize the algorithm to handle the upper limits of the input constraints efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': The average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. For a set of numbers to maintain the same mean after removing two elements, the sum of the remaining elements must be equal to the mean multiplied by the number of remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of elements in the array is greater than a certain threshold.\n    Explanation: In this problem, the phrase 'more than' is used to specify the minimum number of elements required in the array for the mean to be calculated.\n\n# [degree adverb] \n    'largest': Indicates that the value of the elements in the array should be considered the largest possible within the given constraints.\n    Explanation: In this problem, the degree adverb 'largest' refers to the maximum value that an element in the array can take, which is 10^9.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to iterate through all possible pairs [i, j] where i < j, and check if deleting the elements at these positions maintains the same mean. This involves calculating the mean of the entire array, then for each pair, recalculating the mean of the remaining elements and comparing it to the original mean.\n\n# [edge case] \n    Edge case 1: n = 3, array = [1, 2, 3]\n    expected output: 0\n    Explanation: With only three elements, it's impossible to delete any pair and maintain the same mean since we need at least two elements to calculate a mean.\n\n    Edge case 2: n = 4, array = [2, 2, 4, 4]\n    expected output: 2\n    Explanation: The mean of the array is 3. We can delete the pairs [0, 2] and [1, 3] to maintain the same mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where n = 3.\n        if n == 3:\n            return 0\n\n    This additional code checks if the number of elements is exactly 3 and returns 0 since it's impossible to delete any pair to maintain the same mean.\n", "requirement analysis:\nThe requirement is to find pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements of the array. The input consists of multiple test cases, each with a number of elements and their values. The output should be the count of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs [i, j] where deleting them maintains the same mean.\n- Ensure the solution is efficient and can handle the upper limits of input size.\n- Optimize the algorithm for performance.\n- Provide clear and accurate output for each test case.\nTo efficiently solve the problem of finding pairs of positions that can be deleted to maintain the same mean in the array, we will use Python's built-in libraries and data structures. The approach involves calculating the mean of the array and then finding pairs of indices whose deletion does not affect the mean. This will be achieved through a two-step process: first, calculate the total sum of the array and then iterate through possible pairs to check if their deletion maintains the mean. The solution will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': The average value of a set of numbers. In the context of the requirement, it refers to the average value of the remaining elements after deleting a pair of positions.\n    Explanation: To maintain the same mean, the sum of the remaining elements after deleting a pair must be equal to the original sum of the elements divided by the number of remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of remaining elements after deletion must be greater than zero.\n    Explanation: This phrase ensures that we are only considering valid deletions that leave at least one element in the array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest possible number of remaining elements that can maintain the same mean.\n    Explanation: This adverb suggests that we should aim to maximize the number of elements left in the array while still maintaining the original mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves calculating the mean of the array and then iterating through possible pairs to check if their deletion maintains the mean. This can be done efficiently using nested loops to check all possible pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: In this case, the sum of the array is 10, and the mean is 2.5. There are no pairs of positions that can be deleted to maintain the same mean since deleting any pair will change the mean.\n    search([5, 5, 5, 5]) = 5\n    Explanation: The sum of the array is 20, and the mean is 5. Deleting any pair of positions will not change the mean, so the largest integer that can be maintained is 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan already ensures that we only consider valid deletions that do not change the mean.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions that can be deleted to maintain the same mean in the array. This involves understanding the mathematical properties of means and how deleting elements affects the overall mean. The solution should be efficient and scalable to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Develop a function to find all possible pairs of positions [i, j] where i < j.\n- Create a function to check if deleting the elements at positions [i, j] maintains the same mean.\n- Optimize the algorithm to ensure it can handle the upper limits of the input constraints.\n- Ensure the solution is user-friendly and provides clear output.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to calculate the number of pairs of positions that can be deleted to maintain the same mean in the array. We will first calculate the mean of the array, then iterate through all possible pairs of positions, check if deleting these positions maintains the same mean, and count such pairs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. The goal is to find pairs of positions that, when deleted, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array must be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that appears at least as many times as itself.\n    Explanation: This means we need to find the highest number in the array that meets the condition specified by the 'more than' phrase.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: The mean of the array is 2.5, and there are no elements that appear at least 2.5 times, so the function should return -1.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number that meets the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# For example:\n## Prompt 3:\n\n# [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. The goal is to find pairs of positions that, when deleted, result in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears in the array must be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that appears at least as many times as itself.\n    Explanation: This means we need to find the highest number in the array that meets the condition specified by the 'more than' phrase.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through all possible pairs of positions (i, j) where i < j.\n    3. For each pair, check if deleting the elements at positions i and j results in the remaining elements having the same mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: The mean of the array is 2.5, and there are no elements that appear at least 2.5 times, so the function should return -1.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number that meets the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirement is to find pairs of positions [i, j] such that the mean of the remaining elements is the same after their deletion. This involves calculating the mean of the entire array and then checking if the mean of the remaining elements is the same after removing two specific elements. The input consists of multiple test cases, and the output should be the number of such pairs for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Check if the mean of the remaining elements is the same after removing two specific elements.\n- Handle multiple test cases efficiently.\n- Output the number of valid pairs for each test case.\n- Ensure the solution is efficient and can handle large inputs.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations and calculations. We will iterate through each test case, calculate the mean of the array, and then check for pairs of positions that, when removed, result in the remaining elements having the same mean as the original array. We will use list comprehensions and sum functions to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that removing these positions results in the mean of the remaining elements being the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will:\n    1. Calculate the mean of the entire array.\n    2. Iterate through each pair of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the elements at positions i and j.\n    4. Check if this new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and have the mean of the remaining elements be the same as the original mean.\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements are the same, any pair of elements can be removed, and the mean of the remaining elements will still be the same as the original mean.\n    Edge case 3: Large array with varying elements\n    Expected output: A specific count of pairs\n    Explanation: This edge case will test the efficiency of the algorithm by checking a large array with a variety of elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all(x == a[0] for x in a):\n            return (n * (n - 1)) // 2\n\n    This code calculates the number of pairs that can be formed when all elements are the same, which is (n choose 2).\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array such that the mean of the remaining elements remains the same after their deletion. This involves calculating the mean of the entire array and checking if the mean of the remaining elements after deleting any two positions equals this mean. The constraints are high, with up to 2 * 10^5 elements and up to 10^4 test cases, requiring the solution to be efficient.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when deleted, do not change the mean of the remaining elements.\n- Ensure the solution is efficient and can handle the given constraints.\n- Add input validation to handle edge cases.\n- Optimize the code for better performance.\nTo solve this problem efficiently, we will use Python's built-in libraries and data structures. The main challenge is to find pairs of positions in an array such that the mean of the remaining elements remains the same after their deletion. We will calculate the mean of the entire array and then check if the mean of the remaining elements after deleting any two positions equals this mean. We will optimize the solution to handle the large input constraints efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. We need to find pairs of positions in the array such that the mean of the remaining elements is the same as the mean of the entire array.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: We need to find the largest integer in the array that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] in the array.\n    3. For each pair, calculate the mean of the remaining elements after deleting the elements at positions i and j.\n    4. Check if this mean is equal to the mean of the entire array.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: When there are only three elements in the array, it is impossible to delete any two elements and have the mean of the remaining elements be the same as the original mean.\n\n    Edge case 2: All elements are the same\n    Expected output: (n * (n - 1)) / 2\n    Explanation: If all elements in the array are the same, any pair of elements can be deleted, and the mean of the remaining elements will still be the same as the original mean. The number of such pairs is given by the combination formula (n * (n - 1)) / 2.\n\n    Edge case 3: Large array with varying elements\n    Expected output: A specific count of pairs\n    Explanation: This edge case will test the efficiency of the solution by checking a large array with a mix of different elements. The expected output will be the number of pairs that meet the condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all elements are the same:\n            return (n * (n - 1)) / 2\n\n    This code will ensure that we efficiently handle the edge case where all elements are identical, providing the correct number of pairs.\n", "requirement analysis:\nThe problem requires finding pairs of positions in an array such that the mean of the remaining elements remains the same after removing the elements at these positions. This involves calculating the mean of the entire array and then checking if the mean of the remaining elements is the same after removing any two elements. The solution should be efficient to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that can be removed without changing the mean.\n- Ensure the solution is efficient and can handle the upper limits of the input constraints.\n- Provide clear and accurate output for any given input.\n- Ensure the interface is simple and easy to use.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find pairs of positions that, when removed, do not change the mean of the remaining elements. We will calculate the mean of the entire array and then iterate through all possible pairs to check if removing them changes the mean. The solution will be optimized to handle the upper limits of the input constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the elements in the array.\n    Explanation: The mean of an array is calculated by summing all the elements and dividing by the number of elements. The goal is to find pairs of positions in the array such that the mean of the remaining elements is the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'as many times': means that the frequency of the integer in the array should be at least as much as the integer itself.\n    Explanation: For example, if the integer is 2, it should appear at least twice in the array for it to be considered.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: This is important because we want to maximize the integer we return if it meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Check if the mean of the remaining elements is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: n = 3\n    Expected output: 0\n    Explanation: With only three elements, it's impossible to remove two elements and have the mean of the remaining elements be the same as the original mean.\n\n    Edge case 2: All elements are the same\n    Expected output: (n choose 2)\n    Explanation: If all elements are the same, any pair of elements can be removed without changing the mean. The number of such pairs is given by the binomial coefficient (n choose 2).\n\n    Edge case 3: Large array with varying elements\n    Expected output: A specific count of pairs\n    Explanation: This edge case would involve a large array with different elements, and the output would be the number of pairs that, when removed, do not change the mean of the remaining elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same.\n        if all(x == a[0] for x in a):\n            return (n * (n - 1)) // 2\n\n    This code calculates the number of pairs when all elements are the same using the binomial coefficient formula.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array that, when removed, do not change the mean of the remaining elements. This requires calculating the mean of the entire array and then checking each pair of positions to see if removing them results in the same mean. The challenge lies in the need to handle a large number of test cases efficiently, each with potentially large arrays.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when removed, maintain the mean.\n- Ensure the solution can handle large inputs efficiently.\n- Implement error handling for invalid inputs.\n- Optimize the algorithm for minimal computational time and resource usage.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if removing them maintains the mean. We will optimize the algorithm to handle large inputs by using efficient data structures and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that removing these positions does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where removing them does not change the mean.\n    'at least as many times': means that the number of occurrences of the mean in the remaining elements should be the same as the number of occurrences of the mean in the original array.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the array.\n    2. Count the occurrences of the mean in the array.\n    3. Iterate through all possible pairs [i, j] and check if removing them maintains the mean.\n    4. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    Explanation: The mean of the array is 2.5, which does not appear as an element in the array. Therefore, no pairs can be removed to maintain the mean.\n    search([2, 2, 4, 4]) = 2\n    Explanation: The mean of the array is 3.0, which appears twice. The pairs [0, 2] and [1, 3] can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where the mean does not appear in the array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the mean does not appear in the array. This can be done by checking if the mean is in the array before counting pairs. If the mean is not in the array, the function should return 0 immediately.\n", "requirement analysis:\nThe requirement is to find pairs of positions in an array that, when removed, do not change the mean of the remaining elements. This involves calculating the mean of the entire array and then checking pairs of elements to see if their removal results in the same mean. The challenge lies in the efficiency of the solution, especially given the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of positions that, when removed, maintain the same mean.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and accurate output for each test case.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of positions to check if their removal maintains the same mean. We will optimize this by avoiding unnecessary calculations and leveraging Python's efficient list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. We need to find pairs of positions [i, j] such that removing these positions results in the remaining elements having the same mean as the original array.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find pairs where the removal of two elements results in the remaining elements having the same mean.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number of pairs that can be removed to maintain the same mean.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs of positions [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements after removing the pair.\n    4. Check if the mean of the remaining elements is equal to the mean of the original array.\n    5. Count the number of such pairs.\n    6. Return the count of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    Explanation: The mean of the array is (1+2+3+4)/4 = 2.5. There are no pairs that can be removed to keep the mean the same since removing any pair will change the mean.\n    search([1, 3, 2, 6]) = 1\n    Explanation: The mean of the array is (1+3+2+6)/4 = 3. There is one pair (1, 2) that can be removed to keep the mean the same (remaining elements are [3, 6] with mean 4.5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for any given array.\n", "requirement analysis:\nThe primary requirement is to develop a program that can calculate the number of pairs of positions that can be removed to keep the same mean in the remaining elements. The program should be able to handle multiple test cases efficiently, with the sum of n over all test cases not exceeding 2 \u22c5 10^5. The solution should be scalable and capable of handling large datasets.\nrequirement pool:\n- The main code should efficiently calculate the number of pairs of positions that can be removed to keep the same mean in the remaining elements.\n- The program should be able to handle multiple test cases efficiently.\n- Ensure the program is scalable and can handle large datasets efficiently.\n- Provide clear and concise results to the user.\nTo solve this problem, we will use Python's built-in statistics module for calculating the mean of the array. We will iterate through all possible pairs of positions [i, j] where i < j, calculate the mean of the remaining elements after removing the elements at these positions, and count the number of such pairs that match the given mean k. This approach will be efficient and scalable due to the use of built-in functions and the constraints provided.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. For a set of numbers to have the same mean after removing two elements, those two elements must collectively contribute to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears must be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: This means we need to find the biggest number in the array that satisfies the condition of appearing at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Count the number of pairs where the calculated mean matches the given mean k.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: In this case, there are no elements that appear as many times as their value (e.g., 2 appears twice, 3 appears three times, etc.), so the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return -1 if no such integer exists.\n\n## Prompt 3:\n[requirement]\nMonocarp investigates whether there's a pattern in the possible pairs of positions [i, j] that can be removed to keep the same mean in the remaining elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\n[plan]\nTo solve this problem, we will use Python's built-in statistics module for calculating the mean of the array. We will iterate through all possible pairs of positions [i, j] where i < j, calculate the mean of the remaining elements after removing the elements at these positions, and count the number of such pairs that match the given mean k. This approach will be efficient and scalable due to the use of built-in functions and the constraints provided.\n\n## Answer 3:\n\n# [core concept]\n    'mean': the average value of a set of numbers. In this context, it refers to the arithmetic mean of the array elements.\n    Explanation: The mean is calculated by summing all the elements in the array and then dividing by the number of elements. For a set of numbers to have the same mean after removing two elements, those two elements must collectively contribute to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times an element appears must be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': refers to finding the largest integer that meets the condition of appearing at least as many times as itself.\n    Explanation: This means we need to find the biggest number in the array that satisfies the condition of appearing at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Calculate the mean of the entire array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. For each pair, calculate the mean of the remaining elements.\n    4. Count the number of pairs where the calculated mean matches the given mean k.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: In this case, there are no elements that appear as many times as their value (e.g., 2 appears twice, 3 appears three times, etc.), so the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return -1 if no such integer exists.\n", "requirement analysis:\nThe primary requirement is to find pairs of positions [i, j] that can be deleted to maintain the same mean in the remaining elements of the array. The solution must be efficient and scalable to handle up to 2 \u22c5 10^5 elements across multiple test cases. The output should be accurate and clear for each test case.\nrequirement pool:\n- Implement a function to calculate the mean of the array and compare it after deleting pairs of elements.\n- Ensure the solution can handle up to 2 \u22c5 10^5 elements across multiple test cases.\n- Provide clear and accurate output for each test case.\n- Optimize the solution for performance to handle large inputs efficiently.\n- Enhance the user interface for easy interaction and understanding of the solution.\nTo efficiently solve the problem of finding pairs of positions that can be deleted to maintain the same mean in the remaining elements of the array, we will use Python's built-in libraries and data structures. The approach involves calculating the mean of the array and then iterating through possible pairs of elements to check if their deletion maintains the same mean. We will optimize the solution for performance to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'mean': The average value of a set of numbers. In this context, it refers to the average value of the remaining elements after deleting a pair of positions from the array.\n    Explanation: The mean is calculated by summing all the elements in the array and dividing by the number of elements. The goal is to find pairs of positions that, when deleted, do not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest element that meets the condition.\n    Explanation: We need to find the largest integer in the array that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Calculate the mean of the array.\n    2. Iterate through possible pairs of elements in the array.\n    3. Check if deleting the pair maintains the same mean in the remaining elements.\n    4. Optimize the solution for performance to handle large inputs efficiently.\n\n# [edge case] \n    search([1, 2, 3, 4]) = -1\n    Explanation: The mean of the array is 2.5, and there are no pairs of elements that can be deleted to maintain this mean.\n    search([4, 4, 4, 4]) = 4\n    Explanation: The mean of the array is 4, and deleting any pair of elements will still result in a mean of 4. The largest integer that meets the condition is 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no pairs can maintain the mean by returning -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has only one possible pair that maintains the mean. For example, if the array is [1, 1, 2, 2] and the mean is 1.5, we need to check if deleting any specific pair maintains the mean.\n"], "scores": [], "pass_results": [false, true, true, true, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 472, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 386}
