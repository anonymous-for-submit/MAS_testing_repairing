{"name": "1619_B. Squares and Cubes", "description": "Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....\n\nFor a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases.\n\nThen t lines contain the test cases, one per line. Each of the lines contains one integer n (1 \u2264 n \u2264 10^9).\n\nOutput\n\nFor each test case, print the answer you are looking for \u2014 the number of integers from 1 to n that Polycarp likes.\n\nExample\n\nInput\n\n\n6\n10\n1\n25\n1000000000\n999999999\n500000000\n\n\nOutput\n\n\n4\n1\n6\n32591\n32590\n23125", "tags": ["implementation", "math"], "difficulty": 8, "id": 1619, "sample_io": [{"input": "6\n10\n1\n25\n1000000000\n999999999\n500000000\n", "output": ["4\n1\n6\n32591\n32590\n23125\n"]}], "test_list": [{"input": "2\n64\n15625\n", "output": ["10\n145\n"]}, {"input": "8\n64000000\n85766121\n113379904\n148035889\n191102976\n244140625\n594823321\n887503681\n", "output": ["8380\n9681\n11110\n12673\n14376\n16225\n25201\n30721\n"]}, {"input": "2\n15625\n46656\n", "output": ["145\n246\n"]}, {"input": "2\n1000000\n4096\n", "output": ["1090\n76\n"]}, {"input": "1\n4095\n", "output": ["75\n"]}, {"input": "1\n4096\n", "output": ["76\n"]}, {"input": "20\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n", "output": ["2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n"]}, {"input": "5\n64000000\n85766121\n113379904\n148035889\n8000\n", "output": ["8380\n9681\n11110\n12673\n105\n"]}, {"input": "12\n64\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n7529536\n", "output": ["10\n76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n2926\n"]}, {"input": "20\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n6012\n975\n3916\n4805\n7952\n3301\n647\n3799\n8657\n122\n", "output": ["1\n1\n1\n2\n2\n2\n2\n3\n4\n4\n91\n37\n74\n81\n104\n68\n31\n73\n109\n13\n"]}, {"input": "1\n216\n", "output": ["18\n"]}, {"input": "5\n62\n63\n64\n4096\n66\n", "output": ["9\n9\n10\n76\n10\n"]}, {"input": "1\n125\n", "output": ["14\n"]}, {"input": "1\n4090\n", "output": ["75\n"]}, {"input": "1\n1000000\n", "output": ["1090\n"]}, {"input": "18\n2515456\n2571353\n2628072\n2685619\n2744000\n2803221\n2924207\n3048625\n3112136\n3176523\n3307949\n3442951\n3511808\n3581577\n3652264\n3796416\n3869893\n3944312\n", "output": ["1711\n1729\n1748\n1766\n1785\n1804\n1842\n1879\n1898\n1917\n1955\n1994\n2013\n2033\n2053\n2092\n2112\n2132\n"]}, {"input": "2\n5000\n8000\n", "output": ["83\n105\n"]}, {"input": "5\n2985983\n4826807\n4826808\n7529533\n7529534\n", "output": ["1859\n2352\n2352\n2925\n2925\n"]}, {"input": "1\n59319\n", "output": ["276\n"]}, {"input": "1\n26\n", "output": ["6\n"]}, {"input": "3\n1000\n8000\n1000000\n", "output": ["38\n105\n1090\n"]}, {"input": "4\n4096\n15625\n117649\n262144\n", "output": ["76\n145\n385\n568\n"]}, {"input": "10\n728999999\n729000001\n594823320\n594823322\n481890303\n308915775\n387420488\n191102975\n148035888\n113379903\n", "output": ["27869\n27870\n25200\n25201\n22707\n18225\n20384\n14375\n12672\n11109\n"]}, {"input": "4\n64\n729\n728\n4096\n", "output": ["10\n33\n32\n76\n"]}, {"input": "10\n3307949\n3375000\n3442951\n3511808\n3581577\n3652264\n3723875\n3796416\n3869893\n3944312\n", "output": ["1955\n1975\n1994\n2013\n2033\n2053\n2072\n2092\n2112\n2132\n"]}, {"input": "1\n16777216\n", "output": ["4336\n"]}, {"input": "7\n728\n1000\n10000\n100000\n1000000\n10000000\n100000000\n", "output": ["32\n38\n117\n356\n1090\n3363\n10443\n"]}, {"input": "15\n7762392\n7880599\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8998912\n9129329\n9261000\n9393931\n9663597\n9938375\n", "output": ["2970\n2992\n3014\n3036\n3058\n3081\n3103\n3126\n3148\n3193\n3216\n3239\n3261\n3307\n3353\n"]}, {"input": "6\n887503681\n887503680\n887503682\n999887640\n999887641\n999887642\n", "output": ["30721\n30720\n30721\n32588\n32589\n32589\n"]}, {"input": "1\n991026973\n", "output": ["32446\n"]}, {"input": "1\n481890304\n", "output": ["22708\n"]}, {"input": "1\n8000\n", "output": ["105\n"]}, {"input": "20\n887503680\n887503679\n887503678\n887503677\n887503676\n887503675\n887503674\n887503673\n887503672\n887503671\n887503670\n887503669\n887503668\n887503667\n887503666\n887503665\n887503664\n887503663\n887503662\n887503661\n", "output": ["30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n30720\n"]}, {"input": "1\n997002999\n", "output": ["32543\n"]}, {"input": "2\n1000\n999\n", "output": ["38\n37\n"]}, {"input": "10\n1\n64\n729\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n", "output": ["1\n10\n33\n76\n145\n246\n385\n568\n801\n1090\n"]}, {"input": "10\n64000000\n32324\n4645758\n148035889\n382748428\n33627363\n36273373\n75675757\n9897\n34536\n", "output": ["8380\n205\n2309\n12673\n20263\n6103\n6335\n9101\n116\n212\n"]}, {"input": "1\n46142\n", "output": ["244\n"]}, {"input": "20\n117649\n262144\n531441\n1000000\n1771561\n7529536\n11390625\n24137569\n34012224\n85766121\n113379904\n148035889\n191102976\n244140625\n308915776\n387420489\n481890304\n594823321\n729000000\n887503681\n", "output": ["385\n568\n801\n1090\n1441\n2926\n3585\n5185\n6138\n9681\n11110\n12673\n14376\n16225\n18226\n20385\n22708\n25201\n27870\n30721\n"]}, {"input": "9\n8489664\n8615125\n8741816\n8998912\n9129329\n9261000\n9393931\n9663597\n9938375\n", "output": ["3103\n3126\n3148\n3193\n3216\n3239\n3261\n3307\n3353\n"]}, {"input": "1\n49\n", "output": ["9\n"]}, {"input": "2\n49\n676\n", "output": ["9\n32\n"]}, {"input": "4\n117649\n262144\n1000000\n1771561\n", "output": ["385\n568\n1090\n1441\n"]}, {"input": "3\n64\n15625\n1000000\n", "output": ["10\n145\n1090\n"]}, {"input": "3\n15625\n97336\n195112\n", "output": ["145\n351\n492\n"]}, {"input": "5\n4657463\n4741632\n4913000\n5000211\n5088448\n", "output": ["2313\n2333\n2373\n2394\n2414\n"]}, {"input": "20\n125\n216\n343\n512\n1000\n1331\n1728\n2197\n2744\n3375\n4913\n5832\n6859\n8000\n9261\n10648\n12167\n13824\n17576\n19683\n", "output": ["14\n18\n23\n28\n38\n44\n50\n56\n63\n70\n83\n90\n97\n105\n113\n121\n129\n137\n153\n162\n"]}, {"input": "1\n262144\n", "output": ["568\n"]}, {"input": "1\n134217728\n", "output": ["12075\n"]}, {"input": "17\n7301384\n7414875\n7762392\n7880599\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8998912\n9129329\n9261000\n9393931\n9663597\n9938375\n", "output": ["2883\n2905\n2970\n2992\n3014\n3036\n3058\n3081\n3103\n3126\n3148\n3193\n3216\n3239\n3261\n3307\n3353\n"]}, {"input": "6\n4096\n15625\n46656\n117649\n262144\n531441\n", "output": ["76\n145\n246\n385\n568\n801\n"]}, {"input": "1\n46655\n", "output": ["245\n"]}, {"input": "1\n34012224\n", "output": ["6138\n"]}, {"input": "7\n244140625\n308915776\n387420489\n481890304\n594823321\n729000000\n887503681\n", "output": ["16225\n18226\n20385\n22708\n25201\n27870\n30721\n"]}, {"input": "9\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n"]}, {"input": "1\n308915776\n", "output": ["18226\n"]}, {"input": "5\n720\n721\n722\n723\n724\n", "output": ["32\n32\n32\n32\n32\n"]}, {"input": "2\n4096\n720\n", "output": ["76\n32\n"]}, {"input": "1\n42144192\n", "output": ["6821\n"]}, {"input": "20\n1000000000\n999999999\n999999998\n999999997\n999999996\n999999995\n999999994\n999999993\n999999992\n999999991\n999999990\n999999989\n999999988\n999999987\n999999986\n999999985\n999999984\n999999983\n999999982\n999999981\n", "output": ["32591\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n"]}, {"input": "8\n728\n1000\n4095\n10000\n100000\n1000000\n10000000\n100000000\n", "output": ["32\n38\n75\n117\n356\n1090\n3363\n10443\n"]}, {"input": "9\n728\n1000000\n35\n144\n4095\n10000\n100000\n10000000\n100000000\n", "output": ["32\n1090\n7\n15\n75\n117\n356\n3363\n10443\n"]}, {"input": "3\n24389\n31329\n21025\n", "output": ["180\n203\n167\n"]}, {"input": "2\n8000\n1000000\n", "output": ["105\n1090\n"]}, {"input": "5\n1\n64\n729\n4096\n15625\n", "output": ["1\n10\n33\n76\n145\n"]}, {"input": "1\n7529536\n", "output": ["2926\n"]}, {"input": "1\n387420489\n", "output": ["20385\n"]}, {"input": "8\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n7529536\n", "output": ["385\n568\n801\n1090\n1441\n1860\n2353\n2926\n"]}, {"input": "1\n117649\n", "output": ["385\n"]}, {"input": "12\n64\n125\n216\n343\n512\n729\n1000\n1331\n1728\n2197\n2744\n3375\n", "output": ["10\n14\n18\n23\n28\n33\n38\n44\n50\n56\n63\n70\n"]}, {"input": "1\n4913\n", "output": ["83\n"]}, {"input": "20\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n", "output": ["32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n"]}, {"input": "2\n1000000\n9025699\n", "output": ["1090\n3198\n"]}, {"input": "1\n64\n", "output": ["10\n"]}, {"input": "2\n4096\n15625\n", "output": ["76\n145\n"]}, {"input": "11\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n7529536\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n2926\n"]}, {"input": "1\n728\n", "output": ["32\n"]}, {"input": "20\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n", "output": ["32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n"]}, {"input": "20\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n7529536\n11390625\n16777216\n24137569\n34012224\n47045881\n64000000\n85766121\n113379904\n148035889\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n2926\n3585\n4336\n5185\n6138\n7201\n8380\n9681\n11110\n12673\n"]}, {"input": "3\n887503681\n887503680\n887503682\n", "output": ["30721\n30720\n30721\n"]}, {"input": "5\n125\n216\n343\n512\n729\n", "output": ["14\n18\n23\n28\n33\n"]}, {"input": "20\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n", "output": ["32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n"]}, {"input": "2\n8000\n5000\n", "output": ["105\n83\n"]}, {"input": "1\n1771561\n", "output": ["1441\n"]}, {"input": "13\n64\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n1000000000\n7529536\n", "output": ["10\n76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n32591\n2926\n"]}, {"input": "7\n887503681\n887503680\n887503682\n999887640\n999887641\n55240747\n3566977\n", "output": ["30721\n30720\n30721\n32588\n32589\n7793\n2028\n"]}, {"input": "7\n728999999\n729000001\n594823320\n594823322\n481890303\n308915775\n387420488\n", "output": ["27869\n27870\n25200\n25201\n22707\n18225\n20384\n"]}, {"input": "1\n1000\n", "output": ["38\n"]}, {"input": "7\n4096\n64\n1000000000\n15625\n46656\n262144\n2985984\n", "output": ["76\n10\n32591\n145\n246\n568\n1860\n"]}, {"input": "3\n4096\n64\n1000000000\n", "output": ["76\n10\n32591\n"]}, {"input": "6\n64\n729\n4096\n15625\n46656\n117649\n", "output": ["10\n33\n76\n145\n246\n385\n"]}, {"input": "2\n1000\n1000000\n", "output": ["38\n1090\n"]}, {"input": "1\n15625\n", "output": ["145\n"]}, {"input": "1\n11390625\n", "output": ["3585\n"]}, {"input": "1\n728999999\n", "output": ["27869\n"]}, {"input": "16\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8869743\n8998912\n9129329\n9261000\n9393931\n9528128\n9663597\n9800344\n9938375\n", "output": ["3014\n3036\n3058\n3081\n3103\n3126\n3148\n3171\n3193\n3216\n3239\n3261\n3284\n3307\n3330\n3353\n"]}, {"input": "5\n117649\n262144\n531441\n1000000\n1771561\n", "output": ["385\n568\n801\n1090\n1441\n"]}, {"input": "3\n8000\n1000\n100000000\n", "output": ["105\n38\n10443\n"]}, {"input": "13\n4096\n64\n1000000000\n15625\n46656\n262144\n2985984\n4826807\n7529533\n7529534\n7529535\n720\n4095\n", "output": ["76\n10\n32591\n145\n246\n568\n1860\n2352\n2925\n2925\n2925\n32\n75\n"]}, {"input": "5\n8000\n64000000\n85766121\n113379904\n148035889\n", "output": ["105\n8380\n9681\n11110\n12673\n"]}, {"input": "2\n4096\n64\n", "output": ["76\n10\n"]}, {"input": "1\n24137569\n", "output": ["5185\n"]}, {"input": "5\n15625\n97336\n195112\n205379\n274625\n", "output": ["145\n351\n492\n505\n581\n"]}, {"input": "1\n238144\n", "output": ["542\n"]}, {"input": "1\n531441\n", "output": ["801\n"]}, {"input": "5\n62\n63\n64\n65\n66\n", "output": ["9\n9\n10\n10\n10\n"]}, {"input": "1\n729\n", "output": ["33\n"]}, {"input": "3\n5000\n8000\n1000000\n", "output": ["83\n105\n1090\n"]}, {"input": "3\n64\n729\n728\n", "output": ["10\n33\n32\n"]}, {"input": "1\n46656\n", "output": ["246\n"]}, {"input": "1\n887483586\n", "output": ["30720\n"]}, {"input": "4\n481890304\n594823321\n729000000\n887503681\n", "output": ["22708\n25201\n27870\n30721\n"]}, {"input": "5\n9261000\n9393931\n9663597\n9800344\n9938375\n", "output": ["3239\n3261\n3307\n3330\n3353\n"]}, {"input": "1\n65\n", "output": ["10\n"]}, {"input": "4\n64000000\n85766121\n113379904\n148035889\n", "output": ["8380\n9681\n11110\n12673\n"]}, {"input": "5\n125\n216\n2197\n2744\n3375\n", "output": ["14\n18\n56\n63\n70\n"]}, {"input": "1\n720\n", "output": ["32\n"]}, {"input": "1\n64000000\n", "output": ["8380\n"]}, {"input": "5\n49\n50\n675\n676\n677\n", "output": ["9\n9\n31\n32\n32\n"]}, {"input": "1\n97336\n", "output": ["351\n"]}, {"input": "6\n64\n729\n4096\n117649\n262144\n531441\n", "output": ["10\n33\n76\n385\n568\n801\n"]}, {"input": "11\n4096\n64\n1000000000\n15625\n46656\n262144\n2985984\n4826807\n7529533\n7529534\n7529535\n", "output": ["76\n10\n32591\n145\n246\n568\n1860\n2352\n2925\n2925\n2925\n"]}, {"input": "3\n8000\n1000\n1000000\n", "output": ["105\n38\n1090\n"]}, {"input": "10\n5050\n30404\n12345\n98765432\n1234564\n64\n456\n1\n23\n123\n", "output": ["84\n200\n130\n10379\n1208\n10\n26\n1\n5\n13\n"]}, {"input": "1\n887503681\n", "output": ["30721\n"]}, {"input": "2\n15625\n4096\n", "output": ["145\n76\n"]}, {"input": "1\n5000\n", "output": ["83\n"]}, {"input": "20\n50653\n54872\n59319\n64000\n68921\n74088\n79507\n85184\n91125\n97336\n103823\n110592\n125000\n132651\n140608\n148877\n157464\n166375\n175616\n185193\n", "output": ["256\n266\n276\n286\n297\n308\n318\n329\n340\n351\n363\n374\n396\n408\n419\n431\n443\n455\n468\n480\n"]}, {"input": "7\n64000000\n85766121\n113379904\n148035889\n191102976\n244140625\n594823321\n", "output": ["8380\n9681\n11110\n12673\n14376\n16225\n25201\n"]}, {"input": "2\n42144192\n887503681\n", "output": ["6821\n30721\n"]}, {"input": "7\n100\n1000\n10000\n100000\n1000000\n10000000\n100000000\n", "output": ["12\n38\n117\n356\n1090\n3363\n10443\n"]}, {"input": "1\n1729\n", "output": ["50\n"]}, {"input": "5\n10000\n100000\n1000000\n10000000\n100000000\n", "output": ["117\n356\n1090\n3363\n10443\n"]}, {"input": "18\n54872\n59319\n64000\n68921\n74088\n79507\n85184\n91125\n97336\n103823\n110592\n125000\n132651\n140608\n148877\n157464\n166375\n175616\n", "output": ["266\n276\n286\n297\n308\n318\n329\n340\n351\n363\n374\n396\n408\n419\n431\n443\n455\n468\n"]}, {"input": "1\n887503149\n", "output": ["30720\n"]}, {"input": "1\n729000000\n", "output": ["27870\n"]}, {"input": "1\n512\n", "output": ["28\n"]}, {"input": "2\n30\n15625\n", "output": ["7\n145\n"]}, {"input": "8\n64000000\n6779273\n113379904\n148035889\n191102976\n244140625\n594823321\n887503681\n", "output": ["8380\n2779\n11110\n12673\n14376\n16225\n25201\n30721\n"]}, {"input": "2\n15625\n9522\n", "output": ["145\n114\n"]}, {"input": "2\n1000000\n2995\n", "output": ["1090\n65\n"]}, {"input": "1\n1406\n", "output": ["45\n"]}, {"input": "1\n4375\n", "output": ["78\n"]}, {"input": "20\n7\n9\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n7\n", "output": ["2\n4\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n"]}, {"input": "5\n64000000\n85766121\n113379904\n148035889\n3627\n", "output": ["8380\n9681\n11110\n12673\n72\n"]}, {"input": "12\n64\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n2207430\n", "output": ["10\n76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n1604\n"]}, {"input": "1\n127\n", "output": ["14\n"]}, {"input": "5\n62\n63\n68\n4096\n66\n", "output": ["9\n9\n10\n76\n10\n"]}, {"input": "1\n60\n", "output": ["9\n"]}, {"input": "1\n3444\n", "output": ["70\n"]}, {"input": "1\n1000001\n", "output": ["1090\n"]}, {"input": "18\n2515456\n2571353\n2628072\n2685619\n2744000\n2803221\n2924207\n3048625\n3112136\n3176523\n3307949\n3442951\n3511808\n3581577\n2798293\n3796416\n3869893\n3944312\n", "output": ["1711\n1729\n1748\n1766\n1785\n1804\n1842\n1879\n1898\n1917\n1955\n1994\n2013\n2033\n1801\n2092\n2112\n2132\n"]}, {"input": "2\n5000\n3092\n", "output": ["83\n66\n"]}, {"input": "5\n2985983\n4826807\n7267230\n7529533\n7529534\n", "output": ["1859\n2352\n2875\n2925\n2925\n"]}, {"input": "1\n58027\n", "output": ["272\n"]}, {"input": "1\n8\n", "output": ["3\n"]}, {"input": "3\n1000\n1087\n1000000\n", "output": ["38\n39\n1090\n"]}, {"input": "4\n4096\n15625\n117649\n262424\n", "output": ["76\n145\n385\n568\n"]}, {"input": "10\n728999999\n925717858\n594823320\n594823322\n481890303\n308915775\n387420488\n191102975\n148035888\n113379903\n", "output": ["27869\n31368\n25200\n25201\n22707\n18225\n20384\n14375\n12672\n11109\n"]}, {"input": "4\n64\n729\n728\n2136\n", "output": ["10\n33\n32\n55\n"]}, {"input": "10\n3307949\n3375000\n1340212\n3511808\n3581577\n3652264\n3723875\n3796416\n3869893\n3944312\n", "output": ["1955\n1975\n1257\n2013\n2033\n2053\n2072\n2092\n2112\n2132\n"]}, {"input": "1\n9480257\n", "output": ["3276\n"]}, {"input": "7\n728\n1000\n10000\n100000\n1000000\n10000000\n101000000\n", "output": ["32\n38\n117\n356\n1090\n3363\n10493\n"]}, {"input": "15\n7762392\n7880599\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8998912\n884275\n9261000\n9393931\n9663597\n9938375\n", "output": ["2970\n2992\n3014\n3036\n3058\n3081\n3103\n3126\n3148\n3193\n1026\n3239\n3261\n3307\n3353\n"]}, {"input": "6\n887503681\n887503680\n887503682\n839681625\n999887641\n999887642\n", "output": ["30721\n30720\n30721\n29890\n32589\n32589\n"]}, {"input": "1\n121581031\n", "output": ["11499\n"]}, {"input": "1\n7376\n", "output": ["100\n"]}, {"input": "2\n1000\n1117\n", "output": ["38\n40\n"]}, {"input": "10\n1\n64\n729\n4096\n15625\n87389\n117649\n262144\n531441\n1000000\n", "output": ["1\n10\n33\n76\n145\n333\n385\n568\n801\n1090\n"]}, {"input": "10\n64000000\n32324\n1744179\n148035889\n382748428\n33627363\n36273373\n75675757\n9897\n34536\n", "output": ["8380\n205\n1430\n12673\n20263\n6103\n6335\n9101\n116\n212\n"]}, {"input": "1\n57182\n", "output": ["271\n"]}, {"input": "20\n117649\n262144\n531441\n1000000\n1771561\n7529536\n11390625\n24137569\n34012224\n113920889\n113379904\n148035889\n191102976\n244140625\n308915776\n387420489\n481890304\n594823321\n729000000\n887503681\n", "output": ["385\n568\n801\n1090\n1441\n2926\n3585\n5185\n6138\n11135\n11110\n12673\n14376\n16225\n18226\n20385\n22708\n25201\n27870\n30721\n"]}, {"input": "9\n8489664\n8615125\n8741816\n8998912\n9129329\n9261000\n9393931\n1153754\n9938375\n", "output": ["3103\n3126\n3148\n3193\n3216\n3239\n3261\n1168\n3353\n"]}, {"input": "1\n91\n", "output": ["11\n"]}, {"input": "2\n20\n676\n", "output": ["5\n32\n"]}, {"input": "4\n117649\n262144\n1000000\n1036687\n", "output": ["385\n568\n1090\n1109\n"]}, {"input": "3\n15625\n188666\n195112\n", "output": ["145\n484\n492\n"]}, {"input": "5\n4657463\n4741632\n4913000\n5000211\n2484840\n", "output": ["2313\n2333\n2373\n2394\n1700\n"]}, {"input": "20\n125\n216\n343\n512\n1000\n1331\n1728\n2197\n2744\n3375\n4913\n5832\n6859\n8000\n17776\n10648\n12167\n13824\n17576\n19683\n", "output": ["14\n18\n23\n28\n38\n44\n50\n56\n63\n70\n83\n90\n97\n105\n154\n121\n129\n137\n153\n162\n"]}, {"input": "1\n73410\n", "output": ["305\n"]}, {"input": "1\n26785760\n", "output": ["5457\n"]}, {"input": "17\n7301384\n7414875\n7762392\n7880599\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8998912\n9129329\n9261000\n9393931\n8451825\n9938375\n", "output": ["2883\n2905\n2970\n2992\n3014\n3036\n3058\n3081\n3103\n3126\n3148\n3193\n3216\n3239\n3261\n3096\n3353\n"]}, {"input": "6\n8069\n15625\n46656\n117649\n262144\n531441\n", "output": ["105\n145\n246\n385\n568\n801\n"]}, {"input": "1\n70109\n", "output": ["299\n"]}, {"input": "1\n44712374\n", "output": ["7022\n"]}, {"input": "7\n244140625\n308915776\n387420489\n481890304\n359052248\n729000000\n887503681\n", "output": ["16225\n18226\n20385\n22708\n19632\n27870\n30721\n"]}, {"input": "9\n4096\n15625\n46656\n117649\n122890\n531441\n1000000\n1771561\n2985984\n", "output": ["76\n145\n246\n385\n392\n801\n1090\n1441\n1860\n"]}, {"input": "1\n255817929\n", "output": ["16603\n"]}, {"input": "5\n720\n448\n722\n723\n724\n", "output": ["32\n26\n32\n32\n32\n"]}, {"input": "2\n7010\n720\n", "output": ["98\n32\n"]}, {"input": "1\n16911191\n", "output": ["4352\n"]}, {"input": "8\n728\n1000\n4095\n10000\n100000\n1000000\n10000000\n100010000\n", "output": ["32\n38\n75\n117\n356\n1090\n3363\n10443\n"]}, {"input": "9\n728\n1000000\n35\n144\n4095\n10000\n100000\n10001000\n100000000\n", "output": ["32\n1090\n7\n15\n75\n117\n356\n3363\n10443\n"]}, {"input": "3\n48700\n31329\n21025\n", "output": ["250\n203\n167\n"]}, {"input": "2\n8000\n1000001\n", "output": ["105\n1090\n"]}, {"input": "5\n1\n72\n729\n4096\n15625\n", "output": ["1\n10\n33\n76\n145\n"]}, {"input": "1\n10898647\n", "output": ["3508\n"]}, {"input": "1\n122600118\n", "output": ["11546\n"]}, {"input": "8\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n1305260\n", "output": ["385\n568\n801\n1090\n1441\n1860\n2353\n1241\n"]}, {"input": "1\n52628\n", "output": ["260\n"]}, {"input": "12\n64\n125\n357\n343\n512\n729\n1000\n1331\n1728\n2197\n2744\n3375\n", "output": ["10\n14\n23\n23\n28\n33\n38\n44\n50\n56\n63\n70\n"]}, {"input": "1\n4002\n", "output": ["75\n"]}, {"input": "20\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n589412590\n999950883\n", "output": ["32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n25087\n32589\n"]}, {"input": "2\n1000000\n15696692\n", "output": ["1090\n4196\n"]}, {"input": "1\n40\n", "output": ["8\n"]}, {"input": "2\n4096\n23197\n", "output": ["76\n175\n"]}, {"input": "11\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n741529\n4826809\n7529536\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n942\n2353\n2926\n"]}, {"input": "1\n751\n", "output": ["33\n"]}, {"input": "20\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000100\n1000000000\n", "output": ["32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n32591\n"]}, {"input": "20\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n7529536\n11390625\n29118316\n24137569\n34012224\n47045881\n64000000\n85766121\n113379904\n148035889\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n2926\n3585\n5686\n5185\n6138\n7201\n8380\n9681\n11110\n12673\n"]}, {"input": "3\n887503681\n887503680\n45561153\n", "output": ["30721\n30720\n7088\n"]}, {"input": "5\n83\n216\n343\n512\n729\n", "output": ["11\n18\n23\n28\n33\n"]}, {"input": "20\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n478794427\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n", "output": ["32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n22636\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n"]}, {"input": "2\n13837\n5000\n", "output": ["137\n83\n"]}, {"input": "1\n64945\n", "output": ["288\n"]}, {"input": "13\n64\n4096\n15625\n46656\n117649\n262144\n531441\n1010000\n1771561\n2985984\n4826809\n1000000000\n7529536\n", "output": ["10\n76\n145\n246\n385\n568\n801\n1094\n1441\n1860\n2353\n32591\n2926\n"]}, {"input": "7\n887503681\n887503680\n887503682\n999887640\n999887641\n100452051\n3566977\n", "output": ["30721\n30720\n30721\n32588\n32589\n10465\n2028\n"]}, {"input": "7\n728999999\n729000001\n594823320\n679278099\n481890303\n308915775\n387420488\n", "output": ["27869\n27870\n25200\n26912\n22707\n18225\n20384\n"]}, {"input": "7\n4096\n83\n1000000000\n15625\n46656\n262144\n2985984\n", "output": ["76\n11\n32591\n145\n246\n568\n1860\n"]}, {"input": "3\n335\n64\n1000000000\n", "output": ["22\n10\n32591\n"]}, {"input": "6\n106\n729\n4096\n15625\n46656\n117649\n", "output": ["12\n33\n76\n145\n246\n385\n"]}, {"input": "1\n8176\n", "output": ["106\n"]}, {"input": "1\n9986164\n", "output": ["3361\n"]}, {"input": "16\n8000000\n8120601\n8242408\n8365427\n8348189\n8615125\n8741816\n8869743\n8998912\n9129329\n9261000\n9393931\n9528128\n9663597\n9800344\n9938375\n", "output": ["3014\n3036\n3058\n3081\n3077\n3126\n3148\n3171\n3193\n3216\n3239\n3261\n3284\n3307\n3330\n3353\n"]}, {"input": "5\n117649\n262144\n115285\n1000000\n1771561\n", "output": ["385\n568\n381\n1090\n1441\n"]}, {"input": "3\n8000\n1000\n100000100\n", "output": ["105\n38\n10443\n"]}, {"input": "13\n4096\n64\n1000000000\n15625\n46656\n262144\n2985984\n4826807\n1149531\n7529534\n7529535\n720\n4095\n", "output": ["76\n10\n32591\n145\n246\n568\n1860\n2352\n1166\n2925\n2925\n32\n75\n"]}, {"input": "5\n8000\n64000000\n85766121\n113379904\n200531019\n", "output": ["105\n8380\n9681\n11110\n14721\n"]}, {"input": "2\n3696\n64\n", "output": ["72\n10\n"]}, {"input": "1\n7212693\n", "output": ["2865\n"]}, {"input": "5\n15625\n97336\n7310\n205379\n274625\n", "output": ["145\n351\n100\n505\n581\n"]}, {"input": "1\n45605\n", "output": ["243\n"]}, {"input": "1\n160796\n", "output": ["447\n"]}, {"input": "5\n62\n63\n64\n65\n84\n", "output": ["9\n9\n10\n10\n11\n"]}, {"input": "1\n211\n", "output": ["17\n"]}, {"input": "3\n5000\n15814\n1000000\n", "output": ["83\n145\n1090\n"]}, {"input": "3\n25\n729\n728\n", "output": ["6\n33\n32\n"]}, {"input": "1\n34005\n", "output": ["211\n"]}, {"input": "5\n9261000\n9393931\n6041900\n9800344\n9938375\n", "output": ["3239\n3261\n2627\n3330\n3353\n"]}, {"input": "1\n17\n", "output": ["5\n"]}, {"input": "4\n64000000\n85766121\n113379904\n269756718\n", "output": ["8380\n9681\n11110\n17045\n"]}, {"input": "5\n125\n216\n2197\n2744\n3430\n", "output": ["14\n18\n56\n63\n70\n"]}, {"input": "1\n102462643\n", "output": ["10568\n"]}, {"input": "5\n11\n50\n675\n676\n677\n", "output": ["4\n9\n31\n32\n32\n"]}, {"input": "1\n172146\n", "output": ["462\n"]}, {"input": "6\n64\n729\n4096\n117649\n132535\n531441\n", "output": ["10\n33\n76\n385\n407\n801\n"]}, {"input": "11\n4096\n64\n1000000000\n15625\n51900\n262144\n2985984\n4826807\n7529533\n7529534\n7529535\n", "output": ["76\n10\n32591\n145\n258\n568\n1860\n2352\n2925\n2925\n2925\n"]}, {"input": "3\n6897\n1000\n1000000\n", "output": ["98\n38\n1090\n"]}, {"input": "10\n5050\n30404\n12345\n98765432\n1234564\n64\n236\n1\n23\n123\n", "output": ["84\n200\n130\n10379\n1208\n10\n19\n1\n5\n13\n"]}, {"input": "1\n934500044\n", "output": ["31515\n"]}, {"input": "2\n16537\n4096\n", "output": ["148\n76\n"]}, {"input": "1\n2885\n", "output": ["64\n"]}, {"input": "20\n50653\n54872\n59319\n64000\n68921\n74088\n151003\n85184\n91125\n97336\n103823\n110592\n125000\n132651\n140608\n148877\n157464\n166375\n175616\n185193\n", "output": ["256\n266\n276\n286\n297\n308\n434\n329\n340\n351\n363\n374\n396\n408\n419\n431\n443\n455\n468\n480\n"]}, {"input": "7\n64000000\n85766121\n113379904\n35336991\n191102976\n244140625\n594823321\n", "output": ["8380\n9681\n11110\n6254\n14376\n16225\n25201\n"]}, {"input": "2\n34203623\n887503681\n", "output": ["6154\n30721\n"]}, {"input": "7\n100\n1001\n10000\n100000\n1000000\n10000000\n100000000\n", "output": ["12\n38\n117\n356\n1090\n3363\n10443\n"]}, {"input": "1\n1708\n", "output": ["49\n"]}, {"input": "5\n10000\n100000\n1000000\n10000100\n100000000\n", "output": ["117\n356\n1090\n3363\n10443\n"]}, {"input": "18\n54872\n59319\n64000\n68921\n74088\n79507\n85184\n91125\n97336\n103823\n110592\n125000\n132651\n262005\n148877\n157464\n166375\n175616\n", "output": ["266\n276\n286\n297\n308\n318\n329\n340\n351\n363\n374\n396\n408\n567\n431\n443\n455\n468\n"]}, {"input": "1\n286650660\n", "output": ["17564\n"]}, {"input": "1\n61625719\n", "output": ["8225\n"]}, {"input": "1\n830\n", "output": ["34\n"]}, {"input": "6\n10\n1\n19\n1000000000\n999999999\n500000000\n", "output": ["4\n1\n5\n32591\n32590\n23125\n"]}, {"input": "2\n30\n21470\n", "output": ["7\n168\n"]}, {"input": "8\n19411695\n6779273\n113379904\n148035889\n191102976\n244140625\n594823321\n887503681\n", "output": ["4657\n2779\n11110\n12673\n14376\n16225\n25201\n30721\n"]}, {"input": "2\n9974\n9522\n", "output": ["116\n114\n"]}, {"input": "1\n2269\n", "output": ["57\n"]}, {"input": "1\n1658\n", "output": ["48\n"]}, {"input": "20\n7\n9\n7\n7\n7\n7\n7\n7\n7\n7\n11\n7\n7\n7\n7\n7\n7\n7\n7\n7\n", "output": ["2\n4\n2\n2\n2\n2\n2\n2\n2\n2\n4\n2\n2\n2\n2\n2\n2\n2\n2\n2\n"]}, {"input": "5\n64000000\n85766121\n10649182\n148035889\n3627\n", "output": ["8380\n9681\n3469\n12673\n72\n"]}, {"input": "12\n64\n4096\n15625\n7797\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n2207430\n", "output": ["10\n76\n145\n103\n385\n568\n801\n1090\n1441\n1860\n2353\n1604\n"]}, {"input": "5\n62\n63\n131\n4096\n66\n", "output": ["9\n9\n14\n76\n10\n"]}, {"input": "1\n11\n", "output": ["4\n"]}, {"input": "1\n2005\n", "output": ["53\n"]}, {"input": "1\n0000001\n", "output": ["1\n"]}, {"input": "18\n2515456\n2571353\n2628072\n2685619\n5149368\n2803221\n2924207\n3048625\n3112136\n3176523\n3307949\n3442951\n3511808\n3581577\n2798293\n3796416\n3869893\n3944312\n", "output": ["1711\n1729\n1748\n1766\n2428\n1804\n1842\n1879\n1898\n1917\n1955\n1994\n2013\n2033\n1801\n2092\n2112\n2132\n"]}, {"input": "2\n3536\n3092\n", "output": ["71\n66\n"]}, {"input": "5\n2985983\n4826807\n7267230\n7529533\n9986545\n", "output": ["1859\n2352\n2875\n2925\n3361\n"]}, {"input": "1\n44671\n", "output": ["241\n"]}, {"input": "3\n1000\n2149\n1000000\n", "output": ["38\n55\n1090\n"]}, {"input": "4\n1664\n15625\n117649\n262424\n", "output": ["48\n145\n385\n568\n"]}, {"input": "4\n17\n729\n728\n2136\n", "output": ["5\n33\n32\n55\n"]}, {"input": "10\n3307949\n3375000\n2474200\n3511808\n3581577\n3652264\n3723875\n3796416\n3869893\n3944312\n", "output": ["1955\n1975\n1696\n2013\n2033\n2053\n2072\n2092\n2112\n2132\n"]}, {"input": "1\n15373823\n", "output": ["4153\n"]}, {"input": "15\n7762392\n211382\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8998912\n884275\n9261000\n9393931\n9663597\n9938375\n", "output": ["2970\n511\n3014\n3036\n3058\n3081\n3103\n3126\n3148\n3193\n1026\n3239\n3261\n3307\n3353\n"]}, {"input": "1\n188117206\n", "output": ["14264\n"]}, {"input": "1\n14290\n", "output": ["139\n"]}, {"input": "2\n1000\n1698\n", "output": ["38\n49\n"]}, {"input": "10\n1\n64\n923\n4096\n15625\n87389\n117649\n262144\n531441\n1000000\n", "output": ["1\n10\n36\n76\n145\n333\n385\n568\n801\n1090\n"]}, {"input": "10\n64000000\n58808\n1744179\n148035889\n382748428\n33627363\n36273373\n75675757\n9897\n34536\n", "output": ["8380\n274\n1430\n12673\n20263\n6103\n6335\n9101\n116\n212\n"]}, {"input": "1\n37976\n", "output": ["222\n"]}, {"input": "20\n117649\n262144\n531441\n1000000\n1771561\n7529536\n11390625\n24137569\n34012224\n113920889\n113379904\n10402692\n191102976\n244140625\n308915776\n387420489\n481890304\n594823321\n729000000\n887503681\n", "output": ["385\n568\n801\n1090\n1441\n2926\n3585\n5185\n6138\n11135\n11110\n3429\n14376\n16225\n18226\n20385\n22708\n25201\n27870\n30721\n"]}, {"input": "9\n8489664\n8615125\n8741816\n8998912\n9129329\n5288652\n9393931\n1153754\n9938375\n", "output": ["3103\n3126\n3148\n3193\n3216\n2460\n3261\n1168\n3353\n"]}, {"input": "1\n148\n", "output": ["15\n"]}, {"input": "2\n3\n676\n", "output": ["1\n32\n"]}, {"input": "4\n117649\n262144\n1000000\n31710\n", "output": ["385\n568\n1090\n204\n"]}, {"input": "3\n5811\n188666\n195112\n", "output": ["89\n484\n492\n"]}, {"input": "5\n2355981\n4741632\n4913000\n5000211\n2484840\n", "output": ["1656\n2333\n2373\n2394\n1700\n"]}, {"input": "20\n125\n216\n343\n512\n1000\n1331\n1728\n2197\n2744\n3375\n4913\n5832\n238\n8000\n17776\n10648\n12167\n13824\n17576\n19683\n", "output": ["14\n18\n23\n28\n38\n44\n50\n56\n63\n70\n83\n90\n19\n105\n154\n121\n129\n137\n153\n162\n"]}, {"input": "1\n77230\n", "output": ["313\n"]}, {"input": "1\n12979492\n", "output": ["3822\n"]}, {"input": "17\n7301384\n7414875\n7762392\n7880599\n8000000\n8120601\n8242408\n8365427\n8489664\n8615125\n8741816\n8998912\n9129329\n9261000\n9393931\n8451825\n5610507\n", "output": ["2883\n2905\n2970\n2992\n3014\n3036\n3058\n3081\n3103\n3126\n3148\n3193\n3216\n3239\n3261\n3096\n2532\n"]}, {"input": "6\n8069\n15625\n48272\n117649\n262144\n531441\n", "output": ["105\n145\n249\n385\n568\n801\n"]}, {"input": "1\n32683\n", "output": ["206\n"]}, {"input": "1\n7276725\n", "output": ["2877\n"]}, {"input": "7\n244140625\n612920676\n387420489\n481890304\n359052248\n729000000\n887503681\n", "output": ["16225\n25577\n20385\n22708\n19632\n27870\n30721\n"]}, {"input": "9\n4096\n25904\n46656\n117649\n122890\n531441\n1000000\n1771561\n2985984\n", "output": ["76\n184\n246\n385\n392\n801\n1090\n1441\n1860\n"]}, {"input": "1\n85958414\n", "output": ["9691\n"]}, {"input": "5\n720\n448\n722\n916\n724\n", "output": ["32\n26\n32\n36\n32\n"]}, {"input": "2\n8614\n720\n", "output": ["108\n32\n"]}, {"input": "1\n2478976\n", "output": ["1698\n"]}, {"input": "8\n1384\n1000\n4095\n10000\n100000\n1000000\n10000000\n100010000\n", "output": ["45\n38\n75\n117\n356\n1090\n3363\n10443\n"]}, {"input": "3\n17589\n31329\n21025\n", "output": ["153\n203\n167\n"]}, {"input": "5\n1\n143\n729\n4096\n15625\n", "output": ["1\n14\n33\n76\n145\n"]}, {"input": "1\n5136354\n", "output": ["2425\n"]}, {"input": "1\n29308783\n", "output": ["5704\n"]}, {"input": "8\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n469785\n", "output": ["385\n568\n801\n1090\n1441\n1860\n2353\n754\n"]}, {"input": "1\n38886\n", "output": ["225\n"]}, {"input": "12\n64\n125\n357\n343\n512\n729\n1000\n1331\n1728\n2197\n2744\n1220\n", "output": ["10\n14\n23\n23\n28\n33\n38\n44\n50\n56\n63\n41\n"]}, {"input": "1\n6208\n", "output": ["92\n"]}, {"input": "20\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n999950883\n820515574\n999950883\n999950883\n589412590\n999950883\n", "output": ["32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n32589\n29550\n32589\n32589\n25087\n32589\n"]}, {"input": "2\n2567\n23197\n", "output": ["60\n175\n"]}, {"input": "11\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n741529\n1720155\n7529536\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n942\n1420\n2926\n"]}, {"input": "1\n1287\n", "output": ["42\n"]}, {"input": "20\n4096\n15625\n46656\n117649\n262144\n531441\n1000000\n1771561\n2985984\n4826809\n7529536\n11390625\n29118316\n33774247\n34012224\n47045881\n64000000\n85766121\n113379904\n148035889\n", "output": ["76\n145\n246\n385\n568\n801\n1090\n1441\n1860\n2353\n2926\n3585\n5686\n6117\n6138\n7201\n8380\n9681\n11110\n12673\n"]}, {"input": "3\n982427564\n887503680\n45561153\n", "output": ["32306\n30720\n7088\n"]}, {"input": "5\n83\n216\n343\n887\n729\n", "output": ["11\n18\n23\n35\n33\n"]}, {"input": "20\n999999999\n999999999\n999999999\n999999999\n162038073\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n478794427\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n999999999\n", "output": ["32590\n32590\n32590\n32590\n13251\n32590\n32590\n32590\n32590\n32590\n32590\n22636\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n32590\n"]}, {"input": "2\n11100\n5000\n", "output": ["123\n83\n"]}, {"input": "1\n65940\n", "output": ["290\n"]}, {"input": "13\n64\n4096\n11211\n46656\n117649\n262144\n531441\n1010000\n1771561\n2985984\n4826809\n1000000000\n7529536\n", "output": ["10\n76\n123\n246\n385\n568\n801\n1094\n1441\n1860\n2353\n32591\n2926\n"]}, {"input": "7\n643483165\n887503680\n887503682\n999887640\n999887641\n100452051\n3566977\n", "output": ["26200\n30720\n30721\n32588\n32589\n10465\n2028\n"]}, {"input": "7\n1633\n83\n1000000000\n15625\n46656\n262144\n2985984\n", "output": ["48\n11\n32591\n145\n246\n568\n1860\n"]}, {"input": "3\n587\n64\n1000000000\n", "output": ["30\n10\n32591\n"]}, {"input": "6\n39\n729\n4096\n15625\n46656\n117649\n", "output": ["8\n33\n76\n145\n246\n385\n"]}, {"input": "1\n16056\n", "output": ["146\n"]}, {"input": "1\n7360657\n", "output": ["2894\n"]}], "task_id": "codecontest/140", "prompt": "Polycarp takes pleasure in the squares and cubes of positive integers. Here is the start of the sequence of numbers he favors: 1, 4, 8, 9, ....\n\nFor a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Consider edge cases where n is very large to ensure efficient calculation. Remember to account for overlapping numbers which are both perfect squares and perfect cubes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases.\n\nThen t lines contain the test cases, one per line. Each of the lines contains one integer n (1 \u2264 n \u2264 10^9).\n\nOutput\n\nFor each test case, print the answer you are looking for \u2014 the number of integers from 1 to n that Polycarp likes.\n\nExample\n\nInput\n\n\n6\n10\n1\n25\n1000000000\n999999999\n500000000\n\n\nOutput\n\n\n4\n1\n6\n32591\n32590\n23125", "repair_prompt": ["Polycarp takes pleasure in the squares and cubes of positive integers. Here is the start of the sequence of numbers he favors: 1, 4, 8, 9, ....\n\nFor a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Consider edge cases where n is very large to ensure efficient calculation. Remember to account for overlapping numbers which are both perfect squares and perfect cubes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases.\n\nThen t lines contain the test cases, one per line. Each of the lines contains one integer n (1 \u2264 n \u2264 10^9).\n\nOutput\n\nFor each test case, print the answer you are looking for \u2014 the number of integers from 1 to n that Polycarp likes.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6\n10\n1\n25\n1000000000\n999999999\n500000000\n\n\nOutput\n\n\n4\n1\n6\n32591\n32590\n23125\nWrite a main() function and use input() function to read input from stdin", " Polycarp enjoys numbers that are either perfect squares or perfect cubes, or both. He starts his sequence with these numbers: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds pleasing. In essence, find the count of integers x that are either a perfect square of a positive integer or a perfect cube (or both). Be mindful of edge cases where n is extremely large to ensure efficient computation. Also, take into account numbers that are both perfect squares and perfect cubes, as they should not be counted twice.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases.\n\nThen t lines contain the test cases, one per line. Each of the lines contains one integer n (1 \u2264 n \u2264 10^9).\n\nOutput\n\nFor each test case, print the answer you are looking for \u2014 the number of integers from 1 to n that Polycarp likes.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6\n10\n1\n25\n1000000000\n999999999\n500000000\n\n\nOutput\n\n\n4\n1\n6\n32591\n32590\n23125\nWrite a main() function and use input() function to read input from stdin", " Polycarp enjoys numbers that are perfect squares or perfect cubes. He starts with the sequence: 1, 4, 8, 9, .... For a given number n, determine how many numbers from 1 to n Polycarp likes, considering both perfect squares and perfect cubes, and be mindful of overlapping numbers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases.\n\nThen t lines contain the test cases, one per line. Each of the lines contains one integer n (1 \u2264 n \u2264 10^9).\n\nOutput\n\nFor each test case, print the answer you are looking for \u2014 the number of integers from 1 to n that Polycarp likes.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6\n10\n1\n25\n1000000000\n999999999\n500000000\n\n\nOutput\n\n\n4\n1\n6\n32591\n32590\n23125\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef count_polycarp_likes(n: int) -> int:\n    \"\"\"\n    Counts the number of integers from 1 to n that are either perfect squares or perfect cubes (or both).\n    \n    Args:\n        n (int): The upper limit of the range to consider.\n    \n    Returns:\n        int: The count of numbers that are either perfect squares or perfect cubes (or both).\n    \"\"\"\n    # Initialize a set to store unique numbers that are either perfect squares or perfect cubes\n    likes = set()\n    \n    # Calculate the square roots and cube roots up to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        square = i * i\n        likes.add(square)\n        cube = i * i * i\n        if cube <= n:\n            likes.add(cube)\n    \n    # Return the count of unique numbers\n    return len(likes)\n\n# Interface for the function\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        result = count_polycarp_likes(n)\n        print(result)\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nimport math\n\ndef count_polycarp_likes(n: int) -> int:\n    liked_numbers = set()\n    \n    # Iterate through possible square roots up to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        square = i * i\n        if square <= n:\n            liked_numbers.add(square)\n    \n    # Iterate through possible cube roots up to the cube root of n\n    for i in range(1, int(n ** (1/3)) + 1):\n        cube = i * i * i\n        if cube <= n:\n            liked_numbers.add(cube)\n    \n    return len(liked_numbers)\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_polycarp_likes(n)\n    print(result)\n", "from typing import List\n## main.py\nimport math\n\ndef count_polycarp_likes(n: int) -> int:\n    count = 0\n    # Iterate through potential candidates for squares and cubes\n    for i in range(1, int(math.sqrt(n)) + 1):\n        square = i * i\n        if square > n:\n            break\n        # Check if the number is also a cube\n        root = round(math.pow(square, 1/3))\n        if root * root * root == square:\n            count += 1\n        count += 1\n    return count\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_polycarp_likes(n)\n    print(result)\n", "from typing import List\n## main.py\n\nimport math\n\ndef count_pleasing_numbers(n: int) -> int:\n    count = 0\n    # Iterate through numbers to find perfect squares and perfect cubes\n    for i in range(1, int(math.sqrt(n)) + 1):\n        square = i * i\n        if square > n:\n            break\n        count += 1\n        # Check if the number is also a perfect cube\n        cube_root = round(square ** (1/3))\n        if cube_root * cube_root * cube_root == square:\n            # Avoid double-counting numbers that are both perfect squares and perfect cubes\n            if square <= n:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    result = count_pleasing_numbers(n)\n    results.append(result)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport math\n\ndef count_pleasing_numbers(n: int) -> int:\n    \"\"\"\n    Counts the numbers that are either perfect squares or perfect cubes (or both) up to a given number n.\n    \n    Args:\n        n (int): The upper limit number.\n        \n    Returns:\n        int: The count of numbers that are either perfect squares or perfect cubes (or both) up to n.\n    \"\"\"\n    count = 0\n    i = 1\n    \n    while i * i <= n:\n        if i * i <= n:\n            count += 1\n        i += 1\n    \n    i = 1\n    while i * i * i <= n:\n        if i * i * i <= n:\n            count += 1\n        i += 1\n    \n    return count\n\n# Interface for the program\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_pleasing_numbers(n)\n    print(result)\n", "from typing import List\n## main.py\n\nimport math\n\ndef count_pleasing_numbers(n: int) -> int:\n    \"\"\"\n    Counts the number of integers that are either perfect squares or perfect cubes, or both, up to a given number n.\n    \n    Args:\n        n (int): The upper limit for the numbers to be considered.\n        \n    Returns:\n        int: The count of numbers that are either perfect squares or perfect cubes, or both, up to n.\n    \"\"\"\n    # Initialize a set to store the numbers that are either perfect squares or perfect cubes\n    pleasing_numbers = set()\n    \n    # Iterate through possible values of i (integers) from 1 to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        square = i * i\n        if square <= n:\n            pleasing_numbers.add(square)\n    \n    # Iterate through possible values of j (integers) from 1 to the cube root of n\n    for j in range(1, int(math.sqrt(n)) + 1):\n        cube = j * j * j\n        if cube <= n:\n            pleasing_numbers.add(cube)\n    \n    # Return the size of the set as the result\n    return len(pleasing_numbers)\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_pleasing_numbers(n)\n    print(result)\n", "from typing import List\nimport math\n\ndef count_polycarp_likes(n: int) -> int:\n    \"\"\"\n    Counts the number of integers from 1 to n that are both perfect squares and perfect cubes.\n    \n    Args:\n        n (int): The upper limit for the range of numbers to consider.\n        \n    Returns:\n        int: The count of numbers that are both perfect squares and perfect cubes up to n.\n    \"\"\"\n    count = 0\n    i = 1\n    while i * i <= n:\n        j = i * i\n        k = i * i * i\n        if j <= n and k <= n:\n            count += 1\n        i += 1\n    return count\n\n# Interface for the program\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_polycarp_likes(n)\n    print(result)\n", "from typing import List\nimport math\n\ndef count_liked_numbers(n: int) -> int:\n    liked_numbers = set()\n    \n    # Check for perfect squares\n    for i in range(1, int(math.sqrt(n)) + 1):\n        liked_numbers.add(i * i)\n    \n    # Check for perfect cubes\n    for i in range(1, int(math.cbrt(n)) + 1):\n        liked_numbers.add(i * i * i)\n    \n    return len(liked_numbers)\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_liked_numbers(n)\n    print(result)\n", "from typing import List\nimport math\n\ndef count_polycarp_likes(n: int) -> int:\n    \"\"\"\n    Counts the number of integers from 1 to n that are either perfect squares or perfect cubes.\n    \n    Args:\n        n (int): The upper limit of the range.\n    \n    Returns:\n        int: The count of numbers that are either perfect squares or perfect cubes.\n    \"\"\"\n    count = 0\n    perfect_squares = set()\n    perfect_cubes = set()\n    \n    # Find all perfect squares up to n\n    i = 1\n    while i * i <= n:\n        perfect_squares.add(i * i)\n        i += 1\n    \n    # Find all perfect cubes up to n\n    j = 1\n    while j * j * j <= n:\n        perfect_cubes.add(j * j * j)\n        j += 1\n    \n    # Combine both sets and count unique numbers\n    combined_set = perfect_squares.union(perfect_cubes)\n    count = len(combined_set)\n    \n    return count\n\n# Interface for the program\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_polycarp_likes(n)\n    print(result)\n", "from typing import List\nimport math\n\ndef count_polycarp_likes(n: int) -> int:\n    \"\"\"\n    Counts the number of integers from 1 to n that are either perfect squares or perfect cubes.\n    \n    Args:\n        n (int): The upper limit for the range of numbers to consider.\n        \n    Returns:\n        int: The count of numbers that are either perfect squares or perfect cubes.\n    \"\"\"\n    count = 0\n    root_n = int(math.sqrt(n))\n    cube_root_n = int(math.pow(n, 1/3))\n    \n    # Count perfect squares\n    for i in range(1, root_n + 1):\n        if i * i <= n:\n            count += 1\n    \n    # Count perfect cubes\n    for i in range(1, cube_root_n + 1):\n        if i * i * i <= n:\n            count += 1\n    \n    # Adjust for numbers that are both perfect squares and perfect cubes (perfect sixth powers)\n    for i in range(1, min(root_n, cube_root_n) + 1):\n        if i * i * i * i * i * i <= n:\n            count -= 1\n    \n    return count\n\n# Interface for the program\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    result = count_polycarp_likes(n)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to count the number of integers from 1 to n that are either perfect squares or perfect cubes (or both). The challenge lies in handling large inputs efficiently, as n can be as large as 10^9. The solution must be optimized to avoid performance issues and ensure accurate results for each test case.\nrequirement pool:\n- Implement a function to count numbers that are either squares or cubes within a given range.\n- Ensure the function can handle large inputs efficiently.\n- Provide accurate results for each test case.\n- Optimize the algorithm for speed and memory usage.\n- Test the application with various large inputs to ensure reliability.\nTo efficiently count the number of integers from 1 to n that are either perfect squares or perfect cubes (or both), we can use Python's built-in functions and set operations. The approach involves iterating through possible square and cube roots, calculating the respective values, and using set operations to avoid counting overlaps. This method ensures that the solution is both simple and efficient, capable of handling large inputs up to 10^9.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'squares and cubes': means we are looking for numbers that are either a perfect square or a perfect cube (or both).\n    'overlapping numbers': numbers that are both perfect squares and perfect cubes (i.e., perfect sixth powers).\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    To efficiently count the number of integers from 1 to n that are either perfect squares or perfect cubes (or both), we can use Python's built-in functions and set operations. The approach involves iterating through possible square and cube roots, calculating the respective values, and using set operations to avoid counting overlaps.\n\n# [edge case] \n    n = 10\n    expected output = 4\n    Explanation: The numbers that Polycarp likes are 1, 4, 8, and 9. 1 is a square (1^2), 4 is a square (2^2), 8 is a cube (2^3), and 9 is both a square (3^2) and a cube (3^3).\n\n    n = 1000000000\n    expected output = 3689\n    Explanation: Given the large value of n, we need to efficiently count the numbers that are either perfect squares or perfect cubes (or both). The result is the count of such numbers up to n, considering overlaps.\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge case. The provided logic is efficient and can handle the largest possible input value of n (10^9).\n", "requirement analysis:\nThe requirement involves counting numbers that are either perfect squares or perfect cubes up to a given number n. The challenge lies in handling large values of n efficiently, especially when n is as large as 10^9. The solution must account for numbers that are both perfect squares and perfect cubes, which are counted only once. The algorithm should be optimized to handle such large inputs without excessive computation time.\nrequirement pool:\n- Implement an efficient algorithm to count numbers that are squares or cubes up to n.\n- Handle edge cases where n is very large.\n- Ensure the solution is optimized for performance.\n- Provide clear and accurate results for each test case.\n- Ensure the solution is scalable and can handle large inputs.\nTo efficiently count the number of integers Polycarp likes, we will use Python's built-in libraries to handle large inputs. We will iterate through possible square and cube roots up to the square root of n, as higher roots will exceed n. We will use sets to avoid counting duplicates that are both perfect squares and perfect cubes. The use of sets will help in efficiently checking membership and avoiding redundant calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'squares and cubes': means we are looking for numbers that are either a square of a positive integer or a cube of a positive integer.\n    'overlapping numbers': numbers that are both perfect squares and perfect cubes (e.g., 1, 64, etc.) should be counted once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the number of integers Polycarp likes, we will use Python's built-in libraries to handle large inputs. We will iterate through possible square and cube roots up to the square root of n, as higher roots will exceed n. We will use sets to avoid counting duplicates that are both perfect squares and perfect cubes. The use of sets will help in efficiently checking membership and avoiding redundant calculations.\n\n# [edge case] \n    n = 10\n    expected output = 4\n    Explanation: The numbers Polycarp likes are 1, 4, 8, and 9. 1 is a square (1^2), 4 is a square (2^2), 8 is a cube (2^3), and 9 is both a square (3^2) and a cube (3^3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the given constraints.\n", "requirement analysis:\nThe requirement involves counting numbers that are either perfect squares or perfect cubes up to a given number n. The challenge lies in handling large values of n efficiently, especially when n is as large as 10^9. The solution must account for numbers that are both squares and cubes (perfect sixth powers) to avoid double-counting.\nrequirement pool:\n- Implement an efficient algorithm to count numbers that are squares or cubes up to n.\n- Handle edge cases where n is very large.\n- Ensure the solution is optimized for performance.\n- Provide clear and accurate results for each test case.\n- Avoid double-counting numbers that are both squares and cubes.\nTo efficiently count the number of integers Polycarp likes, we will use Python's built-in capabilities and leverage the math library to handle the square and cube root calculations. We will iterate through potential candidates for squares and cubes, ensuring we do not double-count numbers that are both. The key challenge is to ensure the solution is optimized for large values of n, up to 10^9.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'squares and cubes': means we need to find numbers that are either a perfect square or a perfect cube (or both)\n    'overlapping numbers': numbers that are both perfect squares and perfect cubes (e.g., 1, 64, etc.)\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the number of integers Polycarp likes, we will use Python's built-in capabilities and leverage the math library to handle the square and cube root calculations. We will iterate through potential candidates for squares and cubes, ensuring we do not double-count numbers that are both. The key challenge is to ensure the solution is optimized for large values of n, up to 10^9.\n\n# [edge case] \n    n = 10\n    expected output = 4\n    Explanation: The numbers Polycarp likes are 1, 4, 8, and 9. 1 is a square (1^2), 4 is a square (2^2), 8 is a cube (2^3), and 9 is both a square (3^2) and a cube (3^3).\n\n    n = 1000000000\n    expected output = 3689\n    Explanation: The largest number Polycarp likes up to 10^9 is 3689, which is 1000^2 and 10^3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is already optimized for large values of n.\n", "requirement analysis:\nThe primary requirement is to count the numbers that are either perfect squares or perfect cubes (or both) up to a given number n. The challenge lies in handling large inputs efficiently, avoiding double-counting, and ensuring the solution is robust against large values of n. The output should be clear and concise, providing the count of such numbers for each test case.\nrequirement pool:\n- Implement an efficient algorithm to count numbers that are either perfect squares or perfect cubes.\n- Ensure the solution can handle large inputs efficiently.\n- Avoid double-counting numbers that are both perfect squares and perfect cubes.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance.\nTo efficiently count the numbers that are either perfect squares or perfect cubes (or both) up to a given number n, we can use Python's built-in functions and libraries. We will iterate through the range of numbers, check if each number is a perfect square or a perfect cube, and avoid double-counting numbers that are both. We will optimize the algorithm to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': a number that can be expressed as the product of an integer with itself (e.g., 1, 4, 9, 16, ...)\n    'perfect cube': a number that can be expressed as the product of an integer with itself three times (e.g., 1, 8, 27, 64, ...)\n    'avoid double-counting': numbers that are both perfect squares and perfect cubes (e.g., 1, 64, ...) should not be counted twice.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the numbers that are either perfect squares or perfect cubes (or both) up to a given number n, we can use Python's built-in functions and libraries. We will iterate through the range of numbers, check if each number is a perfect square or a perfect cube, and avoid double-counting numbers that are both. We will optimize the algorithm to handle large inputs efficiently.\n\n# [edge case] \n    search(10) = 7\n    explanation: The numbers that are either perfect squares or perfect cubes (or both) up to 10 are: 1, 4, 8, 9. There are 7 such numbers.\n    search(100) = 32\n    explanation: The numbers that are either perfect squares or perfect cubes (or both) up to 100 are: 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100. There are 32 such numbers.\n    search(1000000000) = 333333333\n    explanation: The numbers that are either perfect squares or perfect cubes (or both) up to 1,000,000,000 are numerous, but we can efficiently count them using the approach outlined in the plan. The result is 333,333,333.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is efficient and can handle large inputs.\n", "requirement analysis:\nThe primary requirement is to count the numbers that are either perfect squares or perfect cubes (or both) up to a given number n. The challenge lies in handling large inputs efficiently, given the constraint that n can be as large as 10^9. The solution must be optimized to avoid slow performance, especially for large values of n. Additionally, the output should be clear and concise, providing the count of numbers pleasing to Polycarp for each test case.\nrequirement pool:\n- Implement an efficient algorithm to count perfect squares and perfect cubes up to n.\n- Ensure the algorithm can handle large inputs efficiently.\n- Provide clear and concise output for each test case.\n- Test the solution with various large inputs to ensure it performs well.\n- Optimize the algorithm for optimal performance.\nTo efficiently count the numbers that are either perfect squares or perfect cubes (or both) up to a given number n, we can leverage Python's capabilities to handle large integers. The approach involves iterating through potential candidates and checking if they are perfect squares or perfect cubes. We need to ensure that numbers which are both perfect squares and perfect cubes (i.e., perfect sixth powers) are not counted twice. This can be efficiently achieved using mathematical properties and set operations to avoid redundant checks.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': a number that can be expressed as the product of an integer with itself.\n    'perfect cube': a number that can be expressed as the product of an integer with itself twice.\n    'both': numbers that are both perfect squares and perfect cubes (perfect sixth powers).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the numbers that are either perfect squares or perfect cubes (or both) up to a given number n, we can leverage Python's capabilities to handle large integers. The approach involves iterating through potential candidates and checking if they are perfect squares or perfect cubes. We need to ensure that numbers which are both perfect squares and perfect cubes (i.e., perfect sixth powers) are not counted twice. This can be efficiently achieved using mathematical properties and set operations to avoid redundant checks.\n\n# [edge case] \n    search(10) = 4\n    explanation: The numbers that are either perfect squares or perfect cubes (or both) up to 10 are 1, 4, 8, 9. So, there are 4 such numbers.\n    search(100) = 8\n    explanation: The numbers that are either perfect squares or perfect cubes (or both) up to 100 are 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100. So, there are 8 such numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is efficient and can handle large values of n.\n", "requirement analysis:\nThe requirement involves counting numbers that are either perfect squares or perfect cubes, or both, up to a given number n. The challenge lies in handling large inputs efficiently, as n can be as large as 10^9. The solution must be robust and optimized to ensure it performs well even for large values of n.\nrequirement pool:\n- Implement a function to count numbers that are perfect squares or perfect cubes up to n.\n- Ensure the function is optimized for large inputs.\n- Provide clear and efficient output for each test case.\n- Test the function with various large inputs to ensure performance.\n- Implement user-friendly input and output mechanisms.\nTo efficiently count the number of integers that are either perfect squares or perfect cubes, or both, up to a given number n, we can use Python's built-in functions and libraries. We will leverage the mathematical properties of perfect squares and cubes to avoid unnecessary computations. The key is to find the largest integer i such that i^2 <= n and the largest integer j such that j^3 <= n. We will then count all unique numbers that satisfy either condition, ensuring that numbers that are both perfect squares and perfect cubes are not counted twice.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': a number that can be expressed as the product of an integer with itself.\n    'perfect cube': a number that can be expressed as the product of an integer with itself three times.\n    'both': numbers that satisfy both conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the number of integers from 1 to n that are either perfect squares or perfect cubes, or both, we can use the following approach:\n    1. Initialize a set to store the numbers that are either perfect squares or perfect cubes.\n    2. Iterate through possible values of i (integers) from 1 to the square root of n. For each i, add i^2 to the set.\n    3. Iterate through possible values of j (integers) from 1 to the cube root of n. For each j, add j^3 to the set if j^3 is less than or equal to n and not already in the set.\n    4. Return the size of the set as the result.\n\n# [edge case] \n    search(100) = 10\n    Explanation: The numbers that are either perfect squares or perfect cubes, or both, up to 100 are: 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100. There are 10 such numbers.\n    search(1000) = 32\n    Explanation: The numbers that are either perfect squares or perfect cubes, or both, up to 1000 are: 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100, 121, 125, 144, 169, 196, 225, 243, 256, 289, 324, 343, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961. There are 32 such numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic is efficient and handles large values of n.\n", "requirement analysis:\nThe requirement involves calculating the number of integers from 1 to n that are either perfect squares or perfect cubes. The challenge lies in handling large values of n efficiently. The solution should consider both perfect squares and perfect cubes without double-counting numbers that are both. The input consists of multiple test cases, and the output should provide the count for each test case.\nrequirement pool:\n- Implement a function to count perfect squares and perfect cubes up to n.\n- Ensure the function handles large inputs efficiently.\n- Avoid double-counting numbers that are both perfect squares and perfect cubes.\n- Provide clear and accurate results for each test case.\n- Optimize the algorithm for speed and memory usage.\nTo efficiently calculate the number of numbers Polycarp likes, we will use Python's built-in libraries to handle large inputs and avoid double-counting. We will iterate through potential perfect squares and perfect cubes up to n, ensuring we do not count numbers that are both. This approach leverages Python's ability to handle large integers and mathematical operations efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': a number that can be expressed as the product of an integer with itself (e.g., 1, 4, 9, 16, ...)\n    'perfect cube': a number that can be expressed as the product of an integer with itself three times (e.g., 1, 8, 27, 64, ...)\n    'overlapping': numbers that are both perfect squares and perfect cubes (e.g., 1, 64, ...)\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently calculate the number of numbers Polycarp likes, we will use Python's built-in libraries to handle large inputs and avoid double-counting. We will iterate through potential perfect squares and perfect cubes up to n, ensuring we do not count numbers that are both.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: The number 1 is both a perfect square (1^2) and a perfect cube (1^3).\n\n    n = 64\n    expected output: 7\n    Explanation: The numbers 1, 4, 8, 9, 16, 25, 27, 36, 49, 64 are all perfect squares or perfect cubes up to 64. However, 64 is counted only once because it is both a perfect square (8^2) and a perfect cube (4^3).\n\n    n = 1000\n    expected output: 31\n    Explanation: The numbers 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100, 121, 125, 144, 169, 196, 216, 225, 243, 256, 289, 324, 343, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961 are all perfect squares or perfect cubes up to 1000. However, numbers like 64, 125, 216, etc., are counted only once because they are both perfect squares and perfect cubes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the smallest possible value of n.\n", "requirement analysis:\nThe requirement is to count the numbers from 1 to n that are either perfect squares or perfect cubes. The challenge lies in handling large values of n efficiently. The solution should be optimized to avoid timeouts for large inputs.\nrequirement pool:\n- Implement a function to count numbers that are perfect squares or perfect cubes.\n- Ensure the function works efficiently for large values of n.\n- Handle input and output as specified in the problem statement.\n- Ensure the solution is clear and easy to understand.\n- Optimize the algorithm to handle large inputs within a reasonable time frame.\nTo solve this problem efficiently, we will use Python's built-in math library to check for perfect squares and cubes. We will iterate through numbers from 1 to n, checking each number to see if it is a perfect square or perfect cube. We will use a set to avoid counting numbers that are both perfect squares and perfect cubes (i.e., perfect sixth powers) multiple times. The use of a set will help in maintaining the uniqueness of numbers liked by Polycarp.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': a number that can be expressed as the product of an integer with itself.\n    'perfect cube': a number that can be expressed as the product of an integer with itself three times.\n    'overlapping': numbers that are both perfect squares and perfect cubes (e.g., 1, 64) should be counted only once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem efficiently, we will use Python's built-in math library to check for perfect squares and cubes. We will iterate through numbers from 1 to n, checking each number to see if it is a perfect square or perfect cube. We will use a set to avoid counting numbers that are both perfect squares and perfect cubes (i.e., perfect sixth powers) multiple times. The use of a set will help in maintaining the uniqueness of numbers liked by Polycarp.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: The number 1 is both a perfect square (1^2) and a perfect cube (1^3), so Polycarp likes it.\n\n    n = 64\n    expected output: 7\n    Explanation: The numbers 1, 4, 8, 9, 16, 25, 27, 36, 49, 64 are liked by Polycarp. 64 is both a perfect square (8^2) and a perfect cube (4^3), but it should be counted only once.\n\n    n = 1000\n    expected output: 31\n    Explanation: The numbers 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100, 121, 125, 144, 169, 196, 216, 225, 243, 256, 289, 324, 343, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961 are liked by Polycarp. Note that numbers like 1000 (which is not a perfect square or cube) are not included.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem for all given test cases.\n", "requirement analysis:\nThe requirement is to count the numbers from 1 to n that are either perfect squares or perfect cubes. The challenge lies in handling large values of n efficiently. The solution should be optimized to avoid excessive computation time, especially for large n up to 10^9.\nrequirement pool:\n- Implement a function to count numbers that are perfect squares or perfect cubes.\n- Ensure the function works efficiently for large values of n.\n- Handle overlapping numbers between perfect squares and perfect cubes.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm to handle large inputs within a reasonable time frame.\nTo efficiently count the numbers from 1 to n that are either perfect squares or perfect cubes, we can use Python's built-in functions and libraries. The challenge is to handle large values of n efficiently, which can be achieved by leveraging mathematical properties of perfect squares and perfect cubes. We will use the square root and cube root functions to identify these numbers and avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': A number that can be expressed as the product of an integer with itself.\n    'perfect cube': A number that can be expressed as the product of an integer with itself three times.\n    'overlapping': Both perfect squares and perfect cubes can overlap, e.g., 1 (square and cube), 64 (square and cube), etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the numbers from 1 to n that are either perfect squares or perfect cubes, we can use Python's built-in functions and libraries. The challenge is to handle large values of n efficiently, which can be achieved by leveraging mathematical properties of perfect squares and perfect cubes. We will use the square root and cube root functions to identify these numbers and avoid unnecessary computations.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: The number 1 is both a perfect square (1^2) and a perfect cube (1^3).\n\n    n = 28\n    expected output: 7\n    Explanation: The perfect squares up to 28 are 1, 4, 9, 16, 25. The perfect cubes up to 28 are 1, 8, 27. However, 1 is counted only once, so the total count is 5 (perfect squares) + 2 (perfect cubes) - 1 (overlap) = 6.\n\n    n = 1000000000\n    expected output: 3203123\n    Explanation: This is a large number, and we need to efficiently count the numbers that are either perfect squares or perfect cubes up to 10^9. The exact count involves calculating the number of integers up to the square root and cube root of 10^9, respectively, and accounting for overlaps.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can be used to count the numbers efficiently for any given n.\n", "requirement analysis:\nThe requirement is to count the numbers from 1 to n that are either perfect squares or perfect cubes, considering the overlap where a number is both. The challenge lies in handling large inputs efficiently, given the constraint that n can be as large as 10^9. The solution must be optimized to avoid performance issues and ensure accuracy.\nrequirement pool:\n- Implement a function to count numbers that are perfect squares or perfect cubes.\n- Ensure the function can handle large inputs efficiently.\n- Account for numbers that are both perfect squares and perfect cubes.\n- Optimize the algorithm for large inputs.\n- Test the solution with various edge cases to ensure accuracy and robustness.\nTo efficiently count the number of integers from 1 to n that are either perfect squares or perfect cubes, we will use Python's built-in capabilities and leverage the math library for square root and cube root calculations. The approach involves iterating up to the square root and cube root of n, respectively, and counting these numbers. We will also handle the overlap where a number is both a perfect square and a perfect cube (a perfect sixth power).\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'perfect square': an integer that is the square of another integer (e.g., 1, 4, 9, 16, ...)\n    'perfect cube': an integer that is the cube of another integer (e.g., 1, 8, 27, 64, ...)\n    'overlap': numbers that are both perfect squares and perfect cubes (e.g., 1, 64, ...)\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently count the number of integers from 1 to n that are either perfect squares or perfect cubes, we will use Python's built-in capabilities and leverage the math library for square root and cube root calculations. The approach involves iterating up to the square root and cube root of n, respectively, and counting these numbers. We will also handle the overlap where a number is both a perfect square and a perfect cube (a perfect sixth power).\n\n# [edge case] \n    n = 10\n    explanation: The numbers that are perfect squares or perfect cubes up to 10 are 1, 4, 8, 9. Polycarp likes 4 numbers (1, 4, 8, 9).\n    n = 100\n    explanation: The numbers that are perfect squares or perfect cubes up to 100 are 1, 4, 8, 9, 16, 25, 27, 36, 49, 64, 81, 100. Polycarp likes 12 numbers.\n    n = 1000000000\n    explanation: The numbers that are perfect squares or perfect cubes up to 10^9 are numerous, but we need to efficiently calculate them without iterating through all numbers up to 10^9.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is efficient for large values of n.\n"], "scores": [], "pass_results": [false, false, true, true, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 615, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases.\n\nThen t lines contain the test cases, one per line. Each of the lines contains one integer n (1 \u2264 n \u2264 10^9).\n\nOutput\n\nFor each test case, print the answer you are looking for \u2014 the number of integers from 1 to n that Polycarp likes.\n\nExample\n\nInput\n\n\n6\n10\n1\n25\n1000000000\n999999999\n500000000\n\n\nOutput\n\n\n4\n1\n6\n32591\n32590\n23125", "mutate_method": "rephrase_one", "parent_index": 247}
