{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You have an array a of size n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). Elements that are not greater than x are included in the left part. The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You have an array a of size n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). Elements that are not greater than x are included in the left part. The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You have an array a of size n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). Elements that are not greater than x are included in the left part. The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You have an array a of size n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). Elements that are not greater than x are included in the left part. The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef eversion_count(arr: List[int]) -> int:\n    def perform_eversion(arr: List[int]) -> List[int]:\n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    iterations = 0\n    while True:\n        original_arr = arr.copy()\n        arr = perform_eversion(arr)\n        iterations += 1\n        if arr == original_arr:\n            break\n    return iterations - 1  # Subtract 1 because the last iteration was the unchanged state\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef eversion_operations(arr: List[int]) -> int:\n    k = 0\n    while True:\n        original_arr = arr.copy()\n        x = max(arr)\n        left = [num for num in arr if num <= x]\n        right = [num for num in arr if num > x]\n        arr = left + right\n        k += 1\n        if arr == original_arr:\n            break\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = eversion_operations(a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\n\ndef find_stable_eversions(arr: List[int]) -> int:\n    def eversion(a: List[int]) -> List[int]:\n        if not a:\n            return []\n        pivot = a[-1]\n        left = [x for x in a if x <= pivot]\n        right = [x for x in a if x > pivot]\n        return left + right\n\n    def is_stable(a: List[int]) -> bool:\n        return all(a[i] <= i for i in range(len(a)))\n\n    count = 0\n    while not is_stable(arr):\n        arr = eversion(arr)\n        count += 1\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr_size = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_eversions(arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef eversion_operation(arr: list) -> int:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def count_eversions(arr):\n        eversion_count = 0\n        while True:\n            pivot = arr[-1]\n            i = partition(arr, 0, len(arr) - 1)\n            if i == len(arr) // 2:\n                break\n            eversion_count += 1\n            arr = arr[:i + 1] + arr[len(arr):]\n        return eversion_count\n\n    return count_eversions(arr)\n\n# Provide the Interface\nn = int(sys.stdin.readline())\nfor _ in range(n):\n    a = list(map(int, sys.stdin.readline().split()))\n    result = eversion_operation(a)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> int:\n    \"\"\"\n    Perform the eversion operation on the given array and return the number of eversions.\n    \n    Args:\n        arr (list): A list of integers.\n        \n    Returns:\n        int: The number of eversions. If no element appears more than or equal to its value, return -1.\n    \"\"\"\n    if not arr:\n        return -1\n    \n    pivot = max(arr)\n    eversion_count = 0\n    \n    while True:\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        \n        if left + right == arr:\n            break\n        \n        arr = left + [pivot] + right\n        eversion_count += 1\n    \n    for num in arr:\n        if arr.count(num) >= num:\n            return num\n    \n    return -1\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list[int]) -> list[int]:\n    def partition(arr: list[int], pivot: int) -> tuple[list[int], list[int]]:\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def find_largest_pivot(arr: list[int]) -> int:\n        return max(arr)\n\n    def concatenate_arrays(left: list[int], right: list[int]) -> list[int]:\n        return left + right\n\n    pivot = find_largest_pivot(arr)\n    new_arr = arr\n    iterations = 0\n\n    while True:\n        left, right = partition(new_arr, pivot)\n        new_arr = concatenate_arrays(left, right)\n        iterations += 1\n        if new_arr == left + right:\n            break\n\n    return new_arr\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(len(result) - 1)\n", "from typing import List\ndef eversion_operation(arr: list[int]) -> list[int]:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot element and then concatenating the two parts.\n    The process is repeated until the array stops changing.\n    \n    Args:\n        arr (list[int]): The input array to be everted.\n        \n    Returns:\n        list[int]: The array after the eversion operation has stabilized.\n    \"\"\"\n    original_arr = arr.copy()\n    k = 0\n    while True:\n        pivot = arr[-1]\n        left_part = [x for x in arr[:-1] if x <= pivot]\n        right_part = [x for x in arr[:-1] if x > pivot]\n        arr = left_part + [pivot] + right_part\n        k += 1\n        if arr == original_arr:\n            break\n    return arr\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\n\n# Call the eversion_operation function and print the result\nresult = eversion_operation(a)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    def partition(arr: List[int], pivot: int) -> (List[int], List[int]):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def concatenate(left: List[int], right: List[int]) -> List[int]:\n        return left + right\n\n    pivot = max(arr)\n    while True:\n        left, right = partition(arr, pivot)\n        if left + right == arr:\n            break\n        arr = concatenate(left, right)\n    return arr\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\ndef eversion_operation(arr: list[int]) -> list[int]:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    original_arr = arr.copy()\n    iterations = 0\n    while not is_sorted(arr):\n        quick_sort(arr, 0, len(arr) - 1)\n        iterations += 1\n        if arr == original_arr:\n            break\n        arr = original_arr\n    return arr\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = eversion_operation(a)\n    print(len(result))\n", "from typing import List\nfrom typing import List\n\ndef find_stable_k(n: int, a: List[int]) -> int:\n    def eversion_operation(arr: List[int]) -> List[int]:\n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    k = 0\n    while True:\n        original_array = a.copy()\n        a = eversion_operation(a)\n        if a == original_array:\n            break\n        k += 1\n    return k\n\n# Interface\nn = int(input())\na = list(map(int, input().split()))\nresult = find_stable_k(n, a)\nprint(result)\n"], "plans": ["requirement analysis:\nThe problem requires understanding the eversion operation and how it affects the array. The goal is to find the minimum number of eversions after which the array stops changing. This involves partitioning the array based on a pivot and then merging the partitions. The solution should be efficient enough to handle large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation and partitioning logic\n- Ensure the algorithm can handle multiple test cases\n- Optimize the number of operations to find the minimum k\n- Add error handling for invalid inputs\n- Include comments and documentation for better understanding\nTo solve this problem, we will implement a function that performs the eversion operation on an array and counts the number of iterations until the array stops changing. The eversion operation involves partitioning the array based on a pivot element and then merging the partitions. We will use Python, leveraging its efficient handling of large data structures and operations. The algorithm will be designed to handle multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then merging the partitions. The goal is to find the minimum number of iterations until the array stops changing.\n    Explanation: The eversion operation splits the array into two parts based on a pivot (the last element of the array), and then it merges these parts while maintaining the order of elements within each part. This process is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value in the array.\n    'at least as many times': This phrase indicates that we need to find an integer whose frequency in the array is greater than or equal to its value.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more than its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Perform the eversion operation iteratively.\n    2. Check if the array has changed after each eversion.\n    3. Continue until the array no longer changes.\n    4. Return the number of iterations performed.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: The array does not change after the first eversion because all elements are the same. Therefore, the number of iterations is 0.\n    search([2, 2, 3, 3, 3]) = 2\n    Explanation: The array changes after the first eversion (2, 2, 3, 3, 3) \u2192 (2, 2, 3), (3, 3) \u2192 (2, 2, 3, 3, 3). It changes again after the second eversion (2, 2, 3, 3, 3) \u2192 (2, 2, 3), (3, 3) \u2192 (2, 2, 3, 3, 3), and does not change afterward.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic is sufficient to handle arrays where all elements are the same, as the array will not change after the first eversion.\n", "requirement analysis:\nThe primary requirement is to determine the number of eversions required for an array to reach a stable state. This involves repeatedly partitioning the array based on a pivot element and checking if the array changes after each partition. The solution should be efficient and handle large inputs within the given constraints. The output should be the minimum number of eversions after which the array stops changing.\nrequirement pool:\n- Implement the eversion operation and partitioning logic.\n- Ensure the solution is efficient and can handle large inputs.\n- Output the minimum number of eversions for the array to reach a stable state.\n- Add user interface elements for input and output.\n- Include documentation and comments for easier understanding and maintenance.\nTo implement the solution, we will use Python due to its simplicity and efficiency. The main challenge is to repeatedly partition the array based on a pivot element and check if the array changes after each partition. We will use a loop to perform the eversion operations until the array stops changing. We will also ensure that the solution is efficient and can handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element and then concatenating the partitioned parts. The partitioning is stable, meaning the order of elements in each part remains the same as before the operation.\n    Explanation: The eversion operation helps in sorting parts of the array by repeatedly partitioning and concatenating until the array stops changing.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element must be greater than some value.\n    Explanation: In the context of the requirement, 'more than' is used to define the pivot element for partitioning.\n\n# [degree adverb] \n    'largest': Indicates that the pivot element should be the largest in the array.\n    Explanation: In the requirement, 'largest' suggests that the pivot element should be the maximum value in the array to ensure the most significant partition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Read the input for each test case.\n    2. Perform the eversion operation iteratively until the array stops changing.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: The array is already sorted, so no eversions are needed.\n    search([3, 2, 1]) = 1\n    Explanation: The first eversion will sort the array to [2, 1, 3], and subsequent eversions will not change the array.\n    search([4, 3, 2, 1]) = 2\n    Explanation: The first eversion will sort the array to [3, 2, 1, 4], and the second eversion will sort the array to [2, 1, 3, 4], and subsequent eversions will not change the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle arrays that are already sorted or have a single element.\n\n# Main function to read input and perform eversion operations\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        k = 0\n        while True:\n            original_a = a.copy()\n            x = max(a)\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            a = left + right\n            k += 1\n            if a == original_a:\n                break\n        \n        results.append(k)\n    \n    for result in results:\n        print(result)\n", "requirement analysis:\nThe problem requires understanding the eversion operation and how it affects the array. The goal is to find the minimum number of eversions after which the array stops changing. This involves simulating the eversion process and checking for array stability. The input size can be large, so the solution must be efficient and scalable.\nrequirement pool:\n- Implement the eversion operation and simulate the array transformation\n- Develop a method to determine when the array stops changing\n- Ensure the solution handles large inputs efficiently\n- Optimize the number of operations to find the fixed point\nTo solve this problem, we will use Python, leveraging its powerful data manipulation capabilities and efficient standard library functions. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and the built-in 'sorted' function. We will simulate the eversion process iteratively, checking for array stability after each operation. The goal is to find the minimum number of eversions after which the array stops changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and the built-in 'sorted' function.\n    Explanation: The eversion operation splits the array into two parts based on a pivot value (x), where the left part contains elements less than or equal to x, and the right part contains elements greater than x. This operation is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the pivot value (x) such that the number of elements greater than x is less than the value of x itself.\n    Explanation: For example, if x = 3, then there should be more than 3 elements greater than x for the array to stop changing.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we need to find the smallest number of eversions required for the array to stop changing.\n    Explanation: We need to perform the eversion operation until the array no longer changes, and we want to find the minimum number of such operations.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. For each test case, perform eversions iteratively until the array stops changing.\n    3. Keep track of the number of eversions performed.\n    4. Output the number of eversions for each test case.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already consists of identical elements, so no eversions are needed.\n    Edge case 2: [2, 2, 3, 3, 3] = 1\n    Explanation: The array will stabilize after one eversion because the pivot value (3) appears more than 3 times, and the left and right parts will be [2, 2, 3] and [3, 3], respectively.\n    Edge case 3: [5, 5, 4, 4, 4] = 2\n    Explanation: The array will stabilize after two eversions. In the first eversion, the pivot value (4) appears more than 4 times, and in the second eversion, the array will be [4, 4, 4, 5, 5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly handle arrays that are already stable or require a minimum number of eversions to stabilize.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array, which partitions the array into two parts based on a pivot element. The left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. The order of elements in each part is preserved. The task is to determine the number of iterations required for the array to stop changing through eversion operations.\nrequirement pool:\n- Implement the eversion operation on the array\n- Ensure the array partition is stable\n- Optimize the algorithm for large arrays\n- Provide user-friendly output for the number of eversions\n- Enhance the user interface for better usability\nTo implement the eversion operation on an array efficiently, we will use Python's built-in list operations and the concept of partitioning the array based on a pivot. The partitioning will be stable, meaning the order of elements in each part will be preserved. We will optimize the algorithm to handle large arrays efficiently. The output will be a single integer representing the number of eversions required for the array to stop changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot value, maintaining the order of elements within each part.\n    Explanation: In the requirement, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). The order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the elements in the right part are strictly greater than the pivot.\n    Explanation: For example, in the requirement, \"The right part contains the elements of a that are strictly greater than x (> x).\"\n\n# [degree adverb] \n    'largest': indicates that the pivot is the largest element in the array.\n    Explanation: In the requirement, \"Let x = a_n. Then array a is partitioned into two parts...\" where 'a_n' refers to the last element of the array, which is the largest by definition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we can follow these steps:\n    1. For each test case, read the size of the array and the elements.\n    2. Perform the eversion operation by partitioning the array based on the last element (largest element) as the pivot.\n    3. Continue partitioning until the array stops changing.\n    4. Count the number of partitions (eversions) performed.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    expected output: 1\n    Explanation: The array is already sorted in ascending order. The last element (5) is the largest, and the array does not change after the first partition.\n    Edge case 2: [5, 4, 3, 2, 1]\n    expected output: 1\n    Explanation: The array is sorted in descending order. The last element (1) is the smallest, and the array does not change after the first partition.\n    Edge case 3: [3, 1, 2, 4, 5]\n    expected output: 2\n    Explanation: After the first partition, the array becomes [2, 1, 3, 4, 5]. The last element (5) is the largest, and the array does not change after the second partition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle the edge cases by checking if the array is already sorted or reversed, in which case the number of eversions is 1.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle multiple test cases efficiently, with each test case involving an array and the application of the eversion operation. The program should be able to determine the number of eversions after which the array stops changing. The constraints indicate that the sum of n over all test cases does not exceed 2 \u22c5 10^5, which implies that the program should be able to handle large datasets.\nrequirement pool:\n- Implement the eversion operation as described\n- Handle multiple test cases efficiently\n- Ensure the program can handle large datasets\n- Provide clear and concise output for each test case\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and functions. The eversion operation involves partitioning the array based on a pivot element, which can be achieved using list comprehensions and slicing. We will iterate over the array until it stops changing, counting the number of iterations as the number of eversions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot element, and then concatenating these parts while maintaining the order of elements within each part. The pivot element is the last element of the array in this context.\n    Explanation: The eversion operation is a specific way to rearrange the elements of an array based on a chosen pivot. The goal is to split the array into two parts where the left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. This operation is repeated until the array stops changing, indicating that no more eversions can occur.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements in the array that are strictly greater than the pivot.\n    Explanation: In the context of the eversion operation, 'more than' is used to define the elements that will be placed in the right part of the array after partitioning. These elements are greater than the pivot but less than or equal to the maximum value in the array.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the largest element in the array to use as the pivot for partitioning.\n    Explanation: The 'largest' degree adverb is used to identify the element that will be placed at the end of the array after partitioning. This element is the largest in the array and helps in determining the direction of partitioning.\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and functions. The eversion operation involves partitioning the array based on a pivot element, which can be achieved using list comprehensions and slicing. We will iterate over the array until it stops changing, counting the number of iterations as the number of eversions.\n\n# [edge case] \n    Edge case 1:\n    search([1, 2, 3, 4, 5]) = -1\n    Explanation: In this case, the array is already sorted in ascending order. Since no element appears more than or equal to its value, the function should return -1.\n\n    Edge case 2:\n    search([5, 4, 3, 2, 1]) = 1\n    Explanation: In this case, the array is sorted in descending order. The element 5 appears exactly once, which is more than its value. This is the largest integer that meets the condition, so the function should return 1.\n\n    Edge case 3:\n    search([2, 2, 2, 2, 2]) = 2\n    Explanation: All elements in the array are the same. The element 2 appears exactly twice, which is more than its value. This is the largest integer that meets the condition, so the function should return 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle multiple test cases efficiently, with each test case involving an array of integers and the application of the eversion operation. The output should indicate the number of iterations required for the array to stop changing. The constraints are such that the total number of elements across all test cases does not exceed 2 * 10^5, ensuring scalability.\nrequirement pool:\n- Implement the eversion operation as described.\n- Ensure the program can handle multiple test cases efficiently.\n- Provide clear and concise output for the number of eversions.\n- Optimize the code to handle large arrays without performance issues.\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will ensure the partitioning is stable by maintaining the order of elements in each part.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot element, maintaining the order of elements in each part.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). The order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find elements greater than the pivot.\n    Explanation: In the eversion operation, the right part of the array contains elements that are strictly greater than the pivot element.\n\n# [degree adverb] \n    'largest': indicates that we need to find the largest element in the array to use it as the pivot.\n    Explanation: The pivot element is chosen as the largest element in the array to ensure that the partitioning is done effectively.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will follow these steps:\n    1. For each test case, read the size of the array and the elements.\n    2. Choose the largest element in the array as the pivot.\n    3. Partition the array into two parts based on the pivot.\n    4. Concatenate the left and right parts to form the new array.\n    5. Repeat the process until the array stops changing.\n    6. Return the number of iterations it took for the array to stop changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] = 1\n    Explanation: The array is already sorted in ascending order, so after one eversion operation, the array stops changing.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The array is sorted in descending order, so after one eversion operation, the array stops changing.\n    Edge case 3: [3, 1, 2, 4, 5] = 2\n    Explanation: The array undergoes two eversion operations to reach a stable state: [2, 1, 3, 4, 5] and then [1, 2, 3, 4, 5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work for these cases as well.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array, which partitions the array into two parts based on a pivot element and then concatenates them back together. The task is to determine the number of iterations required for the array to stop changing, which indicates the stable state.\nrequirement pool:\n- Implement the eversion operation to partition the array\n- Ensure the array reaches a stable state\n- Optimize the algorithm for large arrays\n- Add user-friendly features for easy understanding\n- Enhance the user interface for better performance\nTo implement the eversion operation on an array, we will use Python's built-in data structures and functions. The eversion operation involves partitioning the array based on a pivot element and then concatenating the two parts. We will ensure the partition is stable by maintaining the order of elements in each part. The main challenge is to determine the number of iterations required for the array to reach a stable state, which indicates the stable state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot element.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). The order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the elements in the right part are strictly greater than the pivot.\n    Explanation: For example, in the requirement, \"The right part contains the elements of a that are strictly greater than x (> x).\"\n\n# [degree adverb] \n    'largest': indicates that the pivot element is the largest element in the array.\n    Explanation: In the requirement, \"Let x = a_n. Then array a is partitioned into two parts...\" where 'a_n' refers to the last element of the array, which is the largest element.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Identify the pivot element (the last element of the array).\n    2. Partition the array into two parts based on the pivot.\n    3. Concatenate the left and right parts to form the new array.\n    4. Repeat the process until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so it does not change after the first eversion operation.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is sorted in descending order, so it becomes [3, 1, 4, 2, 5] after the first eversion operation and stops changing.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion operation, the array becomes [2, 1, 3, 4, 5]. After the second eversion operation, it becomes [1, 2, 3, 4, 5], which is stable.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    To handle edge cases where the array is already sorted or nearly sorted, we can add a check to see if the array has changed after an eversion operation. If it hasn't changed, we can return the current iteration count as the number of eversions.\n\n    Example code:\n    ```python\n    def count_eversions(arr):\n        original_arr = arr.copy()\n        k = 0\n        while True:\n            pivot = arr[-1]\n            left_part = [x for x in arr[:-1] if x <= pivot]\n            right_part = [x for x in arr[:-1] if x > pivot]\n            arr = left_part + [pivot] + right_part\n            k += 1\n            if arr == original_arr:\n                break\n        return k\n    ```\n", "requirement analysis:\nThe requirements specify the need for a tool that can evert an array based on a defined operation, which involves partitioning the array into two parts based on a pivot element and then concatenating them back together. The tool should be able to handle multiple test cases efficiently and provide the number of eversions after which the array stops changing. The performance and user experience are critical, as the tool needs to handle large arrays and provide clear results.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the tool can handle multiple test cases efficiently\n- Provide a user-friendly interface for easy interaction\n- Optimize the performance for large arrays\n- Ensure the tool is scalable and can handle future enhancements\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the parts back together. We will use a stable partition algorithm to ensure the order of elements is maintained. The main challenge is to handle multiple test cases efficiently, which requires optimizing the partition and concatenation operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partition': the process of dividing a list into two parts based on a pivot element.\n    Explanation: In the eversion operation, the array is divided into two parts: one containing elements less than or equal to the pivot (left part) and the other containing elements greater than the pivot (right part). The order of elements within each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the elements in the right part are strictly greater than the pivot.\n    Explanation: In the eversion operation, the right part contains elements that are strictly greater than the pivot element.\n\n# [degree adverb] \n    'largest': indicates that the pivot element is the largest in the array.\n    Explanation: The pivot element is chosen as the largest element in the array to ensure that the right part contains elements that are strictly greater than it.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will follow these steps for each test case:\n    1. Read the input for the number of test cases and the size of the array.\n    2. Read the array elements.\n    3. Choose the pivot element as the largest element in the array.\n    4. Partition the array into left and right parts based on the pivot.\n    5. Concatenate the left and right parts to form the new array.\n    6. Repeat the partitioning and concatenation until the array stops changing.\n    7. Count the number of iterations (eversions) until the array stabilizes.\n    8. Output the count of eversions for each test case.\n\n# [edge case] \n    search([1]) = 0\n    Explanation: The array has only one element, so there are no eversions. The array does not change, and the count is 0.\n    search([2, 1]) = 1\n    Explanation: The array is partitioned into [2] (left part) and [1] (right part). After one eversion, the array becomes [2, 1], which does not change further. The count of eversions is 1.\n    search([3, 1, 2]) = 2\n    Explanation: The array is partitioned into [3] (left part) and [1, 2] (right part). After one eversion, the array becomes [3, 1, 2]. The next eversion partitions [3] and [1, 2] into [2, 1] and [3], respectively. The array does not change further. The count of eversions is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers the edge cases where the array has only one element or two elements. For larger arrays, the partitioning and concatenation will handle the edge cases implicitly.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array, which partitions the array into two parts based on a pivot element. The left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. The array is then reconstructed by concatenating these two parts. The task is to determine the number of iterations required for the array to stop changing, which indicates the stable state.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the array is partitioned and concatenated efficiently\n- Provide a user-friendly interface to display the number of eversions\n- Optimize the algorithm for large arrays\nTo implement the eversion operation efficiently, we will utilize Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the two parts. We will ensure that the partitioning is stable and that the algorithm handles large arrays efficiently. The main challenge lies in determining the number of iterations required for the array to reach a stable state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': the process of dividing a list into two parts based on a pivot element, maintaining the order of elements in each part.\n    Explanation: In the eversion operation, the array is split into two parts where the left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. The order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the elements in the right part are strictly greater than the pivot.\n    Explanation: For example, in the requirement, \"The right part contains the elements of a that are strictly greater than x (> x).\"\n\n# [degree adverb] \n    'largest': indicates that the pivot element is the largest element in the array.\n    Explanation: In the requirement, \"Let x = a_n. Then array a is partitioned into two parts...\" where 'a_n' refers to the last element of the array, which is the largest element.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will follow these steps:\n    1. For each test case, read the size of the array and the elements.\n    2. Perform the eversion operation iteratively until the array stops changing.\n    3. Count the number of iterations required for the array to reach a stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so it takes only one eversion to reach a stable state.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array is sorted in descending order, so it takes five eversions to reach a stable state.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work for these cases as well.\n\n    (code for handling the edge case)\n    # Example code to handle edge cases\n    if t == 1 and n == 1:\n        print(0)  # If there's only one element, no eversions are needed.\n    elif t == 1 and n == 2 and a[0] > a[1]:\n        print(1)  # If there are two elements and they are in descending order, one eversion is needed.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and how it affects the array. The goal is to find the minimum number of eversions after which the array stops changing. This involves partitioning the array based on a pivot and then merging the partitions while maintaining stability. The challenge lies in efficiently handling large inputs and ensuring the solution is scalable.\nrequirement pool:\n- Implement the eversion operation and partitioning logic\n- Ensure the solution is efficient and handles large inputs\n- Optimize the number of operations for large arrays\n- Test the solution for various edge cases\n- Consider memory efficiency for large datasets\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The eversion operation involves partitioning the array based on a pivot and then merging the partitions while maintaining stability. We will implement a function that performs the eversion operation iteratively until the array stops changing. To ensure efficiency, we will use list slicing to partition the array and avoid unnecessary copying of elements. The solution will be optimized to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot and then merging the partitions while maintaining stability. The pivot is the last element of the array, and the array is split into two parts: elements less than or equal to the pivot and elements greater than the pivot.\n\n    Explanation: The eversion operation is a specific way of rearranging the elements of an array based on a chosen pivot. The pivot is the last element of the array, and the array is split into two parts: elements that are less than or equal to the pivot (left part) and elements that are greater than the pivot (right part). The order of elements in each part is preserved, ensuring the partition is stable.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements greater than a certain value.\n    Explanation: In the context of the eversion operation, 'more than' is used to specify the elements that should be placed in the right part of the partitioned array.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest element in the array to use as the pivot.\n    Explanation: In the eversion operation, the largest element is chosen as the pivot to ensure that the right part of the partition contains elements greater than the pivot.\n\n# [code logic]\n    To implement the eversion operation, we will follow these steps:\n    1. Identify the pivot as the last element of the array.\n    2. Partition the array into two parts: elements less than or equal to the pivot and elements greater than the pivot.\n    3. Merge the two parts while maintaining the order of elements within each part.\n    4. Repeat the process until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already consists of identical elements, so no eversion is needed, and the array stops changing after 0 eversions.\n\n    Edge case 2: [2, 1, 3, 3, 2] = 1\n    Explanation: The first eversion will result in [1, 2, 3, 3, 2], with a pivot of 2. The next eversion will result in [1, 2, 2, 3, 3], with a pivot of 3. The array stops changing after 1 eversion.\n\n    Edge case 3: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will result in [4, 3, 2, 1, 5], with a pivot of 5. The array stops changing after 1 eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will work correctly for arrays with identical elements or arrays that stabilize after a single eversion.\n"], "scores": [], "pass_results": [true, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 33, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "rephrase_one", "parent_index": 32}
