{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaged in yet another video game. In this game, his character has the task of vanquishing a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon using a poisoned dagger. The i-th attack occurs at the start of the a_i-th second from the beginning of the battle. The dagger doesn't inflict direct damage, but instead, it imposes a poison effect on the dragon, causing 1 damage during each of the succeeding k seconds (starting with the same second when the dragon was stabbed by the dagger). Nonetheless, if the dragon is already poisoned, the dagger refreshes the poison effect (i.e. nullifies the existing poison effect and introduces a fresh one).\n\nFor instance, assume k = 4, and Monocarp strikes the dragon during the seconds 2, 4 and 10. Then, the poison effect is initiated at the start of the 2-nd second and causes 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the poison effect is reinstated, causing precisely 1 damage during the seconds 4, 5, 6 and 7; then, at the 10-th second, the poison effect is once more applied, resulting in 1 damage during the seconds 10, 11, 12 and 13. Overall, the dragon takes 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon throughout the battle \u2014 he defeats the dragon. Monocarp has yet to decide on the potency of the poison he'll employ during the fight, so he aims to determine the smallest possible value of k (the duration in seconds the poison effect persists) sufficient to inflict at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaged in yet another video game. In this game, his character has the task of vanquishing a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon using a poisoned dagger. The i-th attack occurs at the start of the a_i-th second from the beginning of the battle. The dagger doesn't inflict direct damage, but instead, it imposes a poison effect on the dragon, causing 1 damage during each of the succeeding k seconds (starting with the same second when the dragon was stabbed by the dagger). Nonetheless, if the dragon is already poisoned, the dagger refreshes the poison effect (i.e. nullifies the existing poison effect and introduces a fresh one).\n\nFor instance, assume k = 4, and Monocarp strikes the dragon during the seconds 2, 4 and 10. Then, the poison effect is initiated at the start of the 2-nd second and causes 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the poison effect is reinstated, causing precisely 1 damage during the seconds 4, 5, 6 and 7; then, at the 10-th second, the poison effect is once more applied, resulting in 1 damage during the seconds 10, 11, 12 and 13. Overall, the dragon takes 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon throughout the battle \u2014 he defeats the dragon. Monocarp has yet to decide on the potency of the poison he'll employ during the fight, so he aims to determine the smallest possible value of k (the duration in seconds the poison effect persists) sufficient to inflict at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_defeat_dragon(k: int) -> bool:\n        damage = 0\n        last_attack = 0\n        for attack in attacks:\n            start = attack\n            end = attack + k - 1\n            if start > last_attack:\n                damage += k\n            else:\n                damage += max(0, end - last_attack)\n            if damage >= h:\n                return True\n            last_attack = max(last_attack, end)\n        return damage >= h\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_defeat_dragon(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Provide input interface using input(), DO NOT use stdin\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n\n# Provide output interface using print()\nfor _ in range(n):\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    \"\"\"\n    Find the minimum value of k such that Monocarp inflicts at least h damage on the dragon.\n\n    Args:\n        attacks (List[int]): List of attack times.\n        h (int): The amount of damage that needs to be dealt.\n\n    Returns:\n        int: The minimum value of k.\n    \"\"\"\n    attacks.sort()\n    n = len(attacks)\n\n    # Calculate the total damage if k is 1\n    total_damage_k1 = sum(attacks[i+1] - attacks[i] for i in range(n - 1))\n    if total_damage_k1 >= h:\n        return 1\n\n    # Binary search to find the minimum k\n    left, right = 2, attacks[-1] - attacks[0]\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        for i in range(n - 1):\n            total_damage += min(mid, attacks[i + 1] - attacks[i])\n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_k(attacks: List[int], h: int) -> int:\n    def can_defeat_dragon(k: int) -> bool:\n        damage = 0\n        last_poison_end = 0\n        for attack_time in attacks:\n            poison_start = attack_time\n            poison_end = poison_start + k - 1\n            damage += max(0, poison_end - last_poison_end)\n            last_poison_end = max(last_poison_end, poison_end + 1)\n        damage += max(0, h - last_poison_end + 1)\n        return damage >= h\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_defeat_dragon(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_minimum_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_min_k(attacks: List[int], h: int, max_attack: int) -> int:\n    def can_defeat_dragon(k: int) -> bool:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time < k:\n                damage += 1\n            else:\n                damage += 2\n            last_attack_time = attack_time\n        return damage >= h\n\n    left, right = 1, max_attack\n    while left < right:\n        mid = (left + right) // 2\n        if can_defeat_dragon(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Provide the Interface\nfrom typing import List\n\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = calculate_min_k(attacks, h, max(attacks))\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_minimum_k(attacks, h):\n    # Sort the attacks list to process them in order\n    attacks.sort()\n    \n    # Initialize the possible range for k\n    left, right = 1, h\n    \n    # Function to calculate the total damage for a given k\n    def total_damage(k):\n        damage = 0\n        last_poison_end = 0\n        for attack in attacks:\n            if attack != last_poison_end:\n                damage += k\n                last_poison_end = attack + k\n            else:\n                damage += k\n        return damage\n    \n    # Binary search to find the minimum k\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    \n    # Find and print the minimum k for each test case\n    result = find_minimum_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_minimum_k(attacks: List[int], h: int) -> int:\n    attacks.sort()\n    max_gap = attacks[-1] - attacks[-2]\n    second_max_gap = attacks[-2] - attacks[0]\n    \n    if h <= max_gap:\n        return 1\n    if h <= second_max_gap + max_gap:\n        return 2\n    return (h + max_gap - 1) // max_gap  # Ceiling division\n\n# Provide input interface using input(), DO NOT use stdin\nn, h = map(int, input().split())\nattacks = list(map(int, input().split()))\n\n# Provide output interface using print().\nresult = find_minimum_k(attacks, h)\nprint(result)\n", "from typing import List\n## main.py\n\ndef find_min_k(attacks, h):\n    def can_achieve_damage(k):\n        total_damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time > last_attack_time:\n                total_damage += (attack_time - last_attack_time) // k\n                last_attack_time = attack_time\n        return total_damage >= h\n\n    left, right = 1, max(attacks) * h\n    while left < right:\n        mid = (left + right) // 2\n        if can_achieve_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_k(attacks: List[int], h: int) -> int:\n    attacks.sort()\n    n = len(attacks)\n    \n    # Calculate the total damage if k is the difference between the last two attacks\n    k = attacks[-1] - attacks[-2]\n    total_damage = k * (n - 1)\n    \n    if total_damage >= h:\n        return k\n    \n    # If the total damage is still not enough, check if we can increase k to cover the entire range\n    remaining_damage = h - total_damage\n    if remaining_damage <= attacks[-1]:\n        return k + 1\n    \n    # If we still can't cover the damage, increase k to cover the entire range and then some\n    return k + (remaining_damage + n - 2) // (n - 1)\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = calculate_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_deal_damage(k: int) -> bool:\n        damage = 0\n        last_poison_end = 0\n        for attack_time in attacks:\n            if attack_time > last_poison_end:\n                damage += (attack_time - last_poison_end + k - 2) // (k - 1)\n                last_poison_end = attack_time\n        damage += (h - last_poison_end + k - 2) // (k - 1)\n        return damage <= h\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_defeat_dragon(k: int) -> bool:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time < k:\n                damage += 1\n            else:\n                damage += 2\n            last_attack_time = attack_time\n        return damage >= h\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_defeat_dragon(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements involve creating a game where the player must strategically attack a dragon to inflict poison damage over time. The challenge lies in determining the minimum duration of the poison effect required to defeat the dragon. The game must handle large numbers and efficiently calculate the minimum k value for each test case. The interface should be simple and intuitive, allowing players to focus on the gameplay.\nrequirement pool:\n- Implement the game logic for calculating the minimum k value.\n- Develop a user interface that displays game information clearly.\n- Ensure the game can handle large inputs and perform efficiently.\n- Add difficulty settings to cater to players of different skill levels.\n- Include a scoring system to track player progress.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach will be efficient in handling large inputs and performing the necessary calculations. We will also use a sorted list to keep track of the attack times, which will allow us to quickly determine the intervals during which the poison effect is active.\n", "requirement analysis:\nThe requirements for this project involve creating a game where the player must determine the minimum potency of poison needed to defeat a dragon. The game involves attacks at specific times, and the poison effect needs to be calculated to ensure the dragon is damaged sufficiently. The challenge lies in determining the smallest k value that will inflict the required damage. The game should be designed with simplicity in mind, focusing on the core gameplay mechanics.\nrequirement pool:\n- Implement the game mechanics for attack times and poison effects.\n- Develop a system to calculate the minimum k value needed to inflict the required damage.\n- Create a user interface that is visually appealing and responsive.\n- Ensure the game is accessible and can be played on various devices.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will be used to efficiently determine the smallest k that ensures Monocarp inflicts at least h damage on the dragon. We will sort the attack times and then use a function to calculate the total damage inflicted by the poison effects for a given k. This approach will ensure that we efficiently find the minimum k without having to simulate each second of the battle.\n", "requirement analysis:\nThe requirements for this project involve creating a game where the player must determine the minimum potency of poison needed to defeat a dragon. The game should be engaging, with a clear objective and user interface. The requirements also include handling large numbers and ensuring the game is accessible across different platforms.\nrequirement pool:\n- Implement the game logic for calculating the minimum poison potency.\n- Ensure the game interface is responsive and visually appealing.\n- Handle large numbers efficiently to manage the duration of the poison effect.\n- Allow players to choose different difficulty levels.\n- Provide a restart button for players who lose.\nTo tackle the problem of determining the minimum potency of poison needed to defeat the dragon, we will use Python due to its robust standard library and ability to handle large numbers efficiently. The main challenge lies in calculating the cumulative damage inflicted by the poison over time, considering the potential for multiple attacks within the poison's duration. We will use a binary search approach to efficiently find the minimum k value.\n", "requirement analysis:\nThe project requires a main function to read input from stdin, process the data to determine the minimum value of k, and output the result to stdout. The input consists of multiple test cases, each with a specific number of attacks and the required damage. The output should provide the smallest k for each test case to inflict at least the required damage.\nrequirement pool:\n- Implement a function to read input from stdin.\n- Implement a function to calculate the minimum k for each test case.\n- Implement a function to output the result to stdout.\n- Ensure the program can handle multiple test cases efficiently.\n- Optimize the algorithm to find the minimum k efficiently.\nWe will use Python for this project due to its simplicity and readability. The main challenge is to efficiently calculate the minimum k for each test case given the constraints. We will use binary search to optimize the search for the minimum k.\n", "requirement analysis:\nThe requirements for this project involve creating a game where the player must determine the minimum potency of poison needed to defeat a dragon. The game should be engaging, with a clear objective and user interface. The requirements also include handling large numbers and ensuring the game is accessible across different platforms.\nrequirement pool:\n- Implement the game logic for calculating the minimum poison potency.\n- Ensure the game interface is responsive and visually appealing.\n- Develop a user-friendly interface for selecting game settings and displaying scores.\n- Optimize the game for different devices and screen sizes.\n- Include options for different difficulty levels to cater to players of various skill levels.\nTo tackle the problem of determining the minimum potency of poison needed to defeat the dragon, we will use a Python script that calculates the smallest value of k based on the given attacks and the required damage. We will use a brute-force approach to iterate through possible values of k and check if the total damage inflicted is at least h. This approach will be efficient enough given the constraints of the problem.\n", "requirement analysis:\nThe project requires creating a game where the player must determine the minimum potency of poison to defeat a dragon. The game involves attacks at specific times, and the poison effect needs to be calculated to inflict the required damage. The challenge lies in balancing the game mechanics to ensure the player faces a fair and engaging challenge.\nrequirement pool:\n- Implement the game mechanics for attacks and poison effects.\n- Develop a system to calculate the minimum k value for each test case.\n- Create a user interface for the game with options for difficulty levels.\n- Implement a scoring system to track player progress.\nTo tackle the problem, we will use Python due to its simplicity and powerful standard libraries. The main challenge is to calculate the minimum value of k such that the total damage inflicted by Monocarp's attacks with poison is at least h. We will approach this by simulating each attack and calculating the poison effect duration, then find the smallest k that meets the requirement.\n", "requirement analysis:\nThe project requires a main function to read input, calculate the minimum value of k, and print the result for each test case. The input includes the number of test cases, the number of attacks and the damage required, and the times of each attack. The output should be the smallest k that ensures the dragon is defeated.\nrequirement pool:\n- Implement the main function to read input and output results.\n- Calculate the minimum value of k based on the given attacks and required damage.\n- Ensure the program can handle multiple test cases efficiently.\n- Ensure the program is user-friendly and can be easily understood.\n- Ensure the program is optimized for performance and can handle large inputs.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach is efficient and suitable for handling large inputs. We will read the number of test cases and then for each test case, we will read the number of attacks and the required damage. We will then read the times of each attack. Using binary search, we will determine the minimum value of k that ensures Monocarp causes at least h damage to the dragon.\n", "requirement analysis:\nThe project requires a main function to read input, calculate the minimum value of k, and print the result for each test case. The input includes the number of test cases, the number of attacks and the damage required, and the times of each attack. The output should be the smallest k that ensures the dragon is defeated.\nrequirement pool:\n- Implement the main function to read input and output results.\n- Calculate the minimum value of k based on the given attacks and required damage.\n- Ensure the game mechanics are balanced and fair.\n- Develop a user-friendly interface for easy gameplay.\nWe will use Python for the implementation as it is versatile and supports large integer calculations. The main challenge is to calculate the minimum value of k such that the total damage inflicted by Monocarp's attacks is at least h. This involves determining the intervals in which the poison effect occurs and summing them up.\n", "requirement analysis:\nThe project requires a main function that reads input from stdin, processes the data to determine the minimum value of k, and outputs the result to stdout. The input consists of multiple test cases, each with a specific number of attacks and the required damage. The output should provide the smallest k for each test case to ensure the dragon is defeated.\nrequirement pool:\n- Implement a function to read input from stdin.\n- Develop a function to calculate the minimum k for each test case.\n- Ensure the output is given to stdout in the correct format.\n- Create a user-friendly interface for input and output.\n- Optimize the algorithm to handle large inputs efficiently.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach will be efficient for handling large inputs. We will read the number of test cases and then for each test case, we will read the number of attacks and the required damage. We will then read the attack times and use a binary search to find the minimum k that satisfies the condition.\n", "requirement analysis:\nThe project requires a main function to read input from stdin, process the data according to the given rules, and output the result to stdout. The input consists of multiple test cases, each with a specific number of attacks and the required damage. The output should provide the smallest value of k that ensures the dragon is defeated. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to read input from stdin.\n- Develop a function to calculate the minimum value of k.\n- Ensure the program can handle multiple test cases efficiently.\n- Create a user-friendly interface for input and output.\n- Optimize the algorithm to handle large inputs within a reasonable time frame.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach is efficient and suitable for handling large inputs within a reasonable time frame. We will read the input, process each test case, and output the result for each case.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 15, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 15}
