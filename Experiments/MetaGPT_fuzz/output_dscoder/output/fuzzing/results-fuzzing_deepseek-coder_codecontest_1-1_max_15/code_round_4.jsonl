{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city can be represented as a plane. He is planning a housing complex that will be built in this city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). The Euclidean distance between two points is important for calculating S(x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city can be represented as a plane. He is planning a housing complex that will be built in this city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). The Euclidean distance between two points is important for calculating S(x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef calculate_distance(grid, x, y, n, m) -> int:\n    min_distance = float('inf')\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distance = (x - i) ** 2 + (y - j) ** 2\n                if distance < min_distance:\n                    min_distance = distance\n    return min_distance\n\ndef main(grid, n, m) -> int:\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_distance(grid, x, y, n, m)\n    return total_sum\n\n# Interface\nn, m = map(int, input().split())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\nresult = main(grid, n, m)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_distances(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Initialize the distances grid with a large number\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Add all poles to the queue and set their distances to 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distances[i][j] = 0\n                queue.append((i, j))\n    \n    # Directions for BFS (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # BFS to calculate the nearest pole distance for each point\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distances[nx][ny] > distances[x][y] + 1:\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of distances\n    sum_of_distances = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_distances += distances[i][j] ** 2\n    \n    return sum_of_distances\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_distances(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nimport sys\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Initialize the distance grid with a large number\n    distance_grid = [[sys.maxsize] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = []\n    \n    # Add all poles to the queue and initialize their distances\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n                distance_grid[i][j] = 0\n    \n    # Directions for 4-connected grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to calculate distances from all poles\n    while queue:\n        x, y = queue.pop(0)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                distance_grid[nx][ny] = distance_grid[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of squares of distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += distance_grid[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nimport math\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    sum_of_squares = 0\n\n    # Precompute the minimum distance to a pole for each point in the grid\n    min_distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                min_distance_grid[i][j] = 0\n            else:\n                if i > 0:\n                    min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i - 1][j] + 1)\n                if j > 0:\n                    min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i][j - 1] + 1)\n    \n    for i in range(n, -1, -1):\n        for j in range(m, -1, -1):\n            if i < n:\n                min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i + 1][j] + 1)\n            if j < m:\n                min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i][j + 1] + 1)\n    \n    # Calculate the sum of squares of distances\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += min_distance_grid[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\ndef calculate_distance_sum(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    total_distance_sum = 0\n\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                distance_sum = 0\n            else:\n                min_distance_squared = sys.maxsize\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                distance_sum = min_distance_squared\n            total_distance_sum += distance_sum\n\n    return total_distance_sum\n\n# Interface\nn, m = map(int, input().split())\ngrid = [list(map(int, list(input()))) for _ in range(n + 1)]\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    sum_of_squares = 0\n\n    # Pre-compute the minimum distance to any pole for each point in the grid\n    min_distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                min_distance_grid[i][j] = 0\n            else:\n                if i > 0:\n                    min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i - 1][j] + 1)\n                if j > 0:\n                    min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i][j - 1] + 1)\n    \n    for i in range(n, -1, -1):\n        for j in range(m, -1, -1):\n            if i < n:\n                min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i + 1][j] + 1)\n            if j < m:\n                min_distance_grid[i][j] = min(min_distance_grid[i][j], min_distance_grid[i][j + 1] + 1)\n    \n    # Calculate the sum of squares for each point in the grid\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += min_distance_grid[i][j] ** 2\n    \n    return sum_of_squares\n\n# Interface\nn, m = map(int, input().split())\ngrid = [list(map(int, list(input().strip()))) for _ in range(n + 1)]\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Find all positions of telephone poles\n    poles = []\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                poles.append((i, j))\n    \n    # Define the directions for BFS\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize the distance grid with a large number\n    distance = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # BFS queue\n    queue = deque()\n    \n    # Initialize the queue with all pole positions\n    for pole in poles:\n        x, y = pole\n        distance[x][y] = 0\n        queue.append(pole)\n    \n    # Perform BFS to calculate distances\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distance[nx][ny] > distance[x][y] + 1:\n                distance[nx][ny] = distance[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Sum up the squares of distances\n    result = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            result += distance[i][j] ** 2\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate the result\nresult = calculate_sum_of_squares(grid)\n\n# Output the result\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Initialize the distance grid with a large number\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Pre-compute the minimum distance to the nearest telephone pole\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distance_grid[i][j] = 0\n            else:\n                if i > 0:\n                    distance_grid[i][j] = min(distance_grid[i][j], distance_grid[i - 1][j] + 1)\n                if j > 0:\n                    distance_grid[i][j] = min(distance_grid[i][j], distance_grid[i][j - 1] + 1)\n    \n    # Update the distance grid from the bottom-right to the top-left\n    for i in range(n, -1, -1):\n        for j in range(m, -1, -1):\n            if i < n:\n                distance_grid[i][j] = min(distance_grid[i][j], distance_grid[i + 1][j] + 1)\n            if j < m:\n                distance_grid[i][j] = min(distance_grid[i][j], distance_grid[i][j + 1] + 1)\n    \n    # Calculate the sum of squares of the distances\n    result = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            result += distance_grid[i][j] ** 2\n    \n    return result\n\n# Read input from stdin\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\nimport sys\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    sum_of_squares = 0\n\n    # Pre-compute the minimum distance to a pole for each point\n    min_distance = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                min_distance[x][y] = 0\n            else:\n                if x > 0:\n                    min_distance[x][y] = min(min_distance[x][y], min_distance[x - 1][y] + 1)\n                if y > 0:\n                    min_distance[x][y] = min(min_distance[x][y], min_distance[x][y - 1] + 1)\n    \n    for x in range(n + 1):\n        for y in range(m + 1):\n            if x < n:\n                min_distance[x][y] = min(min_distance[x][y], min_distance[x + 1][y] + 1)\n            if y < m:\n                min_distance[x][y] = min(min_distance[x][y], min_distance[x][y + 1] + 1)\n    \n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squares += min_distance[x][y] ** 2\n\n    return sum_of_squares\n\n# Interface\nn, m = map(int, input().split())\ngrid = [list(map(int, list(input()))) for _ in range(n + 1)]\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Directions for BFS\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize the distance grid with a large number\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Add all poles to the queue and set their distance to 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distance_grid[i][j] = 0\n                queue.append((i, j))\n    \n    # BFS to calculate the distance from each point to the nearest pole\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                distance_grid[nx][ny] = distance_grid[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of squares of distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += distance_grid[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n"], "plans": ["requirement analysis:\nThe project requires a program that can handle large grids efficiently, calculate the Euclidean distance to the nearest pole for each point, and sum these distances. The program should be able to read input from standard input and output the result to standard output.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest pole for each point in the grid.\n- Develop a main function to read the grid size and pole positions, and calculate the sum of S(x, y) for each point.\n- Optimize the code for large grid sizes to ensure performance.\n- Ensure the program can handle edge cases, such as no poles or multiple poles at the same location.\nTo solve this problem, we will use Python due to its efficiency and ease of handling mathematical operations. The main challenge is to calculate the Euclidean distance to the nearest pole for each point in the grid efficiently. We will use a brute-force approach initially and optimize it later if necessary. The program will read the grid size and pole positions, calculate the sum of S(x, y) for each point, and output the result.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances to the nearest telephone pole for each point in a grid. This involves finding the minimum distance from each point to any pole and then summing these distances. The grid size is up to 2000x2000, which requires an efficient algorithm to handle large datasets.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest telephone pole for each point in the grid.\n- Develop a main function to sum the squares of these distances.\n- Optimize the algorithm for large grid sizes.\n- Ensure the output is in the correct format and matches the given examples.\nTo solve this problem efficiently, we will use a combination of breadth-first search (BFS) and dynamic programming. The BFS will be used to find the nearest telephone pole for each point, and dynamic programming will help in optimizing the calculation for large grids. We will preprocess the grid to store the nearest pole distance for each point, which will significantly reduce the computation time.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. This involves finding the minimum distance for each point to any pole and then summing these distances. The grid size is up to 2000x2000, so an efficient algorithm is necessary to handle this within reasonable time constraints.\nrequirement pool:\n- Implement an algorithm to find the nearest pole for each point in the grid.\n- Optimize the algorithm to handle large grids efficiently.\n- Ensure the output is accurate and in the required format.\n- Test the solution with various grid sizes to ensure performance.\n- Provide a user-friendly interface for input and output.\nTo solve this problem efficiently, we will use a combination of Breadth-First Search (BFS) and a distance transform approach. The BFS will be used to find the nearest pole for each point, and the distance transform will help in calculating the square of the Euclidean distance efficiently. We will preprocess the grid to store the distances from each pole to all other points, which will allow us to quickly find the nearest pole for any given point.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances from each point in a grid to the nearest telephone pole. This involves finding the minimum distance for each point to any pole and then summing these distances. The grid size is up to 2000x2000, which requires an efficient algorithm to handle the computation within reasonable time.\nrequirement pool:\n- Implement an algorithm to calculate the minimum distance from each point to the nearest pole.\n- Ensure the solution is optimized for large grids.\n- Provide a clear and concise output for the given problem.\n- Test the solution with various grid sizes to ensure scalability.\n- Optimize the code for better performance.\nTo solve this problem efficiently, we will use a combination of a brute-force approach and optimizations. The brute-force approach will involve checking the distance to all poles for each point in the grid. However, to handle large grids efficiently, we will use a precomputation technique to store the distances from each point to the nearest pole, which can be reused for different queries. This will significantly reduce the computation time for each point.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. This involves identifying the nearest pole for each point and computing the distance, then summing these distances. The solution should be efficient and handle large grids efficiently within the given constraints.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest telephone pole for each point in the grid.\n- Develop a main function to compute the sum of squares of distances.\n- Optimize the distance calculation for efficiency.\n- Ensure the solution can handle edge cases, such as grids with no poles or multiple poles.\nTo solve this problem efficiently, we will use Python's built-in libraries and optimize the distance calculations. We will iterate through each point in the grid, find the nearest telephone pole, and compute the square of the Euclidean distance. The sum of these distances for all points will be our final result.\n", "requirement analysis:\nThe requirements involve calculating the sum of squares of Euclidean distances from each point in a grid to the nearest telephone pole. This is a classic problem in computational geometry and requires an efficient algorithm to handle large grids within the given constraints. The solution should be able to handle inputs up to 2000x2000, which necessitates an optimized approach to avoid performance issues.\nrequirement pool:\n- Implement an algorithm to calculate the Euclidean distance to the nearest pole for each point in the grid.\n- Ensure the solution is optimized for large grids to handle inputs up to 2000x2000.\n- Provide a clear and accurate output for the sum of squares of distances.\n- Implement input parsing to handle different grid sizes and pole positions.\n- Include error handling to manage unexpected inputs or edge cases.\nTo solve this problem efficiently, we will use a brute-force approach to calculate the Euclidean distance from each point in the grid to the nearest telephone pole. Given the constraints, we will optimize the process by pre-computing the distances for each pole position and then summing them up for each point in the grid. This approach will ensure that we can handle the large grid sizes within the given constraints.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. This involves finding the minimum distance for each point to any pole and then summing these distances. The grid size is up to 2000x2000, so an efficient algorithm is necessary to handle this within reasonable time constraints.\nrequirement pool:\n- Implement an algorithm to find the nearest pole for each point in the grid.\n- Optimize the algorithm to handle large grids efficiently.\n- Ensure the output is accurate and in the required format.\n- Test the solution with various grid sizes to ensure performance.\n- Provide clear and concise documentation for the code.\nTo solve this problem efficiently, we will use a Breadth-First Search (BFS) approach to find the nearest telephone pole for each point in the grid. BFS is suitable for this problem because it explores all points at the present depth level before moving on to the points at the next depth level, ensuring that we find the shortest path to the nearest pole. We will preprocess the grid to store the positions of all telephone poles and then use BFS to calculate the distance to the nearest pole for each point in the grid. This approach ensures that we handle large grids efficiently without running into performance issues.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances to the nearest telephone pole for each point in a grid. The grid size can be large, up to 2000x2000, so an efficient solution is necessary to handle this. The input includes the grid size and the positions of telephone poles, and the output is the sum of squares of distances for all points in the grid.\nrequirement pool:\n- Implement an efficient algorithm to calculate the sum of squares of Euclidean distances.\n- Ensure the solution can handle large grids efficiently.\n- Provide clear and accurate output for the given problem.\n- Test the solution against multiple test cases to ensure robustness.\n- Optimize the code for better performance.\nTo solve this problem efficiently, we will use a grid-based approach to calculate the sum of squares of Euclidean distances to the nearest telephone pole. We will leverage the fact that the grid size is relatively small (up to 2000x2000) and use a pre-computation technique to avoid recalculating distances for each point. This approach will involve creating a distance grid where each cell stores the minimum distance to any telephone pole. We will then sum up the squares of these distances to get the final result.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances to the nearest telephone pole for each point in a grid. The solution should be efficient and handle large grids within the given constraints. The output should be a single integer representing the sum of all S(x, y) values.\nrequirement pool:\n- Implement an efficient algorithm to calculate the sum of squares of Euclidean distances.\n- Ensure the solution can handle large grids within the given constraints.\n- Provide a clear and concise output for the given problem.\n- Test the solution with various test cases to ensure accuracy and robustness.\n- Optimize the algorithm for better performance.\nTo solve this problem efficiently, we will use a combination of a grid traversal and distance calculation. We will iterate through each point in the grid and calculate the Euclidean distance to the nearest pole using a brute-force approach. This method is straightforward but may be slow for large grids. However, given the constraints (0 \u2264 n, m < 2000), this approach should be feasible. We will ensure the solution is optimized for large grids by leveraging Python's efficient list operations and avoiding unnecessary computations.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. This involves finding the minimum distance for each point to any pole and then summing these values. The grid size can be large, so optimization is crucial. The output should be an integer representing the total sum of these distances.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Find the nearest telephone pole for each point in the grid.\n- Calculate the sum of squares of these distances.\n- Optimize the algorithm to handle large grids efficiently.\n- Ensure the output is in the correct format and within the given constraints.\nTo solve this problem efficiently, we will use a combination of a brute-force approach and optimizations. We will iterate through each point in the grid and calculate the Euclidean distance to the nearest pole. To optimize this, we will preprocess the grid to store the distances from each point to the nearest pole, which can be done using a Breadth-First Search (BFS) approach.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 4, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "expand_one2two", "parent_index": 4}
