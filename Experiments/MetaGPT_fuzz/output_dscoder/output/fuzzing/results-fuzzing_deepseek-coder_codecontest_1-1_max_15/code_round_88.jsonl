{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You possess a sequence of integers (starting off as vacant).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 append the element x to the conclusion of the array; \n  * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. \n\nFind the resulting array after performing all the queries. Ensure the array maintains its order after all operations are performed.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You possess a sequence of integers (starting off as vacant).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 append the element x to the conclusion of the array; \n  * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. \n\nFind the resulting array after performing all the queries. Ensure the array maintains its order after all operations are performed.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef func(queries: List[List[int]]) -> List[int]:\n    sequence = []\n    \n    for query in queries:\n        if query[0] == 1:\n            sequence.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            sequence = [y if elem == x else elem for elem in sequence]\n    \n    return sequence\n\n# Interface\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef process_queries(q: int, queries: List[List[int]]) -> List[int]:\n    result = []\n    \n    for query in queries:\n        if query[0] == 1:\n            result.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            result = [y if num == x else num for num in result]\n    \n    return result\n\n# Interface\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = process_queries(q, queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result = []\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            result.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            result = [y if num == x else num for num in result]\n    return result\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef process_queries(q: int, queries: List[List[int]]) -> List[int]:\n    result_list = []\n    \n    for query in queries:\n        if query[0] == 1:\n            result_list.append(query[1])\n        elif query[0] == 2:\n            for i in range(len(result_list)):\n                if result_list[i] == query[1]:\n                    result_list[i] = query[2]\n    \n    return result_list\n\n# Interface\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = process_queries(q, queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\ndef process_queries(q: int) -> list:\n    sequence = []\n    \n    for _ in range(q):\n        query = input().split()\n        query_type = int(query[0])\n        \n        if query_type == 1:\n            x = int(query[1])\n            sequence.append(x)\n        elif query_type == 2:\n            x = int(query[1])\n            y = int(query[2])\n            sequence = [y if elem == x else elem for elem in sequence]\n    \n    return sequence\n\n# Read the number of queries\nq = int(input())\nresult = process_queries(q)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport sys\ninput = sys.stdin.readline\n\ndef process_queries(q: int) -> list:\n    sequence = []\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            sequence.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            sequence = [y if elem == x else elem for elem in sequence]\n    return sequence\n\n# Provide the Interface\nq = int(input())\nresult = process_queries(q)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(queries: List[str]) -> List[int]:\n    array = []\n    replacement_map = {}\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            array.append(x)\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            replacement_map[x] = y\n    \n    # Perform replacements in one pass\n    for i in range(len(array)):\n        if array[i] in replacement_map:\n            array[i] = replacement_map[array[i]]\n    \n    return array\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = process_queries(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef process_queries(queries: List[str]) -> List[int]:\n    result = []\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            result.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            result = [y if num == x else num for num in result]\n    return result\n\n# Interface\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = process_queries(queries)\nfor num in result:\n    print(num, end=' ')\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef process_queries(queries: List[str]) -> List[int]:\n    result = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            result.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            result = [y if num == x else num for num in result]\n    \n    return result\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = process_queries(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\ndef handle_queries(q: int) -> list:\n    sequence = []\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        \n        if query[0] == 1:\n            sequence.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            sequence = [y if elem == x else elem for elem in sequence]\n    \n    return sequence\n\n# Interface\nq = int(input())\nresult = handle_queries(q)\nprint(*result)\n"], "plans": ["requirement analysis:\nThe requirements specify the need for a program that can handle two types of queries on a sequence of integers. The first type of query adds an element to the end of the sequence, while the second type replaces all occurrences of a specified element with another value. The program must maintain the order of the sequence and handle a large number of queries efficiently.\nrequirement pool:\n- Implement the ability to add elements to the sequence via the first type of query.\n- Implement the ability to replace elements in the sequence via the second type of query.\n- Ensure the sequence maintains its order after all operations are performed.\n- Optimize the program to handle a large number of queries efficiently.\nTo implement the requirements, we will use Python, leveraging its simplicity and efficiency. The program will handle two types of queries: adding an element to the sequence and replacing all occurrences of a specified element with another value. We will use a list to store the sequence, which allows for efficient appending and updating operations. The program will ensure that the sequence maintains its order after all operations are performed.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle two types of queries on a sequence of integers. The first type allows appending an element to the sequence, and the second type allows replacing all occurrences of a specified element with another element. The program must maintain the order of the sequence and handle a large number of queries efficiently.\nrequirement pool:\n- Implement the ability to append elements to the sequence.\n- Implement the ability to replace elements in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Handle a large number of queries efficiently.\nTo implement the requirements, we will use a simple and efficient approach using Python's built-in list data structure. The list will dynamically grow as we append elements and can be efficiently modified by replacing elements based on their values. The operations will be performed sequentially, ensuring that each query is processed one by one.\n", "requirement analysis:\nThe requirements specify a need for a sequence manipulation tool that can handle two types of operations: appending elements and replacing specific elements with others. The system must maintain the order of elements and handle a large number of operations efficiently. The user interface should be intuitive, allowing users to easily perform the required operations.\nrequirement pool:\n- Implement the ability to append elements to the sequence.\n- Allow the replacement of specific elements in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Handle a large number of operations efficiently.\n- Provide a user-friendly interface for easy interaction.\nWe will use Python's built-in list data structure to store the sequence of integers. For each query, we will implement the logic to either append an element or replace all occurrences of a specific element with another element. To ensure efficiency, we will avoid unnecessary list operations by keeping track of the sequence's length and updating elements directly.\n", "requirement analysis:\nThe requirements involve managing a sequence of integers with two types of operations: appending an element and substituting one element for another. The operations need to be performed efficiently, especially considering the upper limits for the number of queries and the values of the integers involved.\nrequirement pool:\n- The main code should handle the input and output efficiently.\n- The code should correctly process the append and substitute operations.\n- The user interface should be responsive and visually appealing.\n- The product should be accessible and work well on mobile devices.\n- The product should provide a clear and engaging user experience.\nTo efficiently handle the sequence of integer operations as described, we will use a Python list to store the sequence of integers. For each query, we will perform the corresponding operation: appending an element or substituting one element with another. We will ensure that the operations are performed efficiently by leveraging Python's dynamic array nature, which allows for efficient append operations. For the substitute operation, we will iterate through the list to replace all occurrences of the specified element.\n", "requirement analysis:\nThe requirements involve managing a sequence of integers with two types of operations: appending an element and replacing occurrences of a specific element with another element. The operations need to be performed efficiently, especially considering the upper limits for the number of queries and the values of elements.\nrequirement pool:\n- Implement the ability to append integers to the sequence.\n- Implement the ability to replace occurrences of one integer with another in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Optimize performance for handling a large number of queries and elements.\nTo implement the requirements, we will use Python, leveraging its dynamic nature and the ability to handle large datasets efficiently. The solution will involve creating a list to store the sequence of integers and processing each query to either append an element or replace occurrences of a specific element with another element. We will ensure that the sequence maintains its order after all operations by using standard list operations.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle two types of queries: appending an integer to a sequence and substituting one integer with another. The program must maintain the order of the sequence and provide the final sequence after all operations are performed. The input is structured with the first line indicating the number of queries, followed by each query on a new line.\nrequirement pool:\n- The main code must handle the input and output format as specified.\n- The program must be able to append integers to the sequence.\n- The program must be able to substitute one integer with another in the sequence.\n- The program should maintain the order of the sequence.\n- The program should provide the final sequence after all operations are performed.\nTo implement the solution, we will use a simple and efficient approach using Python's built-in data structures and list operations. The list will be used to store the sequence of integers, and we will handle the queries by either appending an element or replacing all occurrences of a specified element with another. The operations will be performed efficiently to ensure the application can handle large volumes of data.\n", "requirement analysis:\nThe requirements specify a dynamic array that can be modified in two ways: appending an element and replacing all occurrences of a specified element with another element. The array must maintain its order after all operations. The input consists of a number of queries, each specifying either an append operation or a replace operation. The output is the final state of the array after all queries have been processed.\nrequirement pool:\n- The main code must handle the input and output efficiently.\n- The array must maintain its order after all operations.\n- The system should handle up to 5 * 10^5 queries.\n- The system should handle integers up to 5 * 10^5.\n- The user interface should be responsive and visually appealing.\nTo implement the dynamic array functionality with the specified operations, we will use Python's built-in list data structure, which is efficient for append operations. For the replace operation, we will iterate through the list to find and replace all occurrences of a specified element. Given the constraints, we will ensure that the operations are performed efficiently by handling up to 5 * 10^5 queries.\n", "requirement analysis:\nThe requirement analysis involves understanding the need to manage a sequence of integers and perform operations on it. The operations include appending an element and substituting one element with another. The system should maintain the order of elements after each operation. The input is a series of queries, and the output is the final state of the sequence after all queries are processed.\nrequirement pool:\n- The main code should handle the input and output efficiently.\n- The system should be able to process each query in constant time.\n- The user interface should be responsive and visually appealing.\n- The system should handle large inputs within the given constraints.\n- The system should provide a clear and informative user experience.\nTo efficiently handle the sequence of integer operations and maintain the order of elements, we will use a list to store the sequence. Each query will be processed in constant time by checking the type of the query and performing the corresponding operation. The list will be updated in place to ensure the order is maintained. For the user interface, we will design a simple and responsive interface to allow users to input queries and view the results.\n", "requirement analysis:\nThe requirements specify the need for a program to handle two types of queries on a sequence of integers. The first type appends an integer to the sequence, and the second type replaces all occurrences of a specified integer with another integer. The program must maintain the order of the sequence and handle a large number of queries efficiently.\nrequirement pool:\n- Implement query handling for appending and replacing integers in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Handle a large number of queries efficiently.\n- Provide a user-friendly interface for managing sequences.\n- Optimize performance for handling large datasets.\nTo implement the requirements, we will use a simple and efficient approach using Python's built-in list data structure. The list will dynamically grow as we append elements and can be efficiently modified by replacing elements based on their values. We will handle the queries sequentially, processing each one in turn.\n", "requirement analysis:\nThe requirements involve managing a sequence of integers through a series of queries. The queries can either append an integer to the sequence or replace all occurrences of one integer with another. The application must handle a large number of queries efficiently and maintain the order of the sequence.\nrequirement pool:\n- Implement query handling for both append and replace operations\n- Ensure the application can handle large numbers of queries\n- Maintain the order of the sequence after all operations\n- Provide clear and concise output\n- Ensure the application is user-friendly and easy to use\nTo implement this application, we will use Python due to its simplicity and efficiency. The application will handle the sequence of integers and perform operations based on the queries provided. We will use a list to store the sequence of integers and perform operations like appending and replacing elements as per the queries.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 88, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "rephrase_one", "parent_index": 75}
