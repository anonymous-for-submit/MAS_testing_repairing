{"name": "1618_A. Polycarp and Sums of Subsequences", "description": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "tags": ["math", "sortings"], "difficulty": 7, "id": 1618, "sample_io": [{"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}], "test_list": [{"input": "1\n69696868 69696868 69696868 139393736 139393736 139393736 209090604\n", "output": ["69696868 69696868 69696868 \n"]}, {"input": "2\n1 1 2 69696874 69696875 69696875 69696876\n1 1 1 2 2 2 3\n", "output": ["1 1 69696874\n1 1 1\n"]}, {"input": "1\n1 1 2 69696880 69696881 69696881 69696882\n", "output": ["1 1 69696880\n"]}, {"input": "2\n1 1 2 69696967 69696968 69696968 69696969\n1 1 1 2 2 2 3\n", "output": ["1 1 69696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696868 69696869 69696869 69696870\n1 2 3 4 5 6 7\n", "output": ["1 1 69696868\n1 2 4\n"]}, {"input": "2\n1 1 2 696967 696968 696968 696969\n1 1 1 2 2 2 3\n", "output": ["1 1 696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696873 69696874 69696874 69696875\n1 1 1 2 2 2 3\n", "output": ["1 1 69696873\n1 1 1\n"]}, {"input": "2\n1 1 2 69696889 69696890 69696890 69696891\n1 1 1 2 2 2 3\n", "output": ["1 1 69696889\n1 1 1\n"]}, {"input": "1\n1 2 3 69696875 69696876 69696877 69696878\n", "output": ["1 2 69696875\n"]}, {"input": "2\n1 1 2 69696870 69696871 69696871 69696872\n1 1 1 2 2 2 3\n", "output": ["1 1 69696870\n1 1 1\n"]}, {"input": "2\n1 1 2 69696881 69696882 69696882 69696883\n1 1 1 2 2 2 3\n", "output": ["1 1 69696881\n1 1 1\n"]}, {"input": "2\n1 1 2 598989 598990 598990 598991\n1 3 4 4 5 7 8\n", "output": ["1 1 598989\n1 3 4\n"]}, {"input": "2\n1 1 2 69696875 69696876 69696876 69696877\n1 1 1 2 2 2 3\n", "output": ["1 1 69696875\n1 1 1\n"]}, {"input": "1\n1 1 2 69696884 69696885 69696885 69696886\n", "output": ["1 1 69696884\n"]}, {"input": "1\n1 1 2 69696883 69696884 69696884 69696885\n", "output": ["1 1 69696883\n"]}, {"input": "2\n1 1 2 69696885 69696886 69696886 69696887\n1 1 1 2 2 2 3\n", "output": ["1 1 69696885\n1 1 1\n"]}, {"input": "2\n1 1 2 69696879 69696880 69696880 69696881\n1 1 1 2 2 2 3\n", "output": ["1 1 69696879\n1 1 1\n"]}, {"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}, {"input": "2\n1 1 2 69696886 69696887 69696887 69696888\n1 1 1 2 2 2 3\n", "output": ["1 1 69696886\n1 1 1\n"]}, {"input": "2\n1 1 2 69696869 69696870 69696870 69696871\n1 1 1 2 2 2 3\n", "output": ["1 1 69696869\n1 1 1\n"]}, {"input": "2\n1 1 2 69696887 69696888 69696888 69696889\n1 1 1 2 2 2 3\n", "output": ["1 1 69696887\n1 1 1\n"]}, {"input": "2\n1 1 2 69696877 69696878 69696878 69696879\n1 1 1 2 2 2 3\n", "output": ["1 1 69696877\n1 1 1\n"]}, {"input": "2\n1 1 2 69696871 69696872 69696872 69696873\n1 1 1 2 2 2 3\n", "output": ["1 1 69696871\n1 1 1\n"]}, {"input": "2\n1 1 2 69696882 69696883 69696883 69696884\n1 1 1 2 2 2 3\n", "output": ["1 1 69696882\n1 1 1\n"]}, {"input": "1\n1 2 3 69696887 69696888 69696889 69696890\n", "output": ["1 2 69696887\n"]}, {"input": "2\n1 1 2 69696872 69696873 69696873 69696874\n1 1 1 2 2 2 3\n", "output": ["1 1 69696872\n1 1 1\n"]}, {"input": "2\n1 1 2 69696878 69696879 69696879 69696880\n1 1 1 2 2 2 3\n", "output": ["1 1 69696878\n1 1 1\n"]}], "task_id": "codecontest/132", "prompt": "Polycarp had an array a of 3 positive integers. The three integers are stored in an array. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "repair_prompt": ["Polycarp had an array a of 3 positive integers. The three integers are stored in an array. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to make it easier to find the sums\n    b.sort()\n    \n    # The smallest sum is the sum of the two smallest elements\n    # The largest sum is the sum of all three elements\n    sum_two_smallest = b[0] + b[1]\n    sum_all_three = b[0] + b[1] + b[2]\n    \n    # The sum of the two smallest elements is also the difference between the second smallest and the third smallest elements\n    a1_plus_a2 = b[1]\n    a1_plus_a2_plus_a3 = b[6]\n    \n    # Calculate the individual elements\n    a3 = a1_plus_a2_plus_a3 - a1_plus_a2\n    a2 = a1_plus_a2 - b[0]\n    a1 = b[0]\n    \n    return [a1, a2, a3]\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(sums: List[int]) -> List[int]:\n    # The sums array contains the sums of all non-empty subsequences of the original array.\n    # Since the original array has 3 elements, the sums array will have 7 elements.\n    # The smallest sum is the sum of the two smallest elements.\n    # The largest sum is the sum of all three elements.\n    # The next largest sum is the sum of the two largest elements.\n    # The next smallest sum is the sum of the smallest and the middle element.\n    # The second largest sum is the sum of all three elements.\n    \n    # Sort the sums array to easily identify the smallest, middle, and largest sums.\n    sums.sort()\n    \n    # The smallest sum is the sum of the two smallest elements.\n    sum_of_two_smallest = sums[0]\n    # The largest sum is the sum of all three elements.\n    sum_of_three = sums[-1]\n    # The next largest sum is the sum of the two largest elements.\n    sum_of_two_largest = sums[-2]\n    \n    # The sum of the three elements can be found by adding the smallest and the largest sums.\n    # sum_of_three = sum_of_two_smallest + sum_of_two_largest\n    \n    # The three elements can be found by solving the system of equations.\n    # Let a, b, c be the three elements.\n    # a + b + c = sum_of_three\n    # a + b = sum_of_two_smallest\n    # b + c = sum_of_two_largest\n    \n    # Solving these equations, we get:\n    # c = sum_of_three - sum_of_two_smallest\n    # a = sum_of_two_smallest - b\n    # b = (sum_of_two_smallest + sum_of_two_largest - sum_of_three) / 2\n    \n    # Calculate the third element.\n    c = sum_of_three - sum_of_two_smallest\n    \n    # Calculate the first element.\n    a = sum_of_two_smallest - (sum_of_two_largest - c)\n    \n    # Calculate the second element.\n    b = sum_of_two_largest - c\n    \n    return [a, b, c]\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    sums = list(map(int, input().split()))\n    result = restore_array(sums)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the sums to make it easier to find the smallest and largest sums\n    b.sort()\n    \n    # The smallest sum is the sum of the two smallest numbers\n    sum_of_two_smallest = b[0] + b[1]\n    \n    # The largest sum is the sum of all three numbers\n    sum_of_all_three = b[-1]\n    \n    # The third smallest sum is the sum of the smallest number and the second smallest number\n    sum_of_smallest_and_second_smallest = b[1] + b[2]\n    \n    # The second largest sum is the sum of the two largest numbers\n    sum_of_two_largest = b[-2] + b[-3]\n    \n    # The sum of the three numbers can be found by subtracting the sum of the two smallest numbers from the sum of all seven numbers\n    sum_of_three_numbers = sum_of_all_three - sum_of_two_smallest\n    \n    # The three numbers are the sum of the three numbers, the sum of the smallest and second smallest numbers, and the sum of the two largest numbers\n    a = [sum_of_three_numbers, sum_of_smallest_and_second_smallest - sum_of_three_numbers, sum_of_two_largest - sum_of_three_numbers]\n    \n    return a\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\nfrom itertools import combinations\n\ndef restore_array(sums: List[int]) -> List[int]:\n    # Generate all possible combinations of 3 integers\n    possible_combinations = combinations(sums, 3)\n    \n    for combo in possible_combinations:\n        # Sort the combination to ensure we can compare with the sorted sums\n        sorted_combo = sorted(combo)\n        # Check if the sorted combination matches the sorted sums\n        if sorted(sorted_combo) == sorted(sums):\n            return sorted_combo\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    sums = list(map(int, input().split()))\n    result = restore_array(sums)\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # The sum of the three elements in a is the total sum of b\n    total_sum = sum(b)\n    \n    # The sum of the three elements in a is also twice the sum of the two smallest elements in a\n    # because each element in a is included in three sums in b (two times directly and once indirectly)\n    a_sum = total_sum // 2\n    \n    # Find the two smallest elements in b\n    b.sort()\n    a1 = b[0]\n    a2 = b[1]\n    \n    # The third element in a is the difference between the sum of the three elements and the sum of the two smallest elements\n    a3 = a_sum - (a1 + a2)\n    \n    return [a1, a2, a3]\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array b to easily find the smallest sums\n    b.sort()\n    \n    # The three smallest sums in b correspond to the three elements of a\n    # Extract the first three elements from the sorted b\n    a = [b[0], b[1], b[2]]\n    \n    # Verify the sums to ensure the solution is correct\n    assert b[0] + b[1] == b[2]\n    assert b[0] + b[2] == b[3]\n    assert b[1] + b[2] == b[4]\n    assert b[0] + b[1] + b[2] == b[5]\n    \n    return a\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array b to make it easier to find the three integers\n    b.sort()\n    \n    # Initialize a list to store the three integers\n    a = []\n    \n    # Use a set to keep track of the sums we have seen\n    seen_sums = set()\n    \n    # Iterate through the array b to find the three integers\n    for num in b:\n        if num not in seen_sums:\n            a.append(num)\n            seen_sums.add(num)\n    \n    return a\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # The sum of all elements in a should be the sum of the first three elements in b\n    total_sum = sum(b[:3])\n    \n    # The sum of the smallest two elements in a should be the difference between the first two elements in b\n    min_sum = b[0] + b[1] - b[2]\n    \n    # The largest element in a is the last element in b\n    max_element = b[-1]\n    \n    # The smallest element in a is the difference between the total sum and the sum of the two largest elements in a\n    a = [min_sum, b[2] - min_sum, max_element - b[2]]\n    \n    return a\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # The sum of all elements in the array a is the sum of the first three elements in b\n    total_sum = sum(b[:3])\n    \n    # The sum of the two smallest elements in b\n    min_sum_two = b[0] + b[1]\n    \n    # The sum of the two largest elements in b\n    max_sum_two = b[6] + b[-1]\n    \n    # The sum of all three elements in a\n    sum_three_elements = total_sum\n    \n    # The sum of the two elements in a, excluding the largest one\n    sum_two_elements = max_sum_two\n    \n    # The largest element in a\n    a_3 = sum_three_elements - sum_two_elements\n    \n    # The second largest element in a\n    a_2 = sum_two_elements - a_3\n    \n    # The smallest element in a\n    a_1 = min_sum_two - a_2\n    \n    return [a_1, a_2, a_3]\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(sums: List[int]) -> List[int]:\n    # The sums array contains the sums of all non-empty subsequences of the original array a\n    # Since the original array has 3 elements, the sums array will have 7 elements\n    # The smallest sum is the sum of the two smallest elements (a[0] + a[1])\n    # The largest sum is the sum of all three elements (a[0] + a[1] + a[2])\n    # The middle sum is the sum of the largest and the smallest element (a[1] + a[2])\n    \n    # Sort the sums array to easily identify the smallest, middle, and largest sums\n    sums.sort()\n    \n    # The smallest sum is the sum of the two smallest elements\n    smallest_sum = sums[0]\n    # The largest sum is the sum of all three elements\n    largest_sum = sums[-1]\n    # The middle sum is the sum of the largest and the smallest element\n    middle_sum = sums[1]\n    \n    # The sum of the two largest elements is the second largest sum in the array\n    second_largest_sum = sums[-2]\n    \n    # The sum of the two smallest elements is the second smallest sum in the array\n    second_smallest_sum = sums[2]\n    \n    # The sum of the three elements is the largest sum\n    # The sum of the two largest elements is the second largest sum\n    # The sum of the two smallest elements is the second smallest sum\n    # The sum of the largest and the smallest element is the middle sum\n    \n    # Calculate the three elements of the original array\n    a1 = (smallest_sum + middle_sum - largest_sum) // 2\n    a2 = (middle_sum - smallest_sum + largest_sum) // 2\n    a3 = (largest_sum - middle_sum + smallest_sum) // 2\n    \n    return [a1, a2, a3]\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    sums = list(map(int, input().split()))\n    result = restore_array(sums)\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe primary requirement is to restore the original array a from the given sums in array b. This involves identifying the three integers that could have produced the given sums when all non-empty subsequences are summed. The solution must handle multiple test cases efficiently, and the output must be clear and easy to understand.\nrequirement pool:\n- Implement a function to restore the original array a from the given sums in array b.\n- Ensure the solution can handle up to 5000 test cases efficiently.\n- Provide a clear and concise output for each test case.\n- Optimize the algorithm to handle large inputs without performance issues.\n- Enhance user interface for better readability and understanding of the output.\nTo restore the original array a from the given sums in array b, we need to identify the three integers that could have produced the given sums. This involves recognizing that the sums in array b are all possible sums of the three integers in array a, including the sums of pairs and the sum of all three integers. We can use a combination of set operations and mathematical properties to deduce the original array a.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from the given sums. This involves identifying the three integers that could have produced the given sums when combined in all possible non-empty subsequences. The solution must be efficient to handle up to 5000 test cases, each with 7 integers.\nrequirement pool:\n- Implement a function to restore the original array from the given sums.\n- Ensure the solution can handle multiple test cases efficiently.\n- Provide clear and concise output for each test case.\n- Test the solution with a variety of inputs to ensure robustness.\nTo restore the original array from the given sums, we need to identify the three integers that could have produced the given sums when combined in all possible non-empty subsequences. This involves a combinatorial approach to find the three integers that match the given sums. We will use Python's built-in libraries and some mathematical properties of the sums to achieve this.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from the given sums. This involves identifying the three integers that could have produced the given sums when combined in all possible non-empty subsequences. The solution must handle multiple test cases efficiently, making it suitable for large inputs.\nrequirement pool:\n- Implement a function to restore the original array from the given sums.\n- Ensure the solution can handle multiple test cases efficiently.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm to handle large inputs within reasonable time limits.\n- Ensure the user interface is simple and intuitive for easy input and output.\nTo restore the original array from the given sums, we need to identify the three integers that could have produced the given sums when combined in all possible non-empty subsequences. This involves a combinatorial approach to deduce the original numbers from the sorted sums. We will use Python's built-in functions and libraries to handle the input/output and to perform the necessary calculations efficiently.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from the given sums. This involves identifying the three integers that could have produced the given sums when combined in all possible non-empty subsequences. The solution must be efficient to handle up to 5000 test cases, each with 7 integers.\nrequirement pool:\n- Implement a function to restore the original array from the given sums.\n- Ensure the solution can handle up to 5000 test cases efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize processing time and memory usage.\nTo restore the original array from the given sums, we need to identify the three integers that could have produced the given sums. This involves a combinatorial approach to find all possible sums of three integers and then match them with the given sums. We will use Python's itertools to generate all possible combinations of the given sums.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the given sums in array b. The solution must handle multiple test cases efficiently. The input constraints are such that there is always at least one array a that can yield the given array b, ensuring solvability. The output should be three integers that form the original array a.\nrequirement pool:\n- Implement a function to restore the original array a from the given array b.\n- Ensure the solution can handle multiple test cases efficiently.\n- Optimize the algorithm for performance to handle large inputs.\n- Provide a clear and easy-to-understand solution.\n- Ensure the solution is robust and can handle edge cases.\nTo restore the original array a from the given array b, we need to identify the three integers that were summed to produce each of the seven integers in array b. Given the constraints, we can use a combination of set operations and mathematical properties to deduce the original array. We will iterate through the possible combinations of three numbers from the given sums to find the correct original array.\n", "requirement analysis:\nThe problem requires identifying the original array a from the sorted sums b. This involves recognizing that b contains all possible sums of the elements of a, including single elements and combinations. The solution must be able to handle multiple test cases efficiently, making it suitable for large inputs.\nrequirement pool:\n- Implement a function to restore the original array from the given sums.\n- Ensure the solution can handle multiple test cases efficiently.\n- Provide clear and concise output for each test case.\n- Test the solution with various edge cases and invalid inputs.\n- Optimize the code for performance and readability.\nTo restore the original array a from the given sums, we can approach this problem by leveraging the properties of the sums. Since the array b contains all possible sums of the elements of a, we can deduce the original array by identifying the three smallest sums in b, which correspond to the three elements of a. We will sort the array b and then extract the first three elements to form the array a.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the sorted sums array b. The solution must handle multiple test cases efficiently. The input consists of 7 integers, which are sums of all non-empty subsequences of the original array a. The output should be the original array a with three integers. The problem guarantees that there exists at least one array a that yields the given array b.\nrequirement pool:\n- Implement a function to restore the original array a from the given array b.\n- Ensure the solution can handle multiple test cases efficiently.\n- Verify the solution against various inputs to ensure accuracy.\n- Optimize the algorithm for performance to handle large inputs.\n- Enhance user interface for better user experience.\nTo restore the original array a from the given array b, we need to identify the three integers that were summed to produce each of the seven integers in array b. Given the constraints and the nature of the problem, we can use combinatorial mathematics to deduce the original array. We will use Python's built-in libraries and efficient algorithms to achieve this.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the given sums in array b. The solution must handle multiple test cases efficiently. The output should be clear and concise, providing the three integers of the original array a for each test case.\nrequirement pool:\n- Implement an algorithm to restore the original array a from the given sums in array b.\n- Ensure the solution can handle t test cases efficiently.\n- Provide a clear and concise output for each test case.\n- Test the solution for robustness and handle edge cases.\n- Optimize the code for readability and maintainability.\nTo restore the original array a from the given sums in array b, we can use a combination of mathematical properties and algorithmic techniques. Given that the sums are sorted in non-decreasing order, we can deduce the smallest and largest elements of the original array by analyzing the sums. The sum of all elements in a should be the sum of the first three elements in b, and the sum of the smallest two elements in a should be the difference between the first two elements in b. We can then use these properties to reconstruct the original array.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from the given sums. This involves understanding the combinatorial nature of the sums and how they relate to the original array elements. The solution must be efficient and capable of handling multiple test cases.\nrequirement pool:\n- Implement a function to restore the original array from the given sums.\n- Ensure the solution can handle up to 5000 test cases.\n- Provide clear and concise output for each test case.\n- Optimize the solution for efficiency to handle large inputs.\nTo restore the original array from the given sums, we need to reverse-engineer the process of summing all non-empty subsequences of the array. Given the sums are already sorted in non-decreasing order, we can deduce the original array elements by considering the smallest and largest sums, which will include the sum of all three elements and the sum of two elements. By subtracting these sums from the total sums, we can find the third element. This approach leverages the properties of combinations and sums to reconstruct the original array.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from the given sums. This involves identifying the three integers that could have produced the given sums when combined in all possible non-empty subsequences. The solution must be efficient to handle up to 5000 test cases, each with 7 integers.\nrequirement pool:\n- Implement a function to restore the original array from the given sums.\n- Ensure the solution can handle up to 5000 test cases efficiently.\n- Provide clear and concise output for each test case.\n- Test the solution with a variety of inputs to ensure robustness.\nTo restore the original array from the given sums, we need to identify the three integers that could have produced the given sums. This involves a combination of mathematical analysis and algorithmic manipulation. We will use Python due to its efficiency and ease of handling large datasets. The approach involves deducing the possible values of the three integers by considering all possible combinations of sums and their corresponding unique values.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 18, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "mutate_method": "expand_one2two", "parent_index": 18}
