{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You possess a sequence of integers. This sequence is initially starting off as vacant.\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 append the element x to the conclusion of the array; \n  * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. \n\nFind the resulting array after performing all the queries. Ensure the array maintains its order after all operations are performed.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You possess a sequence of integers. This sequence is initially starting off as vacant.\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 append the element x to the conclusion of the array; \n  * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. \n\nFind the resulting array after performing all the queries. Ensure the array maintains its order after all operations are performed.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef process_queries(queries: List[str]) -> List[int]:\n    sequence = []\n    index_map = {}\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            sequence.append(x)\n            index_map[x] = len(sequence) - 1\n        elif parts[0] == '2':\n            x, y = int(parts[1]), int(parts[2])\n            if x in index_map:\n                index = index_map[x]\n                sequence[index] = y\n                index_map[y] = index\n                del index_map[x]\n                # Remove the original element from the list\n                del sequence[index]\n                # Update indices for elements after the replaced element\n                for key, value in index_map.items():\n                    if value > index:\n                        index_map[key] = value - 1\n    \n    return sequence\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = process_queries(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef func(q: int) -> List[int]:\n    sequence = []\n    \n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            sequence.append(int(query[1]))\n        elif query[0] == '2':\n            x = int(query[1])\n            y = int(query[2])\n            for i in range(len(sequence)):\n                if sequence[i] == x:\n                    sequence[i] = y\n    \n    return sequence\n\n# Read the number of queries\nq = int(input())\nresult = func(q)\nprint(*result)\n", "from typing import List\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    sequence = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            sequence.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            sequence = [y if num == x else num for num in sequence]\n    \n    return sequence\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    sequence = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            sequence.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            sequence = [y if elem == x else elem for elem in sequence]\n    \n    return sequence\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef manipulate_sequence(queries: List[List[int]]) -> List[int]:\n    sequence = []\n    \n    for query in queries:\n        if query[0] == 1:\n            sequence.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            sequence = [y if num == x else num for num in sequence]\n    \n    return sequence\n\n# Interface\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = manipulate_sequence(queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result_list = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            result_list.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            result_list = [y if num == x else num for num in result_list]\n    \n    return result_list\n\n# Provide the Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef process_queries(q: int, queries: List[List[int]]) -> List[int]:\n    sequence = []\n    \n    for query in queries:\n        if query[0] == 1:\n            sequence.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            sequence = [y if num == x else num for num in sequence]\n    \n    return sequence\n\n# Interface\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = process_queries(q, queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result_list = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            # Append the element x to the end of the array\n            result_list.append(int(parts[1]))\n        elif parts[0] == '2':\n            # Replace all occurrences of x with y\n            x = int(parts[1])\n            y = int(parts[2])\n            result_list = [y if elem == x else elem for elem in result_list]\n    \n    return result_list\n\n# Provide the Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    sequence = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            sequence.append(x)\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            for i in range(len(sequence)):\n                if sequence[i] == x:\n                    sequence[i] = y\n    \n    return sequence\n\n# Provide the Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    sequence = []\n    replacement_map = {}\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            sequence.append(x)\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            replacement_map[x] = y\n    \n    # Apply replacements after processing all queries\n    for i in range(len(sequence)):\n        if sequence[i] in replacement_map:\n            sequence[i] = replacement_map[sequence[i]]\n    \n    return sequence\n\n# Interface\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe requirements specify a need for a program that can handle two types of queries on a sequence of integers. The first type allows appending an element to the sequence, and the second type allows replacing all occurrences of a specified element with another element. The program must maintain the order of the sequence and handle a large number of queries efficiently.\nrequirement pool:\n- Implement the ability to append elements to the sequence.\n- Implement the ability to replace elements in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Handle a large number of queries efficiently.\nTo implement this functionality, we will use Python, leveraging its dynamic nature and the availability of efficient data structures. The primary data structure will be a list, which allows for dynamic appending and efficient indexing. For handling the replacement query efficiently, we will use a dictionary to keep track of the indices of elements to be replaced. This will help in updating the sequence in constant time for the replacement query.\n", "requirement analysis:\nThe requirements specify a need for a sequence manipulation application that can handle two types of queries: appending an element and replacing occurrences of a specific element with another element. The application must maintain the order of elements and provide a final output after all operations are performed. The constraints indicate a potential for a large number of queries, so the application must be efficient in handling such data.\nrequirement pool:\n- Implement the ability to append elements to a sequence.\n- Implement the ability to replace elements in a sequence.\n- Ensure the application can handle a large number of queries efficiently.\n- Provide clear and concise output of the final sequence after all operations.\nTo implement the requirements, we will use Python due to its simplicity and efficiency. The application will manage a list of integers, handling two types of queries: appending an element and replacing occurrences of a specific element with another element. We will use a list to store the sequence and perform operations accordingly.\n", "requirement analysis:\nThe requirements specify a need for a program that can handle two types of operations on a sequence of integers: appending a new integer and substituting one integer for another. The program must maintain the order of the sequence and handle a large number of queries efficiently. The user must be able to see the final state of the sequence after all operations are performed.\nrequirement pool:\n- Implement the ability to append integers to the sequence.\n- Implement the ability to substitute one integer with another in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Optimize the program for high performance and scalability.\nTo implement the requirements, we will use Python due to its simplicity and efficiency. The program will handle two types of operations: appending an integer to the sequence and substituting one integer with another. We will use a list to store the sequence and manage the operations efficiently.\n", "requirement analysis:\nThe requirements specify a need for a program that can handle two types of operations on a sequence of integers: appending a new element and replacing all occurrences of a specific element with another element. The program must maintain the order of elements and provide the final sequence after all operations are performed. The input is structured with the first line specifying the number of queries, followed by each query's details.\nrequirement pool:\n- Implement the ability to append elements to the sequence.\n- Implement the ability to replace elements in the sequence.\n- Ensure the sequence maintains its order after all operations.\n- Provide a clear and concise output of the final sequence.\nTo implement the requirements, we will use Python, leveraging its simplicity and efficiency. The program will handle two types of operations: appending an element to the sequence and replacing all occurrences of a specific element with another element. We will use a list to store the sequence, which allows for efficient appending and element replacement operations. The list will be dynamically resized as elements are added and removed.\n", "requirement analysis:\nThe requirements specify a need for a sequence manipulation tool that can append integers and substitute specific integers with another integer. The system should handle a large number of queries efficiently and provide a clear output of the final sequence. The user must be able to easily understand and use the system to achieve their goals.\nrequirement pool:\n- Implement append and substitute functionalities\n- Ensure efficient handling of a large number of queries\n- Provide clear and concise output of the final sequence\n- Improve user interface for better usability\n- Add features for sorting or filtering the sequence\nTo implement the sequence manipulation tool efficiently, we will use Python, leveraging its dynamic typing and ease of use. The system will handle two primary operations: appending integers and substituting specific integers with another integer. We will use a list to store the sequence of integers, which allows for efficient appending and substitution operations. The list will be dynamically resized as needed to accommodate the number of queries.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle two types of operations on a sequence of integers: appending a new element and replacing all occurrences of a specific element with another element. The program must maintain the order of elements and provide the final sequence after all operations are performed. The constraints indicate that the number of queries can be as high as 5 * 10^5, so the program must be efficient in terms of both time and space complexity.\nrequirement pool:\n- Implement the ability to append integers to a list.\n- Implement the ability to replace all occurrences of a specific integer with another integer.\n- Ensure the final list maintains the order of elements after all operations.\n- Optimize the program for handling a large number of queries efficiently.\n- Provide clear and concise output of the final list.\nTo implement the requirements, we will use Python, leveraging its dynamic nature and the ability to handle large datasets efficiently. The program will maintain a list to store the sequence of integers and will handle the two types of queries efficiently. For the second type of query (replace all occurrences of x with y), we will use the list's built-in methods to replace elements.\n", "requirement analysis:\nThe requirements specify a need to manage a sequence of integers through a series of queries. The queries can either append an integer to the sequence or replace all occurrences of one integer with another. The application must handle a large number of queries efficiently and provide a clear output of the final sequence. The requirements are clear and specific, providing a good starting point for development.\nrequirement pool:\n- Implement the ability to append integers to a list\n- Implement the ability to replace integers in the list\n- Ensure the application can handle a large number of queries efficiently\n- Provide clear and concise output of the final sequence\nTo implement the requirements, we will use Python, leveraging its simplicity and efficiency. The application will manage a list of integers, handling two types of queries: appending an integer and replacing all occurrences of one integer with another. We will use a list to store the sequence of integers and perform operations based on the query type. For efficiency, we will ensure that operations are optimized, especially for large numbers of queries.\n", "requirement analysis:\nThe requirements specify the need for a program that can handle a sequence of integers and perform two types of operations: appending an element and replacing occurrences of a specific element with another element. The program must maintain the order of elements and provide the final sequence after all operations are performed. The constraints indicate that the number of queries can be as high as 5 * 10^5, so the solution must be efficient to handle such a large number of operations.\nrequirement pool:\n- Implement the ability to append elements to a list.\n- Implement the ability to replace elements in the list.\n- Ensure the list maintains its order after all operations.\n- Optimize the solution to handle a large number of queries efficiently.\nTo implement the requirements, we will use Python, leveraging its dynamic nature and the ability to handle large datasets efficiently. The solution will involve a list to store the sequence of integers and two main operations: appending an element and replacing occurrences of a specific element. We will optimize the solution to handle up to 5 * 10^5 queries efficiently by ensuring minimal operations on the list.\n", "requirement analysis:\nThe requirements specify a need for a sequence manipulation tool that can handle two primary operations: appending elements and replacing elements based on specific criteria. The system must be able to handle a large number of queries efficiently, which implies a need for optimized algorithms and data structures. The user interface should be intuitive to ensure ease of use, especially considering the potential complexity of the operations.\nrequirement pool:\n- Implement efficient data structures to handle sequence operations.\n- Ensure the application can handle a large number of queries without performance degradation.\n- Develop a user-friendly interface for easy interaction with the application.\n- Implement error handling to manage unexpected inputs or operations.\n- Optimize the application for high performance and scalability.\nTo implement the sequence manipulation tool efficiently, we will use Python, leveraging its powerful standard library and the ability to handle large datasets due to its design. We will use a list to store the sequence of integers, which allows for efficient append operations. For the replace operation, we will iterate through the list to find and replace occurrences of a specific element.\n", "requirement analysis:\nThe requirements specify the need for a sequence manipulation tool that can handle two types of queries: appending an element and replacing occurrences of a specific element with another. The system should maintain the order of elements and handle large datasets efficiently. The product should also be user-friendly and scalable.\nrequirement pool:\n- Implement the ability to append elements to the sequence\n- Implement the ability to replace elements in the sequence\n- Ensure the sequence maintains its order after all operations\n- Handle large datasets efficiently\n- Provide a user-friendly interface for easy interaction\nTo implement the sequence manipulation tool efficiently, we will use Python, leveraging its powerful list operations and the ability to handle large datasets. The primary challenge is to ensure that both append and replace operations are performed efficiently, especially with large numbers of queries. We will use a list to store the sequence and handle the append operation by simply adding the element to the list. For the replace operation, we will iterate through the list and replace all occurrences of the specified element with the new element. To maintain the order of elements, we will ensure that the replace operation does not alter the order of elements in the list.\n"], "scores": [], "pass_results": [true, true, true, true, true, false, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 99, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "expand_one2two", "parent_index": 84}
