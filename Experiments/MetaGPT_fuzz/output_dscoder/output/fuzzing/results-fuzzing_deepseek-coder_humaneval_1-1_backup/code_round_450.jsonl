{"task_id": "HumanEval/49", "prompt": "def modp(n: int, p: int):\t\n'''Return 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    '''", "entry_point": "modp", "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "test": ["def check(modp):\n\tassert modp(104, 97) == 62", "def check(modp):\n\tassert modp(97, 102) == 2", "def check(modp):\n\tassert modp(28, 9) == 7", "def check(modp):\n\tassert modp(4, 8) == 0", "def check(modp):\n\tassert modp(3, 11) == 8", "def check(modp):\n\tassert modp(1, 106) == 2", "def check(modp):\n\tassert modp(4, 12) == 4", "def check(modp):\n\tassert modp(102, 104) == 64", "def check(modp):\n\tassert modp(6, 9) == 1", "def check(modp):\n\tassert modp(1, 103) == 2", "def check(modp):\n\tassert modp(26, 9) == 4", "def check(modp):\n\tassert modp(1101, 101) == 2", "def check(modp):\n\tassert modp(34, 8) == 0", "def check(modp):\n\tassert modp(35, 8) == 0", "def check(modp):\n\tassert modp(1376, 99) == 31", "def check(modp):\n\tassert modp(25, 3) == 2", "def check(modp):\n\tassert modp(7, 7) == 2", "def check(modp):\n\tassert modp(100, 101) == 1", "def check(modp):\n\tassert modp(2, 100) == 4", "def check(modp):\n\tassert modp(102, 105) == 64", "def check(modp):\n\tassert modp(1, 9) == 2", "def check(modp):\n\tassert modp(33, 7) == 1", "def check(modp):\n\tassert modp(3, 101) == 8", "def check(modp):\n\tassert modp(892, 106) == 44", "def check(modp):\n\tassert modp(4, 14) == 2", "def check(modp):\n\tassert modp(31, 6) == 2", "def check(modp):\n\tassert modp(1950, 97) == 33", "def check(modp):\n\tassert modp(6, 7) == 1", "def check(modp):\n\tassert modp(101, 99) == 68", "def check(modp):\n\tassert modp(31, 3) == 2", "def check(modp):\n\tassert modp(1257, 99) == 62", "def check(modp):\n\tassert modp(6, 3) == 1", "def check(modp):\n\tassert modp(32, 7) == 4", "def check(modp):\n\tassert modp(8, 6) == 4", "def check(modp):\n\tassert modp(1, 7) == 2", "def check(modp):\n\tassert modp(3, 104) == 8", "def check(modp):\n\tassert modp(96, 99) == 64", "def check(modp):\n\tassert modp(497, 96) == 32", "def check(modp):\n\tassert modp(33, 8) == 0", "def check(modp):\n\tassert modp(30, 10) == 4", "def check(modp):\n\tassert modp(2, 9) == 4", "def check(modp):\n\tassert modp(36, 3) == 1", "def check(modp):\n\tassert modp(1357, 101) == 74", "def check(modp):\n\tassert modp(1670, 104) == 56", "def check(modp):\n\tassert modp(125, 96) == 32", "def check(modp):\n\tassert modp(6, 1) == 0", "def check(modp):\n\tassert modp(35, 2) == 0", "def check(modp):\n\tassert modp(32, 9) == 4", "def check(modp):\n\tassert modp(1625, 103) == 33", "def check(modp):\n\tassert modp(7, 2) == 0", "def check(modp):\n\tassert modp(102, 100) == 4", "def check(modp):\n\tassert modp(8, 13) == 9", "def check(modp):\n\tassert modp(27, 7) == 1", "def check(modp):\n\tassert modp(280, 98) == 30", "def check(modp):\n\tassert modp(597, 102) == 32", "def check(modp):\n\tassert modp(2, 8) == 4", "def check(modp):\n\tassert modp(1, 98) == 2", "def check(modp):\n\tassert modp(104, 106) == 54", "def check(modp):\n\tassert modp(33, 10) == 2", "def check(modp):\n\tassert modp(2, 101) == 4", "def check(modp):\n\tassert modp(1000, 105) == 16", "def check(modp):\n\tassert modp(2, 96) == 4", "def check(modp):\n\tassert modp(29, 5) == 2", "def check(modp):\n\tassert modp(28, 6) == 4", "def check(modp):\n\tassert modp(1, 105) == 2", "def check(modp):\n\tassert modp(95, 106) == 50", "def check(modp):\n\tassert modp(97, 99) == 29", "def check(modp):\n\tassert modp(7, 11) == 7", "def check(modp):\n\tassert modp(3, 13) == 8", "def check(modp):\n\tassert modp(3, 14) == 8", "def check(modp):\n\tassert modp(95, 101) == 60", "def check(modp):\n\tassert modp(4, 99) == 16", "def check(modp):\n\tassert modp(4, 7) == 2", "def check(modp):\n\tassert modp(31, 1) == 0", "def check(modp):\n\tassert modp(5, 16) == 0", "def check(modp):\n\tassert modp(5, 102) == 32", "def check(modp):\n\tassert modp(26, 5) == 4", "def check(modp):\n\tassert modp(4, 16) == 0", "def check(modp):\n\tassert modp(0, 101) == 1", "def check(modp):\n\tassert modp(104, 104) == 48", "def check(modp):\n\tassert modp(96, 100) == 36", "def check(modp):\n\tassert modp(32, 6) == 4", "def check(modp):\n\tassert modp(26, 8) == 0", "def check(modp):\n\tassert modp(103, 97) == 31", "def check(modp):\n\tassert modp(1, 4) == 2", "def check(modp):\n\tassert modp(2, 97) == 4", "def check(modp):\n\tassert modp(25, 8) == 0", "def check(modp):\n\tassert modp(5, 12) == 8", "def check(modp):\n\tassert modp(2, 104) == 4", "def check(modp):\n\tassert modp(1, 14) == 2", "def check(modp):\n\tassert modp(34, 6) == 4", "def check(modp):\n\tassert modp(1161, 104) == 96", "def check(modp):\n\tassert modp(1999, 96) == 32", "def check(modp):\n\tassert modp(3, 103) == 8", "def check(modp):\n\tassert modp(30, 3) == 1", "def check(modp):\n\tassert modp(4, 6) == 4", "def check(modp):\n\tassert modp(7, 8) == 0", "def check(modp):\n\tassert modp(30, 5) == 4", "def check(modp):\n\tassert modp(457, 101) == 74", "def check(modp):\n\tassert modp(36, 2) == 0", "def check(modp):\n\tassert modp(4, 104) == 16", "def check(modp):\n\tassert modp(1, 104) == 2", "def check(modp):\n\tassert modp(35, 7) == 4", "def check(modp):\n\tassert modp(4, 5) == 1", "def check(modp):\n\tassert modp(26, 2) == 0", "def check(modp):\n\tassert modp(100, 105) == 16", "def check(modp):\n\tassert modp(102, 103) == 1", "def check(modp):\n\tassert modp(377, 99) == 95", "def check(modp):\n\tassert modp(1262, 98) == 4", "def check(modp):\n\tassert modp(1, 101) == 2", "def check(modp):\n\tassert modp(1, 1) == 0", "def check(modp):\n\tassert modp(30, 8) == 0", "def check(modp):\n\tassert modp(28, 5) == 1", "def check(modp):\n\tassert modp(99, 104) == 8", "def check(modp):\n\tassert modp(3, 5) == 3", "def check(modp):\n\tassert modp(31, 5) == 3", "def check(modp):\n\tassert modp(7, 10) == 8", "def check(modp):\n\tassert modp(33, 9) == 8", "def check(modp):\n\tassert modp(5, 15) == 2", "def check(modp):\n\tassert modp(3, 4) == 0"], "test_case_list": ["assert modp(104, 97) == 62", "assert modp(97, 102) == 2", "assert modp(28, 9) == 7", "assert modp(4, 8) == 0", "assert modp(3, 11) == 8", "assert modp(1, 106) == 2", "assert modp(4, 12) == 4", "assert modp(102, 104) == 64", "assert modp(6, 9) == 1", "assert modp(1, 103) == 2", "assert modp(26, 9) == 4", "assert modp(1101, 101) == 2", "assert modp(34, 8) == 0", "assert modp(35, 8) == 0", "assert modp(1376, 99) == 31", "assert modp(25, 3) == 2", "assert modp(7, 7) == 2", "assert modp(100, 101) == 1", "assert modp(2, 100) == 4", "assert modp(102, 105) == 64", "assert modp(1, 9) == 2", "assert modp(33, 7) == 1", "assert modp(3, 101) == 8", "assert modp(892, 106) == 44", "assert modp(4, 14) == 2", "assert modp(31, 6) == 2", "assert modp(1950, 97) == 33", "assert modp(6, 7) == 1", "assert modp(101, 99) == 68", "assert modp(31, 3) == 2", "assert modp(1257, 99) == 62", "assert modp(6, 3) == 1", "assert modp(32, 7) == 4", "assert modp(8, 6) == 4", "assert modp(1, 7) == 2", "assert modp(3, 104) == 8", "assert modp(96, 99) == 64", "assert modp(497, 96) == 32", "assert modp(33, 8) == 0", "assert modp(30, 10) == 4", "assert modp(2, 9) == 4", "assert modp(36, 3) == 1", "assert modp(1357, 101) == 74", "assert modp(1670, 104) == 56", "assert modp(125, 96) == 32", "assert modp(6, 1) == 0", "assert modp(35, 2) == 0", "assert modp(32, 9) == 4", "assert modp(1625, 103) == 33", "assert modp(7, 2) == 0", "assert modp(102, 100) == 4", "assert modp(8, 13) == 9", "assert modp(27, 7) == 1", "assert modp(280, 98) == 30", "assert modp(597, 102) == 32", "assert modp(2, 8) == 4", "assert modp(1, 98) == 2", "assert modp(104, 106) == 54", "assert modp(33, 10) == 2", "assert modp(2, 101) == 4", "assert modp(1000, 105) == 16", "assert modp(2, 96) == 4", "assert modp(29, 5) == 2", "assert modp(28, 6) == 4", "assert modp(1, 105) == 2", "assert modp(95, 106) == 50", "assert modp(97, 99) == 29", "assert modp(7, 11) == 7", "assert modp(3, 13) == 8", "assert modp(3, 14) == 8", "assert modp(95, 101) == 60", "assert modp(4, 99) == 16", "assert modp(4, 7) == 2", "assert modp(31, 1) == 0", "assert modp(5, 16) == 0", "assert modp(5, 102) == 32", "assert modp(26, 5) == 4", "assert modp(4, 16) == 0", "assert modp(0, 101) == 1", "assert modp(104, 104) == 48", "assert modp(96, 100) == 36", "assert modp(32, 6) == 4", "assert modp(26, 8) == 0", "assert modp(103, 97) == 31", "assert modp(1, 4) == 2", "assert modp(2, 97) == 4", "assert modp(25, 8) == 0", "assert modp(5, 12) == 8", "assert modp(2, 104) == 4", "assert modp(1, 14) == 2", "assert modp(34, 6) == 4", "assert modp(1161, 104) == 96", "assert modp(1999, 96) == 32", "assert modp(3, 103) == 8", "assert modp(30, 3) == 1", "assert modp(4, 6) == 4", "assert modp(7, 8) == 0", "assert modp(30, 5) == 4", "assert modp(457, 101) == 74", "assert modp(36, 2) == 0", "assert modp(4, 104) == 16", "assert modp(1, 104) == 2", "assert modp(35, 7) == 4", "assert modp(4, 5) == 1", "assert modp(26, 2) == 0", "assert modp(100, 105) == 16", "assert modp(102, 103) == 1", "assert modp(377, 99) == 95", "assert modp(1262, 98) == 4", "assert modp(1, 101) == 2", "assert modp(1, 1) == 0", "assert modp(30, 8) == 0", "assert modp(28, 5) == 1", "assert modp(99, 104) == 8", "assert modp(3, 5) == 3", "assert modp(31, 5) == 3", "assert modp(7, 10) == 8", "assert modp(33, 9) == 8", "assert modp(5, 15) == 2", "assert modp(3, 4) == 0"], "nl": "Return 2^n modulo p (be aware of numerics).\n    ", "func": "def modp(n: int, p: int):", "examples": ">>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    ", "completions": ["from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    Computes 2^n % p efficiently using modular exponentiation.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n % p.\n    \"\"\"\n    result = 1\n    base = 2\n\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n = n // 2\n\n    return result\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    '''\n    Parameters:\n    n (int): The exponent\n    p (int): The modulus\n\n    Returns:\n    int: 2^n modulo p\n    '''\n    result = 1\n    base = 2\n    \n    for _ in range(n):\n        result = (result * base) % p\n        base = (base * 2) % p\n    \n    return result\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    '''\n    Return 2^n modulo p.\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    Returns:\n        int: The result of 2^n modulo p.\n    '''\n    if n < 0 or p <= 0:\n        raise ValueError(\"Invalid input: n must be non-negative and p must be positive.\")\n    \n    return pow(2, n, p)\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    This function computes (2^n) % p using Python's built-in pow() function.\n    \n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n        \n    Returns:\n        int: The result of (2^n) % p.\n    \"\"\"\n    return pow(2, n, p)\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    '''\n    Return 2^n modulo p.\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    Returns:\n        int: The result of 2^n modulo p.\n    '''\n    return pow(2, n, p)\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    '''\n    Return 2^n modulo p.\n    Parameters:\n        n (int): The exponent.\n        p (int): The modulus.\n    Returns:\n        int: The result of 2^n modulo p.\n    '''\n    result = 1\n    base = 2\n    \n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        n = n // 2\n        base = (base * base) % p\n    \n    return result\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    Computes 2^n % p efficiently using Python's built-in pow function with modulus.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n % p.\n    \"\"\"\n    return pow(2, n, p)\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    Perform modular exponentiation efficiently.\n\n    This function calculates (2^n) % p using an optimized approach.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of (2^n) % p.\n    \"\"\"\n    result = 1\n    base = 2\n    exponent = n\n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        exponent = exponent // 2\n        base = (base * base) % p\n\n    return result\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    Computes 2^n modulo p.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    result = 1\n    base = 2\n\n    for _ in range(n):\n        result = (result * base) % p\n\n    return result\n", "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    '''\n    Return 2^n modulo p.\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    Returns:\n        int: The result of 2^n modulo p.\n    '''\n    if n < 0 or p <= 0:\n        raise ValueError(\"Invalid input: n must be non-negative and p must be positive.\")\n    \n    return pow(2, n, p)\n"], "plans": ["requirement analysis:\nThe original requirements specify a function that calculates 2^n modulo p. This is a fundamental operation in cryptography and number theory. The function should handle both small and large inputs efficiently. The requirements also include several test cases to verify the correctness of the function.\nrequirement pool:\n- Implement the function modp(n, p) to return 2^n modulo p\n- Ensure the function handles large numbers correctly\n- Optimize the function for performance\n- Include detailed documentation for the function\n- Add error handling for invalid inputs\nTo implement the function `modp(n, p)` efficiently, we will utilize Python's built-in capabilities for handling large integers. Specifically, we will use the `pow` function with the third argument to compute the modular exponentiation directly. This approach is both efficient and leverages Python's robust standard library.\n", "requirement analysis:\nThe original requirements specify a function that calculates 2^n modulo p. This is a fundamental operation in number theory and cryptography. The function should handle both small and large numbers efficiently. The doctests provided give examples of expected outputs for specific inputs, which will be useful for testing the function's correctness.\nrequirement pool:\n- Implement the function to accurately calculate 2^n modulo p\n- Ensure the function can handle large values of n and p\n- Optimize the function for performance to handle large inputs quickly\n- Include detailed documentation and tests to ensure reliability\n- Make the function user-friendly for both developers and mathematicians\nTo implement the function for modular exponentiation efficiently, we will leverage Python's built-in capabilities for handling large integers. The function will use the modular exponentiation algorithm, which is both efficient and straightforward. We will ensure that the function can handle large values of n and p gracefully by utilizing Python's `int` type, which supports arbitrary-precision integers.\n", "requirement analysis:\nThe function needs to handle both small and large inputs efficiently. It should be accurate and secure, suitable for cryptographic applications. The function should be compatible with Python's built-in types and operations.\nrequirement pool:\n- Implement the function to handle both small and large inputs efficiently\n- Ensure the function is accurate and secure for various applications\n- Make the function compatible with Python's built-in types and operations\n- Provide comprehensive documentation and testing for the function\n- Include error handling for unexpected inputs\nTo implement the function efficiently for modular exponentiation, we will utilize Python's built-in capabilities, specifically leveraging the `pow` function with the modulus argument. This approach is versatile, well-documented, and suitable for handling large numbers gracefully. We will ensure that the function is optimized for performance by taking advantage of Python's efficient numeric handling and by implementing any necessary optimizations for large inputs. Additionally, we will include error handling to manage unexpected inputs, ensuring the function's robustness.\n", "requirement analysis:\nThe original requirements specify a simple function that calculates 2^n modulo p. This is a fundamental mathematical operation used in cryptography and other applications. The function should handle both small and large numbers efficiently. The doctests provided give examples of expected outputs for various inputs, which will be used to verify the correctness of the implementation.\nrequirement pool:\n- Implement the function to calculate 2^n modulo p accurately\n- Ensure the function can handle large numbers without performance issues\n- Include comprehensive testing to verify the correctness of the function\n- Provide clear documentation for developers and users\n- Optimize the function for speed and memory usage\nTo implement the function for modular exponentiation efficiently, we will leverage Python's built-in capabilities for handling large integers. The function will use the pow() function with three arguments, which allows us to compute (2^n) % p in a performant manner. This approach is both simple and efficient, ensuring that the function can handle large numbers gracefully. We will also include comprehensive testing to verify the correctness of the function across a wide range of inputs.\n", "requirement analysis:\nThe requirement is to implement a function that calculates 2^n modulo p. This is a common problem in cryptography and number theory. The function should handle both small and large numbers efficiently. The doctests provided give examples of expected outputs for various inputs, which will be used to verify the correctness of the implementation.\nrequirement pool:\n- The function should correctly compute 2^n modulo p for any integer n and any positive integer p.\n- The function should be optimized for performance, especially for large values of n and p.\n- The function should be easy to understand and use, with clear documentation.\n- The function should handle edge cases, such as n = 0 or p being a prime number.\n- The function should be compatible with Python's standard library and other common libraries.\nTo implement the function `modp(n: int, p: int)` efficiently, we will utilize Python's built-in `pow` function, which is optimized for modular exponentiation. This function can directly compute `(2^n) % p` with high performance. We will ensure that the function handles large numbers gracefully by leveraging Python's support for arbitrary-precision arithmetic.\n", "requirement analysis:\nThe function needs to handle large numbers efficiently and accurately. It should be secure and easy to use. The performance should be optimized for various applications including cryptography.\nrequirement pool:\n- Implement modular exponentiation algorithm\n- Ensure function handles large numbers\n- Optimize for performance\n- Add support for secure cryptographic applications\n- Improve user interface for ease of use\nTo implement the function efficiently, we will utilize Python's built-in capabilities for handling large integers, ensuring that the function can handle large numbers gracefully. We will use the `pow` function in Python, which is optimized for modular exponentiation. This function takes three arguments: the base, the exponent, and the modulus. The `pow` function in Python can compute large powers efficiently and can directly apply the modulus during the computation, which aligns perfectly with our requirement to perform modular arithmetic efficiently.\n", "requirement analysis:\nThe function 'modp' is designed to compute 2^n modulo p. This is a fundamental operation in cryptography and number theory. The requirements are clear and specific, focusing on the accuracy and efficiency of the computation. The function should handle both small and large inputs, including edge cases like n=0 and large values of n and p.\nrequirement pool:\n- The function should accurately compute 2^n modulo p for any integer n and any prime p.\n- The function should be optimized for performance, especially for large values of n and p.\n- The function should handle edge cases, such as n=0 and large values of p.\n- The function should be implemented in a language that supports large integers natively, such as Python.\nTo implement the 'modp' function efficiently, we will utilize Python's built-in capabilities for handling large integers. Specifically, we will use the `pow` function with an appropriate third-party library to manage large numbers and ensure the computation is optimized for performance. The 'pow' function in Python can take three arguments: the base, the exponent, and the modulus. This allows us to compute 2^n % p in a straightforward manner, leveraging Python's efficient handling of large integers.\n", "requirement analysis:\nThe function needs to be able to handle large integers and perform modular exponentiation efficiently. It should be accurate and reliable, especially for cryptographic applications where security is critical. The function should be optimized for performance to handle large inputs without significant delays.\nrequirement pool:\n- Implement a function that can handle large integers for n and p\n- Ensure the function performs modular exponentiation accurately\n- Optimize the function for performance to handle large inputs\n- Provide clear and concise documentation for the function\n- Include tests to verify the function's correctness\nTo implement the function for modular exponentiation efficiently, we will utilize Python's built-in capabilities, specifically leveraging the `pow` function with the third argument to perform the modulo operation directly. This approach is efficient and leverages Python's optimized numeric handling. We will ensure that the function can handle large integers by using Python's native `int` type, which supports arbitrary-precision integers.\n", "requirement analysis:\nThe original requirements specify a function that calculates 2^n modulo p. This is a fundamental operation in number theory and cryptography. The function should handle both small and large numbers efficiently. The doctests provided give examples of expected outputs for various inputs, which will be used to verify the correctness of the implementation.\nrequirement pool:\n- Implement the function modp(n, p) to return 2^n modulo p\n- Ensure the function handles large numbers gracefully\n- Optimize the function for performance\n- Add detailed documentation to explain the function's usage and behavior\n- Include error handling for edge cases such as negative numbers or zero\nTo implement the function modp(n, p) efficiently, we will use Python's built-in capabilities for handling large integers. The function will compute 2^n modulo p using the properties of modular arithmetic. We will optimize for performance by leveraging Python's efficient handling of large numbers and modular operations. The function will be designed to handle large inputs gracefully, ensuring it can compute results for very large n and p without performance degradation.\n", "requirement analysis:\nThe original requirements specify a simple function that calculates 2^n modulo p. This is a common mathematical operation used in cryptography and other applications. The function should handle both small and large numbers efficiently. The doctests provided give examples of expected outputs for various inputs, which will be useful for testing the function's correctness.\nrequirement pool:\n- The function should correctly compute 2^n modulo p for any positive integers n and p.\n- The function should handle large values of n and p gracefully without performance issues.\n- The function should be optimized for speed and memory usage.\n- The function should include error handling for cases where p is zero or negative.\nTo create a reliable and efficient function for modular exponentiation, we will utilize Python's built-in capabilities, specifically leveraging the `pow` function with the modulus argument. This approach is chosen for its simplicity and efficiency in handling large numbers. We will ensure that the function can handle large values of n and p gracefully, optimizing for performance by minimizing computational overhead.\n"], "scores": [1.0, 0.475, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [120, 57, 120, 120, 120, 120, 120, 120, 120, 120], "completion": "from typing import List\n## main.py\n\ndef modp(n: int, p: int) -> int:\n    '''\n    Return 2^n modulo p.\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n    Returns:\n        int: The result of 2^n modulo p.\n    '''\n    if n < 0 or p <= 0:\n        raise ValueError(\"Invalid input: n must be non-negative and p must be positive.\")\n    \n    return pow(2, n, p)\n", "passed": true, "pass": true, "pass_num": 9, "round": 450, "repair_prompt": ["def modp(n: int, p: int):\t\n'''Return 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    '''"], "mutate_method": "condense_two2one", "parent_index": 362}
