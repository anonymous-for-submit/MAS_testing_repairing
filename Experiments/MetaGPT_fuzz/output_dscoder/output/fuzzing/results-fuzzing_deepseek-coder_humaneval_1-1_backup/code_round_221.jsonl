{"task_id": "HumanEval/93", "prompt": "def encode(message):\t\n'''Write a function that takes a message, and encodes in such a way that it swaps case of all letters and replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the English alphabet. Assume only letters.\nExamples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    '''", "entry_point": "encode", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": ["def check(encode):\n\tassert encode(\"ZUvOnpFUjJGGWcJQYQmTY W\") == 'zwVqNPfwJjggwCjqyqMty w'", "def check(encode):\n\tassert encode(\"SgPXbDsCxLlYIAFFhhIbRfXHjaZ\") == 'sGpxBdScXlLykcffHHkBrFxhJCz'", "def check(encode):\n\tassert encode(\"TEPUFH\") == 'tgpwfh'", "def check(encode):\n\tassert encode(\"FKRTJOGJR\") == 'fkrtjqgjr'", "def check(encode):\n\tassert encode(\"GWHK\") == 'gwhk'", "def check(encode):\n\tassert encode(\"ElaZse dYXHgdVq\") == 'gLCzSG DyxhGDvQ'", "def check(encode):\n\tassert encode(\"SETPXKRTE\") == 'sgtpxkrtg'", "def check(encode):\n\tassert encode(\"JRG\") == 'jrg'", "def check(encode):\n\tassert encode(\"XQAXbNmLpmobUzQtNvacz\") == 'xqcxBnMlPMQBwZqTnVCCZ'", "def check(encode):\n\tassert encode(\"FPENQAZGK\") == 'fpgnqczgk'", "def check(encode):\n\tassert encode(\"TEIPDCVYN\") == 'tgkpdcvyn'", "def check(encode):\n\tassert encode(\"gIVppcmTSMtmvhg ZjTdBs\") == 'GkvPPCMtsmTMVHG zJtDbS'", "def check(encode):\n\tassert encode(\"nds\") == 'NDS'", "def check(encode):\n\tassert encode(\"CVLBOWSP\") == 'cvlbqwsp'", "def check(encode):\n\tassert encode(\"BRVLN\") == 'brvln'", "def check(encode):\n\tassert encode(\"hnbzSknod dSFfSG\") == 'HNBZsKNQD DsfFsg'", "def check(encode):\n\tassert encode(\"BnHJZme\") == 'bNhjzMG'", "def check(encode):\n\tassert encode(\"zTBpeQNFrEsJ\") == 'ZtbPGqnfRgSj'", "def check(encode):\n\tassert encode(\"IstxgcEpahvkDruGyiK\") == 'kSTXGCgPCHVKdRWgYKk'", "def check(encode):\n\tassert encode(\"HzEMwPWyLehG jFTacHALOraUoB\") == 'hZgmWpwYlGHg JftCChclqRCwQb'", "def check(encode):\n\tassert encode(\" BuOTEofYkQJauJaclURS\") == ' bWqtgQFyKqjCWjCCLwrs'", "def check(encode):\n\tassert encode(\"FHEcvmCWtbF aJg\") == 'fhgCVMcwTBf CjG'", "def check(encode):\n\tassert encode(\"RHO\") == 'rhq'", "def check(encode):\n\tassert encode(\"OJMQGVupooekW\") == 'qjmqgvWPQQGKw'", "def check(encode):\n\tassert encode(\"DARS\") == 'dcrs'", "def check(encode):\n\tassert encode(\"ZTTSSFEL\") == 'zttssfgl'", "def check(encode):\n\tassert encode(\"kkAuzPMaJbY\") == 'KKcWZpmCjBy'", "def check(encode):\n\tassert encode(\"kwfcMJBvOIscxpuRJYMQxX\") == 'KWFCmjbVqkSCXPWrjymqXx'", "def check(encode):\n\tassert encode(\"pUgmIEYWAnzEuqFElVbVs\") == 'PwGMkgywcNZgWQfgLvBvS'", "def check(encode):\n\tassert encode(\"kzLQOefkAweHvGBycjn\") == 'KZlqqGFKcWGhVgbYCJN'", "def check(encode):\n\tassert encode(\"CLY\") == 'cly'", "def check(encode):\n\tassert encode(\"GUAU\") == 'gwcw'", "def check(encode):\n\tassert encode(\"YcxmhivPyJIw\") == 'yCXMHKVpYjkW'", "def check(encode):\n\tassert encode('TEST') == 'tgst'", "def check(encode):\n\tassert encode(\"oSYVfHWo kWWvnziVt\") == 'QsyvFhwQ KwwVNZKvT'", "def check(encode):\n\tassert encode(\"TXAFFIW\") == 'txcffkw'", "def check(encode):\n\tassert encode(\"EORCSH\") == 'gqrcsh'", "def check(encode):\n\tassert encode(\"ETMDXUEBC\") == 'gtmdxwgbc'", "def check(encode):\n\tassert encode(\"TQRZQWU\") == 'tqrzqww'", "def check(encode):\n\tassert encode(\"DPGWLEVT\") == 'dpgwlgvt'", "def check(encode):\n\tassert encode(\"PRREkliEYbvcKGoNqvSfsJ\") == 'prrgKLKgyBVCkgQnQVsFSj'", "def check(encode):\n\tassert encode(\"WWBsZMYcpjfNzyCeVVgesJoJhjy\") == 'wwbSzmyCPJFnZYcGvvGGSjQjHJY'", "def check(encode):\n\tassert encode(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg'", "def check(encode):\n\tassert encode(\"gnJhAIkj\") == 'GNjHckKJ'", "def check(encode):\n\tassert encode(\"OHUJlX\") == 'qhwjLx'", "def check(encode):\n\tassert encode(\"EoisHGBfMOUHhIftINGIdF DJqugm\") == 'gQKShgbFmqwhHkFTkngkDf djQWGM'", "def check(encode):\n\tassert encode(\"JJWNGDOT\") == 'jjwngdqt'", "def check(encode):\n\tassert encode(\"DXZBFN\") == 'dxzbfn'", "def check(encode):\n\tassert encode(\"DVKfMTlbOESs\") == 'dvkFmtLBqgsS'", "def check(encode):\n\tassert encode(\"UEeG\") == 'wgGg'", "def check(encode):\n\tassert encode(\"BCKPNMVO\") == 'bckpnmvq'", "def check(encode):\n\tassert encode(\"IMIJTK\") == 'kmkjtk'", "def check(encode):\n\tassert encode(\"ZyWrbakVZJKkkAmmKNRmUPDCi\") == 'zYwRBCKvzjkKKcMMknrMwpdcK'", "def check(encode):\n\tassert encode(\"URMC\") == 'wrmc'", "def check(encode):\n\tassert encode(\"CNJ\") == 'cnj'", "def check(encode):\n\tassert encode(\"grukYfBTTJtVX\") == 'GRWKyFbttjTvx'", "def check(encode):\n\tassert encode(\"FDMjHnZkEhmsNmlJNItsJQlasO\") == 'fdmJhNzKgHMSnMLjnkTSjqLCSq'", "def check(encode):\n\tassert encode(\"rRrZwWEjxTIMMSNiS\") == 'RrRzWwgJXtkmmsnKs'", "def check(encode):\n\tassert encode(\"LHfTwSNWVA\") == 'lhFtWsnwvc'", "def check(encode):\n\tassert encode(\"QwJoXypNyPZVVwtdhDxHhBKXS\") == 'qWjQxYPnYpzvvWTDHdXhHbkxs'", "def check(encode):\n\tassert encode(\"cJbiuaENQvBuUexfhUuJRbvP\") == 'CjBKWCgnqVbWwGXFHwWjrBVp'", "def check(encode):\n\tassert encode(\"Sjf\") == 'sJF'", "def check(encode):\n\tassert encode(\"DZAXVXQ\") == 'dzcxvxq'", "def check(encode):\n\tassert encode(\"HNDsWbIhInLlAGVoRFZw\") == 'hndSwBkHkNlLcgvQrfzW'", "def check(encode):\n\tassert encode(\"YaFsT\") == 'yCfSt'", "def check(encode):\n\tassert encode(\"WNYEUHDUE\") == 'wnygwhdwg'", "def check(encode):\n\tassert encode(\"ROWVCETC\") == 'rqwvcgtc'", "def check(encode):\n\tassert encode(\"Hmj\") == 'hMJ'", "def check(encode):\n\tassert encode(\"ApBJTja\") == 'cPbjtJC'", "def check(encode):\n\tassert encode(\"NNoTLfuGwSHDJdTlRXSyC\") == 'nnQtlFWgWshdjDtLrxsYc'", "def check(encode):\n\tassert encode(\"pvQeerpuzVbW\") == 'PVqGGRPWZvBw'", "def check(encode):\n\tassert encode(\"LCLBDYXRN\") == 'lclbdyxrn'", "def check(encode):\n\tassert encode(\"RcQZkLoILujJnUJ BK lQgY\") == 'rCqzKlQklWJjNwj bk LqGy'", "def check(encode):\n\tassert encode(\"IzXkNbTRYEDDLFF\") == 'kZxKnBtrygddlff'", "def check(encode):\n\tassert encode(\"bBSM\") == 'Bbsm'", "def check(encode):\n\tassert encode(\"rhgAVJOAnVugEnMSSKWsc\") == 'RHGcvjqcNvWGgNmsskwSC'", "def check(encode):\n\tassert encode(\"KTBXLNF\") == 'ktbxlnf'", "def check(encode):\n\tassert encode(\"gEQTanRJKhLxXlJDZQHPwvbnq\") == 'GgqtCNrjkHlXxLjdzqhpWVBNQ'", "def check(encode):\n\tassert encode(\"EjhSPNSJMPQ\") == 'gJHspnsjmpq'", "def check(encode):\n\tassert encode(\"TLU\") == 'tlw'", "def check(encode):\n\tassert encode(\"rjXQvzxCjzaWcAuNeOiaXPpdYVoxCt\") == 'RJxqVZXcJZCwCcWnGqKCxpPDyvQXcT'", "def check(encode):\n\tassert encode(\"ZVS\") == 'zvs'", "def check(encode):\n\tassert encode(\"BODPGNO\") == 'bqdpgnq'", "def check(encode):\n\tassert encode('This is a message') == 'tHKS KS C MGSSCGG'", "def check(encode):\n\tassert encode(\"jZheceVgKgTLjRwOLeRrrtwbE\") == 'JzHGCGvGkGtlJrWqlGrRRTWBg'", "def check(encode):\n\tassert encode(\"AZOCBJD\") == 'czqcbjd'", "def check(encode):\n\tassert encode(\"HrRcDpPaxYYXID\") == 'hRrCdPpCXyyxkd'", "def check(encode):\n\tassert encode(\"DNHIUUVX\") == 'dnhkwwvx'", "def check(encode):\n\tassert encode(\"TEGPKXNB\") == 'tggpkxnb'", "def check(encode):\n\tassert encode(\"OBEcrSHMuaCS\") == 'qbgCRshmWCcs'", "def check(encode):\n\tassert encode(\"jAqqTMHiqs\") == 'JcQQtmhKQS'", "def check(encode):\n\tassert encode(\"IYS\") == 'kys'", "def check(encode):\n\tassert encode(\"HKWXPGN\") == 'hkwxpgn'", "def check(encode):\n\tassert encode(\"aZPgQ vnmhPPOLdLIutuJO\") == 'CzpGq VNMHppqlDlkWTWjq'", "def check(encode):\n\tassert encode(\"fZoHFcbTcLTUWG VdZ\") == 'FzQhfCBtCltwwg vDz'", "def check(encode):\n\tassert encode(\"SSMAQL\") == 'ssmcql'", "def check(encode):\n\tassert encode(\"ITNaCJiUmgbbsXbJggeE\") == 'ktnCcjKwMGBBSxBjGGGg'", "def check(encode):\n\tassert encode(\"PKKLGPQOY\") == 'pkklgpqqy'", "def check(encode):\n\tassert encode(\"XgnELkHHAAUiCCpSfJ\") == 'xGNglKhhccwKccPsFj'", "def check(encode):\n\tassert encode(\"jjHqlFViqHz\") == 'JJhQLfvKQhZ'", "def check(encode):\n\tassert encode('Mudasir') == 'mWDCSKR'", "def check(encode):\n\tassert encode(\"OpzdoaiWPrtwH\") == 'qPZDQCKwpRTWh'", "def check(encode):\n\tassert encode(\" dNVahxVjKzB JTneIFjKfXsk \") == ' DnvCHXvJkZb jtNGkfJkFxSK '", "def check(encode):\n\tassert encode(\"c XkUXkBchEddL\") == 'C xKwxKbCHgDDl'", "def check(encode):\n\tassert encode(\"PSBSBey\") == 'psbsbGY'", "def check(encode):\n\tassert encode(\"mejsPoZxTWVZINkltbTC\") == 'MGJSpQzXtwvzknKLTBtc'", "def check(encode):\n\tassert encode(\"RkeGn HyKwTJKYqIJSWnu\") == 'rKGgN hYkWtjkyQkjswNW'", "def check(encode):\n\tassert encode(\"JMFDUNNFN\") == 'jmfdwnnfn'", "def check(encode):\n\tassert encode(\"DWUOPpLjiGck\") == 'dwwqpPlJKgCK'", "def check(encode):\n\tassert encode(\"KtvgHCwhJPHhZoPrTShCCFjb\") == 'kTVGhcWHjphHzQpRtsHccfJB'", "def check(encode):\n\tassert encode(\"BGPB\") == 'bgpb'", "def check(encode):\n\tassert encode(\"FVABgUJcvAO\") == 'fvcbGwjCVcq'", "def check(encode):\n\tassert encode(\"LPVHOUZC\") == 'lpvhqwzc'", "def check(encode):\n\tassert encode(\"vFk rhQEfvOP ZgydPEhvIVWD\") == 'VfK RHqgFVqp zGYDpgHVkvwd'", "def check(encode):\n\tassert encode(\"QRX\") == 'qrx'", "def check(encode):\n\tassert encode(\"DXV\") == 'dxv'", "def check(encode):\n\tassert encode(\"qmjcLnfY lObRZrX\") == 'QMJClNFy LqBrzRx'", "def check(encode):\n\tassert encode('YES') == 'ygs'", "def check(encode):\n\tassert encode(\"lljsyoqvdrgHLkvty\") == 'LLJSYQQVDRGhlKVTY'", "def check(encode):\n\tassert encode(\"OSWDQFIR\") == 'qswdqfkr'", "def check(encode):\n\tassert encode(\"ZfDqK\") == 'zFdQk'", "def check(encode):\n\tassert encode(\"BYRAIVE\") == 'byrckvg'", "def check(encode):\n\tassert encode(\"AGMBICYE\") == 'cgmbkcyg'", "def check(encode):\n\tassert encode(\"kqmseH\") == 'KQMSGh'", "def check(encode):\n\tassert encode(\"WYLLSZM\") == 'wyllszm'", "def check(encode):\n\tassert encode(\"hgxUMf\") == 'HGXwmF'", "def check(encode):\n\tassert encode(\"xOzJhrPNcVCLkJeMgwsBcYm\") == 'XqZjHRpnCvclKjGmGWSbCyM'", "def check(encode):\n\tassert encode(\"rKELArbzBNVyXuUr\") == 'RkglcRBZbnvYxWwR'", "def check(encode):\n\tassert encode(\"WNRIIJWGO\") == 'wnrkkjwgq'", "def check(encode):\n\tassert encode(\"UNVEY\") == 'wnvgy'"], "test_case_list": ["assert encode(\"ZUvOnpFUjJGGWcJQYQmTY W\") == 'zwVqNPfwJjggwCjqyqMty w'", "assert encode(\"SgPXbDsCxLlYIAFFhhIbRfXHjaZ\") == 'sGpxBdScXlLykcffHHkBrFxhJCz'", "assert encode(\"TEPUFH\") == 'tgpwfh'", "assert encode(\"FKRTJOGJR\") == 'fkrtjqgjr'", "assert encode(\"GWHK\") == 'gwhk'", "assert encode(\"ElaZse dYXHgdVq\") == 'gLCzSG DyxhGDvQ'", "assert encode(\"SETPXKRTE\") == 'sgtpxkrtg'", "assert encode(\"JRG\") == 'jrg'", "assert encode(\"XQAXbNmLpmobUzQtNvacz\") == 'xqcxBnMlPMQBwZqTnVCCZ'", "assert encode(\"FPENQAZGK\") == 'fpgnqczgk'", "assert encode(\"TEIPDCVYN\") == 'tgkpdcvyn'", "assert encode(\"gIVppcmTSMtmvhg ZjTdBs\") == 'GkvPPCMtsmTMVHG zJtDbS'", "assert encode(\"nds\") == 'NDS'", "assert encode(\"CVLBOWSP\") == 'cvlbqwsp'", "assert encode(\"BRVLN\") == 'brvln'", "assert encode(\"hnbzSknod dSFfSG\") == 'HNBZsKNQD DsfFsg'", "assert encode(\"BnHJZme\") == 'bNhjzMG'", "assert encode(\"zTBpeQNFrEsJ\") == 'ZtbPGqnfRgSj'", "assert encode(\"IstxgcEpahvkDruGyiK\") == 'kSTXGCgPCHVKdRWgYKk'", "assert encode(\"HzEMwPWyLehG jFTacHALOraUoB\") == 'hZgmWpwYlGHg JftCChclqRCwQb'", "assert encode(\" BuOTEofYkQJauJaclURS\") == ' bWqtgQFyKqjCWjCCLwrs'", "assert encode(\"FHEcvmCWtbF aJg\") == 'fhgCVMcwTBf CjG'", "assert encode(\"RHO\") == 'rhq'", "assert encode(\"OJMQGVupooekW\") == 'qjmqgvWPQQGKw'", "assert encode(\"DARS\") == 'dcrs'", "assert encode(\"ZTTSSFEL\") == 'zttssfgl'", "assert encode(\"kkAuzPMaJbY\") == 'KKcWZpmCjBy'", "assert encode(\"kwfcMJBvOIscxpuRJYMQxX\") == 'KWFCmjbVqkSCXPWrjymqXx'", "assert encode(\"pUgmIEYWAnzEuqFElVbVs\") == 'PwGMkgywcNZgWQfgLvBvS'", "assert encode(\"kzLQOefkAweHvGBycjn\") == 'KZlqqGFKcWGhVgbYCJN'", "assert encode(\"CLY\") == 'cly'", "assert encode(\"GUAU\") == 'gwcw'", "assert encode(\"YcxmhivPyJIw\") == 'yCXMHKVpYjkW'", "assert encode('TEST') == 'tgst'", "assert encode(\"oSYVfHWo kWWvnziVt\") == 'QsyvFhwQ KwwVNZKvT'", "assert encode(\"TXAFFIW\") == 'txcffkw'", "assert encode(\"EORCSH\") == 'gqrcsh'", "assert encode(\"ETMDXUEBC\") == 'gtmdxwgbc'", "assert encode(\"TQRZQWU\") == 'tqrzqww'", "assert encode(\"DPGWLEVT\") == 'dpgwlgvt'", "assert encode(\"PRREkliEYbvcKGoNqvSfsJ\") == 'prrgKLKgyBVCkgQnQVsFSj'", "assert encode(\"WWBsZMYcpjfNzyCeVVgesJoJhjy\") == 'wwbSzmyCPJFnZYcGvvGGSjQjHJY'", "assert encode(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg'", "assert encode(\"gnJhAIkj\") == 'GNjHckKJ'", "assert encode(\"OHUJlX\") == 'qhwjLx'", "assert encode(\"EoisHGBfMOUHhIftINGIdF DJqugm\") == 'gQKShgbFmqwhHkFTkngkDf djQWGM'", "assert encode(\"JJWNGDOT\") == 'jjwngdqt'", "assert encode(\"DXZBFN\") == 'dxzbfn'", "assert encode(\"DVKfMTlbOESs\") == 'dvkFmtLBqgsS'", "assert encode(\"UEeG\") == 'wgGg'", "assert encode(\"BCKPNMVO\") == 'bckpnmvq'", "assert encode(\"IMIJTK\") == 'kmkjtk'", "assert encode(\"ZyWrbakVZJKkkAmmKNRmUPDCi\") == 'zYwRBCKvzjkKKcMMknrMwpdcK'", "assert encode(\"URMC\") == 'wrmc'", "assert encode(\"CNJ\") == 'cnj'", "assert encode(\"grukYfBTTJtVX\") == 'GRWKyFbttjTvx'", "assert encode(\"FDMjHnZkEhmsNmlJNItsJQlasO\") == 'fdmJhNzKgHMSnMLjnkTSjqLCSq'", "assert encode(\"rRrZwWEjxTIMMSNiS\") == 'RrRzWwgJXtkmmsnKs'", "assert encode(\"LHfTwSNWVA\") == 'lhFtWsnwvc'", "assert encode(\"QwJoXypNyPZVVwtdhDxHhBKXS\") == 'qWjQxYPnYpzvvWTDHdXhHbkxs'", "assert encode(\"cJbiuaENQvBuUexfhUuJRbvP\") == 'CjBKWCgnqVbWwGXFHwWjrBVp'", "assert encode(\"Sjf\") == 'sJF'", "assert encode(\"DZAXVXQ\") == 'dzcxvxq'", "assert encode(\"HNDsWbIhInLlAGVoRFZw\") == 'hndSwBkHkNlLcgvQrfzW'", "assert encode(\"YaFsT\") == 'yCfSt'", "assert encode(\"WNYEUHDUE\") == 'wnygwhdwg'", "assert encode(\"ROWVCETC\") == 'rqwvcgtc'", "assert encode(\"Hmj\") == 'hMJ'", "assert encode(\"ApBJTja\") == 'cPbjtJC'", "assert encode(\"NNoTLfuGwSHDJdTlRXSyC\") == 'nnQtlFWgWshdjDtLrxsYc'", "assert encode(\"pvQeerpuzVbW\") == 'PVqGGRPWZvBw'", "assert encode(\"LCLBDYXRN\") == 'lclbdyxrn'", "assert encode(\"RcQZkLoILujJnUJ BK lQgY\") == 'rCqzKlQklWJjNwj bk LqGy'", "assert encode(\"IzXkNbTRYEDDLFF\") == 'kZxKnBtrygddlff'", "assert encode(\"bBSM\") == 'Bbsm'", "assert encode(\"rhgAVJOAnVugEnMSSKWsc\") == 'RHGcvjqcNvWGgNmsskwSC'", "assert encode(\"KTBXLNF\") == 'ktbxlnf'", "assert encode(\"gEQTanRJKhLxXlJDZQHPwvbnq\") == 'GgqtCNrjkHlXxLjdzqhpWVBNQ'", "assert encode(\"EjhSPNSJMPQ\") == 'gJHspnsjmpq'", "assert encode(\"TLU\") == 'tlw'", "assert encode(\"rjXQvzxCjzaWcAuNeOiaXPpdYVoxCt\") == 'RJxqVZXcJZCwCcWnGqKCxpPDyvQXcT'", "assert encode(\"ZVS\") == 'zvs'", "assert encode(\"BODPGNO\") == 'bqdpgnq'", "assert encode('This is a message') == 'tHKS KS C MGSSCGG'", "assert encode(\"jZheceVgKgTLjRwOLeRrrtwbE\") == 'JzHGCGvGkGtlJrWqlGrRRTWBg'", "assert encode(\"AZOCBJD\") == 'czqcbjd'", "assert encode(\"HrRcDpPaxYYXID\") == 'hRrCdPpCXyyxkd'", "assert encode(\"DNHIUUVX\") == 'dnhkwwvx'", "assert encode(\"TEGPKXNB\") == 'tggpkxnb'", "assert encode(\"OBEcrSHMuaCS\") == 'qbgCRshmWCcs'", "assert encode(\"jAqqTMHiqs\") == 'JcQQtmhKQS'", "assert encode(\"IYS\") == 'kys'", "assert encode(\"HKWXPGN\") == 'hkwxpgn'", "assert encode(\"aZPgQ vnmhPPOLdLIutuJO\") == 'CzpGq VNMHppqlDlkWTWjq'", "assert encode(\"fZoHFcbTcLTUWG VdZ\") == 'FzQhfCBtCltwwg vDz'", "assert encode(\"SSMAQL\") == 'ssmcql'", "assert encode(\"ITNaCJiUmgbbsXbJggeE\") == 'ktnCcjKwMGBBSxBjGGGg'", "assert encode(\"PKKLGPQOY\") == 'pkklgpqqy'", "assert encode(\"XgnELkHHAAUiCCpSfJ\") == 'xGNglKhhccwKccPsFj'", "assert encode(\"jjHqlFViqHz\") == 'JJhQLfvKQhZ'", "assert encode('Mudasir') == 'mWDCSKR'", "assert encode(\"OpzdoaiWPrtwH\") == 'qPZDQCKwpRTWh'", "assert encode(\" dNVahxVjKzB JTneIFjKfXsk \") == ' DnvCHXvJkZb jtNGkfJkFxSK '", "assert encode(\"c XkUXkBchEddL\") == 'C xKwxKbCHgDDl'", "assert encode(\"PSBSBey\") == 'psbsbGY'", "assert encode(\"mejsPoZxTWVZINkltbTC\") == 'MGJSpQzXtwvzknKLTBtc'", "assert encode(\"RkeGn HyKwTJKYqIJSWnu\") == 'rKGgN hYkWtjkyQkjswNW'", "assert encode(\"JMFDUNNFN\") == 'jmfdwnnfn'", "assert encode(\"DWUOPpLjiGck\") == 'dwwqpPlJKgCK'", "assert encode(\"KtvgHCwhJPHhZoPrTShCCFjb\") == 'kTVGhcWHjphHzQpRtsHccfJB'", "assert encode(\"BGPB\") == 'bgpb'", "assert encode(\"FVABgUJcvAO\") == 'fvcbGwjCVcq'", "assert encode(\"LPVHOUZC\") == 'lpvhqwzc'", "assert encode(\"vFk rhQEfvOP ZgydPEhvIVWD\") == 'VfK RHqgFVqp zGYDpgHVkvwd'", "assert encode(\"QRX\") == 'qrx'", "assert encode(\"DXV\") == 'dxv'", "assert encode(\"qmjcLnfY lObRZrX\") == 'QMJClNFy LqBrzRx'", "assert encode('YES') == 'ygs'", "assert encode(\"lljsyoqvdrgHLkvty\") == 'LLJSYQQVDRGhlKVTY'", "assert encode(\"OSWDQFIR\") == 'qswdqfkr'", "assert encode(\"ZfDqK\") == 'zFdQk'", "assert encode(\"BYRAIVE\") == 'byrckvg'", "assert encode(\"AGMBICYE\") == 'cgmbkcyg'", "assert encode(\"kqmseH\") == 'KQMSGh'", "assert encode(\"WYLLSZM\") == 'wyllszm'", "assert encode(\"hgxUMf\") == 'HGXwmF'", "assert encode(\"xOzJhrPNcVCLkJeMgwsBcYm\") == 'XqZjHRpnCvclKjGmGWSbCyM'", "assert encode(\"rKELArbzBNVyXuUr\") == 'RkglcRBZbnvYxWwR'", "assert encode(\"WNRIIJWGO\") == 'wnrkkjwgq'", "assert encode(\"UNVEY\") == 'wnvgy'"], "nl": "\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    ", "func": "def encode(message):", "examples": "Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    ", "completions": ["from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead in the alphabet.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    def swap_case(c: str) -> str:\n        \"\"\"\n        Swaps the case of a given character.\n        \n        Args:\n            c (str): The character to swap the case.\n            \n        Returns:\n            str: The character with swapped case.\n        \"\"\"\n        if c.islower():\n            return c.upper()\n        elif c.isupper():\n            return c.lower()\n        else:\n            return c\n\n    def replace_vowel(c: str) -> str:\n        \"\"\"\n        Replaces a vowel with the letter that appears 2 places ahead in the alphabet.\n        \n        Args:\n            c (str): The vowel to be replaced.\n            \n        Returns:\n            str: The letter that appears 2 places ahead.\n        \"\"\"\n        vowels = 'aeiouAEIOU'\n        if c in vowels:\n            if c.lower() == 'a':\n                return 'C'\n            elif c.lower() == 'e':\n                return 'G'\n            elif c.lower() == 'i':\n                return 'K'\n            elif c.lower() == 'o':\n                return 'Q'\n            elif c.lower() == 'u':\n                return 'W'\n            elif c.upper() == 'A':\n                return 'c'\n            elif c.upper() == 'E':\n                return 'g'\n            elif c.upper() == 'I':\n                return 'k'\n            elif c.upper() == 'O':\n                return 'q'\n            elif c.upper() == 'U':\n                return 'w'\n        else:\n            return c\n\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            char = swap_case(char)\n            char = replace_vowel(char)\n        encoded_message += char\n\n    return encoded_message\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    def is_vowel(char: str) -> bool:\n        \"\"\"\n        Checks if a character is a vowel.\n        \n        Args:\n            char (str): The character to check.\n            \n        Returns:\n            bool: True if the character is a vowel, False otherwise.\n        \"\"\"\n        vowels = \"aeiouAEIOU\"\n        return char in vowels\n\n    def shift_vowel(char: str) -> str:\n        \"\"\"\n        Replaces a vowel with the letter that appears 2 places ahead of that vowel in the English alphabet.\n        \n        Args:\n            char (str): The vowel to be replaced.\n            \n        Returns:\n            str: The letter that appears 2 places ahead of the given vowel.\n        \"\"\"\n        vowels = \"aeiou\"\n        shifted_vowels = \"cgkqw\"\n        index = vowels.index(char.lower())\n        return shifted_vowels[index] if char.islower() else shifted_vowels[index].upper()\n\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                if is_vowel(char):\n                    encoded_message += shift_vowel(char)\n                else:\n                    encoded_message += char.upper() if char.islower() else char.lower()\n            else:\n                if is_vowel(char.lower()):\n                    encoded_message += shift_vowel(char.lower())\n                else:\n                    encoded_message += char.lower() if char.isupper() else char.upper()\n        else:\n            encoded_message += char\n    return encoded_message\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    def is_vowel(char: str) -> bool:\n        \"\"\"\n        Checks if a character is a vowel.\n        \n        Args:\n            char (str): The character to check.\n            \n        Returns:\n            bool: True if the character is a vowel, False otherwise.\n        \"\"\"\n        vowels = \"aeiouAEIOU\"\n        return char in vowels\n\n    def shift_vowel(char: str) -> str:\n        \"\"\"\n        Replaces a vowel with the letter that appears 2 places ahead of that vowel in the English alphabet.\n        \n        Args:\n            char (str): The vowel to be replaced.\n            \n        Returns:\n            str: The letter that appears 2 places ahead of the given vowel.\n        \"\"\"\n        vowels = \"aeiou\"\n        shifted_vowels = \"cgkqw\"\n        index = vowels.index(char.lower())\n        return shifted_vowels[index] if char.islower() else shifted_vowels[index].upper()\n\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                encoded_message += char.upper() if is_vowel(char) else char\n            else:\n                encoded_message += char.lower() if is_vowel(char.lower()) else char\n        else:\n            encoded_message += char\n\n    return encoded_message\n\n# Example usage:\n# encoded_message = encode(\"Hello World!\")\n# print(encoded_message)  # Output: \"hELLO wORLD!\"\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a given message by swapping the case of letters, and replacing vowels with the letter that appears 2 places ahead of that vowel in the English alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowels replacement\n    vowel_replacement = {\n        'a': 'c',\n        'e': 'g',\n        'i': 'k',\n        'o': 'q',\n        'u': 'w',\n        'A': 'C',\n        'E': 'G',\n        'I': 'K',\n        'O': 'Q',\n        'U': 'W'\n    }\n\n    # Function to swap the case of a letter\n    def swap_case(char: str) -> str:\n        if char.islower():\n            return char.upper()\n        elif char.isupper():\n            return char.lower()\n        else:\n            return char\n\n    # Initialize the encoded message\n    encoded_message = []\n\n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():\n            # Swap the case if the character is a letter\n            char = swap_case(char)\n            # Replace the vowel if applicable\n            if char in vowel_replacement:\n                char = vowel_replacement[char]\n        encoded_message.append(char)\n\n    # Join the list into a string and return the encoded message\n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    message = \"Hello World!\"\n    encoded_message = encode(message)\n    print(encoded_message)  # Output: \"Gijq Vqwnsq!\"\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes the input message by swapping the case of each letter and replacing vowels with a specific mapping.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowels and their replacements\n    vowel_mapping = {\n        'a': 'A',\n        'e': 'E',\n        'i': 'I',\n        'o': 'O',\n        'u': 'U',\n        'A': 'a',\n        'E': 'e',\n        'I': 'i',\n        'O': 'o',\n        'U': 'u'\n    }\n\n    # Initialize the encoded message\n    encoded_message = []\n\n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap the case of the letter\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n        else:\n            # If not a letter, keep the character as is\n            new_char = char\n\n        # Replace the vowel if it exists in the mapping\n        if new_char in vowel_mapping:\n            new_char = vowel_mapping[new_char]\n\n        # Append the new character to the encoded message\n        encoded_message.append(new_char)\n\n    # Join the list of characters into a single string\n    return ''.join(encoded_message)\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    def shift_vowel(c: str) -> str:\n        vowels = 'aeiouAEIOU'\n        if c in vowels:\n            index = vowels.index(c)\n            new_index = (index + 2) % len(vowels)\n            return vowels[new_index]\n        return c\n\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                encoded_message += char.upper() if char.isupper() else char.lower()\n            else:\n                encoded_message += char.lower() if char.islower() else char.upper()\n        else:\n            encoded_message += shift_vowel(char)\n    return encoded_message\n", "from typing import List\n## main.py\n\nimport pygame\n\ndef encode(message: str) -> str:\n    # Function to encode the message\n    # Input: str\n    # Output: str\n    # Description: Swaps case of all letters and replaces vowels with the letter that appears two places ahead in the alphabet.\n\n    def is_vowel(char: str) -> bool:\n        vowels = \"aeiouAEIOU\"\n        return char in vowels\n\n    def shift_vowel(char: str) -> str:\n        shift_map = {\n            'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n            'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'\n        }\n        return shift_map.get(char, char)\n\n    encoded_message = []\n\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                encoded_message.append(char.upper())\n            else:\n                encoded_message.append(char.lower())\n            if is_vowel(char):\n                encoded_message[-1] = shift_vowel(encoded_message[-1])\n        else:\n            encoded_message.append(char)\n\n    return ''.join(encoded_message)\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    def shift_char(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2) % 26 + ord('A'))\n        return c\n\n    def swap_case(c: str) -> str:\n        if 'a' <= c <= 'z':\n            return c.upper()\n        elif 'A' <= c <= 'Z':\n            return c.lower()\n        return c\n\n    swapped_case_message = ''.join(swap_case(c) for c in message)\n    encoded_message = ''.join(shift_char(c) if c.lower() in 'aeiou' else c for c in swapped_case_message)\n    return encoded_message\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    def swap_case(c: str) -> str:\n        return c.lower() if c.isupper() else c.upper()\n\n    def replace_vowel(c: str) -> str:\n        vowels = 'aeiou'\n        if c in vowels:\n            index = vowels.index(c)\n            return vowels[(index + 2) % len(vowels)]\n        return c\n\n    result = []\n    for char in message:\n        if char.isalpha():\n            char = swap_case(char)\n            char = replace_vowel(char)\n        result.append(char)\n\n    return ''.join(result)\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes the input message by swapping the case of each letter and replacing vowels with a specific mapping.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowels and their replacements\n    vowel_mapping = {\n        'a': 'A',\n        'e': 'E',\n        'i': 'I',\n        'o': 'O',\n        'u': 'U',\n        'A': 'a',\n        'E': 'e',\n        'I': 'i',\n        'O': 'o',\n        'U': 'u'\n    }\n\n    # Initialize the encoded message\n    encoded_message = []\n\n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap the case of the letter\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n        else:\n            # If not a letter, keep the character as is\n            new_char = char\n\n        # Replace the vowel if it exists in the mapping\n        if new_char in vowel_mapping:\n            new_char = vowel_mapping[new_char]\n\n        # Append the new character to the encoded message\n        encoded_message.append(new_char)\n\n    # Join the list of characters into a single string\n    return ''.join(encoded_message)\n"], "plans": ["requirement analysis:\nThe primary requirement is to create a function that encodes messages by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead in the alphabet. This function should handle only letters and should be efficient and easy to use. The output should be visually appealing and easy to read.\nrequirement pool:\n- Implement the function to swap cases and replace vowels as specified.\n- Ensure the function is efficient and handles only letters.\n- Design a user-friendly interface for encoding messages.\n- Ensure the output is visually appealing and easy to read.\n- Test the function with various inputs to ensure accuracy and robustness.\nTo implement the function that encodes messages by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead in the alphabet, we will use Python's built-in string manipulation functions and a simple mapping for vowel replacement. The function will iterate through each character in the input message, check if it's a letter, and then apply the case swap or vowel replacement as needed. The output will be formatted to ensure readability and visual appeal.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This function should handle only letters and should be able to encode both lowercase and uppercase letters appropriately.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The function should replace all vowels with the letter that appears 2 places ahead in the alphabet.\n- The function should handle both lowercase and uppercase letters.\n- The function should be able to encode messages containing spaces and other non-letter characters.\nTo implement the function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet, we will use Python's built-in string manipulation functions and a simple approach to handle the encoding. The function will iterate through each character in the input message, check if it's a letter, and then apply the necessary transformations based on whether the letter is uppercase or lowercase. For vowels, it will replace them with the appropriate letter that is two places ahead in the alphabet.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This function should handle only letters and should be able to handle both uppercase and lowercase letters correctly.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The main code should correctly replace all vowels with the letter that appears 2 places ahead.\n- The function should handle both uppercase and lowercase letters.\n- The function should be able to handle messages with multiple words.\nTo implement the function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet, we will use Python's built-in string manipulation functions and a simple mapping for vowel replacement. The function will iterate through each character in the input message, check if it's a letter, and then apply the case swap or vowel replacement as needed. This approach ensures simplicity and efficiency.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This function should handle only letters and provide clear examples of its functionality.\nrequirement pool:\n- The main code should correctly swap the case of letters and replace vowels as specified.\n- The function should handle edge cases such as all vowels or all consonants.\n- The output should be visually appealing and easy to read.\n- The function should be efficient and quick to encode messages.\n- The application should be user-friendly and provide clear instructions.\nWe will implement the function by creating a Python function that takes a string as input, iterates through each character, swaps its case if it's a letter, and replaces vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This will be achieved using basic Python string operations and a predefined mapping for the vowel replacement.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This function should handle only letters and should be efficient and easy to use.\nrequirement pool:\n- The main code should efficiently swap case and replace vowels.\n- The function should handle only letters.\n- The encoded message should be easily readable.\n- The process should be user-friendly and fast.\nWe will implement the function by first defining a mapping for vowels and their replacements. Then, we will iterate through each character in the input message, swapping its case and replacing vowels according to the defined mapping. This approach ensures efficiency and simplicity in handling the requirements.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead in the alphabet. This function should handle only letters and should be able to handle both uppercase and lowercase letters correctly.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The function should replace all vowels with the letter that appears 2 places ahead in the alphabet.\n- The function should handle both uppercase and lowercase letters.\n- The function should be able to handle messages containing only letters.\nTo implement the function that encodes a message by swapping the case of all letters and replacing vowels with the letter that appears 2 places ahead in the alphabet, we will use Python's built-in string manipulation functions. We will iterate through each character in the input message, check if it's a letter, and then swap its case. For vowels, we will replace them with the letter that appears 2 places ahead in the alphabet. This approach ensures that the function handles both uppercase and lowercase letters correctly.\n", "requirement analysis:\nThe original requirements specify a function that encodes a message by swapping the case of all letters and replacing vowels with the letter that appears two places ahead in the alphabet. This includes handling only letters and providing examples of expected outputs.\nrequirement pool:\n- Implement the function to swap case and replace vowels as specified\n- Ensure the function handles only letters and ignores non-letter characters\n- Provide clear and correct examples of the function's output\nTo implement the function that encodes a message by swapping the case of all letters and replacing vowels with the letter that appears two places ahead in the alphabet, we will use Python's built-in string manipulation methods and a simple dictionary for vowel replacement. The function will iterate through each character in the input message, check if it's a letter, and then apply the case swap and vowel replacement as per the requirements. This approach ensures simplicity and efficiency.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This function should only process letters and should handle both uppercase and lowercase letters appropriately.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The main code should correctly replace all vowels with the letter that appears 2 places ahead.\n- The function should handle both uppercase and lowercase letters.\n- The function should only process letters and ignore non-letter characters.\nWe will implement the function by first swapping the case of all letters in the message. Then, we will replace all vowels with the letter that appears 2 places ahead in the English alphabet. This will be done using string manipulation techniques available in Python.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. The function should handle only letters and should be efficient and easy to understand.\nrequirement pool:\n- The main code should efficiently swap cases and replace vowels.\n- The function should be easy to understand and maintain.\n- The UI for encoding messages should be intuitive and visually appealing.\n- The function should handle edge cases such as empty strings or strings with no vowels.\nWe will use Python's built-in string manipulation methods and a custom function to swap the case of letters and replace vowels. This approach ensures efficiency and clarity in the code.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. This function should handle only letters and should be efficient and easy to use.\nrequirement pool:\n- The main code should efficiently swap case and replace vowels.\n- The function should handle only letters.\n- The encoded message should be easily readable.\n- The process should be user-friendly and fast.\nWe will implement the function by first defining a mapping for vowels and their replacements. Then, we will iterate through each character in the input message, swapping its case and replacing vowels according to the defined mapping. This approach ensures efficiency and simplicity in handling the requirements.\n"], "scores": [0.2692, 0.5462, 0.0, 1.0, 0.1462, 0.0, 0.0, 1.0, 0.1462, 0.1462], "pass_results": [false, false, false, true, false, false, false, true, false, false], "pass_test_cases_num": [35, 71, 0, 130, 19, 0, 0, 130, 19, 19], "completion": "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes the input message by swapping the case of each letter and replacing vowels with a specific mapping.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowels and their replacements\n    vowel_mapping = {\n        'a': 'A',\n        'e': 'E',\n        'i': 'I',\n        'o': 'O',\n        'u': 'U',\n        'A': 'a',\n        'E': 'e',\n        'I': 'i',\n        'O': 'o',\n        'U': 'u'\n    }\n\n    # Initialize the encoded message\n    encoded_message = []\n\n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap the case of the letter\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n        else:\n            # If not a letter, keep the character as is\n            new_char = char\n\n        # Replace the vowel if it exists in the mapping\n        if new_char in vowel_mapping:\n            new_char = vowel_mapping[new_char]\n\n        # Append the new character to the encoded message\n        encoded_message.append(new_char)\n\n    # Join the list of characters into a single string\n    return ''.join(encoded_message)\n", "passed": true, "pass": true, "pass_num": 2, "round": 221, "repair_prompt": ["def encode(message):\t\n'''Write a function that takes a message, and encodes in such a way that it swaps case of all letters and replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the English alphabet. Assume only letters.\nExamples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    '''"], "mutate_method": "condense_two2one", "parent_index": 72}
