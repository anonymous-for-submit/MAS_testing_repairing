{"task_id": "HumanEval/6", "prompt": "def parse_nested_parens(paren_string: str) -> List[int]:\t\n'''Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    '''", "entry_point": "parse_nested_parens", "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "test": ["def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()()) ((())) (((()))) (((()))) (()) ()\") == [3, 2, 3, 4, 4, 2, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()) (()()) ((())) ((())()())\") == [3, 1, 2, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) ((())) ((())()()) (()) (()()) ((())) ((())) () () ((())()()) (()()) () (((()))) ((())()()) () (((()))) (((()))) ()\") == [4, 3, 3, 2, 2, 3, 3, 1, 1, 3, 2, 1, 4, 3, 1, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (((()))) ((())()()) (()()) () (((())))\") == [3, 4, 3, 2, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())) (()()) () () (()()) () ()\") == [2, 3, 2, 1, 1, 2, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) () ((())()()) () () ((())) ((())) (()()) () () (()())\") == [3, 2, 1, 3, 1, 1, 3, 3, 2, 1, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) ((())()()) ((())) (()()) () ((())()()) (()()) ((())()()) ((())) ((())) (()())\") == [3, 2, 3, 3, 2, 1, 3, 2, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()(())((()))) (((()))) ((())) (()) () ((())) ((())) (()()) ((())()()) (()()) () (()) (((()))) (()) ((())) (((()))) ((())) ((())()()) ((())()())\") == [3, 1, 4, 4, 3, 2, 1, 3, 3, 2, 3, 2, 1, 2, 4, 2, 3, 4, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) ((())()()) ((())()()) (()()) ((())) () () ((())) () () (()())\") == [3, 2, 3, 3, 2, 3, 1, 1, 3, 1, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())) () () () () (()()) (()()) (()()) ((())()()) ()\") == [3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) (()) ((())()()) () () ((())) ((())) (((()))) () (()()) (((())))\") == [2, 4, 2, 3, 1, 1, 3, 3, 4, 1, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())) ((())) ((())()())\") == [2, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())) (()) (()()) ((())()()) ((())()())\") == [2, 3, 2, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()) (()()) ((())) (((()))) () ((())()()) ((())) (()()) (()()) (()) ((())()())\") == [3, 2, 2, 3, 4, 1, 3, 3, 2, 2, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () ((())()()) ((())()()) (((()))) ((())()()) (((())))\") == [3, 1, 3, 3, 4, 3, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) ((())) (()) ((())) () () () (((()))) (()()) (()()) (((()))) (()) (()) (((())))\") == [4, 3, 2, 3, 1, 1, 1, 4, 2, 2, 4, 2, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()) (()()) (()()) (()()) ((())) (((()))) (()(())((()))) (()) () (((()))) (()) ((())) (())\") == [4, 2, 2, 2, 2, 3, 4, 4, 2, 1, 4, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()) (()) (()()) (()()) (((()))) (()) (((()))) (()(())((()))) ((())) ((())) ((())()()) () (((())))\") == [2, 2, 2, 2, 2, 4, 2, 4, 4, 3, 3, 3, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) ((())) (((()))) ((())()()) (()()) (()(())((()))) ((())()()) ((())) ((())) (()()) ((())()()) ((())) (()) (()(())((()))) () () (()(())((()))) (()()) (((()))) (((()))) ()\") == [4, 3, 4, 3, 2, 4, 3, 3, 3, 2, 3, 3, 2, 4, 1, 1, 4, 2, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) ((())) ((())) ((())) (()) (()(())((()))) () ((())) (((()))) (()) ((())) ((())) () (()(())((())))\") == [4, 3, 3, 3, 2, 4, 1, 3, 4, 2, 3, 3, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()()) () ((())) (()()) () ((())()()) ((())) ((())) ((())) ((())) ((()))\") == [3, 2, 1, 3, 2, 1, 3, 3, 3, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())()()) ((())()()) () (((()))) ((())()()) ((())()()) (()()) (()()) (()) ((())) (()())\") == [2, 3, 3, 1, 4, 3, 3, 2, 2, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()(())((()))) (()) (()(())((()))) (((()))) (()(())((()))) (())\") == [3, 4, 2, 4, 4, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()) (()(())((()))) (()) (((()))) (((()))) ((())()())\") == [2, 2, 4, 2, 4, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) ((())()()) (((()))) (()(())((()))) ((())()())\") == [4, 4, 4, 3, 4, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) ((())()()) () ((())()()) (()()) () () ((())) (()()) ((())) ((())()())\") == [1, 3, 3, 1, 3, 2, 1, 1, 3, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()()) ((())()()) (()()) () () ((())) () ((())()()) (((()))) (((()))) ()\") == [2, 2, 3, 2, 1, 1, 3, 1, 3, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())()()) ((())) (()())\") == [2, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())()()) (()()) (()) ((())()()) (((()))) (((()))) ((())()()) ((())) ((())()()) () (()()) (()()) ((())()()) (()) ((())) ((())()())\") == [3, 3, 3, 2, 2, 3, 4, 4, 3, 3, 3, 1, 2, 2, 3, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) () (()()) (()())\") == [2, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) ((())) () ((())()()) (()()) (()()) () ((())) ((())) (()()) (((()))) (()())\") == [4, 3, 1, 3, 2, 2, 1, 3, 3, 2, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())()()) () ((())) (()()) ((())()()) (()())\") == [3, 3, 3, 1, 3, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())) ((())) ((())()()) () ((()))\") == [2, 3, 3, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) (()()) () () ((())) ((())()()) ()\") == [2, 2, 2, 1, 1, 3, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()(())((()))) ((())()()) (()()) (((()))) ((())()()) ((())()())\") == [2, 4, 3, 2, 4, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (((()))) (((()))) (()()) (((())))\") == [3, 1, 4, 4, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) () (()()) (((()))) ((())) (()()) () (()) (((()))) (()(())((()))) (((()))) (((()))) ()\") == [1, 3, 1, 2, 4, 3, 2, 1, 2, 4, 4, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())()()) () ((()))\") == [3, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () ((()))\") == [2, 2, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) () (()) () (()) (())\") == [4, 1, 2, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())()()) () ((())) (()()) () () () () (()()) ((())) ((()))\") == [1, 3, 1, 3, 2, 1, 1, 1, 1, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) (()()) (()()) ((())()()) ((())) ((())) ((())()())\") == [3, 3, 2, 2, 3, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () ((())()()) (((()))) (()) (((()))) () ((())) (()()) (()) (((()))) (()())\") == [3, 1, 3, 4, 2, 4, 1, 3, 2, 2, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()) ((())) () () () ((()))\") == [2, 2, 3, 1, 1, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (((()))) ((())()()) ((())) ((())()()) (())\") == [3, 4, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())) (()()) ((())()()) () () ()\") == [3, 3, 3, 2, 3, 1, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () (()()) ((())()()) (()()) () (()()) ((())) () () (()())\") == [2, 2, 1, 2, 3, 2, 1, 2, 3, 1, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (((()))) (()) (()) ((())) () ((())) ((())()()) ((())) (()) (()()) (((())))\") == [2, 4, 2, 2, 3, 1, 3, 3, 3, 2, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (((()))) () (()()) ((())()()) () (()(())((()))) (()(())((()))) (()()) () (()()) (()) (()) ((())()())\") == [4, 4, 1, 2, 3, 1, 4, 4, 2, 1, 2, 2, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (((()))) ((())) ((())) ((())) ((())()()) ((())()()) (()()) () () (()(())((()))) ((())) ((())()()) (()(())((()))) () ((())()()) (((()))) (((()))) (()(())((()))) ((())()()) ()\") == [3, 4, 3, 3, 3, 3, 3, 2, 1, 1, 4, 3, 3, 4, 1, 3, 4, 4, 4, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) ((())()()) ((())) () (()()) () (()())\") == [1, 3, 3, 3, 1, 2, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()()) () (()()) ((())()()) ((())) ((())) (()) ((())()()) () ((())()()) (()()) () (()) ((())) (()()) (()()) ((())()())\") == [2, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 2, 1, 2, 3, 2, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) (((()))) (()) (()()) (((()))) () (((()))) (()) ((())) () ()\") == [2, 4, 4, 2, 2, 4, 1, 4, 2, 3, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) (((()))) (()()) (((()))) ((())) ((())()()) (()) ((())()()) (((()))) (()()) () (()) (((()))) () (()(())((()))) () (()) (()(())((()))) ((())) ((())()())\") == [2, 4, 4, 2, 4, 3, 3, 2, 3, 4, 2, 1, 2, 4, 1, 4, 1, 2, 4, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() (()(())((()))) (()) (()()) ((())()()) (()()) (()())\") == [1, 4, 2, 2, 3, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()(())((()))) (()()) (()()) ((())()()) (()()) ((())) () () (()()) (()(())((()))) ((())()()) (()()) ((())()()) (((()))) (()(())((()))) (()()) () ((())()()) ((())()()) ()\") == [3, 4, 2, 2, 3, 2, 3, 1, 1, 2, 4, 3, 2, 3, 4, 4, 2, 1, 3, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () () (()()) (()()) (()()) ((())) (()())\") == [3, 1, 1, 2, 2, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())()()) (()()) (()) ((())()()) () (((()))) ((())()()) () (()) (()) ((())()()) (()) (()) (()) ((())) ((())) (((())))\") == [1, 3, 2, 2, 3, 1, 4, 3, 1, 2, 2, 3, 2, 2, 2, 3, 3, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) () (()(())((()))) (()) (((()))) ((())()()) ((())()()) ((())) ((())()()) (()(())((()))) ((())) (()(())((()))) ((())) ((())()())\") == [4, 1, 4, 2, 4, 3, 3, 3, 3, 4, 3, 4, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) () (()) (()) ((())) (()()) () () ((())()()) (()) ((()))\") == [2, 4, 1, 2, 2, 3, 2, 1, 1, 3, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())()()) (()()) ((())()()) (((()))) (()()) (()(())((()))) (()()) (()(())((()))) ((())) (()) ((())) (()()) (()) (()()) () ((())) ((())) ((())) ((())) (()())\") == [2, 3, 2, 3, 4, 2, 4, 2, 4, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) ((())()()) ((())) ((())()()) ((())) () ()\") == [3, 3, 3, 3, 3, 3, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) () ((())()())\") == [3, 2, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () (()()) ((())) (()()) () ((())()()) ((()))\") == [3, 1, 2, 3, 2, 1, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) () (()) (((()))) ((())) (()) ((())()()) ((())()()) () ((())()()) (()) ((())()())\") == [4, 1, 2, 4, 3, 2, 3, 3, 1, 3, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () (()()) ((())) ((())()()) ((())()())\") == [3, 1, 2, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () ((())) () (()()) ((())) ((())()()) () () ((())()()) () (()())\") == [3, 1, 3, 1, 2, 3, 3, 1, 1, 3, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) (()()) (((()))) () ((())) (((()))) () (()) () () ((())()()) (()) (()()) ((())) (((()))) (()) (())\") == [1, 3, 2, 4, 1, 3, 4, 1, 2, 1, 1, 3, 2, 2, 3, 4, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () ((())()()) ((())()()) ((())) () ((())()()) ((())) () ((())()()) (()()) (()())\") == [3, 1, 3, 3, 3, 1, 3, 3, 1, 3, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() (()()) ((())()()) (()(())((()))) (((()))) (()(())((()))) ((())()()) (()) (()()) (((()))) (()) (()) (()()) (((()))) (((()))) () (()) ((())) () (()) (()())\") == [1, 2, 3, 4, 4, 4, 3, 2, 2, 4, 2, 2, 2, 4, 4, 1, 2, 3, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) () (((()))) (()()) ((())) () (()()) (((()))) (()()) (((()))) () ()\") == [4, 1, 4, 2, 3, 1, 2, 4, 2, 4, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) () (()) () ((())) (()) (()()) (((()))) ((())) () () (()) () () (()) () ((())) (()(())((()))) ((()))\") == [4, 4, 4, 1, 2, 1, 3, 2, 2, 4, 3, 1, 1, 2, 1, 1, 2, 1, 3, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()) (()()) ((())()()) (()) (()()) ((())) (()()) (()(())((()))) (()(())((()))) ((())()()) ((())) (((()))) (()(())((()))) ((())) ((())) (()(())((()))) () ((())) ((())) ((())()())\") == [2, 2, 2, 3, 2, 2, 3, 2, 4, 4, 3, 3, 4, 4, 3, 3, 4, 1, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()) ((())()()) (()()) ((())) (()) () () (((()))) (((()))) (())\") == [3, 1, 2, 3, 2, 3, 2, 1, 1, 4, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"\") == []", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()) (()()) ((())) () ((())) ((())()()) () () (()) (()) (((()))) (((()))) ((())) () () (()()) (())\") == [3, 2, 2, 3, 1, 3, 3, 1, 1, 2, 2, 4, 4, 3, 1, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())()()) ((())) (()()) ((())()()) () (()()) ((()))\") == [3, 3, 3, 2, 3, 1, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())()()) ((())()()) ((())) (()()) ((())) ((())()()) ((())()()) ((())()()) () ((())) (()())\") == [3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()) () (((()))) ((())()()) ((())()()) (((()))) (()) (((()))) () (((()))) ((())()()) (()()) (()) (()) (()) () (())\") == [3, 2, 1, 4, 3, 3, 4, 2, 4, 1, 4, 3, 2, 2, 2, 2, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()) ((())()()) ((())()()) () ((()))\") == [2, 2, 3, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) () ((())()()) () ((())) () ((())) ()\") == [2, 1, 3, 1, 3, 1, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()()) ()\") == [3, 1, 2, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) (()()) ((())()()) () ((())()()) ((())()()) ((())) (()()) ((())) () ((())()())\") == [3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) () (()()) ((())) () ((())()()) (()()) ((())()())\") == [2, 1, 2, 3, 1, 3, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()) () ((())()()) (()()) () (()()) (()(())((()))) (()(())((()))) ((())) (((()))) (()(())((()))) ((())()()) ()\") == [4, 2, 1, 3, 2, 1, 2, 4, 4, 3, 4, 4, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () (()())\") == [2, 2, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) (((()))) (()) (()()) (()()) () ((())) ((())()()) () (()(())((()))) (()()) (()(())((()))) ((()))\") == [3, 3, 4, 2, 2, 2, 1, 3, 3, 1, 4, 2, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () (()) () (()()) (()) (()) (((()))) () (()()) (())\") == [2, 2, 1, 2, 1, 2, 2, 2, 4, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens('(()(())((())))') == [4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()) (((()))) () (()()) (((()))) ((())()()) ((())) (()()) ((())()()) (((()))) ((())) (()) ((())) ((())) () ((())) ((())()())\") == [3, 2, 4, 1, 2, 4, 3, 3, 2, 3, 4, 3, 2, 3, 3, 1, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())()()) (()) ((())) ((())) ((())()()) (((()))) () ((())()()) (()(())((()))) ((())) ((())()()) ((())()()) (())\") == [2, 3, 2, 3, 3, 3, 4, 1, 3, 4, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())()()) (()()) ()\") == [2, 3, 2, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) ((())()()) (((()))) (()(())((()))) () (()(())((()))) ()\") == [4, 3, 4, 4, 1, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) ((())()()) () ((())) ((())) (()()) ((())()()) (((()))) () (()) (((())))\") == [3, 3, 3, 1, 3, 3, 2, 3, 4, 1, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (((()))) ((())) (()()) (()()) ((())()()) (()) (()(())((()))) (()) ((())) (()) ((())) () (((())))\") == [3, 4, 3, 2, 2, 3, 2, 4, 2, 3, 2, 3, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) ((())()()) (()()) () (()(())((()))) (()()) (((()))) (((()))) ((())()()) (()()) () () ((())) (((()))) (()(())((()))) (((()))) ((())()()) ((())) (()(())((()))) (())\") == [3, 3, 3, 2, 1, 4, 2, 4, 4, 3, 2, 1, 1, 3, 4, 4, 4, 3, 3, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) () (((()))) () (((()))) (()()) (()) (((()))) (()(())((()))) (((()))) () (()()) (()(())((()))) (()()) (()(())((()))) (()()) (((()))) (()()) (((()))) (()) (()())\") == [2, 1, 4, 1, 4, 2, 2, 4, 4, 4, 1, 2, 4, 2, 4, 2, 4, 2, 4, 2, 2]"], "test_case_list": ["assert parse_nested_parens(\"((())()()) (()()) ((())) (((()))) (((()))) (()) ()\") == [3, 2, 3, 4, 4, 2, 1]", "assert parse_nested_parens(\"((())) () (()) (()()) ((())) ((())()())\") == [3, 1, 2, 2, 3, 3]", "assert parse_nested_parens(\"(((()))) ((())) ((())()()) (()) (()()) ((())) ((())) () () ((())()()) (()()) () (((()))) ((())()()) () (((()))) (((()))) ()\") == [4, 3, 3, 2, 2, 3, 3, 1, 1, 3, 2, 1, 4, 3, 1, 4, 4, 1]", "assert parse_nested_parens(\"((())) (((()))) ((())()()) (()()) () (((())))\") == [3, 4, 3, 2, 1, 4]", "assert parse_nested_parens(\"(()()) ((())) (()()) () () (()()) () ()\") == [2, 3, 2, 1, 1, 2, 1, 1]", "assert parse_nested_parens(\"((())) (()()) () ((())()()) () () ((())) ((())) (()()) () () (()())\") == [3, 2, 1, 3, 1, 1, 3, 3, 2, 1, 1, 2]", "assert parse_nested_parens(\"((())) (()()) ((())()()) ((())) (()()) () ((())()()) (()()) ((())()()) ((())) ((())) (()())\") == [3, 2, 3, 3, 2, 1, 3, 2, 3, 3, 3, 2]", "assert parse_nested_parens(\"((())) () (()(())((()))) (((()))) ((())) (()) () ((())) ((())) (()()) ((())()()) (()()) () (()) (((()))) (()) ((())) (((()))) ((())) ((())()()) ((())()())\") == [3, 1, 4, 4, 3, 2, 1, 3, 3, 2, 3, 2, 1, 2, 4, 2, 3, 4, 3, 3, 3]", "assert parse_nested_parens(\"((())) (()()) ((())()()) ((())()()) (()()) ((())) () () ((())) () () (()())\") == [3, 2, 3, 3, 2, 3, 1, 1, 3, 1, 1, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())) () () () () (()()) (()()) (()()) ((())()()) ()\") == [3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 3, 1]", "assert parse_nested_parens(\"(()()) (((()))) (()) ((())()()) () () ((())) ((())) (((()))) () (()()) (((())))\") == [2, 4, 2, 3, 1, 1, 3, 3, 4, 1, 2, 4]", "assert parse_nested_parens(\"(()()) ((())) ((())) ((())()())\") == [2, 3, 3, 3]", "assert parse_nested_parens(\"(()) ((())) (()) (()()) ((())()()) ((())()())\") == [2, 3, 2, 2, 3, 3]", "assert parse_nested_parens(\"((())) (()) (()()) ((())) (((()))) () ((())()()) ((())) (()()) (()()) (()) ((())()())\") == [3, 2, 2, 3, 4, 1, 3, 3, 2, 2, 2, 3]", "assert parse_nested_parens(\"((())) () ((())()()) ((())()()) (((()))) ((())()()) (((())))\") == [3, 1, 3, 3, 4, 3, 4]", "assert parse_nested_parens(\"(((()))) ((())) (()) ((())) () () () (((()))) (()()) (()()) (((()))) (()) (()) (((())))\") == [4, 3, 2, 3, 1, 1, 1, 4, 2, 2, 4, 2, 2, 4]", "assert parse_nested_parens(\"(((()))) (()) (()()) (()()) (()()) ((())) (((()))) (()(())((()))) (()) () (((()))) (()) ((())) (())\") == [4, 2, 2, 2, 2, 3, 4, 4, 2, 1, 4, 2, 3, 2]", "assert parse_nested_parens(\"(()()) (()) (()) (()()) (()()) (((()))) (()) (((()))) (()(())((()))) ((())) ((())) ((())()()) () (((())))\") == [2, 2, 2, 2, 2, 4, 2, 4, 4, 3, 3, 3, 1, 4]", "assert parse_nested_parens(\"(()(())((()))) ((())) (((()))) ((())()()) (()()) (()(())((()))) ((())()()) ((())) ((())) (()()) ((())()()) ((())) (()) (()(())((()))) () () (()(())((()))) (()()) (((()))) (((()))) ()\") == [4, 3, 4, 3, 2, 4, 3, 3, 3, 2, 3, 3, 2, 4, 1, 1, 4, 2, 4, 4, 1]", "assert parse_nested_parens(\"(()(())((()))) ((())) ((())) ((())) (()) (()(())((()))) () ((())) (((()))) (()) ((())) ((())) () (()(())((())))\") == [4, 3, 3, 3, 2, 4, 1, 3, 4, 2, 3, 3, 1, 4]", "assert parse_nested_parens(\"((())()()) (()()) () ((())) (()()) () ((())()()) ((())) ((())) ((())) ((())) ((()))\") == [3, 2, 1, 3, 2, 1, 3, 3, 3, 3, 3, 3]", "assert parse_nested_parens(\"(()) ((())()()) ((())()()) () (((()))) ((())()()) ((())()()) (()()) (()()) (()) ((())) (()())\") == [2, 3, 3, 1, 4, 3, 3, 2, 2, 2, 3, 2]", "assert parse_nested_parens(\"((())()()) (()(())((()))) (()) (()(())((()))) (((()))) (()(())((()))) (())\") == [3, 4, 2, 4, 4, 4, 2]", "assert parse_nested_parens(\"(()) (()) (()(())((()))) (()) (((()))) (((()))) ((())()())\") == [2, 2, 4, 2, 4, 4, 3]", "assert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) ((())()()) (((()))) (()(())((()))) ((())()())\") == [4, 4, 4, 3, 4, 4, 3]", "assert parse_nested_parens(\"() ((())) ((())()()) () ((())()()) (()()) () () ((())) (()()) ((())) ((())()())\") == [1, 3, 3, 1, 3, 2, 1, 1, 3, 2, 3, 3]", "assert parse_nested_parens(\"(()) (()()) ((())()()) (()()) () () ((())) () ((())()()) (((()))) (((()))) ()\") == [2, 2, 3, 2, 1, 1, 3, 1, 3, 4, 4, 1]", "assert parse_nested_parens(\"(()()) ((())()()) ((())) (()())\") == [2, 3, 3, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())()()) (()()) (()) ((())()()) (((()))) (((()))) ((())()()) ((())) ((())()()) () (()()) (()()) ((())()()) (()) ((())) ((())()())\") == [3, 3, 3, 2, 2, 3, 4, 4, 3, 3, 3, 1, 2, 2, 3, 2, 3, 3]", "assert parse_nested_parens(\"(()()) () (()()) (()())\") == [2, 1, 2, 2]", "assert parse_nested_parens(\"(((()))) ((())) () ((())()()) (()()) (()()) () ((())) ((())) (()()) (((()))) (()())\") == [4, 3, 1, 3, 2, 2, 1, 3, 3, 2, 4, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())()()) () ((())) (()()) ((())()()) (()())\") == [3, 3, 3, 1, 3, 2, 3, 2]", "assert parse_nested_parens(\"(()) ((())) ((())) ((())()()) () ((()))\") == [2, 3, 3, 3, 1, 3]", "assert parse_nested_parens(\"(()()) (()()) (()()) () () ((())) ((())()()) ()\") == [2, 2, 2, 1, 1, 3, 3, 1]", "assert parse_nested_parens(\"(()) (()(())((()))) ((())()()) (()()) (((()))) ((())()()) ((())()())\") == [2, 4, 3, 2, 4, 3, 3]", "assert parse_nested_parens(\"((())) () (((()))) (((()))) (()()) (((())))\") == [3, 1, 4, 4, 2, 4]", "assert parse_nested_parens(\"() ((())) () (()()) (((()))) ((())) (()()) () (()) (((()))) (()(())((()))) (((()))) (((()))) ()\") == [1, 3, 1, 2, 4, 3, 2, 1, 2, 4, 4, 4, 4, 1]", "assert parse_nested_parens(\"((())) ((())()()) () ((()))\") == [3, 3, 1, 3]", "assert parse_nested_parens(\"(()()) (()()) () ((()))\") == [2, 2, 1, 3]", "assert parse_nested_parens(\"(((()))) () (()) () (()) (())\") == [4, 1, 2, 1, 2, 2]", "assert parse_nested_parens(\"() ((())()()) () ((())) (()()) () () () () (()()) ((())) ((()))\") == [1, 3, 1, 3, 2, 1, 1, 1, 1, 2, 3, 3]", "assert parse_nested_parens(\"((())) ((())) (()()) (()()) ((())()()) ((())) ((())) ((())()())\") == [3, 3, 2, 2, 3, 3, 3, 3]", "assert parse_nested_parens(\"((())) () ((())()()) (((()))) (()) (((()))) () ((())) (()()) (()) (((()))) (()())\") == [3, 1, 3, 4, 2, 4, 1, 3, 2, 2, 4, 2]", "assert parse_nested_parens(\"(()()) (()) ((())) () () () ((()))\") == [2, 2, 3, 1, 1, 1, 3]", "assert parse_nested_parens(\"((())()()) (((()))) ((())()()) ((())) ((())()()) (())\") == [3, 4, 3, 3, 3, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())) (()()) ((())()()) () () ()\") == [3, 3, 3, 2, 3, 1, 1, 1]", "assert parse_nested_parens(\"(()()) (()()) () (()()) ((())()()) (()()) () (()()) ((())) () () (()())\") == [2, 2, 1, 2, 3, 2, 1, 2, 3, 1, 1, 2]", "assert parse_nested_parens(\"(()) (((()))) (()) (()) ((())) () ((())) ((())()()) ((())) (()) (()()) (((())))\") == [2, 4, 2, 2, 3, 1, 3, 3, 3, 2, 2, 4]", "assert parse_nested_parens(\"(((()))) (((()))) () (()()) ((())()()) () (()(())((()))) (()(())((()))) (()()) () (()()) (()) (()) ((())()())\") == [4, 4, 1, 2, 3, 1, 4, 4, 2, 1, 2, 2, 2, 3]", "assert parse_nested_parens(\"((())()()) (((()))) ((())) ((())) ((())) ((())()()) ((())()()) (()()) () () (()(())((()))) ((())) ((())()()) (()(())((()))) () ((())()()) (((()))) (((()))) (()(())((()))) ((())()()) ()\") == [3, 4, 3, 3, 3, 3, 3, 2, 1, 1, 4, 3, 3, 4, 1, 3, 4, 4, 4, 3, 1]", "assert parse_nested_parens(\"() ((())) ((())()()) ((())) () (()()) () (()())\") == [1, 3, 3, 3, 1, 2, 1, 2]", "assert parse_nested_parens(\"(()) (()()) () (()()) ((())()()) ((())) ((())) (()) ((())()()) () ((())()()) (()()) () (()) ((())) (()()) (()()) ((())()())\") == [2, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 2, 1, 2, 3, 2, 2, 3]", "assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]", "assert parse_nested_parens(\"(()()) (((()))) (((()))) (()) (()()) (((()))) () (((()))) (()) ((())) () ()\") == [2, 4, 4, 2, 2, 4, 1, 4, 2, 3, 1, 1]", "assert parse_nested_parens(\"(()()) (((()))) (((()))) (()()) (((()))) ((())) ((())()()) (()) ((())()()) (((()))) (()()) () (()) (((()))) () (()(())((()))) () (()) (()(())((()))) ((())) ((())()())\") == [2, 4, 4, 2, 4, 3, 3, 2, 3, 4, 2, 1, 2, 4, 1, 4, 1, 2, 4, 3, 3]", "assert parse_nested_parens(\"() (()(())((()))) (()) (()()) ((())()()) (()()) (()())\") == [1, 4, 2, 2, 3, 2, 2]", "assert parse_nested_parens(\"((())()()) (()(())((()))) (()()) (()()) ((())()()) (()()) ((())) () () (()()) (()(())((()))) ((())()()) (()()) ((())()()) (((()))) (()(())((()))) (()()) () ((())()()) ((())()()) ()\") == [3, 4, 2, 2, 3, 2, 3, 1, 1, 2, 4, 3, 2, 3, 4, 4, 2, 1, 3, 3, 1]", "assert parse_nested_parens(\"((())()()) () () (()()) (()()) (()()) ((())) (()())\") == [3, 1, 1, 2, 2, 2, 3, 2]", "assert parse_nested_parens(\"() ((())()()) (()()) (()) ((())()()) () (((()))) ((())()()) () (()) (()) ((())()()) (()) (()) (()) ((())) ((())) (((())))\") == [1, 3, 2, 2, 3, 1, 4, 3, 1, 2, 2, 3, 2, 2, 2, 3, 3, 4]", "assert parse_nested_parens(\"(()(())((()))) () (()(())((()))) (()) (((()))) ((())()()) ((())()()) ((())) ((())()()) (()(())((()))) ((())) (()(())((()))) ((())) ((())()())\") == [4, 1, 4, 2, 4, 3, 3, 3, 3, 4, 3, 4, 3, 3]", "assert parse_nested_parens(\"(()()) (((()))) () (()) (()) ((())) (()()) () () ((())()()) (()) ((()))\") == [2, 4, 1, 2, 2, 3, 2, 1, 1, 3, 2, 3]", "assert parse_nested_parens(\"(()) ((())()()) (()()) ((())()()) (((()))) (()()) (()(())((()))) (()()) (()(())((()))) ((())) (()) ((())) (()()) (()) (()()) () ((())) ((())) ((())) ((())) (()())\") == [2, 3, 2, 3, 4, 2, 4, 2, 4, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3, 2]", "assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]", "assert parse_nested_parens(\"((())) ((())) ((())()()) ((())) ((())()()) ((())) () ()\") == [3, 3, 3, 3, 3, 3, 1, 1]", "assert parse_nested_parens(\"((())) (()()) () ((())()())\") == [3, 2, 1, 3]", "assert parse_nested_parens(\"((())()()) () (()()) ((())) (()()) () ((())()()) ((()))\") == [3, 1, 2, 3, 2, 1, 3, 3]", "assert parse_nested_parens(\"(((()))) () (()) (((()))) ((())) (()) ((())()()) ((())()()) () ((())()()) (()) ((())()())\") == [4, 1, 2, 4, 3, 2, 3, 3, 1, 3, 2, 3]", "assert parse_nested_parens(\"((())()()) () (()()) ((())) ((())()()) ((())()())\") == [3, 1, 2, 3, 3, 3]", "assert parse_nested_parens(\"((())()()) () ((())) () (()()) ((())) ((())()()) () () ((())()()) () (()())\") == [3, 1, 3, 1, 2, 3, 3, 1, 1, 3, 1, 2]", "assert parse_nested_parens(\"() ((())) (()()) (((()))) () ((())) (((()))) () (()) () () ((())()()) (()) (()()) ((())) (((()))) (()) (())\") == [1, 3, 2, 4, 1, 3, 4, 1, 2, 1, 1, 3, 2, 2, 3, 4, 2, 2]", "assert parse_nested_parens(\"((())()()) () ((())()()) ((())()()) ((())) () ((())()()) ((())) () ((())()()) (()()) (()())\") == [3, 1, 3, 3, 3, 1, 3, 3, 1, 3, 2, 2]", "assert parse_nested_parens(\"() (()()) ((())()()) (()(())((()))) (((()))) (()(())((()))) ((())()()) (()) (()()) (((()))) (()) (()) (()()) (((()))) (((()))) () (()) ((())) () (()) (()())\") == [1, 2, 3, 4, 4, 4, 3, 2, 2, 4, 2, 2, 2, 4, 4, 1, 2, 3, 1, 2, 2]", "assert parse_nested_parens(\"(((()))) () (((()))) (()()) ((())) () (()()) (((()))) (()()) (((()))) () ()\") == [4, 1, 4, 2, 3, 1, 2, 4, 2, 4, 1, 1]", "assert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) () (()) () ((())) (()) (()()) (((()))) ((())) () () (()) () () (()) () ((())) (()(())((()))) ((()))\") == [4, 4, 4, 1, 2, 1, 3, 2, 2, 4, 3, 1, 1, 2, 1, 1, 2, 1, 3, 4, 3]", "assert parse_nested_parens(\"(()) (()) (()()) ((())()()) (()) (()()) ((())) (()()) (()(())((()))) (()(())((()))) ((())()()) ((())) (((()))) (()(())((()))) ((())) ((())) (()(())((()))) () ((())) ((())) ((())()())\") == [2, 2, 2, 3, 2, 2, 3, 2, 4, 4, 3, 3, 4, 4, 3, 3, 4, 1, 3, 3, 3]", "assert parse_nested_parens(\"((())) () (()) ((())()()) (()()) ((())) (()) () () (((()))) (((()))) (())\") == [3, 1, 2, 3, 2, 3, 2, 1, 1, 4, 4, 2]", "assert parse_nested_parens(\"\") == []", "assert parse_nested_parens(\"((())()()) (()) (()()) ((())) () ((())) ((())()()) () () (()) (()) (((()))) (((()))) ((())) () () (()()) (())\") == [3, 2, 2, 3, 1, 3, 3, 1, 1, 2, 2, 4, 4, 3, 1, 1, 2, 2]", "assert parse_nested_parens(\"((())) ((())()()) ((())) (()()) ((())()()) () (()()) ((()))\") == [3, 3, 3, 2, 3, 1, 2, 3]", "assert parse_nested_parens(\"((())()()) ((())()()) ((())()()) ((())) (()()) ((())) ((())()()) ((())()()) ((())()()) () ((())) (()())\") == [3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 2]", "assert parse_nested_parens(\"((())()()) (()) () (((()))) ((())()()) ((())()()) (((()))) (()) (((()))) () (((()))) ((())()()) (()()) (()) (()) (()) () (())\") == [3, 2, 1, 4, 3, 3, 4, 2, 4, 1, 4, 3, 2, 2, 2, 2, 1, 2]", "assert parse_nested_parens(\"(()()) (()) ((())()()) ((())()()) () ((()))\") == [2, 2, 3, 3, 1, 3]", "assert parse_nested_parens(\"(()()) () ((())()()) () ((())) () ((())) ()\") == [2, 1, 3, 1, 3, 1, 3, 1]", "assert parse_nested_parens(\"((())) () (()()) ()\") == [3, 1, 2, 1]", "assert parse_nested_parens(\"((())) ((())) (()()) ((())()()) () ((())()()) ((())()()) ((())) (()()) ((())) () ((())()())\") == [3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 1, 3]", "assert parse_nested_parens(\"(()()) () (()()) ((())) () ((())()()) (()()) ((())()())\") == [2, 1, 2, 3, 1, 3, 2, 3]", "assert parse_nested_parens(\"(((()))) (()) () ((())()()) (()()) () (()()) (()(())((()))) (()(())((()))) ((())) (((()))) (()(())((()))) ((())()()) ()\") == [4, 2, 1, 3, 2, 1, 2, 4, 4, 3, 4, 4, 3, 1]", "assert parse_nested_parens(\"(()()) (()()) () (()())\") == [2, 2, 1, 2]", "assert parse_nested_parens(\"((())) ((())) (((()))) (()) (()()) (()()) () ((())) ((())()()) () (()(())((()))) (()()) (()(())((()))) ((()))\") == [3, 3, 4, 2, 2, 2, 1, 3, 3, 1, 4, 2, 4, 3]", "assert parse_nested_parens(\"(()()) (()()) () (()) () (()()) (()) (()) (((()))) () (()()) (())\") == [2, 2, 1, 2, 1, 2, 2, 2, 4, 1, 2, 2]", "assert parse_nested_parens('(()(())((())))') == [4]", "assert parse_nested_parens(\"((())) (()) (((()))) () (()()) (((()))) ((())()()) ((())) (()()) ((())()()) (((()))) ((())) (()) ((())) ((())) () ((())) ((())()())\") == [3, 2, 4, 1, 2, 4, 3, 3, 2, 3, 4, 3, 2, 3, 3, 1, 3, 3]", "assert parse_nested_parens(\"(()) ((())()()) (()) ((())) ((())) ((())()()) (((()))) () ((())()()) (()(())((()))) ((())) ((())()()) ((())()()) (())\") == [2, 3, 2, 3, 3, 3, 4, 1, 3, 4, 3, 3, 3, 2]", "assert parse_nested_parens(\"(()()) ((())()()) (()()) ()\") == [2, 3, 2, 1]", "assert parse_nested_parens(\"(()(())((()))) ((())()()) (((()))) (()(())((()))) () (()(())((()))) ()\") == [4, 3, 4, 4, 1, 4, 1]", "assert parse_nested_parens(\"((())) ((())) ((())()()) () ((())) ((())) (()()) ((())()()) (((()))) () (()) (((())))\") == [3, 3, 3, 1, 3, 3, 2, 3, 4, 1, 2, 4]", "assert parse_nested_parens(\"((())) (((()))) ((())) (()()) (()()) ((())()()) (()) (()(())((()))) (()) ((())) (()) ((())) () (((())))\") == [3, 4, 3, 2, 2, 3, 2, 4, 2, 3, 2, 3, 1, 4]", "assert parse_nested_parens(\"((())) ((())) ((())()()) (()()) () (()(())((()))) (()()) (((()))) (((()))) ((())()()) (()()) () () ((())) (((()))) (()(())((()))) (((()))) ((())()()) ((())) (()(())((()))) (())\") == [3, 3, 3, 2, 1, 4, 2, 4, 4, 3, 2, 1, 1, 3, 4, 4, 4, 3, 3, 4, 2]", "assert parse_nested_parens(\"(()) () (((()))) () (((()))) (()()) (()) (((()))) (()(())((()))) (((()))) () (()()) (()(())((()))) (()()) (()(())((()))) (()()) (((()))) (()()) (((()))) (()) (()())\") == [2, 1, 4, 1, 4, 2, 2, 4, 4, 4, 1, 2, 4, 2, 4, 2, 4, 2, 4, 2, 2]"], "nl": " Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    ", "func": "def parse_nested_parens(paren_string: str) -> List[int]:", "examples": ">>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    ", "completions": ["from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    def find_max_depth(group: str) -> int:\n        max_depth = 0\n        depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = find_max_depth(group)\n        result.append(max_depth)\n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    result = []\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        depth_counter = 0\n        \n        for char in group:\n            if char == '(':\n                depth_counter += 1\n                if depth_counter > max_depth:\n                    max_depth = depth_counter\n            elif char == ')':\n                depth_counter -= 1\n        \n        result.append(max_depth)\n    \n    return result\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input: paren_string (str) - A string containing multiple groups of nested parentheses separated by spaces.\n    Output: List[int] - A list of integers representing the maximum depth of nesting for each group.\n    '''\n    # Split the input string by spaces to get individual groups\n    groups = paren_string.split()\n    max_depths = []\n\n    for group in groups:\n        # Initialize a counter for tracking depth\n        depth_counter = 0\n        max_depth = 0\n        unbalanced = False\n\n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                depth_counter += 1\n                if depth_counter > max_depth:\n                    max_depth = depth_counter\n            elif char == ')':\n                depth_counter -= 1\n                if depth_counter < 0:\n                    unbalanced = True\n                    break\n            else:\n                raise ValueError(f\"Invalid character '{char}' in input string\")\n\n        # Handle unbalanced parentheses\n        if unbalanced or depth_counter != 0:\n            raise ValueError(\"Unbalanced parentheses in the input string\")\n\n        # Append the maximum depth of the current group to the result list\n        max_depths.append(max_depth)\n\n    return max_depths\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    def find_max_depth(group: str) -> int:\n        max_depth = 0\n        depth_counter = 0\n        for char in group:\n            if char == '(':\n                depth_counter += 1\n                max_depth = max(max_depth, depth_counter)\n            elif char == ')':\n                depth_counter -= 1\n        return max_depth\n\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = find_max_depth(group)\n        result.append(max_depth)\n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    result = []\n    \n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        depth_counter = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                depth_counter += 1\n                if depth_counter > max_depth:\n                    max_depth = depth_counter\n            elif char == ')':\n                depth_counter -= 1\n        \n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    result = []\n    \n    # Split the input string by spaces to get individual groups\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        # Initialize a stack to keep track of the depth\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        \n        # Append the deepest level to the result list\n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        \n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        # Initialize a stack to keep track of the depth of nested parentheses\n        stack = []\n        max_depth = 0\n        \n        # Iterate through the characters in the group\n        for char in group:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if stack:\n                    stack.pop()\n                # Update the maximum depth if the stack size is greater than the current max_depth\n                max_depth = max(max_depth, len(stack))\n        \n        # Append the maximum depth to the result list\n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input: paren_string (str) - A string representing multiple groups of nested parentheses separated by spaces.\n    Output: List[int] - A list of integers representing the deepest level of nesting for each group of parentheses.\n    '''\n    # Split the input string by spaces to handle each group\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        depth_count = 0\n        for char in group:\n            if char == '(':\n                depth_count += 1\n                if depth_count > max_depth:\n                    max_depth = depth_count\n            elif char == ')':\n                depth_count -= 1\n        result.append(max_depth)\n    \n    return result\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Output: List[int] - A list where each element corresponds to the deepest level of nesting for each group in the input string.\n    \n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    \n    # Initialize a list to store the depths of each group\n    depths = []\n    \n    # Loop through each group\n    for group in groups:\n        # Initialize a stack to track the depth of nested parentheses\n        stack = []\n        max_depth = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                # Push to stack and update max depth\n                stack.append(char)\n                max_depth = max(max_depth, len(stack))\n            elif char == ')':\n                # Pop from stack\n                stack.pop()\n        \n        # Append the max depth to the result list\n        depths.append(max_depth)\n    \n    return depths\n"], "plans": ["requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses separated by spaces. Each group needs to be analyzed to determine the deepest level of nesting. This involves counting the nested parentheses and tracking the maximum depth reached.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately\n- Ensure the function can handle multiple groups of parentheses\n- Optimize the function for performance\n- Improve error handling for invalid input\n- Add support for more input formats\nTo implement the function parse_nested_parens, we will use a combination of Python's built-in string manipulation methods and a stack data structure. The stack will help us keep track of the depth of nested parentheses. We will iterate through the string, pushing to the stack when encountering an opening parenthesis '(' and popping when encountering a closing parenthesis ')'. The maximum depth reached during this process will represent the deepest level of nesting for each group of parentheses.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the maximum depth of nested parentheses in each group. The function should handle spaces in the input string and be robust against various input formats.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately\n- Ensure the function can handle multiple groups of nested parentheses\n- Optimize the function for performance, especially with large input strings\n- Improve the user interface for better readability and usability\n- Add support for handling spaces in the input string\nTo implement the function `parse_nested_parens` accurately and efficiently, we will use Python's built-in capabilities along with the `collections` module to manage the nested structure effectively. The function will iterate through the input string, counting the depth of nested parentheses and handling multiple groups as specified.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses, separated by spaces. Each group needs to be analyzed to determine the maximum depth of nested parentheses. This involves counting the parentheses and tracking the deepest level reached.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately\n- Ensure the function can handle multiple groups of parentheses\n- Optimize the function for performance\n- Add error handling for malformed input strings\n- Provide detailed documentation and examples for user guidance\nTo implement the function `parse_nested_parens` accurately and efficiently, we will use Python's built-in capabilities along with the `collections` module to manage the nested structure effectively. The function will iterate through the string, counting the depth of nested parentheses and handling multiple groups separated by spaces. We will ensure that the function can handle malformed input strings by adding basic error handling.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses separated by spaces. Each group needs to be analyzed to determine the deepest level of nesting. This is a fundamental task in parsing and string manipulation, requiring a clear understanding of nested structures and efficient handling of input formats.\nrequirement pool:\n- Implement a function to parse nested parentheses correctly\n- Handle multiple groups separated by spaces\n- Ensure compatibility with different input formats\n- Optimize performance for large input strings\nTo implement the function parse_nested_parens, we will use Python's built-in string manipulation capabilities combined with a stack-based approach to efficiently track the depth of nested parentheses. This method ensures that we can handle multiple groups of nested parentheses separated by spaces and accurately determine the deepest level of nesting for each group.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the parentheses and tracking the maximum depth reached.\nrequirement pool:\n- Implement the function to accurately parse and determine nesting levels\n- Ensure the function can handle various input formats\n- Optimize performance for large input strings\n- Add error handling for invalid input strings\n- Provide clear documentation and examples for user guidance\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `collections` module for handling the parentheses parsing. The function will iterate through the input string, tracking the depth of nested parentheses using a counter. It will handle multiple groups of nested parentheses separated by spaces, and output the deepest level of nesting for each group.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the maximum number of nested parentheses in each group. The function should handle spaces separating different groups and return a list of integers representing the deepest level of nesting for each group.\nrequirement pool:\n- Implement the function to accurately parse and determine nesting levels\n- Ensure the function can handle multiple groups of nested parentheses\n- Optimize the function for performance, especially with large input strings\n- Include error handling for invalid input strings\n- Provide clear documentation and examples for user guidance\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `collections` module for handling nested structures. The function will split the input string by spaces to process each group of parentheses separately, then use a stack to keep track of the depth of nested parentheses. Each time an opening parenthesis '(' is encountered, the stack will be incremented, and each time a closing parenthesis ')' is encountered, the stack will be decremented. The maximum value of the stack during this process will represent the deepest level of nesting for that group.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses, separated by spaces. Each group needs to be analyzed to determine the deepest level of nesting. This is a fundamental task in data structure analysis and has applications in various fields including computer science, mathematics, and linguistics.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately\n- Ensure the function can handle multiple groups of parentheses\n- Optimize the function for performance\n- Add support for error handling in case of malformed input\n- Enhance the documentation and examples for better understanding\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `re` module for regular expressions. The function will split the input string by spaces to handle multiple groups of nested parentheses. Each group will be analyzed to determine the deepest level of nesting using a stack-based approach. This method ensures both accuracy and performance, making it suitable for large input strings.\n", "requirement analysis:\nThe primary requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves understanding the structure of nested parentheses and counting the levels of depth accurately. The function should be able to handle various input formats and provide clear, concise output.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately\n- Ensure the function can handle multiple groups of parentheses\n- Optimize the function for performance and scalability\n- Include detailed documentation and examples for user guidance\n- Test the function with various edge cases to ensure robustness\nTo implement the function `parse_nested_parens` accurately and efficiently, we will use Python's built-in capabilities along with the `re` module for regular expressions. The function will split the input string by spaces to handle multiple groups of nested parentheses. Each group will be processed to determine the maximum depth of nested parentheses using a simple stack-based approach. This method ensures that the function can handle large input strings efficiently and accurately.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the maximum number of nested parentheses in each group. The function should be efficient and handle various input formats effectively.\nrequirement pool:\n- Implement the function to accurately determine the deepest level of nesting for each group of parentheses\n- Ensure the function can handle large input strings efficiently\n- Provide clear and concise documentation for easy integration\n- Test the function for robustness and edge cases\n- Optimize the performance for optimal user experience\nTo implement the function that parses nested parentheses and determines the deepest level of nesting for each group, we will use Python's built-in capabilities along with the 'collections' module for efficient counting. The function will split the input string by spaces to handle multiple groups, then for each group, it will use a stack to track the depth of nested parentheses. The maximum depth encountered during the parsing will be the output for each group.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the maximum depth of nested parentheses in each group. The function should handle spaces separating groups and ensure accurate results for each group.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately\n- Ensure the function can handle multiple groups separated by spaces\n- Optimize the function for performance, especially for large input strings\n- Enhance user documentation and support for better understanding and usage\nTo implement the function that parses nested parentheses and determines the deepest level of nesting for each group, we will use Python's built-in capabilities along with the 'collections' module for efficient counting. The function will split the input string by spaces to handle multiple groups, then for each group, it will use a stack to track the depth of nested parentheses. The maximum depth encountered during the parsing will be the output for each group.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0101, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, false, true, true], "pass_test_cases_num": [99, 99, 99, 99, 99, 99, 99, 1, 99, 99], "completion": "from typing import List\n## main.py\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Output: List[int] - A list where each element corresponds to the deepest level of nesting for each group in the input string.\n    \n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    \n    # Initialize a list to store the depths of each group\n    depths = []\n    \n    # Loop through each group\n    for group in groups:\n        # Initialize a stack to track the depth of nested parentheses\n        stack = []\n        max_depth = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                # Push to stack and update max depth\n                stack.append(char)\n                max_depth = max(max_depth, len(stack))\n            elif char == ')':\n                # Pop from stack\n                stack.pop()\n        \n        # Append the max depth to the result list\n        depths.append(max_depth)\n    \n    return depths\n", "passed": true, "pass": true, "pass_num": 9, "round": 5, "repair_prompt": ["def parse_nested_parens(paren_string: str) -> List[int]:\t\n'''Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each group of nested parentheses is separated by a space. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    '''"], "mutate_method": "expand_one2two", "parent_index": 5}
