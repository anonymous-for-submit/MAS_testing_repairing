{"task_id": "HumanEval/68", "prompt": "def pluck(arr):\t\n'''Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found, you should return the node that has the smallest index. The plucked node should be returned in a list. The list should include [ smallest_value, its index ]. If there are no even values or the given array is empty, return [].\nExample 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    '''", "entry_point": "pluck", "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "test": ["def check(pluck):\n\tassert pluck([5, 7, 3]) == []", "def check(pluck):\n\tassert pluck([3, 5, 2, 5, 3, 2]) == [2, 2]", "def check(pluck):\n\tassert pluck([2, 6, 9, 4, 8]) == [2, 0]", "def check(pluck):\n\tassert pluck([7, 7, 8]) == [8, 2]", "def check(pluck):\n\tassert pluck([3, 11, 6, 5]) == [6, 2]", "def check(pluck):\n\tassert pluck([7, 4, 6, 4, 7, 7]) == [4, 1]", "def check(pluck):\n\tassert pluck([6, 7, 10, 8, 8]) == [6, 0]", "def check(pluck):\n\tassert pluck([8, 3, 2, 5]) == [2, 2]", "def check(pluck):\n\tassert pluck([1, 1, 7, 4, 3, 7]) == [4, 3]", "def check(pluck):\n\tassert pluck([8, 1, 12, 4, 4]) == [4, 3]", "def check(pluck):\n\tassert pluck([7, 3, 1, 1, 3, 7]) == []", "def check(pluck):\n\tassert pluck([8, 11, 2, 2]) == [2, 2]", "def check(pluck):\n\tassert pluck([1, 3, 7, 2, 1, 3]) == [2, 3]", "def check(pluck):\n\tassert pluck([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"", "def check(pluck):\n\tassert pluck([6, 3, 3, 2, 8, 7]) == [2, 3]", "def check(pluck):\n\tassert pluck([3, 1, 8, 4, 5, 5]) == [4, 3]", "def check(pluck):\n\tassert pluck([1, 4, 4, 3, 5, 4]) == [4, 1]", "def check(pluck):\n\tassert pluck([5, 1, 6, 2, 4, 1]) == [2, 3]", "def check(pluck):\n\tassert pluck([2, 5, 3, 1]) == [2, 0]", "def check(pluck):\n\tassert pluck([]) == [], \"Error\"", "def check(pluck):\n\tassert pluck([7, 6, 4]) == [4, 2]", "def check(pluck):\n\tassert pluck([4,2,3]) == [2, 1], \"Error\"", "def check(pluck):\n\tassert pluck([8, 2, 3, 1, 8, 3]) == [2, 1]", "def check(pluck):\n\tassert pluck([1, 3, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([6, 4, 4, 4, 8, 6]) == [4, 1]", "def check(pluck):\n\tassert pluck([7, 9, 7, 1]) == [], \"Error\"", "def check(pluck):\n\tassert pluck([1, 5, 5]) == []", "def check(pluck):\n\tassert pluck([7, 5, 13, 4, 8]) == [4, 3]", "def check(pluck):\n\tassert pluck([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.", "def check(pluck):\n\tassert pluck([10, 9, 6, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([5, 4, 8, 1]) == [4, 1]", "def check(pluck):\n\tassert pluck([2, 7, 8]) == [2, 0]", "def check(pluck):\n\tassert pluck([1, 1, 1]) == []", "def check(pluck):\n\tassert pluck([6, 7, 2, 4, 5, 1]) == [2, 2]", "def check(pluck):\n\tassert pluck([7, 6, 7, 1]) == [6, 1], \"Error\"", "def check(pluck):\n\tassert pluck([11, 11, 3, 4]) == [4, 3]", "def check(pluck):\n\tassert pluck([4, 6, 5, 4, 4, 2]) == [2, 5]", "def check(pluck):\n\tassert pluck([5, 4, 2, 1, 3, 4]) == [2, 2]", "def check(pluck):\n\tassert pluck([4, 2, 4]) == [2, 1]", "def check(pluck):\n\tassert pluck([3, 1, 3, 3, 6, 4]) == [4, 5]", "def check(pluck):\n\tassert pluck([9, 5, 2, 4, 9, 6]) == [2, 2]", "def check(pluck):\n\tassert pluck([2, 7, 6, 5, 3]) == [2, 0]", "def check(pluck):\n\tassert pluck([10, 1, 4, 3, 4]) == [4, 2]", "def check(pluck):\n\tassert pluck([7, 1, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([5, 7, 7, 5, 10, 7]) == [10, 4]", "def check(pluck):\n\tassert pluck([1,2,3]) == [2, 1], \"Error\"", "def check(pluck):\n\tassert pluck([9, 10, 3, 3]) == [10, 1]", "def check(pluck):\n\tassert pluck([7, 7, 5]) == []", "def check(pluck):\n\tassert pluck([5, 1, 2, 1, 6, 6]) == [2, 2]", "def check(pluck):\n\tassert pluck([6, 9, 9, 4, 10]) == [4, 3]", "def check(pluck):\n\tassert pluck([2, 4, 2, 2, 7, 4]) == [2, 0]", "def check(pluck):\n\tassert pluck([5, 1, 4, 4, 10, 5]) == [4, 2]", "def check(pluck):\n\tassert pluck([10, 6, 6, 3]) == [6, 1]", "def check(pluck):\n\tassert pluck([]) == []", "def check(pluck):\n\tassert pluck([6, 2, 6, 4, 8, 7]) == [2, 1]", "def check(pluck):\n\tassert pluck([2, 3, 3]) == [2, 0]", "def check(pluck):\n\tassert pluck([1, 4, 8]) == [4, 1]", "def check(pluck):\n\tassert pluck([2, 11, 10, 5]) == [2, 0]", "def check(pluck):\n\tassert pluck([5, 6, 8, 1, 5, 4]) == [4, 5]", "def check(pluck):\n\tassert pluck([5, 4, 5, 5, 6, 6]) == [4, 1]", "def check(pluck):\n\tassert pluck([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"", "def check(pluck):\n\tassert pluck([9, 1, 3, 5, 8, 1]) == [8, 4]", "def check(pluck):\n\tassert pluck([7, 1, 5, 6, 13]) == [6, 3]", "def check(pluck):\n\tassert pluck([3, 1, 1, 2, 1, 1]) == [2, 3]", "def check(pluck):\n\tassert pluck([2, 1, 3, 8, 4]) == [2, 0]", "def check(pluck):\n\tassert pluck([5, 5, 2]) == [2, 2]", "def check(pluck):\n\tassert pluck([9, 2, 12, 8, 6]) == [2, 1]", "def check(pluck):\n\tassert pluck([4, 3, 4]) == [4, 0]", "def check(pluck):\n\tassert pluck([7, 3, 9, 3, 8]) == [8, 4]", "def check(pluck):\n\tassert pluck([7, 3, 4]) == [4, 2]", "def check(pluck):\n\tassert pluck([2, 4, 7]) == [2, 0]", "def check(pluck):\n\tassert pluck([10, 5, 6, 3, 4, 2]) == [2, 5]", "def check(pluck):\n\tassert pluck([2, 5, 7]) == [2, 0]", "def check(pluck):\n\tassert pluck([6, 4, 5]) == [4, 1]", "def check(pluck):\n\tassert pluck([12, 4, 12, 5]) == [4, 1]", "def check(pluck):\n\tassert pluck([2, 1, 6]) == [2, 0]", "def check(pluck):\n\tassert pluck([4, 1, 4, 3, 3, 6]) == [4, 0]", "def check(pluck):\n\tassert pluck([5, 4, 1]) == [4, 1]", "def check(pluck):\n\tassert pluck([4, 4, 6]) == [4, 0]", "def check(pluck):\n\tassert pluck([7, 3, 12, 9, 13]) == [12, 2]", "def check(pluck):\n\tassert pluck([8, 1, 8]) == [8, 0]", "def check(pluck):\n\tassert pluck([4, 6, 5, 2, 7, 1]) == [2, 3]", "def check(pluck):\n\tassert pluck([5, 9, 12, 1]) == [12, 2]", "def check(pluck):\n\tassert pluck([1, 2, 4]) == [2, 1]", "def check(pluck):\n\tassert pluck([7, 6, 7]) == [6, 1]", "def check(pluck):\n\tassert pluck([5, 1, 13, 2, 13]) == [2, 3]", "def check(pluck):\n\tassert pluck([4, 5, 8, 3, 9, 1]) == [4, 0]", "def check(pluck):\n\tassert pluck([5, 3, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([12, 1, 12, 1]) == [12, 0]", "def check(pluck):\n\tassert pluck([3, 3, 1, 3, 2, 6]) == [2, 4]", "def check(pluck):\n\tassert pluck([5, 6, 4, 1, 12]) == [4, 2]", "def check(pluck):\n\tassert pluck([4, 4, 3, 7, 12]) == [4, 0]", "def check(pluck):\n\tassert pluck([8, 6, 8]) == [6, 1]", "def check(pluck):\n\tassert pluck([7, 6, 1]) == [6, 1]", "def check(pluck):\n\tassert pluck([2, 8, 6, 5]) == [2, 0]", "def check(pluck):\n\tassert pluck([3, 2, 9, 6]) == [2, 1]", "def check(pluck):\n\tassert pluck([2, 4, 8]) == [2, 0]", "def check(pluck):\n\tassert pluck([3, 7, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([2, 2, 8]) == [2, 0]"], "test_case_list": ["assert pluck([5, 7, 3]) == []", "assert pluck([3, 5, 2, 5, 3, 2]) == [2, 2]", "assert pluck([2, 6, 9, 4, 8]) == [2, 0]", "assert pluck([7, 7, 8]) == [8, 2]", "assert pluck([3, 11, 6, 5]) == [6, 2]", "assert pluck([7, 4, 6, 4, 7, 7]) == [4, 1]", "assert pluck([6, 7, 10, 8, 8]) == [6, 0]", "assert pluck([8, 3, 2, 5]) == [2, 2]", "assert pluck([1, 1, 7, 4, 3, 7]) == [4, 3]", "assert pluck([8, 1, 12, 4, 4]) == [4, 3]", "assert pluck([7, 3, 1, 1, 3, 7]) == []", "assert pluck([8, 11, 2, 2]) == [2, 2]", "assert pluck([1, 3, 7, 2, 1, 3]) == [2, 3]", "assert pluck([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"", "assert pluck([6, 3, 3, 2, 8, 7]) == [2, 3]", "assert pluck([3, 1, 8, 4, 5, 5]) == [4, 3]", "assert pluck([1, 4, 4, 3, 5, 4]) == [4, 1]", "assert pluck([5, 1, 6, 2, 4, 1]) == [2, 3]", "assert pluck([2, 5, 3, 1]) == [2, 0]", "assert pluck([]) == [], \"Error\"", "assert pluck([7, 6, 4]) == [4, 2]", "assert pluck([4,2,3]) == [2, 1], \"Error\"", "assert pluck([8, 2, 3, 1, 8, 3]) == [2, 1]", "assert pluck([1, 3, 6]) == [6, 2]", "assert pluck([6, 4, 4, 4, 8, 6]) == [4, 1]", "assert pluck([7, 9, 7, 1]) == [], \"Error\"", "assert pluck([1, 5, 5]) == []", "assert pluck([7, 5, 13, 4, 8]) == [4, 3]", "assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.", "assert pluck([10, 9, 6, 6]) == [6, 2]", "assert pluck([5, 4, 8, 1]) == [4, 1]", "assert pluck([2, 7, 8]) == [2, 0]", "assert pluck([1, 1, 1]) == []", "assert pluck([6, 7, 2, 4, 5, 1]) == [2, 2]", "assert pluck([7, 6, 7, 1]) == [6, 1], \"Error\"", "assert pluck([11, 11, 3, 4]) == [4, 3]", "assert pluck([4, 6, 5, 4, 4, 2]) == [2, 5]", "assert pluck([5, 4, 2, 1, 3, 4]) == [2, 2]", "assert pluck([4, 2, 4]) == [2, 1]", "assert pluck([3, 1, 3, 3, 6, 4]) == [4, 5]", "assert pluck([9, 5, 2, 4, 9, 6]) == [2, 2]", "assert pluck([2, 7, 6, 5, 3]) == [2, 0]", "assert pluck([10, 1, 4, 3, 4]) == [4, 2]", "assert pluck([7, 1, 6]) == [6, 2]", "assert pluck([5, 7, 7, 5, 10, 7]) == [10, 4]", "assert pluck([1,2,3]) == [2, 1], \"Error\"", "assert pluck([9, 10, 3, 3]) == [10, 1]", "assert pluck([7, 7, 5]) == []", "assert pluck([5, 1, 2, 1, 6, 6]) == [2, 2]", "assert pluck([6, 9, 9, 4, 10]) == [4, 3]", "assert pluck([2, 4, 2, 2, 7, 4]) == [2, 0]", "assert pluck([5, 1, 4, 4, 10, 5]) == [4, 2]", "assert pluck([10, 6, 6, 3]) == [6, 1]", "assert pluck([]) == []", "assert pluck([6, 2, 6, 4, 8, 7]) == [2, 1]", "assert pluck([2, 3, 3]) == [2, 0]", "assert pluck([1, 4, 8]) == [4, 1]", "assert pluck([2, 11, 10, 5]) == [2, 0]", "assert pluck([5, 6, 8, 1, 5, 4]) == [4, 5]", "assert pluck([5, 4, 5, 5, 6, 6]) == [4, 1]", "assert pluck([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"", "assert pluck([9, 1, 3, 5, 8, 1]) == [8, 4]", "assert pluck([7, 1, 5, 6, 13]) == [6, 3]", "assert pluck([3, 1, 1, 2, 1, 1]) == [2, 3]", "assert pluck([2, 1, 3, 8, 4]) == [2, 0]", "assert pluck([5, 5, 2]) == [2, 2]", "assert pluck([9, 2, 12, 8, 6]) == [2, 1]", "assert pluck([4, 3, 4]) == [4, 0]", "assert pluck([7, 3, 9, 3, 8]) == [8, 4]", "assert pluck([7, 3, 4]) == [4, 2]", "assert pluck([2, 4, 7]) == [2, 0]", "assert pluck([10, 5, 6, 3, 4, 2]) == [2, 5]", "assert pluck([2, 5, 7]) == [2, 0]", "assert pluck([6, 4, 5]) == [4, 1]", "assert pluck([12, 4, 12, 5]) == [4, 1]", "assert pluck([2, 1, 6]) == [2, 0]", "assert pluck([4, 1, 4, 3, 3, 6]) == [4, 0]", "assert pluck([5, 4, 1]) == [4, 1]", "assert pluck([4, 4, 6]) == [4, 0]", "assert pluck([7, 3, 12, 9, 13]) == [12, 2]", "assert pluck([8, 1, 8]) == [8, 0]", "assert pluck([4, 6, 5, 2, 7, 1]) == [2, 3]", "assert pluck([5, 9, 12, 1]) == [12, 2]", "assert pluck([1, 2, 4]) == [2, 1]", "assert pluck([7, 6, 7]) == [6, 1]", "assert pluck([5, 1, 13, 2, 13]) == [2, 3]", "assert pluck([4, 5, 8, 3, 9, 1]) == [4, 0]", "assert pluck([5, 3, 6]) == [6, 2]", "assert pluck([12, 1, 12, 1]) == [12, 0]", "assert pluck([3, 3, 1, 3, 2, 6]) == [2, 4]", "assert pluck([5, 6, 4, 1, 12]) == [4, 2]", "assert pluck([4, 4, 3, 7, 12]) == [4, 0]", "assert pluck([8, 6, 8]) == [6, 1]", "assert pluck([7, 6, 1]) == [6, 1]", "assert pluck([2, 8, 6, 5]) == [2, 0]", "assert pluck([3, 2, 9, 6]) == [2, 1]", "assert pluck([2, 4, 8]) == [2, 0]", "assert pluck([3, 7, 6]) == [6, 2]", "assert pluck([2, 2, 8]) == [2, 0]"], "nl": "\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    ", "func": "def pluck(arr):", "examples": "Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    ", "completions": ["from typing import List\n## main.py\n\ndef pluck(arr: list) -> list:\n    \"\"\"\n    Retrieves the smallest even value and its index from the given list.\n\n    Args:\n        arr (list): A list containing non-negative integer nodes.\n\n    Returns:\n        list: A list containing the smallest even value and its index, or an empty list if no even values are present.\n    \"\"\"\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and (smallest_even is None or value < smallest_even):\n            smallest_even = value\n            smallest_index = index\n\n    if smallest_index == -1:\n        return []\n    else:\n        return [smallest_even, smallest_index]\n", "from typing import List\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    \"\"\"\n    Plucks the smallest even value and its index from the given list of non-negative integers.\n    \n    Args:\n        arr (List[int]): A list of non-negative integers.\n    \n    Returns:\n        List[int]: A list containing the smallest even value and its index. If no even values are found, returns an empty list.\n    \"\"\"\n    smallest_even = float('inf')\n    smallest_even_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even:\n            smallest_even = value\n            smallest_even_index = index\n    \n    if smallest_even_index == -1:\n        return []\n    else:\n        return [smallest_even, smallest_even_index]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list) -> list:\n    '''\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    your task is to pluck one of the nodes and return it. The plucked node should be the node\n    with the smallest even value. If multiple nodes with the same smallest even value are found,\n    you should return the node that has the smallest index. The plucked node should be returned\n    in a list. The list should include [ smallest_value, its index ]. If there are no even values\n    or the given array is empty, return [].\n    '''\n    if not arr:\n        return []\n\n    min_even = float('inf')\n    min_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < min_even:\n            min_even = value\n            min_index = index\n\n    if min_index == -1:\n        return []\n\n    return [min_even, min_index]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list) -> list:\n    \"\"\"\n    Takes a list of non-negative integers and returns a list containing the smallest even value and its index,\n    or an empty list if no even values are found.\n    \n    Args:\n        arr (list): A list of non-negative integers.\n    \n    Returns:\n        list: A list containing the smallest even value and its index, or an empty list if no even values are found.\n    \"\"\"\n    if not arr:\n        return []\n    \n    smallest_even = float('inf')\n    smallest_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even:\n            smallest_even = value\n            smallest_index = index\n    \n    if smallest_index == -1:\n        return []\n    \n    return [smallest_even, smallest_index]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list) -> list:\n    \"\"\"\n    Returns a list containing the smallest even value and its index, or an empty list if no even values are found.\n    \n    Args:\n        arr (list): A list of non-negative integers.\n    \n    Returns:\n        list: A list containing the smallest even value and its index, or an empty list if no even values are found.\n    \"\"\"\n    smallest_even = float('inf')\n    smallest_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even:\n            smallest_even = value\n            smallest_index = index\n    \n    if smallest_index == -1:\n        return []\n    else:\n        return [smallest_even, smallest_index]\n", "from typing import List\n## main.py\n\nimport sys\n\ndef pluck(arr: list) -> list:\n    '''\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    your task is to pluck one of the nodes and return it. The plucked node should be the node\n    with the smallest even value. If multiple nodes with the same smallest even value are found,\n    you should return the node that has the smallest index. The plucked node should be returned\n    in a list. The list should include [ smallest_value, its index ]. If there are no even values\n    or the given array is empty, return [].\n    '''\n    if not arr:\n        return []\n\n    smallest_even_value = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and (smallest_even_value is None or value < smallest_even_value):\n            smallest_even_value = value\n            smallest_index = index\n        elif value % 2 == 0 and value == smallest_even_value and index < smallest_index:\n            smallest_index = index\n\n    if smallest_even_value is None:\n        return []\n\n    return [smallest_even_value, smallest_index]\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    min_even = float('inf')\n    min_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if value < min_even:\n                min_even = value\n                min_index = index\n\n    if min_even != float('inf'):\n        return [min_even, min_index]\n    else:\n        return []\n", "from typing import List\nfrom typing import List, Optional\n\ndef pluck(arr: List[int]) -> List[int]:\n    min_even: Optional[int] = None\n    min_index: int = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and (min_even is None or value < min_even):\n            min_even = value\n            min_index = index\n\n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []\n", "from typing import List\nfrom typing import List, Tuple\n\ndef pluck(arr: List[int]) -> List[int]:\n    '''\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    your task is to pluck one of the nodes and return it. The plucked node should be the node\n    with the smallest even value. If multiple nodes with the same smallest even value are found,\n    you should return the node that has the smallest index. The plucked node should be returned\n    in a list. The list should include [ smallest_value, its index ]. If there are no even values\n    or the given array is empty, return [].\n    '''\n    min_even = None\n    min_index = -1\n\n    for index, node in enumerate(arr):\n        if node % 2 == 0:\n            if min_even is None or node < min_even:\n                min_even = node\n                min_index = index\n            elif node == min_even and index < min_index:\n                min_index = index\n\n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []\n", "from typing import List\nfrom typing import List, Optional\n\ndef pluck(arr: List[int]) -> List[int]:\n    min_even: Optional[int] = None\n    min_index: int = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and (min_even is None or value < min_even):\n            min_even = value\n            min_index = index\n\n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []\n"], "plans": ["requirement analysis:\nThe requirement involves finding the smallest even value in an array and returning it along with its index. The function should handle edge cases such as empty arrays and arrays without even values. The solution should be efficient and handle large datasets effectively.\nrequirement pool:\n- The main code should find the smallest even value in the array\n- The function should return the index of the smallest even value\n- The function should handle empty arrays and return []\n- Ensure the function is efficient and can handle large datasets\n- Include comments in the code to explain the logic\nTo implement the function `pluck` efficiently, we will use Python's built-in capabilities to iterate through the list and find the smallest even value along with its index. The function will first check for the presence of even numbers, and if none are found, it will return an empty list. If even numbers are present, it will iterate through the list to find the smallest even value and its index, ensuring that the smallest index is chosen in case of ties.\n", "requirement analysis:\nThe requirement is to find the smallest even value in an array along with its index. The function should handle edge cases such as empty arrays and arrays without even values. The solution should be efficient and handle large datasets effectively.\nrequirement pool:\n- The main code should efficiently find the smallest even value and its index.\n- The function should handle edge cases such as empty arrays and arrays without even values.\n- The solution should be scalable and maintainable.\n- The function should optimize performance for large datasets.\nTo implement the function efficiently, we will use Python's built-in data structures and functions. The main challenge is to find the smallest even value and its index in a given array. We will iterate through the array, check for even values, and keep track of the smallest even value and its index. If no even values are found, we will return an empty list. The function will be optimized to handle large datasets efficiently.\n", "requirement analysis:\nThe requirement is to find the node with the smallest even value in a given array. If there are multiple nodes with the same smallest even value, the node with the smallest index should be returned. The function should handle edge cases such as an empty array or no even values.\nrequirement pool:\n- Implement a function to find the smallest even value in the array\n- Ensure the function returns the index of the smallest even value\n- Handle edge cases such as empty arrays or no even values\n- Optimize the function for large datasets\n- Ensure the function is easy to understand and maintain\nTo implement the function `pluck` efficiently, we will use Python's built-in data structures and functions to ensure the solution is both scalable and maintainable. The function will iterate through the array to find the smallest even value and its index. If no even values are found, it will return an empty list. We will optimize the function to handle large datasets efficiently.\n", "requirement analysis:\nThe original requirements specify a function that takes an array of non-negative integers and returns a list containing the smallest even value and its index. The function should handle edge cases such as no even values or an empty array. The requirements are clear and specific, providing a good starting point for development.\nrequirement pool:\n- The main code should efficiently find the smallest even value and its index\n- The function should handle edge cases such as no even values or an empty array\n- The code should be scalable and maintainable\n- The function should be optimized for large datasets\nWe will implement the function `pluck` using Python, leveraging the built-in capabilities of the language to ensure efficiency and clarity. The function will iterate through the input array to find the smallest even value and its index. If no even values are found or the array is empty, the function will return an empty list.\n", "requirement analysis:\nThe requirement is to find the smallest even value in an array along with its index. The array can contain non-negative integers. The solution should handle edge cases such as empty arrays or arrays without even values. The output should be a list containing the smallest even value and its index.\nrequirement pool:\n- Implement a function to find the smallest even value in an array.\n- Ensure the function returns the index of the smallest even value.\n- Handle edge cases such as empty arrays or arrays without even values.\n- Optimize the function to handle large arrays efficiently.\nTo implement the function `pluck` efficiently, we will use Python's built-in capabilities and the `min` function to find the smallest even value along with its index. We will iterate through the array, check for even values, and keep track of the smallest even value and its index. If no even values are found, we will return an empty list.\n", "requirement analysis:\nThe requirement is to find the node with the smallest even value in an array. If there are multiple nodes with the same smallest even value, the node with the smallest index should be returned. The function should handle edge cases such as an empty array or no even values.\nrequirement pool:\n- Implement a function to find the node with the smallest even value\n- Ensure the function returns the index of the node along with its value\n- Handle edge cases such as empty arrays or no even values\n- Optimize the function for large datasets\n- Ensure the function is easy to understand and maintain\nTo implement the function `pluck` efficiently, we will use Python's built-in data structures and functions to ensure the solution is both simple and scalable. The function will iterate through the array to find the smallest even value, and in case of ties, the smallest index. We will handle edge cases such as empty arrays or arrays without even values.\n", "requirement analysis:\nThe requirement is to find the node with the smallest even value in an array. If there are multiple nodes with the same smallest even value, the node with the smallest index should be returned. The function should handle edge cases such as an empty array or no even values.\nrequirement pool:\n- Implement a function to find the node with the smallest even value\n- Ensure the function returns the index of the smallest even value\n- Handle edge cases such as empty arrays or no even values\n- Optimize the function for large datasets\n- Ensure the function is efficient and easy to understand\nTo implement the function `pluck` efficiently and correctly, we will use Python's built-in data structures and functions. The function will iterate through the array to find the smallest even value and its index. If multiple nodes have the same smallest even value, the function will return the one with the smallest index. The function will handle edge cases such as an empty array or no even values by returning an empty list.\n", "requirement analysis:\nThe requirement involves finding the smallest even value in an array and returning it along with its index. The function should handle edge cases such as empty arrays and arrays without even values. The solution should be efficient and scalable.\nrequirement pool:\n- Implement a function to find the smallest even value in an array\n- Ensure the function returns the index of the smallest even value\n- Handle edge cases such as empty arrays and arrays without even values\n- Optimize the function for large datasets\n- Ensure the function is easy to understand and maintain\nTo implement the function `pluck` efficiently, we will use Python's built-in capabilities and the `typing` module to ensure type hints are clear. The function will iterate through the array to find the smallest even value and its index. If no even values are found or the array is empty, it will return an empty list. We will optimize the function for large datasets by using list comprehensions and avoiding unnecessary iterations.\n", "requirement analysis:\nThe requirement is to find the smallest even value in an array and return it along with its index. The function should handle edge cases such as empty arrays and arrays without even values. The solution should be efficient and handle large datasets effectively.\nrequirement pool:\n- Implement a function to find the smallest even value in an array\n- Ensure the function returns the index of the smallest even value\n- Handle edge cases such as empty arrays and arrays without even values\n- Optimize the function for large datasets\nTo implement the function `pluck` efficiently, we will use Python's built-in capabilities and the `typing` module for type hints. The function will iterate through the array to find the smallest even value and its index. If no even values are found, it will return an empty list. The function will be optimized to handle large datasets effectively.\n", "requirement analysis:\nThe requirement involves finding the smallest even value in an array and returning it along with its index. The function should handle edge cases such as empty arrays and arrays without even values. The solution should be efficient and scalable.\nrequirement pool:\n- Implement a function to find the smallest even value in an array\n- Ensure the function returns the index of the smallest even value\n- Handle edge cases such as empty arrays and arrays without even values\n- Optimize the function for large datasets\n- Ensure the function is easy to understand and maintain\nTo implement the function `pluck` efficiently, we will use Python's built-in capabilities and the `typing` module to ensure type hints are clear. The function will iterate through the array to find the smallest even value and its index. If no even values are found or the array is empty, it will return an empty list. We will optimize the function for large datasets by using list comprehensions and avoiding unnecessary iterations.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [99, 99, 99, 99, 99, 99, 99, 99, 99, 99], "completion": "from typing import List\nfrom typing import List, Optional\n\ndef pluck(arr: List[int]) -> List[int]:\n    min_even: Optional[int] = None\n    min_index: int = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and (min_even is None or value < min_even):\n            min_even = value\n            min_index = index\n\n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []\n", "passed": true, "pass": true, "pass_num": 10, "round": 305, "repair_prompt": ["def pluck(arr):\t\n'''Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found, you should return the node that has the smallest index. The plucked node should be returned in a list. The list should include [ smallest_value, its index ]. If there are no even values or the given array is empty, return [].\nExample 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    '''"], "mutate_method": "expand_one2two", "parent_index": 275}
