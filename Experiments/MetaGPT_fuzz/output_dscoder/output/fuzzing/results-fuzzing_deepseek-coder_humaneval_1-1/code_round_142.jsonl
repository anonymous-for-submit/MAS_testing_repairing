{"task_id": "HumanEval/99", "prompt": "def closest_integer(value):\t\n'''Create a function that takes a value (string) representing a number and returns the nearest whole number to it. If the number is equidistant from two integers, round it away from zero.\nExamples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''", "entry_point": "closest_integer", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "test": ["def check(closest_integer):\n\tassert closest_integer(\"396630.07482315193744715\") == 396630", "def check(closest_integer):\n\tassert closest_integer(\"400421550.6045760047304053\") == 400421551", "def check(closest_integer):\n\tassert closest_integer(\"7474101960.9946621112548985\") == 7474101961", "def check(closest_integer):\n\tassert closest_integer(\"20.2284164882780635\") == 20", "def check(closest_integer):\n\tassert closest_integer(\"79430.17924732795127563\") == 79430", "def check(closest_integer):\n\tassert closest_integer(\"79.29738\") == 79", "def check(closest_integer):\n\tassert closest_integer(\"281040.6070070426978076\") == 281041", "def check(closest_integer):\n\tassert closest_integer(\"-10.7668049208854797\") == -11", "def check(closest_integer):\n\tassert closest_integer(\"70.7148103668424428\") == 71", "def check(closest_integer):\n\tassert closest_integer(\"7752780.5410381165130523\") == 7752781", "def check(closest_integer):\n\tassert closest_integer(\"7170.16745005290685966\") == 7170", "def check(closest_integer):\n\tassert closest_integer(\"170.6921985077015881\") == 171", "def check(closest_integer):\n\tassert closest_integer(\"54538150.6638877369321192\") == 54538151", "def check(closest_integer):\n\tassert closest_integer(\"810.05084880400338965\") == 810", "def check(closest_integer):\n\tassert closest_integer(\"5510.8938181386660865\") == 5511", "def check(closest_integer):\n\tassert closest_integer(\"5589713.\") == 5589713", "def check(closest_integer):\n\tassert closest_integer(\"0.9093998495250931\") == 1", "def check(closest_integer):\n\tassert closest_integer(\"90050.4404481408550571\") == 90050", "def check(closest_integer):\n\tassert closest_integer(\".55\") == 1", "def check(closest_integer):\n\tassert closest_integer(\"20.9952573487089358\") == 21", "def check(closest_integer):\n\tassert closest_integer(\"4.1\") == 4", "def check(closest_integer):\n\tassert closest_integer(\"304510.07731976168722998\") == 304510", "def check(closest_integer):\n\tassert closest_integer(\"920.5503068267302647\") == 921", "def check(closest_integer):\n\tassert closest_integer(\"50.5108701326835627\") == 51", "def check(closest_integer):\n\tassert closest_integer(\"8090.2130747773426992\") == 8090", "def check(closest_integer):\n\tassert closest_integer(\"5420.6753885072984122\") == 5421", "def check(closest_integer):\n\tassert closest_integer(\"2127780.6194993537705912\") == 2127781", "def check(closest_integer):\n\tassert closest_integer(\".23\") == 0", "def check(closest_integer):\n\tassert closest_integer(\"58720.6576278790833077\") == 58721", "def check(closest_integer):\n\tassert closest_integer(\"6130.863753701502481\") == 6131", "def check(closest_integer):\n\tassert closest_integer(\"9556050.7817362719643586\") == 9556051", "def check(closest_integer):\n\tassert closest_integer(\"20.287830685087748\") == 20", "def check(closest_integer):\n\tassert closest_integer(\"2002770.9156885375054495\") == 2002771", "def check(closest_integer):\n\tassert closest_integer(\"60.4151789292601701\") == 60", "def check(closest_integer):\n\tassert closest_integer(\"188164680.8625164010892828\") == 188164681", "def check(closest_integer):\n\tassert closest_integer(\"2510.8534760249415141\") == 2511", "def check(closest_integer):\n\tassert closest_integer(\"-15.5\") == -16, \"Test 3\"", "def check(closest_integer):\n\tassert closest_integer(\"396.\") == 396", "def check(closest_integer):\n\tassert closest_integer(\"80.18362563426599365\") == 80", "def check(closest_integer):\n\tassert closest_integer(\"965180090.27865264317516414\") == 965180090", "def check(closest_integer):\n\tassert closest_integer(\"32950.12731759775110685\") == 32950", "def check(closest_integer):\n\tassert closest_integer(\"335640.43815039154886604\") == 335640", "def check(closest_integer):\n\tassert closest_integer(\"20.\") == 20", "def check(closest_integer):\n\tassert closest_integer(\"184964420.27548611693624514\") == 184964420", "def check(closest_integer):\n\tassert closest_integer(\"9682550.8652164441655846\") == 9682551", "def check(closest_integer):\n\tassert closest_integer(\"60.6541701356105623\") == 61", "def check(closest_integer):\n\tassert closest_integer(\".917694\") == 1", "def check(closest_integer):\n\tassert closest_integer(\"420.3730741094554919\") == 420", "def check(closest_integer):\n\tassert closest_integer(\".73\") == 1", "def check(closest_integer):\n\tassert closest_integer(\"8.26\") == 8", "def check(closest_integer):\n\tassert closest_integer(\"568882230.3460506747741575\") == 568882230", "def check(closest_integer):\n\tassert closest_integer(\"9909140.22019882247107447\") == 9909140", "def check(closest_integer):\n\tassert closest_integer(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.", "def check(closest_integer):\n\tassert closest_integer(\"8588230.0004916487098123312\") == 8588230", "def check(closest_integer):\n\tassert closest_integer(\"79050.9507930940642703\") == 79051", "def check(closest_integer):\n\tassert closest_integer(\"3370.20175253216166456\") == 3370", "def check(closest_integer):\n\tassert closest_integer(\"2750.9171920354992185\") == 2751", "def check(closest_integer):\n\tassert closest_integer(\"80.7127796045265017\") == 81", "def check(closest_integer):\n\tassert closest_integer(\"807720.6176298175605032\") == 807721", "def check(closest_integer):\n\tassert closest_integer(\"50.06568006872727938\") == 50", "def check(closest_integer):\n\tassert closest_integer(\"18030.8511815378525301\") == 18031", "def check(closest_integer):\n\tassert closest_integer(\"93539740.8429573417816859\") == 93539741", "def check(closest_integer):\n\tassert closest_integer(\"0.08050974009664802\") == 0", "def check(closest_integer):\n\tassert closest_integer(\"8667431660.1773809642921491\") == 8667431660", "def check(closest_integer):\n\tassert closest_integer(\"4560.07986037903944365\") == 4560", "def check(closest_integer):\n\tassert closest_integer(\"90.8718389292538408\") == 91", "def check(closest_integer):\n\tassert closest_integer(\"58720470.3151774565803682\") == 58720470", "def check(closest_integer):\n\tassert closest_integer(\"219670.3814735103021585\") == 219670", "def check(closest_integer):\n\tassert closest_integer(\"3550.3795035988000094\") == 3550", "def check(closest_integer):\n\tassert closest_integer(\"4930.8578331989039943\") == 4931", "def check(closest_integer):\n\tassert closest_integer(\"1187974430.6396705049308593\") == 1187974431", "def check(closest_integer):\n\tassert closest_integer(\"3840583540.8121445801379602\") == 3840583541", "def check(closest_integer):\n\tassert closest_integer(\"643190.9074997847487993\") == 643191", "def check(closest_integer):\n\tassert closest_integer(\"90.41784910359843574\") == 90", "def check(closest_integer):\n\tassert closest_integer(\"8647610.19615183923123347\") == 8647610", "def check(closest_integer):\n\tassert closest_integer(\"5.9\") == 6", "def check(closest_integer):\n\tassert closest_integer(\"49530.9923686605409962\") == 49531", "def check(closest_integer):\n\tassert closest_integer(\"60.3982054790544489\") == 60", "def check(closest_integer):\n\tassert closest_integer(\"9120.7857264964633935\") == 9121", "def check(closest_integer):\n\tassert closest_integer(\"90.310328840125088\") == 90", "def check(closest_integer):\n\tassert closest_integer(\"80.9081244975972714\") == 81", "def check(closest_integer):\n\tassert closest_integer(\"30.4875496675711467\") == 30", "def check(closest_integer):\n\tassert closest_integer(\"96830.7798358829352927\") == 96831", "def check(closest_integer):\n\tassert closest_integer(\"473120.6040377644717714\") == 473121", "def check(closest_integer):\n\tassert closest_integer(\".10826\") == 0", "def check(closest_integer):\n\tassert closest_integer(\"4870.7514635289854439\") == 4871", "def check(closest_integer):\n\tassert closest_integer(\"42850.9135283560202653\") == 42851", "def check(closest_integer):\n\tassert closest_integer(\"70.9074597640722244\") == 71", "def check(closest_integer):\n\tassert closest_integer(\"105759420.7092501708226783\") == 105759421", "def check(closest_integer):\n\tassert closest_integer(\"3250.6874339166783494\") == 3251", "def check(closest_integer):\n\tassert closest_integer(\"58340.27521511057002124\") == 58340", "def check(closest_integer):\n\tassert closest_integer(\"0\") == 0, \"Test 0\"", "def check(closest_integer):\n\tassert closest_integer(\"+740.7675428815072424\") == 741", "def check(closest_integer):\n\tassert closest_integer(\"-9.\") == -9", "def check(closest_integer):\n\tassert closest_integer(\"9376920.32484597586363007\") == 9376920", "def check(closest_integer):\n\tassert closest_integer(\"90.754166\") == 91", "def check(closest_integer):\n\tassert closest_integer(\"20.9560740535157867\") == 21", "def check(closest_integer):\n\tassert closest_integer(\"30651380.06269969697942035\") == 30651380", "def check(closest_integer):\n\tassert closest_integer(\"50.6846461124165827\") == 51", "def check(closest_integer):\n\tassert closest_integer(\"0910.38918638690228935\") == 910", "def check(closest_integer):\n\tassert closest_integer(\"25270.26236878929945096\") == 25270", "def check(closest_integer):\n\tassert closest_integer(\"5956430.2031336848206573\") == 5956430", "def check(closest_integer):\n\tassert closest_integer(\"14.5\") == 15, \"Test 2\"", "def check(closest_integer):\n\tassert closest_integer(\"21095172.\") == 21095172", "def check(closest_integer):\n\tassert closest_integer(\"36490.19589678824090695\") == 36490", "def check(closest_integer):\n\tassert closest_integer(\"7284790.9387083108844197\") == 7284791", "def check(closest_integer):\n\tassert closest_integer(\"14550.36803024128148376\") == 14550", "def check(closest_integer):\n\tassert closest_integer(\"716986380.8908632298127022\") == 716986381", "def check(closest_integer):\n\tassert closest_integer(\"2920.2909064116656561\") == 2920", "def check(closest_integer):\n\tassert closest_integer(\"4.3\") == 4", "def check(closest_integer):\n\tassert closest_integer(\"95630.00899682001984714\") == 95630", "def check(closest_integer):\n\tassert closest_integer(\"6277620.047448415643293274\") == 6277620", "def check(closest_integer):\n\tassert closest_integer(\"80.5093924567968169\") == 81", "def check(closest_integer):\n\tassert closest_integer(\"7180.08904084585638494\") == 7180", "def check(closest_integer):\n\tassert closest_integer(\"234430.8213641009547066\") == 234431", "def check(closest_integer):\n\tassert closest_integer(\"9830.2887871019878405\") == 9830", "def check(closest_integer):\n\tassert closest_integer(\"10\") == 10, \"Test 1\"", "def check(closest_integer):\n\tassert closest_integer(\"40.4775205107302265\") == 40", "def check(closest_integer):\n\tassert closest_integer(\"4790.3957977986146939\") == 4790", "def check(closest_integer):\n\tassert closest_integer(\"87061.2\") == 87061", "def check(closest_integer):\n\tassert closest_integer(\"0.47356705599235294\") == 0", "def check(closest_integer):\n\tassert closest_integer(\"29540.8266023455315558\") == 29541", "def check(closest_integer):\n\tassert closest_integer(\"387460.9626228213640998\") == 387461", "def check(closest_integer):\n\tassert closest_integer(\"349.7\") == 350", "def check(closest_integer):\n\tassert closest_integer(\"70.1069369965509347\") == 70", "def check(closest_integer):\n\tassert closest_integer(\"35730.009102915382992016\") == 35730", "def check(closest_integer):\n\tassert closest_integer(\"90.19186788324286208\") == 90", "def check(closest_integer):\n\tassert closest_integer(\"720.33604724999783553\") == 720", "def check(closest_integer):\n\tassert closest_integer(\"8450.5441516861955107\") == 8451", "def check(closest_integer):\n\tassert closest_integer(\"9470.5170825437128881\") == 9471"], "test_case_list": ["assert closest_integer(\"396630.07482315193744715\") == 396630", "assert closest_integer(\"400421550.6045760047304053\") == 400421551", "assert closest_integer(\"7474101960.9946621112548985\") == 7474101961", "assert closest_integer(\"20.2284164882780635\") == 20", "assert closest_integer(\"79430.17924732795127563\") == 79430", "assert closest_integer(\"79.29738\") == 79", "assert closest_integer(\"281040.6070070426978076\") == 281041", "assert closest_integer(\"-10.7668049208854797\") == -11", "assert closest_integer(\"70.7148103668424428\") == 71", "assert closest_integer(\"7752780.5410381165130523\") == 7752781", "assert closest_integer(\"7170.16745005290685966\") == 7170", "assert closest_integer(\"170.6921985077015881\") == 171", "assert closest_integer(\"54538150.6638877369321192\") == 54538151", "assert closest_integer(\"810.05084880400338965\") == 810", "assert closest_integer(\"5510.8938181386660865\") == 5511", "assert closest_integer(\"5589713.\") == 5589713", "assert closest_integer(\"0.9093998495250931\") == 1", "assert closest_integer(\"90050.4404481408550571\") == 90050", "assert closest_integer(\".55\") == 1", "assert closest_integer(\"20.9952573487089358\") == 21", "assert closest_integer(\"4.1\") == 4", "assert closest_integer(\"304510.07731976168722998\") == 304510", "assert closest_integer(\"920.5503068267302647\") == 921", "assert closest_integer(\"50.5108701326835627\") == 51", "assert closest_integer(\"8090.2130747773426992\") == 8090", "assert closest_integer(\"5420.6753885072984122\") == 5421", "assert closest_integer(\"2127780.6194993537705912\") == 2127781", "assert closest_integer(\".23\") == 0", "assert closest_integer(\"58720.6576278790833077\") == 58721", "assert closest_integer(\"6130.863753701502481\") == 6131", "assert closest_integer(\"9556050.7817362719643586\") == 9556051", "assert closest_integer(\"20.287830685087748\") == 20", "assert closest_integer(\"2002770.9156885375054495\") == 2002771", "assert closest_integer(\"60.4151789292601701\") == 60", "assert closest_integer(\"188164680.8625164010892828\") == 188164681", "assert closest_integer(\"2510.8534760249415141\") == 2511", "assert closest_integer(\"-15.5\") == -16, \"Test 3\"", "assert closest_integer(\"396.\") == 396", "assert closest_integer(\"80.18362563426599365\") == 80", "assert closest_integer(\"965180090.27865264317516414\") == 965180090", "assert closest_integer(\"32950.12731759775110685\") == 32950", "assert closest_integer(\"335640.43815039154886604\") == 335640", "assert closest_integer(\"20.\") == 20", "assert closest_integer(\"184964420.27548611693624514\") == 184964420", "assert closest_integer(\"9682550.8652164441655846\") == 9682551", "assert closest_integer(\"60.6541701356105623\") == 61", "assert closest_integer(\".917694\") == 1", "assert closest_integer(\"420.3730741094554919\") == 420", "assert closest_integer(\".73\") == 1", "assert closest_integer(\"8.26\") == 8", "assert closest_integer(\"568882230.3460506747741575\") == 568882230", "assert closest_integer(\"9909140.22019882247107447\") == 9909140", "assert closest_integer(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.", "assert closest_integer(\"8588230.0004916487098123312\") == 8588230", "assert closest_integer(\"79050.9507930940642703\") == 79051", "assert closest_integer(\"3370.20175253216166456\") == 3370", "assert closest_integer(\"2750.9171920354992185\") == 2751", "assert closest_integer(\"80.7127796045265017\") == 81", "assert closest_integer(\"807720.6176298175605032\") == 807721", "assert closest_integer(\"50.06568006872727938\") == 50", "assert closest_integer(\"18030.8511815378525301\") == 18031", "assert closest_integer(\"93539740.8429573417816859\") == 93539741", "assert closest_integer(\"0.08050974009664802\") == 0", "assert closest_integer(\"8667431660.1773809642921491\") == 8667431660", "assert closest_integer(\"4560.07986037903944365\") == 4560", "assert closest_integer(\"90.8718389292538408\") == 91", "assert closest_integer(\"58720470.3151774565803682\") == 58720470", "assert closest_integer(\"219670.3814735103021585\") == 219670", "assert closest_integer(\"3550.3795035988000094\") == 3550", "assert closest_integer(\"4930.8578331989039943\") == 4931", "assert closest_integer(\"1187974430.6396705049308593\") == 1187974431", "assert closest_integer(\"3840583540.8121445801379602\") == 3840583541", "assert closest_integer(\"643190.9074997847487993\") == 643191", "assert closest_integer(\"90.41784910359843574\") == 90", "assert closest_integer(\"8647610.19615183923123347\") == 8647610", "assert closest_integer(\"5.9\") == 6", "assert closest_integer(\"49530.9923686605409962\") == 49531", "assert closest_integer(\"60.3982054790544489\") == 60", "assert closest_integer(\"9120.7857264964633935\") == 9121", "assert closest_integer(\"90.310328840125088\") == 90", "assert closest_integer(\"80.9081244975972714\") == 81", "assert closest_integer(\"30.4875496675711467\") == 30", "assert closest_integer(\"96830.7798358829352927\") == 96831", "assert closest_integer(\"473120.6040377644717714\") == 473121", "assert closest_integer(\".10826\") == 0", "assert closest_integer(\"4870.7514635289854439\") == 4871", "assert closest_integer(\"42850.9135283560202653\") == 42851", "assert closest_integer(\"70.9074597640722244\") == 71", "assert closest_integer(\"105759420.7092501708226783\") == 105759421", "assert closest_integer(\"3250.6874339166783494\") == 3251", "assert closest_integer(\"58340.27521511057002124\") == 58340", "assert closest_integer(\"0\") == 0, \"Test 0\"", "assert closest_integer(\"+740.7675428815072424\") == 741", "assert closest_integer(\"-9.\") == -9", "assert closest_integer(\"9376920.32484597586363007\") == 9376920", "assert closest_integer(\"90.754166\") == 91", "assert closest_integer(\"20.9560740535157867\") == 21", "assert closest_integer(\"30651380.06269969697942035\") == 30651380", "assert closest_integer(\"50.6846461124165827\") == 51", "assert closest_integer(\"0910.38918638690228935\") == 910", "assert closest_integer(\"25270.26236878929945096\") == 25270", "assert closest_integer(\"5956430.2031336848206573\") == 5956430", "assert closest_integer(\"14.5\") == 15, \"Test 2\"", "assert closest_integer(\"21095172.\") == 21095172", "assert closest_integer(\"36490.19589678824090695\") == 36490", "assert closest_integer(\"7284790.9387083108844197\") == 7284791", "assert closest_integer(\"14550.36803024128148376\") == 14550", "assert closest_integer(\"716986380.8908632298127022\") == 716986381", "assert closest_integer(\"2920.2909064116656561\") == 2920", "assert closest_integer(\"4.3\") == 4", "assert closest_integer(\"95630.00899682001984714\") == 95630", "assert closest_integer(\"6277620.047448415643293274\") == 6277620", "assert closest_integer(\"80.5093924567968169\") == 81", "assert closest_integer(\"7180.08904084585638494\") == 7180", "assert closest_integer(\"234430.8213641009547066\") == 234431", "assert closest_integer(\"9830.2887871019878405\") == 9830", "assert closest_integer(\"10\") == 10, \"Test 1\"", "assert closest_integer(\"40.4775205107302265\") == 40", "assert closest_integer(\"4790.3957977986146939\") == 4790", "assert closest_integer(\"87061.2\") == 87061", "assert closest_integer(\"0.47356705599235294\") == 0", "assert closest_integer(\"29540.8266023455315558\") == 29541", "assert closest_integer(\"387460.9626228213640998\") == 387461", "assert closest_integer(\"349.7\") == 350", "assert closest_integer(\"70.1069369965509347\") == 70", "assert closest_integer(\"35730.009102915382992016\") == 35730", "assert closest_integer(\"90.19186788324286208\") == 90", "assert closest_integer(\"720.33604724999783553\") == 720", "assert closest_integer(\"8450.5441516861955107\") == 8451", "assert closest_integer(\"9470.5170825437128881\") == 9471"], "nl": "\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    ", "func": "def closest_integer(value):", "examples": "Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    ", "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef closest_integer(value: str) -> int:\n    \"\"\"\n    Takes a string representing a number and returns the nearest whole number,\n    rounding away from zero when equidistant.\n    \n    Args:\n        value (str): A string representing a number.\n        \n    Returns:\n        int: The nearest integer to the input value, rounding away from zero when equidistant.\n    \"\"\"\n    # Convert the string to a float\n    number = float(value)\n    \n    # Use the built-in round function with a custom adjustment for equidistant cases\n    if number > 0:\n        return int(number + 0.5) if number % 1 >= 0.5 else int(number)\n    else:\n        return int(number - 0.5) if number % 1 <= -0.5 else int(number)\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    rounded_num = round(num)\n    if num % 1 == 0.5 or num % 1 == -0.5:\n        return int(num + (1 if num > 0 else -1))\n    return rounded_num\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    \"\"\"\n    Rounds the given string representation of a number to the nearest integer.\n    If the number is equidistant between two integers, it rounds away from zero.\n    \n    Args:\n        value (str): A string representing a floating-point number.\n    \n    Returns:\n        int: The closest integer to the given number.\n    \"\"\"\n    # Convert the string to a float\n    number = float(value)\n    \n    # Round the float to the nearest integer\n    rounded_number = round(number)\n    \n    # Handle equidistant numbers by rounding away from zero\n    if number > 0 and number - int(rounded_number) == 0.5:\n        return int(rounded_number)\n    elif number < 0 and number - int(rounded_number) == -0.5:\n        return int(rounded_number)\n    else:\n        return rounded_number\n\n# Example usage:\n# print(closest_integer(\"2.5\"))  # Output: 3\n# print(closest_integer(\"-2.5\")) # Output: -3\n# print(closest_integer(\"2.4\"))  # Output: 2\n# print(closest_integer(\"-2.4\")) # Output: -2\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    \"\"\"\n    This function takes a string representing a number and returns the nearest whole number as an integer.\n    It rounds away from zero when the number is equidistant from two integers.\n    \n    Args:\n        value (str): A string representing a number.\n        \n    Returns:\n        int: The nearest integer to the given value, rounded away from zero if necessary.\n    \"\"\"\n    number = float(value)\n    if number > 0:\n        return int(number + 0.5)\n    else:\n        return int(number - 0.5) if number % 1 != 0 else int(number)\n\n# Example usage:\n# print(closest_integer(\"3.7\"))  # Output: 4\n# print(closest_integer(\"-3.7\")) # Output: -4\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    '''\n    Takes a string representing a number and returns the nearest whole number to it.\n    If the number is equidistant from two integers, round it away from zero.\n    '''\n    number = float(value)\n    if number % 1 == 0.5 or number % 1 == -0.5:\n        return int(number + (1 if number > 0 else -1))\n    return round(number)\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    '''\n    Takes a value (string) representing a number and returns the nearest whole number to it.\n    If the number is equidistant from two integers, round it away from zero.\n    '''\n    # Convert the input string to a float\n    number = float(value)\n    \n    # Apply the rounding rule\n    if number % 1 == 0.5:\n        return int(number + 0.5)\n    elif number % 1 == -0.5:\n        return int(number - 0.5)\n    else:\n        return round(number)\n\n# Example usage:\n# print(closest_integer(\"2.3\"))  # Output: 2\n# print(closest_integer(\"2.5\"))  # Output: 3\n# print(closest_integer(\"-2.5\")) # Output: -3\n# print(closest_integer(\"-2.3\")) # Output: -2\n", "from typing import List\n## main.py\n\nimport math\n\ndef closest_integer(value: str) -> int:\n    \"\"\"\n    This function takes a string representing a number and returns the nearest whole number as an integer.\n    It rounds away from zero when the number is equidistant from two integers.\n    \n    Args:\n        value (str): A string representing a number.\n        \n    Returns:\n        int: The nearest whole number as an integer.\n    \"\"\"\n    # Parse the string to a float\n    number = float(value)\n    \n    # Determine the nearest integer\n    if number > 0:\n        nearest = int(number + 0.5) if number % 1 >= 0.5 else int(number - 0.5)\n    else:\n        nearest = int(number - 0.5) if number % 1 <= -0.5 else int(number + 0.5)\n    \n    return nearest\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    '''Create a function that takes a value (string) representing a number and returns the nearest whole number to it. If the number is equidistant from two integers, round it away from zero.\n    Examples\n        >>> closest_integer(\"10\")\n        10\n        >>> closest_integer(\"15.3\")\n        15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    # Convert the string to a float\n    number = float(value)\n    \n    # Apply custom rounding logic\n    if number > 0:\n        if number % 1 >= 0.5:\n            result = int(number) + 1\n        else:\n            result = int(number)\n    else:\n        if number % 1 <= -0.5:\n            result = int(number) - 1\n        else:\n            result = int(number)\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    print(closest_integer(\"10\"))       # Output: 10\n    print(closest_integer(\"15.3\"))     # Output: 15\n    print(closest_integer(\"14.5\"))     # Output: 15\n    print(closest_integer(\"-14.5\"))    # Output: -15\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    \"\"\"\n    Rounds the given string representation of a number to the nearest integer.\n    If the number is equidistant between two integers, it rounds away from zero.\n    \n    Args:\n        value (str): A string representing a floating-point number.\n    \n    Returns:\n        int: The closest integer to the given number.\n    \"\"\"\n    # Convert the string to a float\n    number = float(value)\n    \n    # Round the float to the nearest integer\n    rounded_number = round(number)\n    \n    # Handle equidistant numbers by rounding away from zero\n    if number > 0 and number - int(rounded_number) == 0.5:\n        return int(rounded_number)\n    elif number < 0 and number - int(rounded_number) == -0.5:\n        return int(rounded_number)\n    else:\n        return rounded_number\n\n# Example usage:\n# print(closest_integer(\"2.5\"))  # Output: 3\n# print(closest_integer(\"-2.5\")) # Output: -3\n# print(closest_integer(\"2.4\"))  # Output: 2\n# print(closest_integer(\"-2.4\")) # Output: -2\n", "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    '''\n    Takes a string representing a number and returns the nearest whole number to it.\n    If the number is equidistant from two integers, round it away from zero.\n    '''\n    number = float(value)\n    if number % 1 == 0.5 or number % 1 == -0.5:\n        return int(number + (1 if number > 0 else -1))\n    return round(number)\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that takes a string representing a number and returns the nearest whole number, rounding away from zero when equidistant. This requirement is clear and specific, aligning well with the product goals of accuracy and efficiency.\nrequirement pool:\n- Implement the function to accurately round numbers to the nearest integer, rounding away from zero when equidistant.\n- Ensure the function can handle both positive and negative numbers correctly.\n- Optimize the function for performance to handle large datasets efficiently.\n- Develop the function to accept string inputs and return appropriate integer outputs.\n- Test the function for edge cases, including numbers exactly halfway between two integers.\nTo implement the function 'closest_integer' that takes a string representing a number and returns the nearest whole number, rounding away from zero when equidistant, we will use Python's built-in 'round' function with a custom adjustment for equidistant cases. This approach ensures accuracy and efficiency while handling both positive and negative numbers correctly.\n", "requirement analysis:\nThe function 'closest_integer' needs to take a string input representing a number, convert it to a float, and then round it to the nearest whole number. If the number is equidistant from two integers, it should round away from zero. This requirement ensures the function is versatile and can handle both positive and negative numbers, as well as whole numbers and decimals.\nrequirement pool:\n- Implement the function to accurately round numbers as per the given specifications.\n- Ensure the function can handle various data types and edge cases.\n- Optimize the function for performance to handle large datasets efficiently.\n- Develop a user-friendly interface for easy integration and usage.\n- Include comprehensive testing to verify the accuracy and reliability of the function.\nTo implement the 'closest_integer' function, we will use Python's built-in 'round' function with a custom approach to handle the specific requirement of rounding away from zero when the number is equidistant from two integers. This will ensure accuracy and efficiency in handling both positive and negative numbers, as well as whole numbers and decimals.\n", "requirement analysis:\nThe function needs to handle string inputs representing numbers, convert them to floating-point numbers, and then round them to the nearest whole number. The special case of equidistant numbers needs to be handled by rounding away from zero.\nrequirement pool:\n- Implement the function to accurately round numbers as per the requirements.\n- Ensure the function can handle both positive and negative numbers.\n- Optimize the function for performance to handle large datasets efficiently.\n- Design the user interface to be simple and intuitive.\n- Include error handling for invalid inputs to ensure robustness.\nTo implement the 'closest_integer' function, we will use Python's built-in capabilities for handling numbers and strings. The function will convert the input string to a float, round it to the nearest integer, and handle the special case of equidistant numbers by rounding away from zero.\n", "requirement analysis:\nThe requirement is to create a function that rounds a given string representing a number to the nearest whole number, rounding away from zero when the number is equidistant from two integers. This requirement is clear and specific, focusing on the functionality and behavior of the rounding algorithm.\nrequirement pool:\n- Implement the rounding function to handle both positive and negative numbers accurately.\n- Ensure the function returns an integer value as output.\n- Optimize the function for performance, especially for large datasets.\n- Include comprehensive testing to verify the accuracy and reliability of the rounding algorithm.\n- Provide documentation and examples to help users understand how to use the function.\nWe will use Python's built-in functions and standard libraries to implement the rounding function. The main challenge is to ensure that the function correctly handles both positive and negative numbers, rounding away from zero when necessary.\n", "requirement analysis:\nThe requirement is to create a function that rounds a given number to the nearest whole number, with a specific rule for handling equidistant values. The function should be able to handle both positive and negative numbers and should be efficient in terms of performance.\nrequirement pool:\n- The function should accurately round the number to the nearest whole number.\n- The function should handle both positive and negative numbers correctly.\n- The function should be efficient in terms of performance.\n- The function should be easy to integrate and use.\n- The function should have comprehensive documentation.\nTo create a function that rounds a given number to the nearest whole number, with a specific rule for handling equidistant values, we will use Python's built-in `round` function with a custom approach for handling equidistant cases. Python's standard library provides all necessary tools for this task, ensuring efficiency and simplicity.\n", "requirement analysis:\nThe requirement is to create a function that rounds a given number to the nearest integer, with a specific rule for handling equidistant values. The function should handle both positive and negative numbers correctly and be efficient.\nrequirement pool:\n- The function should accurately round the number to the nearest integer.\n- The function should handle both positive and negative numbers correctly.\n- The function should be efficient and fast for large datasets.\n- The function should be easy to integrate and use.\n- The function should be well-documented and include examples.\nTo create a function that rounds a given number to the nearest integer, with a specific rule for handling equidistant values, we will use Python's built-in `round` function with a custom approach for handling equidistant cases. The function will first convert the input string to a float, then apply the rounding rule, and finally return the result as an integer.\n", "requirement analysis:\nThe requirement is to create a function that rounds a given number (in string format) to the nearest whole number, rounding away from zero when the number is equidistant from two integers. This requirement is clear and specific, focusing on the functionality and behavior of the rounding algorithm.\nrequirement pool:\n- Implement the rounding function as described in the original requirements.\n- Ensure the function can handle both positive and negative numbers correctly.\n- Return an integer value as the result of the rounding operation.\n- Optimize the function for performance, especially for large datasets.\n- Test the function with various inputs to ensure accuracy and reliability.\nWe will use Python's built-in functions and standard libraries to implement the rounding functionality. The main challenge is to ensure that the function correctly handles both positive and negative numbers, rounding away from zero when necessary.\n", "requirement analysis:\nThe requirement is to create a function that rounds a given number (as a string) to the nearest whole number, rounding away from zero when the number is equidistant from two integers. This requirement is clear and specific, focusing on the functionality of rounding and the method to handle equidistant cases.\nrequirement pool:\n- Implement the function to round numbers correctly according to the specified rules.\n- Ensure the function can handle both positive and negative numbers.\n- Optimize the function for performance to handle large datasets efficiently.\n- Test the function with various edge cases to ensure accuracy.\n- Document the function clearly for easy understanding and usage.\nTo implement the 'closest_integer' function, we will use Python's built-in 'round' function with a custom approach to handle the specific rounding rules. The 'round' function in Python rounds to the nearest even number when the number is equidistant from two integers, but we need to round away from zero in such cases. We will convert the string input to a float, apply the custom rounding logic, and then return the result as an integer.\n", "requirement analysis:\nThe function needs to handle string inputs representing numbers, convert them to floating-point numbers, and then round them to the nearest whole number. The special case of equidistant numbers needs to be handled by rounding away from zero.\nrequirement pool:\n- Implement the function to accurately round numbers as per the requirements.\n- Ensure the function can handle both positive and negative numbers.\n- Optimize the function for performance to handle large datasets efficiently.\n- Design the user interface to be simple and intuitive.\n- Include error handling for invalid inputs to ensure robustness.\nTo implement the 'closest_integer' function, we will use Python's built-in capabilities for handling numbers and strings. The function will convert the input string to a float, round it to the nearest integer, and handle the special case of equidistant numbers by rounding away from zero.\n", "requirement analysis:\nThe requirement is to create a function that rounds a given number to the nearest whole number, with a specific rule for handling equidistant values. The function should be able to handle both positive and negative numbers and should be efficient in terms of performance.\nrequirement pool:\n- The function should accurately round the number to the nearest whole number.\n- The function should handle both positive and negative numbers correctly.\n- The function should be efficient in terms of performance.\n- The function should be easy to integrate and use.\n- The function should have comprehensive documentation.\nTo create a function that rounds a given number to the nearest whole number, with a specific rule for handling equidistant values, we will use Python's built-in `round` function with a custom approach for handling equidistant cases. Python's standard library provides all necessary tools for this task, ensuring efficiency and simplicity.\n"], "scores": [0.9846, 1.0, 0.9923, 1.0, 1.0, 0.9923, 0.5077, 0.9846, 0.9923, 1.0], "pass_results": [false, true, false, true, true, false, false, false, false, true], "pass_test_cases_num": [128, 130, 129, 130, 130, 129, 66, 128, 129, 130], "completion": "from typing import List\n## main.py\n\ndef closest_integer(value: str) -> int:\n    '''\n    Takes a string representing a number and returns the nearest whole number to it.\n    If the number is equidistant from two integers, round it away from zero.\n    '''\n    number = float(value)\n    if number % 1 == 0.5 or number % 1 == -0.5:\n        return int(number + (1 if number > 0 else -1))\n    return round(number)\n", "passed": true, "pass": true, "pass_num": 4, "round": 142, "repair_prompt": ["def closest_integer(value):\t\n'''Create a function that takes a value (string) representing a number and returns the nearest whole number to it. If the number is equidistant from two integers, round it away from zero.\nExamples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''"], "mutate_method": "rephrase_one", "parent_index": 175}
