{"task_id": "HumanEval/6", "prompt": "def parse_nested_parens(paren_string: str) -> List[int]:\t\n'''Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    '''", "entry_point": "parse_nested_parens", "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "test": ["def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()()) ((())) (((()))) (((()))) (()) ()\") == [3, 2, 3, 4, 4, 2, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()) (()()) ((())) ((())()())\") == [3, 1, 2, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) ((())) ((())()()) (()) (()()) ((())) ((())) () () ((())()()) (()()) () (((()))) ((())()()) () (((()))) (((()))) ()\") == [4, 3, 3, 2, 2, 3, 3, 1, 1, 3, 2, 1, 4, 3, 1, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (((()))) ((())()()) (()()) () (((())))\") == [3, 4, 3, 2, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())) (()()) () () (()()) () ()\") == [2, 3, 2, 1, 1, 2, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) () ((())()()) () () ((())) ((())) (()()) () () (()())\") == [3, 2, 1, 3, 1, 1, 3, 3, 2, 1, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) ((())()()) ((())) (()()) () ((())()()) (()()) ((())()()) ((())) ((())) (()())\") == [3, 2, 3, 3, 2, 1, 3, 2, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()(())((()))) (((()))) ((())) (()) () ((())) ((())) (()()) ((())()()) (()()) () (()) (((()))) (()) ((())) (((()))) ((())) ((())()()) ((())()())\") == [3, 1, 4, 4, 3, 2, 1, 3, 3, 2, 3, 2, 1, 2, 4, 2, 3, 4, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) ((())()()) ((())()()) (()()) ((())) () () ((())) () () (()())\") == [3, 2, 3, 3, 2, 3, 1, 1, 3, 1, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())) () () () () (()()) (()()) (()()) ((())()()) ()\") == [3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) (()) ((())()()) () () ((())) ((())) (((()))) () (()()) (((())))\") == [2, 4, 2, 3, 1, 1, 3, 3, 4, 1, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())) ((())) ((())()())\") == [2, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())) (()) (()()) ((())()()) ((())()())\") == [2, 3, 2, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()) (()()) ((())) (((()))) () ((())()()) ((())) (()()) (()()) (()) ((())()())\") == [3, 2, 2, 3, 4, 1, 3, 3, 2, 2, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () ((())()()) ((())()()) (((()))) ((())()()) (((())))\") == [3, 1, 3, 3, 4, 3, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) ((())) (()) ((())) () () () (((()))) (()()) (()()) (((()))) (()) (()) (((())))\") == [4, 3, 2, 3, 1, 1, 1, 4, 2, 2, 4, 2, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()) (()()) (()()) (()()) ((())) (((()))) (()(())((()))) (()) () (((()))) (()) ((())) (())\") == [4, 2, 2, 2, 2, 3, 4, 4, 2, 1, 4, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()) (()) (()()) (()()) (((()))) (()) (((()))) (()(())((()))) ((())) ((())) ((())()()) () (((())))\") == [2, 2, 2, 2, 2, 4, 2, 4, 4, 3, 3, 3, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) ((())) (((()))) ((())()()) (()()) (()(())((()))) ((())()()) ((())) ((())) (()()) ((())()()) ((())) (()) (()(())((()))) () () (()(())((()))) (()()) (((()))) (((()))) ()\") == [4, 3, 4, 3, 2, 4, 3, 3, 3, 2, 3, 3, 2, 4, 1, 1, 4, 2, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) ((())) ((())) ((())) (()) (()(())((()))) () ((())) (((()))) (()) ((())) ((())) () (()(())((())))\") == [4, 3, 3, 3, 2, 4, 1, 3, 4, 2, 3, 3, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()()) () ((())) (()()) () ((())()()) ((())) ((())) ((())) ((())) ((()))\") == [3, 2, 1, 3, 2, 1, 3, 3, 3, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())()()) ((())()()) () (((()))) ((())()()) ((())()()) (()()) (()()) (()) ((())) (()())\") == [2, 3, 3, 1, 4, 3, 3, 2, 2, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()(())((()))) (()) (()(())((()))) (((()))) (()(())((()))) (())\") == [3, 4, 2, 4, 4, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()) (()(())((()))) (()) (((()))) (((()))) ((())()())\") == [2, 2, 4, 2, 4, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) ((())()()) (((()))) (()(())((()))) ((())()())\") == [4, 4, 4, 3, 4, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) ((())()()) () ((())()()) (()()) () () ((())) (()()) ((())) ((())()())\") == [1, 3, 3, 1, 3, 2, 1, 1, 3, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()()) ((())()()) (()()) () () ((())) () ((())()()) (((()))) (((()))) ()\") == [2, 2, 3, 2, 1, 1, 3, 1, 3, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())()()) ((())) (()())\") == [2, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())()()) (()()) (()) ((())()()) (((()))) (((()))) ((())()()) ((())) ((())()()) () (()()) (()()) ((())()()) (()) ((())) ((())()())\") == [3, 3, 3, 2, 2, 3, 4, 4, 3, 3, 3, 1, 2, 2, 3, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) () (()()) (()())\") == [2, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) ((())) () ((())()()) (()()) (()()) () ((())) ((())) (()()) (((()))) (()())\") == [4, 3, 1, 3, 2, 2, 1, 3, 3, 2, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())()()) () ((())) (()()) ((())()()) (()())\") == [3, 3, 3, 1, 3, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())) ((())) ((())()()) () ((()))\") == [2, 3, 3, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) (()()) () () ((())) ((())()()) ()\") == [2, 2, 2, 1, 1, 3, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()(())((()))) ((())()()) (()()) (((()))) ((())()()) ((())()())\") == [2, 4, 3, 2, 4, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (((()))) (((()))) (()()) (((())))\") == [3, 1, 4, 4, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) () (()()) (((()))) ((())) (()()) () (()) (((()))) (()(())((()))) (((()))) (((()))) ()\") == [1, 3, 1, 2, 4, 3, 2, 1, 2, 4, 4, 4, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())()()) () ((()))\") == [3, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () ((()))\") == [2, 2, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) () (()) () (()) (())\") == [4, 1, 2, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())()()) () ((())) (()()) () () () () (()()) ((())) ((()))\") == [1, 3, 1, 3, 2, 1, 1, 1, 1, 2, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) (()()) (()()) ((())()()) ((())) ((())) ((())()())\") == [3, 3, 2, 2, 3, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () ((())()()) (((()))) (()) (((()))) () ((())) (()()) (()) (((()))) (()())\") == [3, 1, 3, 4, 2, 4, 1, 3, 2, 2, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()) ((())) () () () ((()))\") == [2, 2, 3, 1, 1, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (((()))) ((())()()) ((())) ((())()()) (())\") == [3, 4, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())) ((())) (()()) ((())()()) () () ()\") == [3, 3, 3, 2, 3, 1, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () (()()) ((())()()) (()()) () (()()) ((())) () () (()())\") == [2, 2, 1, 2, 3, 2, 1, 2, 3, 1, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (((()))) (()) (()) ((())) () ((())) ((())()()) ((())) (()) (()()) (((())))\") == [2, 4, 2, 2, 3, 1, 3, 3, 3, 2, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (((()))) () (()()) ((())()()) () (()(())((()))) (()(())((()))) (()()) () (()()) (()) (()) ((())()())\") == [4, 4, 1, 2, 3, 1, 4, 4, 2, 1, 2, 2, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (((()))) ((())) ((())) ((())) ((())()()) ((())()()) (()()) () () (()(())((()))) ((())) ((())()()) (()(())((()))) () ((())()()) (((()))) (((()))) (()(())((()))) ((())()()) ()\") == [3, 4, 3, 3, 3, 3, 3, 2, 1, 1, 4, 3, 3, 4, 1, 3, 4, 4, 4, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) ((())()()) ((())) () (()()) () (()())\") == [1, 3, 3, 3, 1, 2, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()()) () (()()) ((())()()) ((())) ((())) (()) ((())()()) () ((())()()) (()()) () (()) ((())) (()()) (()()) ((())()())\") == [2, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 2, 1, 2, 3, 2, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) (((()))) (()) (()()) (((()))) () (((()))) (()) ((())) () ()\") == [2, 4, 4, 2, 2, 4, 1, 4, 2, 3, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) (((()))) (()()) (((()))) ((())) ((())()()) (()) ((())()()) (((()))) (()()) () (()) (((()))) () (()(())((()))) () (()) (()(())((()))) ((())) ((())()())\") == [2, 4, 4, 2, 4, 3, 3, 2, 3, 4, 2, 1, 2, 4, 1, 4, 1, 2, 4, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() (()(())((()))) (()) (()()) ((())()()) (()()) (()())\") == [1, 4, 2, 2, 3, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()(())((()))) (()()) (()()) ((())()()) (()()) ((())) () () (()()) (()(())((()))) ((())()()) (()()) ((())()()) (((()))) (()(())((()))) (()()) () ((())()()) ((())()()) ()\") == [3, 4, 2, 2, 3, 2, 3, 1, 1, 2, 4, 3, 2, 3, 4, 4, 2, 1, 3, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () () (()()) (()()) (()()) ((())) (()())\") == [3, 1, 1, 2, 2, 2, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())()()) (()()) (()) ((())()()) () (((()))) ((())()()) () (()) (()) ((())()()) (()) (()) (()) ((())) ((())) (((())))\") == [1, 3, 2, 2, 3, 1, 4, 3, 1, 2, 2, 3, 2, 2, 2, 3, 3, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) () (()(())((()))) (()) (((()))) ((())()()) ((())()()) ((())) ((())()()) (()(())((()))) ((())) (()(())((()))) ((())) ((())()())\") == [4, 1, 4, 2, 4, 3, 3, 3, 3, 4, 3, 4, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (((()))) () (()) (()) ((())) (()()) () () ((())()()) (()) ((()))\") == [2, 4, 1, 2, 2, 3, 2, 1, 1, 3, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())()()) (()()) ((())()()) (((()))) (()()) (()(())((()))) (()()) (()(())((()))) ((())) (()) ((())) (()()) (()) (()()) () ((())) ((())) ((())) ((())) (()())\") == [2, 3, 2, 3, 4, 2, 4, 2, 4, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) ((())()()) ((())) ((())()()) ((())) () ()\") == [3, 3, 3, 3, 3, 3, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()()) () ((())()())\") == [3, 2, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () (()()) ((())) (()()) () ((())()()) ((()))\") == [3, 1, 2, 3, 2, 1, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) () (()) (((()))) ((())) (()) ((())()()) ((())()()) () ((())()()) (()) ((())()())\") == [4, 1, 2, 4, 3, 2, 3, 3, 1, 3, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () (()()) ((())) ((())()()) ((())()())\") == [3, 1, 2, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () ((())) () (()()) ((())) ((())()()) () () ((())()()) () (()())\") == [3, 1, 3, 1, 2, 3, 3, 1, 1, 3, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() ((())) (()()) (((()))) () ((())) (((()))) () (()) () () ((())()()) (()) (()()) ((())) (((()))) (()) (())\") == [1, 3, 2, 4, 1, 3, 4, 1, 2, 1, 1, 3, 2, 2, 3, 4, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) () ((())()()) ((())()()) ((())) () ((())()()) ((())) () ((())()()) (()()) (()())\") == [3, 1, 3, 3, 3, 1, 3, 3, 1, 3, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"() (()()) ((())()()) (()(())((()))) (((()))) (()(())((()))) ((())()()) (()) (()()) (((()))) (()) (()) (()()) (((()))) (((()))) () (()) ((())) () (()) (()())\") == [1, 2, 3, 4, 4, 4, 3, 2, 2, 4, 2, 2, 2, 4, 4, 1, 2, 3, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) () (((()))) (()()) ((())) () (()()) (((()))) (()()) (((()))) () ()\") == [4, 1, 4, 2, 3, 1, 2, 4, 2, 4, 1, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) () (()) () ((())) (()) (()()) (((()))) ((())) () () (()) () () (()) () ((())) (()(())((()))) ((()))\") == [4, 4, 4, 1, 2, 1, 3, 2, 2, 4, 3, 1, 1, 2, 1, 1, 2, 1, 3, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) (()) (()()) ((())()()) (()) (()()) ((())) (()()) (()(())((()))) (()(())((()))) ((())()()) ((())) (((()))) (()(())((()))) ((())) ((())) (()(())((()))) () ((())) ((())) ((())()())\") == [2, 2, 2, 3, 2, 2, 3, 2, 4, 4, 3, 3, 4, 4, 3, 3, 4, 1, 3, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()) ((())()()) (()()) ((())) (()) () () (((()))) (((()))) (())\") == [3, 1, 2, 3, 2, 3, 2, 1, 1, 4, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"\") == []", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()) (()()) ((())) () ((())) ((())()()) () () (()) (()) (((()))) (((()))) ((())) () () (()()) (())\") == [3, 2, 2, 3, 1, 3, 3, 1, 1, 2, 2, 4, 4, 3, 1, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())()()) ((())) (()()) ((())()()) () (()()) ((()))\") == [3, 3, 3, 2, 3, 1, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) ((())()()) ((())()()) ((())) (()()) ((())) ((())()()) ((())()()) ((())()()) () ((())) (()())\") == [3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())()()) (()) () (((()))) ((())()()) ((())()()) (((()))) (()) (((()))) () (((()))) ((())()()) (()()) (()) (()) (()) () (())\") == [3, 2, 1, 4, 3, 3, 4, 2, 4, 1, 4, 3, 2, 2, 2, 2, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()) ((())()()) ((())()()) () ((()))\") == [2, 2, 3, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) () ((())()()) () ((())) () ((())) ()\") == [2, 1, 3, 1, 3, 1, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) () (()()) ()\") == [3, 1, 2, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) (()()) ((())()()) () ((())()()) ((())()()) ((())) (()()) ((())) () ((())()())\") == [3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 1, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) () (()()) ((())) () ((())()()) (()()) ((())()())\") == [2, 1, 2, 3, 1, 3, 2, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(((()))) (()) () ((())()()) (()()) () (()()) (()(())((()))) (()(())((()))) ((())) (((()))) (()(())((()))) ((())()()) ()\") == [4, 2, 1, 3, 2, 1, 2, 4, 4, 3, 4, 4, 3, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () (()())\") == [2, 2, 1, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) (((()))) (()) (()()) (()()) () ((())) ((())()()) () (()(())((()))) (()()) (()(())((()))) ((()))\") == [3, 3, 4, 2, 2, 2, 1, 3, 3, 1, 4, 2, 4, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) (()()) () (()) () (()()) (()) (()) (((()))) () (()()) (())\") == [2, 2, 1, 2, 1, 2, 2, 2, 4, 1, 2, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens('(()(())((())))') == [4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (()) (((()))) () (()()) (((()))) ((())()()) ((())) (()()) ((())()()) (((()))) ((())) (()) ((())) ((())) () ((())) ((())()())\") == [3, 2, 4, 1, 2, 4, 3, 3, 2, 3, 4, 3, 2, 3, 3, 1, 3, 3]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) ((())()()) (()) ((())) ((())) ((())()()) (((()))) () ((())()()) (()(())((()))) ((())) ((())()()) ((())()()) (())\") == [2, 3, 2, 3, 3, 3, 4, 1, 3, 4, 3, 3, 3, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()()) ((())()()) (()()) ()\") == [2, 3, 2, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()(())((()))) ((())()()) (((()))) (()(())((()))) () (()(())((()))) ()\") == [4, 3, 4, 4, 1, 4, 1]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) ((())()()) () ((())) ((())) (()()) ((())()()) (((()))) () (()) (((())))\") == [3, 3, 3, 1, 3, 3, 2, 3, 4, 1, 2, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) (((()))) ((())) (()()) (()()) ((())()()) (()) (()(())((()))) (()) ((())) (()) ((())) () (((())))\") == [3, 4, 3, 2, 2, 3, 2, 4, 2, 3, 2, 3, 1, 4]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"((())) ((())) ((())()()) (()()) () (()(())((()))) (()()) (((()))) (((()))) ((())()()) (()()) () () ((())) (((()))) (()(())((()))) (((()))) ((())()()) ((())) (()(())((()))) (())\") == [3, 3, 3, 2, 1, 4, 2, 4, 4, 3, 2, 1, 1, 3, 4, 4, 4, 3, 3, 4, 2]", "def check(parse_nested_parens):\n\tassert parse_nested_parens(\"(()) () (((()))) () (((()))) (()()) (()) (((()))) (()(())((()))) (((()))) () (()()) (()(())((()))) (()()) (()(())((()))) (()()) (((()))) (()()) (((()))) (()) (()())\") == [2, 1, 4, 1, 4, 2, 2, 4, 4, 4, 1, 2, 4, 2, 4, 2, 4, 2, 4, 2, 2]"], "test_case_list": ["assert parse_nested_parens(\"((())()()) (()()) ((())) (((()))) (((()))) (()) ()\") == [3, 2, 3, 4, 4, 2, 1]", "assert parse_nested_parens(\"((())) () (()) (()()) ((())) ((())()())\") == [3, 1, 2, 2, 3, 3]", "assert parse_nested_parens(\"(((()))) ((())) ((())()()) (()) (()()) ((())) ((())) () () ((())()()) (()()) () (((()))) ((())()()) () (((()))) (((()))) ()\") == [4, 3, 3, 2, 2, 3, 3, 1, 1, 3, 2, 1, 4, 3, 1, 4, 4, 1]", "assert parse_nested_parens(\"((())) (((()))) ((())()()) (()()) () (((())))\") == [3, 4, 3, 2, 1, 4]", "assert parse_nested_parens(\"(()()) ((())) (()()) () () (()()) () ()\") == [2, 3, 2, 1, 1, 2, 1, 1]", "assert parse_nested_parens(\"((())) (()()) () ((())()()) () () ((())) ((())) (()()) () () (()())\") == [3, 2, 1, 3, 1, 1, 3, 3, 2, 1, 1, 2]", "assert parse_nested_parens(\"((())) (()()) ((())()()) ((())) (()()) () ((())()()) (()()) ((())()()) ((())) ((())) (()())\") == [3, 2, 3, 3, 2, 1, 3, 2, 3, 3, 3, 2]", "assert parse_nested_parens(\"((())) () (()(())((()))) (((()))) ((())) (()) () ((())) ((())) (()()) ((())()()) (()()) () (()) (((()))) (()) ((())) (((()))) ((())) ((())()()) ((())()())\") == [3, 1, 4, 4, 3, 2, 1, 3, 3, 2, 3, 2, 1, 2, 4, 2, 3, 4, 3, 3, 3]", "assert parse_nested_parens(\"((())) (()()) ((())()()) ((())()()) (()()) ((())) () () ((())) () () (()())\") == [3, 2, 3, 3, 2, 3, 1, 1, 3, 1, 1, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())) () () () () (()()) (()()) (()()) ((())()()) ()\") == [3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 3, 1]", "assert parse_nested_parens(\"(()()) (((()))) (()) ((())()()) () () ((())) ((())) (((()))) () (()()) (((())))\") == [2, 4, 2, 3, 1, 1, 3, 3, 4, 1, 2, 4]", "assert parse_nested_parens(\"(()()) ((())) ((())) ((())()())\") == [2, 3, 3, 3]", "assert parse_nested_parens(\"(()) ((())) (()) (()()) ((())()()) ((())()())\") == [2, 3, 2, 2, 3, 3]", "assert parse_nested_parens(\"((())) (()) (()()) ((())) (((()))) () ((())()()) ((())) (()()) (()()) (()) ((())()())\") == [3, 2, 2, 3, 4, 1, 3, 3, 2, 2, 2, 3]", "assert parse_nested_parens(\"((())) () ((())()()) ((())()()) (((()))) ((())()()) (((())))\") == [3, 1, 3, 3, 4, 3, 4]", "assert parse_nested_parens(\"(((()))) ((())) (()) ((())) () () () (((()))) (()()) (()()) (((()))) (()) (()) (((())))\") == [4, 3, 2, 3, 1, 1, 1, 4, 2, 2, 4, 2, 2, 4]", "assert parse_nested_parens(\"(((()))) (()) (()()) (()()) (()()) ((())) (((()))) (()(())((()))) (()) () (((()))) (()) ((())) (())\") == [4, 2, 2, 2, 2, 3, 4, 4, 2, 1, 4, 2, 3, 2]", "assert parse_nested_parens(\"(()()) (()) (()) (()()) (()()) (((()))) (()) (((()))) (()(())((()))) ((())) ((())) ((())()()) () (((())))\") == [2, 2, 2, 2, 2, 4, 2, 4, 4, 3, 3, 3, 1, 4]", "assert parse_nested_parens(\"(()(())((()))) ((())) (((()))) ((())()()) (()()) (()(())((()))) ((())()()) ((())) ((())) (()()) ((())()()) ((())) (()) (()(())((()))) () () (()(())((()))) (()()) (((()))) (((()))) ()\") == [4, 3, 4, 3, 2, 4, 3, 3, 3, 2, 3, 3, 2, 4, 1, 1, 4, 2, 4, 4, 1]", "assert parse_nested_parens(\"(()(())((()))) ((())) ((())) ((())) (()) (()(())((()))) () ((())) (((()))) (()) ((())) ((())) () (()(())((())))\") == [4, 3, 3, 3, 2, 4, 1, 3, 4, 2, 3, 3, 1, 4]", "assert parse_nested_parens(\"((())()()) (()()) () ((())) (()()) () ((())()()) ((())) ((())) ((())) ((())) ((()))\") == [3, 2, 1, 3, 2, 1, 3, 3, 3, 3, 3, 3]", "assert parse_nested_parens(\"(()) ((())()()) ((())()()) () (((()))) ((())()()) ((())()()) (()()) (()()) (()) ((())) (()())\") == [2, 3, 3, 1, 4, 3, 3, 2, 2, 2, 3, 2]", "assert parse_nested_parens(\"((())()()) (()(())((()))) (()) (()(())((()))) (((()))) (()(())((()))) (())\") == [3, 4, 2, 4, 4, 4, 2]", "assert parse_nested_parens(\"(()) (()) (()(())((()))) (()) (((()))) (((()))) ((())()())\") == [2, 2, 4, 2, 4, 4, 3]", "assert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) ((())()()) (((()))) (()(())((()))) ((())()())\") == [4, 4, 4, 3, 4, 4, 3]", "assert parse_nested_parens(\"() ((())) ((())()()) () ((())()()) (()()) () () ((())) (()()) ((())) ((())()())\") == [1, 3, 3, 1, 3, 2, 1, 1, 3, 2, 3, 3]", "assert parse_nested_parens(\"(()) (()()) ((())()()) (()()) () () ((())) () ((())()()) (((()))) (((()))) ()\") == [2, 2, 3, 2, 1, 1, 3, 1, 3, 4, 4, 1]", "assert parse_nested_parens(\"(()()) ((())()()) ((())) (()())\") == [2, 3, 3, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())()()) (()()) (()) ((())()()) (((()))) (((()))) ((())()()) ((())) ((())()()) () (()()) (()()) ((())()()) (()) ((())) ((())()())\") == [3, 3, 3, 2, 2, 3, 4, 4, 3, 3, 3, 1, 2, 2, 3, 2, 3, 3]", "assert parse_nested_parens(\"(()()) () (()()) (()())\") == [2, 1, 2, 2]", "assert parse_nested_parens(\"(((()))) ((())) () ((())()()) (()()) (()()) () ((())) ((())) (()()) (((()))) (()())\") == [4, 3, 1, 3, 2, 2, 1, 3, 3, 2, 4, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())()()) () ((())) (()()) ((())()()) (()())\") == [3, 3, 3, 1, 3, 2, 3, 2]", "assert parse_nested_parens(\"(()) ((())) ((())) ((())()()) () ((()))\") == [2, 3, 3, 3, 1, 3]", "assert parse_nested_parens(\"(()()) (()()) (()()) () () ((())) ((())()()) ()\") == [2, 2, 2, 1, 1, 3, 3, 1]", "assert parse_nested_parens(\"(()) (()(())((()))) ((())()()) (()()) (((()))) ((())()()) ((())()())\") == [2, 4, 3, 2, 4, 3, 3]", "assert parse_nested_parens(\"((())) () (((()))) (((()))) (()()) (((())))\") == [3, 1, 4, 4, 2, 4]", "assert parse_nested_parens(\"() ((())) () (()()) (((()))) ((())) (()()) () (()) (((()))) (()(())((()))) (((()))) (((()))) ()\") == [1, 3, 1, 2, 4, 3, 2, 1, 2, 4, 4, 4, 4, 1]", "assert parse_nested_parens(\"((())) ((())()()) () ((()))\") == [3, 3, 1, 3]", "assert parse_nested_parens(\"(()()) (()()) () ((()))\") == [2, 2, 1, 3]", "assert parse_nested_parens(\"(((()))) () (()) () (()) (())\") == [4, 1, 2, 1, 2, 2]", "assert parse_nested_parens(\"() ((())()()) () ((())) (()()) () () () () (()()) ((())) ((()))\") == [1, 3, 1, 3, 2, 1, 1, 1, 1, 2, 3, 3]", "assert parse_nested_parens(\"((())) ((())) (()()) (()()) ((())()()) ((())) ((())) ((())()())\") == [3, 3, 2, 2, 3, 3, 3, 3]", "assert parse_nested_parens(\"((())) () ((())()()) (((()))) (()) (((()))) () ((())) (()()) (()) (((()))) (()())\") == [3, 1, 3, 4, 2, 4, 1, 3, 2, 2, 4, 2]", "assert parse_nested_parens(\"(()()) (()) ((())) () () () ((()))\") == [2, 2, 3, 1, 1, 1, 3]", "assert parse_nested_parens(\"((())()()) (((()))) ((())()()) ((())) ((())()()) (())\") == [3, 4, 3, 3, 3, 2]", "assert parse_nested_parens(\"((())()()) ((())) ((())) (()()) ((())()()) () () ()\") == [3, 3, 3, 2, 3, 1, 1, 1]", "assert parse_nested_parens(\"(()()) (()()) () (()()) ((())()()) (()()) () (()()) ((())) () () (()())\") == [2, 2, 1, 2, 3, 2, 1, 2, 3, 1, 1, 2]", "assert parse_nested_parens(\"(()) (((()))) (()) (()) ((())) () ((())) ((())()()) ((())) (()) (()()) (((())))\") == [2, 4, 2, 2, 3, 1, 3, 3, 3, 2, 2, 4]", "assert parse_nested_parens(\"(((()))) (((()))) () (()()) ((())()()) () (()(())((()))) (()(())((()))) (()()) () (()()) (()) (()) ((())()())\") == [4, 4, 1, 2, 3, 1, 4, 4, 2, 1, 2, 2, 2, 3]", "assert parse_nested_parens(\"((())()()) (((()))) ((())) ((())) ((())) ((())()()) ((())()()) (()()) () () (()(())((()))) ((())) ((())()()) (()(())((()))) () ((())()()) (((()))) (((()))) (()(())((()))) ((())()()) ()\") == [3, 4, 3, 3, 3, 3, 3, 2, 1, 1, 4, 3, 3, 4, 1, 3, 4, 4, 4, 3, 1]", "assert parse_nested_parens(\"() ((())) ((())()()) ((())) () (()()) () (()())\") == [1, 3, 3, 3, 1, 2, 1, 2]", "assert parse_nested_parens(\"(()) (()()) () (()()) ((())()()) ((())) ((())) (()) ((())()()) () ((())()()) (()()) () (()) ((())) (()()) (()()) ((())()())\") == [2, 2, 1, 2, 3, 3, 3, 2, 3, 1, 3, 2, 1, 2, 3, 2, 2, 3]", "assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]", "assert parse_nested_parens(\"(()()) (((()))) (((()))) (()) (()()) (((()))) () (((()))) (()) ((())) () ()\") == [2, 4, 4, 2, 2, 4, 1, 4, 2, 3, 1, 1]", "assert parse_nested_parens(\"(()()) (((()))) (((()))) (()()) (((()))) ((())) ((())()()) (()) ((())()()) (((()))) (()()) () (()) (((()))) () (()(())((()))) () (()) (()(())((()))) ((())) ((())()())\") == [2, 4, 4, 2, 4, 3, 3, 2, 3, 4, 2, 1, 2, 4, 1, 4, 1, 2, 4, 3, 3]", "assert parse_nested_parens(\"() (()(())((()))) (()) (()()) ((())()()) (()()) (()())\") == [1, 4, 2, 2, 3, 2, 2]", "assert parse_nested_parens(\"((())()()) (()(())((()))) (()()) (()()) ((())()()) (()()) ((())) () () (()()) (()(())((()))) ((())()()) (()()) ((())()()) (((()))) (()(())((()))) (()()) () ((())()()) ((())()()) ()\") == [3, 4, 2, 2, 3, 2, 3, 1, 1, 2, 4, 3, 2, 3, 4, 4, 2, 1, 3, 3, 1]", "assert parse_nested_parens(\"((())()()) () () (()()) (()()) (()()) ((())) (()())\") == [3, 1, 1, 2, 2, 2, 3, 2]", "assert parse_nested_parens(\"() ((())()()) (()()) (()) ((())()()) () (((()))) ((())()()) () (()) (()) ((())()()) (()) (()) (()) ((())) ((())) (((())))\") == [1, 3, 2, 2, 3, 1, 4, 3, 1, 2, 2, 3, 2, 2, 2, 3, 3, 4]", "assert parse_nested_parens(\"(()(())((()))) () (()(())((()))) (()) (((()))) ((())()()) ((())()()) ((())) ((())()()) (()(())((()))) ((())) (()(())((()))) ((())) ((())()())\") == [4, 1, 4, 2, 4, 3, 3, 3, 3, 4, 3, 4, 3, 3]", "assert parse_nested_parens(\"(()()) (((()))) () (()) (()) ((())) (()()) () () ((())()()) (()) ((()))\") == [2, 4, 1, 2, 2, 3, 2, 1, 1, 3, 2, 3]", "assert parse_nested_parens(\"(()) ((())()()) (()()) ((())()()) (((()))) (()()) (()(())((()))) (()()) (()(())((()))) ((())) (()) ((())) (()()) (()) (()()) () ((())) ((())) ((())) ((())) (()())\") == [2, 3, 2, 3, 4, 2, 4, 2, 4, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3, 2]", "assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]", "assert parse_nested_parens(\"((())) ((())) ((())()()) ((())) ((())()()) ((())) () ()\") == [3, 3, 3, 3, 3, 3, 1, 1]", "assert parse_nested_parens(\"((())) (()()) () ((())()())\") == [3, 2, 1, 3]", "assert parse_nested_parens(\"((())()()) () (()()) ((())) (()()) () ((())()()) ((()))\") == [3, 1, 2, 3, 2, 1, 3, 3]", "assert parse_nested_parens(\"(((()))) () (()) (((()))) ((())) (()) ((())()()) ((())()()) () ((())()()) (()) ((())()())\") == [4, 1, 2, 4, 3, 2, 3, 3, 1, 3, 2, 3]", "assert parse_nested_parens(\"((())()()) () (()()) ((())) ((())()()) ((())()())\") == [3, 1, 2, 3, 3, 3]", "assert parse_nested_parens(\"((())()()) () ((())) () (()()) ((())) ((())()()) () () ((())()()) () (()())\") == [3, 1, 3, 1, 2, 3, 3, 1, 1, 3, 1, 2]", "assert parse_nested_parens(\"() ((())) (()()) (((()))) () ((())) (((()))) () (()) () () ((())()()) (()) (()()) ((())) (((()))) (()) (())\") == [1, 3, 2, 4, 1, 3, 4, 1, 2, 1, 1, 3, 2, 2, 3, 4, 2, 2]", "assert parse_nested_parens(\"((())()()) () ((())()()) ((())()()) ((())) () ((())()()) ((())) () ((())()()) (()()) (()())\") == [3, 1, 3, 3, 3, 1, 3, 3, 1, 3, 2, 2]", "assert parse_nested_parens(\"() (()()) ((())()()) (()(())((()))) (((()))) (()(())((()))) ((())()()) (()) (()()) (((()))) (()) (()) (()()) (((()))) (((()))) () (()) ((())) () (()) (()())\") == [1, 2, 3, 4, 4, 4, 3, 2, 2, 4, 2, 2, 2, 4, 4, 1, 2, 3, 1, 2, 2]", "assert parse_nested_parens(\"(((()))) () (((()))) (()()) ((())) () (()()) (((()))) (()()) (((()))) () ()\") == [4, 1, 4, 2, 3, 1, 2, 4, 2, 4, 1, 1]", "assert parse_nested_parens(\"(((()))) (()(())((()))) (()(())((()))) () (()) () ((())) (()) (()()) (((()))) ((())) () () (()) () () (()) () ((())) (()(())((()))) ((()))\") == [4, 4, 4, 1, 2, 1, 3, 2, 2, 4, 3, 1, 1, 2, 1, 1, 2, 1, 3, 4, 3]", "assert parse_nested_parens(\"(()) (()) (()()) ((())()()) (()) (()()) ((())) (()()) (()(())((()))) (()(())((()))) ((())()()) ((())) (((()))) (()(())((()))) ((())) ((())) (()(())((()))) () ((())) ((())) ((())()())\") == [2, 2, 2, 3, 2, 2, 3, 2, 4, 4, 3, 3, 4, 4, 3, 3, 4, 1, 3, 3, 3]", "assert parse_nested_parens(\"((())) () (()) ((())()()) (()()) ((())) (()) () () (((()))) (((()))) (())\") == [3, 1, 2, 3, 2, 3, 2, 1, 1, 4, 4, 2]", "assert parse_nested_parens(\"\") == []", "assert parse_nested_parens(\"((())()()) (()) (()()) ((())) () ((())) ((())()()) () () (()) (()) (((()))) (((()))) ((())) () () (()()) (())\") == [3, 2, 2, 3, 1, 3, 3, 1, 1, 2, 2, 4, 4, 3, 1, 1, 2, 2]", "assert parse_nested_parens(\"((())) ((())()()) ((())) (()()) ((())()()) () (()()) ((()))\") == [3, 3, 3, 2, 3, 1, 2, 3]", "assert parse_nested_parens(\"((())()()) ((())()()) ((())()()) ((())) (()()) ((())) ((())()()) ((())()()) ((())()()) () ((())) (()())\") == [3, 3, 3, 3, 2, 3, 3, 3, 3, 1, 3, 2]", "assert parse_nested_parens(\"((())()()) (()) () (((()))) ((())()()) ((())()()) (((()))) (()) (((()))) () (((()))) ((())()()) (()()) (()) (()) (()) () (())\") == [3, 2, 1, 4, 3, 3, 4, 2, 4, 1, 4, 3, 2, 2, 2, 2, 1, 2]", "assert parse_nested_parens(\"(()()) (()) ((())()()) ((())()()) () ((()))\") == [2, 2, 3, 3, 1, 3]", "assert parse_nested_parens(\"(()()) () ((())()()) () ((())) () ((())) ()\") == [2, 1, 3, 1, 3, 1, 3, 1]", "assert parse_nested_parens(\"((())) () (()()) ()\") == [3, 1, 2, 1]", "assert parse_nested_parens(\"((())) ((())) (()()) ((())()()) () ((())()()) ((())()()) ((())) (()()) ((())) () ((())()())\") == [3, 3, 2, 3, 1, 3, 3, 3, 2, 3, 1, 3]", "assert parse_nested_parens(\"(()()) () (()()) ((())) () ((())()()) (()()) ((())()())\") == [2, 1, 2, 3, 1, 3, 2, 3]", "assert parse_nested_parens(\"(((()))) (()) () ((())()()) (()()) () (()()) (()(())((()))) (()(())((()))) ((())) (((()))) (()(())((()))) ((())()()) ()\") == [4, 2, 1, 3, 2, 1, 2, 4, 4, 3, 4, 4, 3, 1]", "assert parse_nested_parens(\"(()()) (()()) () (()())\") == [2, 2, 1, 2]", "assert parse_nested_parens(\"((())) ((())) (((()))) (()) (()()) (()()) () ((())) ((())()()) () (()(())((()))) (()()) (()(())((()))) ((()))\") == [3, 3, 4, 2, 2, 2, 1, 3, 3, 1, 4, 2, 4, 3]", "assert parse_nested_parens(\"(()()) (()()) () (()) () (()()) (()) (()) (((()))) () (()()) (())\") == [2, 2, 1, 2, 1, 2, 2, 2, 4, 1, 2, 2]", "assert parse_nested_parens('(()(())((())))') == [4]", "assert parse_nested_parens(\"((())) (()) (((()))) () (()()) (((()))) ((())()()) ((())) (()()) ((())()()) (((()))) ((())) (()) ((())) ((())) () ((())) ((())()())\") == [3, 2, 4, 1, 2, 4, 3, 3, 2, 3, 4, 3, 2, 3, 3, 1, 3, 3]", "assert parse_nested_parens(\"(()) ((())()()) (()) ((())) ((())) ((())()()) (((()))) () ((())()()) (()(())((()))) ((())) ((())()()) ((())()()) (())\") == [2, 3, 2, 3, 3, 3, 4, 1, 3, 4, 3, 3, 3, 2]", "assert parse_nested_parens(\"(()()) ((())()()) (()()) ()\") == [2, 3, 2, 1]", "assert parse_nested_parens(\"(()(())((()))) ((())()()) (((()))) (()(())((()))) () (()(())((()))) ()\") == [4, 3, 4, 4, 1, 4, 1]", "assert parse_nested_parens(\"((())) ((())) ((())()()) () ((())) ((())) (()()) ((())()()) (((()))) () (()) (((())))\") == [3, 3, 3, 1, 3, 3, 2, 3, 4, 1, 2, 4]", "assert parse_nested_parens(\"((())) (((()))) ((())) (()()) (()()) ((())()()) (()) (()(())((()))) (()) ((())) (()) ((())) () (((())))\") == [3, 4, 3, 2, 2, 3, 2, 4, 2, 3, 2, 3, 1, 4]", "assert parse_nested_parens(\"((())) ((())) ((())()()) (()()) () (()(())((()))) (()()) (((()))) (((()))) ((())()()) (()()) () () ((())) (((()))) (()(())((()))) (((()))) ((())()()) ((())) (()(())((()))) (())\") == [3, 3, 3, 2, 1, 4, 2, 4, 4, 3, 2, 1, 1, 3, 4, 4, 4, 3, 3, 4, 2]", "assert parse_nested_parens(\"(()) () (((()))) () (((()))) (()()) (()) (((()))) (()(())((()))) (((()))) () (()()) (()(())((()))) (()()) (()(())((()))) (()()) (((()))) (()()) (((()))) (()) (()())\") == [2, 1, 4, 1, 4, 2, 2, 4, 4, 4, 1, 2, 4, 2, 4, 2, 4, 2, 4, 2, 2]"], "nl": " Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    ", "func": "def parse_nested_parens(paren_string: str) -> List[int]:", "examples": ">>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    ", "completions": ["from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    Each of these groups is a sequence of characters that can have nested parentheses.\n    For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Output list to store the deepest level of nesting for each group\n    nesting_levels: List[int] = []\n    # Split the input string into groups of parentheses\n    groups = paren_string.split()\n    # Iterate through each group\n    for group in groups:\n        max_depth = 0\n        depth_counter = 0\n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                depth_counter += 1\n                if depth_counter > max_depth:\n                    max_depth = depth_counter\n            elif char == ')':\n                depth_counter -= 1\n        # Append the maximum depth found in this group to the output list\n        nesting_levels.append(max_depth)\n    return nesting_levels\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Output: List[int] - A list where each element corresponds to the deepest level of nesting for each group in the input string.\n    \n    # Split the input string by spaces to get individual groups\n    groups = paren_string.split()\n    \n    # Initialize a list to store the maximum depths of each group\n    max_depths = []\n    \n    # Iterate through each group\n    for group in groups:\n        # Initialize a counter to track the depth\n        depth_counter = 0\n        # Initialize the maximum depth to 0\n        max_depth = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                # Increase counter when encountering '('\n                depth_counter += 1\n            elif char == ')':\n                # Decrease counter when encountering ')'\n                depth_counter -= 1\n            \n            # Update the maximum depth if the counter exceeds the current maximum\n            max_depth = max(max_depth, depth_counter)\n        \n        # Add the maximum depth to the list\n        max_depths.append(max_depth)\n    \n    # Return the list of maximum depths\n    return max_depths\n", "from typing import List\nimport re\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    if not paren_string:\n        return []\n    \n    # Split the input string by spaces to handle multiple groups of parentheses\n    groups = paren_string.split()\n    depths = []\n    \n    for group in groups:\n        # Use regex to find all nested parentheses\n        matches = re.findall(r'\\([^()]*\\)', group)\n        max_depth = 0\n        \n        # Calculate the maximum depth of nested parentheses\n        while matches:\n            max_depth += 1\n            group = re.sub(r'\\([^()]*\\)', '', group)\n            matches = re.findall(r'\\([^()]*\\)', group)\n        \n        depths.append(max_depth)\n    \n    return depths\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    result = []\n    \n    # Split the input string by spaces to process each group separately\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        depth = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        \n        result.append(max_depth)\n    \n    return result\n", "from typing import List\n## main.py\nimport re\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    \n    # Initialize a list to store the maximum nesting depths\n    max_depths = []\n    \n    # Loop through each group\n    for group in groups:\n        # Initialize the depth counter\n        depth = 0\n        max_depth = 0\n        \n        # Iterate through the group to calculate the maximum depth\n        for char in group:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        \n        # Append the maximum depth to the list\n        max_depths.append(max_depth)\n    \n    return max_depths\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input: paren_string (str) - A string containing multiple groups of nested parentheses separated by spaces.\n    Output: List[int] - A list of integers representing the deepest level of nesting for each group of parentheses.\n    '''\n    result = []\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nimport re\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input: paren_string (str) - A string containing multiple groups of nested parentheses separated by spaces.\n    Output: List[int] - A list of integers representing the deepest level of nesting for each group.\n    '''\n    if not paren_string:\n        return []\n\n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    results = []\n\n    # Regular expression to find all nested parentheses\n    pattern = r'\\([^()]*\\)'\n\n    for group in groups:\n        max_depth = 0\n        depth = 0\n        # Iterate through the group to find the maximum depth of nested parentheses\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        results.append(max_depth)\n\n    return results\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    result = []\n    \n    # Split the input string into groups\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        # Initialize a stack to track levels\n        stack = []\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                stack.append(char)\n            elif char == ')':\n                if stack and stack[-1] == '(':\n                    stack.pop()\n                    current_depth -= 1\n                else:\n                    # Mismatched parentheses, handle as needed\n                    pass\n            \n            # Update the maximum depth\n            max_depth = max(max_depth, current_depth)\n        \n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    '''\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses.\n    '''\n    # Split the input string by spaces to handle multiple groups\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        depth_counter = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                depth_counter += 1\n                if depth_counter > max_depth:\n                    max_depth = depth_counter\n            elif char == ')':\n                depth_counter -= 1\n        \n        # Append the maximum depth to the result list\n        result.append(max_depth)\n    \n    return result\n", "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Parses a string of parentheses and returns a list of the deepest levels of nested parentheses for each group.\n    \n    Args:\n        paren_string (str): A string of parentheses with potential spaces separating groups.\n    \n    Returns:\n        List[int]: A list of integers representing the deepest level of nested parentheses for each group.\n    \"\"\"\n    # Split the input string by spaces to handle multiple groups of parentheses\n    groups = paren_string.split()\n    \n    # Initialize a list to store the depths of each group\n    depths = []\n    \n    # Iterate through each group of parentheses\n    for group in groups:\n        # Initialize a counter for the current depth of nested parentheses\n        current_depth = 0\n        # Initialize a variable to keep track of the maximum depth\n        max_depth = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                # Update the maximum depth if the current depth exceeds it\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        # Append the maximum depth of the current group to the list\n        depths.append(max_depth)\n    \n    return depths\n"], "plans": ["requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the nested parentheses and identifying the maximum depth reached.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately.\n- Ensure the function can handle multiple groups of parentheses.\n- Optimize the function for performance, especially with large inputs.\n- Add support for parsing strings with spaces between groups.\n- Include error handling for malformed input strings.\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `collections` module to keep track of the nesting levels. The function will iterate through each character in the input string, incrementing a counter when encountering an opening parenthesis '(' and decrementing it when encountering a closing parenthesis ')'. The maximum value of this counter during the iteration will represent the deepest level of nesting for that group of parentheses.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the nested parentheses and identifying the maximum depth reached. The function should be able to handle various lengths and complexities of input strings, ensuring accuracy and efficiency.\nrequirement pool:\n- The main code should accurately parse the input string and calculate the deepest level of nesting for each group.\n- The function should be optimized for performance, handling large inputs efficiently.\n- The code should be well-documented and maintainable, suitable for future enhancements.\nTo create an efficient and accurate parser for nested parentheses, we will use Python's built-in capabilities along with a simple algorithm that iterates through the string, tracking the depth of nested parentheses. This approach ensures scalability and handles large inputs efficiently. The algorithm will be optimized for readability and maintainability, making it easy to understand and modify.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves understanding the structure of nested parentheses and counting the levels of nesting accurately. The function should be efficient and capable of handling various lengths and complexities of input strings.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately.\n- Ensure the function can handle large datasets efficiently.\n- Test the function for edge cases and errors.\n- Optimize the function for performance.\n- Enhance the function's robustness to handle more complex inputs.\nTo implement the function `parse_nested_parens` accurately and efficiently, we will use Python's built-in capabilities along with the `re` module for regular expressions. The function will split the input string by spaces to handle multiple groups of parentheses, then use a regular expression to find all occurrences of nested parentheses, and finally, calculate the maximum depth of these nested structures.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the nested parentheses and identifying the maximum depth reached. The function should be able to handle spaces separating different groups and return a list of integers representing the deepest level of nesting for each group.\nrequirement pool:\n- Implement the function to accurately parse and determine nesting levels.\n- Ensure the function can handle multiple groups separated by spaces.\n- Optimize the function for performance to handle large inputs efficiently.\n- Document the function with examples to aid user understanding.\nTo implement the function `parse_nested_parens` efficiently, we will use a stack-based approach. This method is both simple and effective for parsing nested structures like parentheses. The stack will help us keep track of the depth of nested parentheses as we iterate through the string. Each time we encounter an opening parenthesis '(', we will push it onto the stack, and each time we encounter a closing parenthesis ')', we will pop from the stack. The maximum depth reached during this process will give us the deepest level of nesting for each group of parentheses.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves understanding the structure of nested parentheses and counting the levels of nesting accurately. The function should be efficient and handle various lengths and complexities of input strings.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately.\n- Ensure the function is optimized for performance.\n- Develop a user-friendly interface for easy integration.\n- Test the function with various edge cases to ensure robustness.\n- Provide documentation and examples for users.\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `re` module for regular expressions. The function will split the input string by spaces to handle multiple groups of nested parentheses. For each group, we will use a regular expression to find all occurrences of nested parentheses and calculate the maximum depth of these nests. This approach leverages Python's strong string manipulation and regular expression capabilities to achieve both accuracy and efficiency.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves understanding the structure of nested parentheses and counting the levels of nesting accurately. The function should be able to handle various lengths and complexities of input strings efficiently.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately.\n- Ensure the function can handle large inputs efficiently.\n- Add support for various input formats.\n- Optimize the performance for large input strings.\n- Improve the user interface for better usability.\nTo implement the function `parse_nested_parens` efficiently, we will use Python's built-in capabilities along with the `collections` module for handling nested structures. The function will iterate through each character in the input string, keeping track of the current level of nesting using a counter. When encountering an opening parenthesis '(', the counter will increment, and when encountering a closing parenthesis ')', the counter will decrement. The maximum value of this counter at any point in the iteration will represent the deepest level of nesting for that group of parentheses.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses, separated by spaces. Each group needs to be analyzed to determine the deepest level of nesting. The output should be a list of integers, where each integer corresponds to the deepest level of nesting for each group in the input string.\nrequirement pool:\n- Implement a function to parse nested parentheses correctly.\n- Handle multiple groups of parentheses separated by spaces.\n- Ensure the function can handle complex nested structures.\n- Optimize the function for performance, especially for large input strings.\n- Produce a list of integers representing the deepest level of nesting for each group.\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `re` module for regular expressions. The function will split the input string by spaces to handle multiple groups, then use a regular expression to find all occurrences of nested parentheses. We will count the depth of each match to determine the deepest level of nesting for each group.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the nested parentheses and identifying the maximum depth reached. The function should be able to handle various lengths and complexities of input strings, ensuring it can scale with larger data sets.\nrequirement pool:\n- Implement a function to parse nested parentheses and determine their depth.\n- Ensure the function can handle multiple groups of parentheses separated by spaces.\n- Optimize the function for performance to handle large inputs efficiently.\n- Include error handling for malformed input strings.\n- Provide clear documentation and examples of how to use the function.\nTo implement the function `parse_nested_parens`, we will use a combination of Python's built-in string manipulation methods and a simple stack-based approach to efficiently determine the deepest level of nesting for each group of parentheses in the input string. The stack will help us keep track of the parentheses levels, allowing us to easily determine the maximum depth reached at any point in the string.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the nested parentheses and identifying the maximum depth reached. The function should be able to handle spaces separating different groups and return a list of integers representing the deepest level of nesting for each group.\nrequirement pool:\n- The main code should accurately parse the input string and compute the nesting levels.\n- The function should be able to handle various lengths and complexities of input strings.\n- Implement optimizations to ensure the function runs efficiently even on large inputs.\n- Include error handling to manage unexpected input formats gracefully.\nTo implement the function `parse_nested_parens`, we will use a straightforward approach that involves iterating through the input string and counting the nested parentheses. We will split the input string by spaces to handle multiple groups of parentheses. For each group, we will use a counter to track the depth of nested parentheses and determine the maximum depth reached.\n", "requirement analysis:\nThe requirement is to parse a string containing multiple groups of nested parentheses and determine the deepest level of nesting for each group. This involves counting the nested parentheses and identifying the maximum depth reached.\nrequirement pool:\n- Implement a function to parse nested parentheses accurately.\n- Ensure the function can handle multiple groups of parentheses.\n- Optimize the function for performance, especially for large inputs.\n- Add error handling for malformed input strings.\n- Provide clear documentation and examples for user guidance.\nTo implement the function `parse_nested_parens` efficiently and accurately, we will use Python's built-in capabilities along with the `collections` module to keep track of the nesting levels. The function will split the input string by spaces to handle multiple groups of parentheses, then iterate through each character to count the depth of nested parentheses, and finally return a list of the deepest levels for each group.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [99, 99, 99, 99, 99, 99, 99, 99, 99, 99], "completion": "from typing import List\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Parses a string of parentheses and returns a list of the deepest levels of nested parentheses for each group.\n    \n    Args:\n        paren_string (str): A string of parentheses with potential spaces separating groups.\n    \n    Returns:\n        List[int]: A list of integers representing the deepest level of nested parentheses for each group.\n    \"\"\"\n    # Split the input string by spaces to handle multiple groups of parentheses\n    groups = paren_string.split()\n    \n    # Initialize a list to store the depths of each group\n    depths = []\n    \n    # Iterate through each group of parentheses\n    for group in groups:\n        # Initialize a counter for the current depth of nested parentheses\n        current_depth = 0\n        # Initialize a variable to keep track of the maximum depth\n        max_depth = 0\n        \n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                # Update the maximum depth if the current depth exceeds it\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        # Append the maximum depth of the current group to the list\n        depths.append(max_depth)\n    \n    return depths\n", "passed": true, "pass": true, "pass_num": 10, "round": 451, "repair_prompt": ["def parse_nested_parens(paren_string: str) -> List[int]:\t\n'''Input to this function is a string represented multiple groups for nested parentheses separated by spaces. Each of these groups is a sequence of characters that can have nested parentheses. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    '''"], "mutate_method": "expand_one2two", "parent_index": 278}
