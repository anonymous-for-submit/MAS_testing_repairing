{"task_id": "HumanEval/93", "prompt": "def encode(message):\t\n'''Write a function that takes a message, and encodes in such a way that it swaps case of all letters, substitutes all vowels in the message with the character that is located 2 positions forward from that vowel in the English alphabet. Assume only letters.\nExamples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    '''", "entry_point": "encode", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": ["def check(encode):\n\tassert encode(\"ZUvOnpFUjJGGWcJQYQmTY W\") == 'zwVqNPfwJjggwCjqyqMty w'", "def check(encode):\n\tassert encode(\"SgPXbDsCxLlYIAFFhhIbRfXHjaZ\") == 'sGpxBdScXlLykcffHHkBrFxhJCz'", "def check(encode):\n\tassert encode(\"TEPUFH\") == 'tgpwfh'", "def check(encode):\n\tassert encode(\"FKRTJOGJR\") == 'fkrtjqgjr'", "def check(encode):\n\tassert encode(\"GWHK\") == 'gwhk'", "def check(encode):\n\tassert encode(\"ElaZse dYXHgdVq\") == 'gLCzSG DyxhGDvQ'", "def check(encode):\n\tassert encode(\"SETPXKRTE\") == 'sgtpxkrtg'", "def check(encode):\n\tassert encode(\"JRG\") == 'jrg'", "def check(encode):\n\tassert encode(\"XQAXbNmLpmobUzQtNvacz\") == 'xqcxBnMlPMQBwZqTnVCCZ'", "def check(encode):\n\tassert encode(\"FPENQAZGK\") == 'fpgnqczgk'", "def check(encode):\n\tassert encode(\"TEIPDCVYN\") == 'tgkpdcvyn'", "def check(encode):\n\tassert encode(\"gIVppcmTSMtmvhg ZjTdBs\") == 'GkvPPCMtsmTMVHG zJtDbS'", "def check(encode):\n\tassert encode(\"nds\") == 'NDS'", "def check(encode):\n\tassert encode(\"CVLBOWSP\") == 'cvlbqwsp'", "def check(encode):\n\tassert encode(\"BRVLN\") == 'brvln'", "def check(encode):\n\tassert encode(\"hnbzSknod dSFfSG\") == 'HNBZsKNQD DsfFsg'", "def check(encode):\n\tassert encode(\"BnHJZme\") == 'bNhjzMG'", "def check(encode):\n\tassert encode(\"zTBpeQNFrEsJ\") == 'ZtbPGqnfRgSj'", "def check(encode):\n\tassert encode(\"IstxgcEpahvkDruGyiK\") == 'kSTXGCgPCHVKdRWgYKk'", "def check(encode):\n\tassert encode(\"HzEMwPWyLehG jFTacHALOraUoB\") == 'hZgmWpwYlGHg JftCChclqRCwQb'", "def check(encode):\n\tassert encode(\" BuOTEofYkQJauJaclURS\") == ' bWqtgQFyKqjCWjCCLwrs'", "def check(encode):\n\tassert encode(\"FHEcvmCWtbF aJg\") == 'fhgCVMcwTBf CjG'", "def check(encode):\n\tassert encode(\"RHO\") == 'rhq'", "def check(encode):\n\tassert encode(\"OJMQGVupooekW\") == 'qjmqgvWPQQGKw'", "def check(encode):\n\tassert encode(\"DARS\") == 'dcrs'", "def check(encode):\n\tassert encode(\"ZTTSSFEL\") == 'zttssfgl'", "def check(encode):\n\tassert encode(\"kkAuzPMaJbY\") == 'KKcWZpmCjBy'", "def check(encode):\n\tassert encode(\"kwfcMJBvOIscxpuRJYMQxX\") == 'KWFCmjbVqkSCXPWrjymqXx'", "def check(encode):\n\tassert encode(\"pUgmIEYWAnzEuqFElVbVs\") == 'PwGMkgywcNZgWQfgLvBvS'", "def check(encode):\n\tassert encode(\"kzLQOefkAweHvGBycjn\") == 'KZlqqGFKcWGhVgbYCJN'", "def check(encode):\n\tassert encode(\"CLY\") == 'cly'", "def check(encode):\n\tassert encode(\"GUAU\") == 'gwcw'", "def check(encode):\n\tassert encode(\"YcxmhivPyJIw\") == 'yCXMHKVpYjkW'", "def check(encode):\n\tassert encode('TEST') == 'tgst'", "def check(encode):\n\tassert encode(\"oSYVfHWo kWWvnziVt\") == 'QsyvFhwQ KwwVNZKvT'", "def check(encode):\n\tassert encode(\"TXAFFIW\") == 'txcffkw'", "def check(encode):\n\tassert encode(\"EORCSH\") == 'gqrcsh'", "def check(encode):\n\tassert encode(\"ETMDXUEBC\") == 'gtmdxwgbc'", "def check(encode):\n\tassert encode(\"TQRZQWU\") == 'tqrzqww'", "def check(encode):\n\tassert encode(\"DPGWLEVT\") == 'dpgwlgvt'", "def check(encode):\n\tassert encode(\"PRREkliEYbvcKGoNqvSfsJ\") == 'prrgKLKgyBVCkgQnQVsFSj'", "def check(encode):\n\tassert encode(\"WWBsZMYcpjfNzyCeVVgesJoJhjy\") == 'wwbSzmyCPJFnZYcGvvGGSjQjHJY'", "def check(encode):\n\tassert encode(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg'", "def check(encode):\n\tassert encode(\"gnJhAIkj\") == 'GNjHckKJ'", "def check(encode):\n\tassert encode(\"OHUJlX\") == 'qhwjLx'", "def check(encode):\n\tassert encode(\"EoisHGBfMOUHhIftINGIdF DJqugm\") == 'gQKShgbFmqwhHkFTkngkDf djQWGM'", "def check(encode):\n\tassert encode(\"JJWNGDOT\") == 'jjwngdqt'", "def check(encode):\n\tassert encode(\"DXZBFN\") == 'dxzbfn'", "def check(encode):\n\tassert encode(\"DVKfMTlbOESs\") == 'dvkFmtLBqgsS'", "def check(encode):\n\tassert encode(\"UEeG\") == 'wgGg'", "def check(encode):\n\tassert encode(\"BCKPNMVO\") == 'bckpnmvq'", "def check(encode):\n\tassert encode(\"IMIJTK\") == 'kmkjtk'", "def check(encode):\n\tassert encode(\"ZyWrbakVZJKkkAmmKNRmUPDCi\") == 'zYwRBCKvzjkKKcMMknrMwpdcK'", "def check(encode):\n\tassert encode(\"URMC\") == 'wrmc'", "def check(encode):\n\tassert encode(\"CNJ\") == 'cnj'", "def check(encode):\n\tassert encode(\"grukYfBTTJtVX\") == 'GRWKyFbttjTvx'", "def check(encode):\n\tassert encode(\"FDMjHnZkEhmsNmlJNItsJQlasO\") == 'fdmJhNzKgHMSnMLjnkTSjqLCSq'", "def check(encode):\n\tassert encode(\"rRrZwWEjxTIMMSNiS\") == 'RrRzWwgJXtkmmsnKs'", "def check(encode):\n\tassert encode(\"LHfTwSNWVA\") == 'lhFtWsnwvc'", "def check(encode):\n\tassert encode(\"QwJoXypNyPZVVwtdhDxHhBKXS\") == 'qWjQxYPnYpzvvWTDHdXhHbkxs'", "def check(encode):\n\tassert encode(\"cJbiuaENQvBuUexfhUuJRbvP\") == 'CjBKWCgnqVbWwGXFHwWjrBVp'", "def check(encode):\n\tassert encode(\"Sjf\") == 'sJF'", "def check(encode):\n\tassert encode(\"DZAXVXQ\") == 'dzcxvxq'", "def check(encode):\n\tassert encode(\"HNDsWbIhInLlAGVoRFZw\") == 'hndSwBkHkNlLcgvQrfzW'", "def check(encode):\n\tassert encode(\"YaFsT\") == 'yCfSt'", "def check(encode):\n\tassert encode(\"WNYEUHDUE\") == 'wnygwhdwg'", "def check(encode):\n\tassert encode(\"ROWVCETC\") == 'rqwvcgtc'", "def check(encode):\n\tassert encode(\"Hmj\") == 'hMJ'", "def check(encode):\n\tassert encode(\"ApBJTja\") == 'cPbjtJC'", "def check(encode):\n\tassert encode(\"NNoTLfuGwSHDJdTlRXSyC\") == 'nnQtlFWgWshdjDtLrxsYc'", "def check(encode):\n\tassert encode(\"pvQeerpuzVbW\") == 'PVqGGRPWZvBw'", "def check(encode):\n\tassert encode(\"LCLBDYXRN\") == 'lclbdyxrn'", "def check(encode):\n\tassert encode(\"RcQZkLoILujJnUJ BK lQgY\") == 'rCqzKlQklWJjNwj bk LqGy'", "def check(encode):\n\tassert encode(\"IzXkNbTRYEDDLFF\") == 'kZxKnBtrygddlff'", "def check(encode):\n\tassert encode(\"bBSM\") == 'Bbsm'", "def check(encode):\n\tassert encode(\"rhgAVJOAnVugEnMSSKWsc\") == 'RHGcvjqcNvWGgNmsskwSC'", "def check(encode):\n\tassert encode(\"KTBXLNF\") == 'ktbxlnf'", "def check(encode):\n\tassert encode(\"gEQTanRJKhLxXlJDZQHPwvbnq\") == 'GgqtCNrjkHlXxLjdzqhpWVBNQ'", "def check(encode):\n\tassert encode(\"EjhSPNSJMPQ\") == 'gJHspnsjmpq'", "def check(encode):\n\tassert encode(\"TLU\") == 'tlw'", "def check(encode):\n\tassert encode(\"rjXQvzxCjzaWcAuNeOiaXPpdYVoxCt\") == 'RJxqVZXcJZCwCcWnGqKCxpPDyvQXcT'", "def check(encode):\n\tassert encode(\"ZVS\") == 'zvs'", "def check(encode):\n\tassert encode(\"BODPGNO\") == 'bqdpgnq'", "def check(encode):\n\tassert encode('This is a message') == 'tHKS KS C MGSSCGG'", "def check(encode):\n\tassert encode(\"jZheceVgKgTLjRwOLeRrrtwbE\") == 'JzHGCGvGkGtlJrWqlGrRRTWBg'", "def check(encode):\n\tassert encode(\"AZOCBJD\") == 'czqcbjd'", "def check(encode):\n\tassert encode(\"HrRcDpPaxYYXID\") == 'hRrCdPpCXyyxkd'", "def check(encode):\n\tassert encode(\"DNHIUUVX\") == 'dnhkwwvx'", "def check(encode):\n\tassert encode(\"TEGPKXNB\") == 'tggpkxnb'", "def check(encode):\n\tassert encode(\"OBEcrSHMuaCS\") == 'qbgCRshmWCcs'", "def check(encode):\n\tassert encode(\"jAqqTMHiqs\") == 'JcQQtmhKQS'", "def check(encode):\n\tassert encode(\"IYS\") == 'kys'", "def check(encode):\n\tassert encode(\"HKWXPGN\") == 'hkwxpgn'", "def check(encode):\n\tassert encode(\"aZPgQ vnmhPPOLdLIutuJO\") == 'CzpGq VNMHppqlDlkWTWjq'", "def check(encode):\n\tassert encode(\"fZoHFcbTcLTUWG VdZ\") == 'FzQhfCBtCltwwg vDz'", "def check(encode):\n\tassert encode(\"SSMAQL\") == 'ssmcql'", "def check(encode):\n\tassert encode(\"ITNaCJiUmgbbsXbJggeE\") == 'ktnCcjKwMGBBSxBjGGGg'", "def check(encode):\n\tassert encode(\"PKKLGPQOY\") == 'pkklgpqqy'", "def check(encode):\n\tassert encode(\"XgnELkHHAAUiCCpSfJ\") == 'xGNglKhhccwKccPsFj'", "def check(encode):\n\tassert encode(\"jjHqlFViqHz\") == 'JJhQLfvKQhZ'", "def check(encode):\n\tassert encode('Mudasir') == 'mWDCSKR'", "def check(encode):\n\tassert encode(\"OpzdoaiWPrtwH\") == 'qPZDQCKwpRTWh'", "def check(encode):\n\tassert encode(\" dNVahxVjKzB JTneIFjKfXsk \") == ' DnvCHXvJkZb jtNGkfJkFxSK '", "def check(encode):\n\tassert encode(\"c XkUXkBchEddL\") == 'C xKwxKbCHgDDl'", "def check(encode):\n\tassert encode(\"PSBSBey\") == 'psbsbGY'", "def check(encode):\n\tassert encode(\"mejsPoZxTWVZINkltbTC\") == 'MGJSpQzXtwvzknKLTBtc'", "def check(encode):\n\tassert encode(\"RkeGn HyKwTJKYqIJSWnu\") == 'rKGgN hYkWtjkyQkjswNW'", "def check(encode):\n\tassert encode(\"JMFDUNNFN\") == 'jmfdwnnfn'", "def check(encode):\n\tassert encode(\"DWUOPpLjiGck\") == 'dwwqpPlJKgCK'", "def check(encode):\n\tassert encode(\"KtvgHCwhJPHhZoPrTShCCFjb\") == 'kTVGhcWHjphHzQpRtsHccfJB'", "def check(encode):\n\tassert encode(\"BGPB\") == 'bgpb'", "def check(encode):\n\tassert encode(\"FVABgUJcvAO\") == 'fvcbGwjCVcq'", "def check(encode):\n\tassert encode(\"LPVHOUZC\") == 'lpvhqwzc'", "def check(encode):\n\tassert encode(\"vFk rhQEfvOP ZgydPEhvIVWD\") == 'VfK RHqgFVqp zGYDpgHVkvwd'", "def check(encode):\n\tassert encode(\"QRX\") == 'qrx'", "def check(encode):\n\tassert encode(\"DXV\") == 'dxv'", "def check(encode):\n\tassert encode(\"qmjcLnfY lObRZrX\") == 'QMJClNFy LqBrzRx'", "def check(encode):\n\tassert encode('YES') == 'ygs'", "def check(encode):\n\tassert encode(\"lljsyoqvdrgHLkvty\") == 'LLJSYQQVDRGhlKVTY'", "def check(encode):\n\tassert encode(\"OSWDQFIR\") == 'qswdqfkr'", "def check(encode):\n\tassert encode(\"ZfDqK\") == 'zFdQk'", "def check(encode):\n\tassert encode(\"BYRAIVE\") == 'byrckvg'", "def check(encode):\n\tassert encode(\"AGMBICYE\") == 'cgmbkcyg'", "def check(encode):\n\tassert encode(\"kqmseH\") == 'KQMSGh'", "def check(encode):\n\tassert encode(\"WYLLSZM\") == 'wyllszm'", "def check(encode):\n\tassert encode(\"hgxUMf\") == 'HGXwmF'", "def check(encode):\n\tassert encode(\"xOzJhrPNcVCLkJeMgwsBcYm\") == 'XqZjHRpnCvclKjGmGWSbCyM'", "def check(encode):\n\tassert encode(\"rKELArbzBNVyXuUr\") == 'RkglcRBZbnvYxWwR'", "def check(encode):\n\tassert encode(\"WNRIIJWGO\") == 'wnrkkjwgq'", "def check(encode):\n\tassert encode(\"UNVEY\") == 'wnvgy'"], "test_case_list": ["assert encode(\"ZUvOnpFUjJGGWcJQYQmTY W\") == 'zwVqNPfwJjggwCjqyqMty w'", "assert encode(\"SgPXbDsCxLlYIAFFhhIbRfXHjaZ\") == 'sGpxBdScXlLykcffHHkBrFxhJCz'", "assert encode(\"TEPUFH\") == 'tgpwfh'", "assert encode(\"FKRTJOGJR\") == 'fkrtjqgjr'", "assert encode(\"GWHK\") == 'gwhk'", "assert encode(\"ElaZse dYXHgdVq\") == 'gLCzSG DyxhGDvQ'", "assert encode(\"SETPXKRTE\") == 'sgtpxkrtg'", "assert encode(\"JRG\") == 'jrg'", "assert encode(\"XQAXbNmLpmobUzQtNvacz\") == 'xqcxBnMlPMQBwZqTnVCCZ'", "assert encode(\"FPENQAZGK\") == 'fpgnqczgk'", "assert encode(\"TEIPDCVYN\") == 'tgkpdcvyn'", "assert encode(\"gIVppcmTSMtmvhg ZjTdBs\") == 'GkvPPCMtsmTMVHG zJtDbS'", "assert encode(\"nds\") == 'NDS'", "assert encode(\"CVLBOWSP\") == 'cvlbqwsp'", "assert encode(\"BRVLN\") == 'brvln'", "assert encode(\"hnbzSknod dSFfSG\") == 'HNBZsKNQD DsfFsg'", "assert encode(\"BnHJZme\") == 'bNhjzMG'", "assert encode(\"zTBpeQNFrEsJ\") == 'ZtbPGqnfRgSj'", "assert encode(\"IstxgcEpahvkDruGyiK\") == 'kSTXGCgPCHVKdRWgYKk'", "assert encode(\"HzEMwPWyLehG jFTacHALOraUoB\") == 'hZgmWpwYlGHg JftCChclqRCwQb'", "assert encode(\" BuOTEofYkQJauJaclURS\") == ' bWqtgQFyKqjCWjCCLwrs'", "assert encode(\"FHEcvmCWtbF aJg\") == 'fhgCVMcwTBf CjG'", "assert encode(\"RHO\") == 'rhq'", "assert encode(\"OJMQGVupooekW\") == 'qjmqgvWPQQGKw'", "assert encode(\"DARS\") == 'dcrs'", "assert encode(\"ZTTSSFEL\") == 'zttssfgl'", "assert encode(\"kkAuzPMaJbY\") == 'KKcWZpmCjBy'", "assert encode(\"kwfcMJBvOIscxpuRJYMQxX\") == 'KWFCmjbVqkSCXPWrjymqXx'", "assert encode(\"pUgmIEYWAnzEuqFElVbVs\") == 'PwGMkgywcNZgWQfgLvBvS'", "assert encode(\"kzLQOefkAweHvGBycjn\") == 'KZlqqGFKcWGhVgbYCJN'", "assert encode(\"CLY\") == 'cly'", "assert encode(\"GUAU\") == 'gwcw'", "assert encode(\"YcxmhivPyJIw\") == 'yCXMHKVpYjkW'", "assert encode('TEST') == 'tgst'", "assert encode(\"oSYVfHWo kWWvnziVt\") == 'QsyvFhwQ KwwVNZKvT'", "assert encode(\"TXAFFIW\") == 'txcffkw'", "assert encode(\"EORCSH\") == 'gqrcsh'", "assert encode(\"ETMDXUEBC\") == 'gtmdxwgbc'", "assert encode(\"TQRZQWU\") == 'tqrzqww'", "assert encode(\"DPGWLEVT\") == 'dpgwlgvt'", "assert encode(\"PRREkliEYbvcKGoNqvSfsJ\") == 'prrgKLKgyBVCkgQnQVsFSj'", "assert encode(\"WWBsZMYcpjfNzyCeVVgesJoJhjy\") == 'wwbSzmyCPJFnZYcGvvGGSjQjHJY'", "assert encode(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg'", "assert encode(\"gnJhAIkj\") == 'GNjHckKJ'", "assert encode(\"OHUJlX\") == 'qhwjLx'", "assert encode(\"EoisHGBfMOUHhIftINGIdF DJqugm\") == 'gQKShgbFmqwhHkFTkngkDf djQWGM'", "assert encode(\"JJWNGDOT\") == 'jjwngdqt'", "assert encode(\"DXZBFN\") == 'dxzbfn'", "assert encode(\"DVKfMTlbOESs\") == 'dvkFmtLBqgsS'", "assert encode(\"UEeG\") == 'wgGg'", "assert encode(\"BCKPNMVO\") == 'bckpnmvq'", "assert encode(\"IMIJTK\") == 'kmkjtk'", "assert encode(\"ZyWrbakVZJKkkAmmKNRmUPDCi\") == 'zYwRBCKvzjkKKcMMknrMwpdcK'", "assert encode(\"URMC\") == 'wrmc'", "assert encode(\"CNJ\") == 'cnj'", "assert encode(\"grukYfBTTJtVX\") == 'GRWKyFbttjTvx'", "assert encode(\"FDMjHnZkEhmsNmlJNItsJQlasO\") == 'fdmJhNzKgHMSnMLjnkTSjqLCSq'", "assert encode(\"rRrZwWEjxTIMMSNiS\") == 'RrRzWwgJXtkmmsnKs'", "assert encode(\"LHfTwSNWVA\") == 'lhFtWsnwvc'", "assert encode(\"QwJoXypNyPZVVwtdhDxHhBKXS\") == 'qWjQxYPnYpzvvWTDHdXhHbkxs'", "assert encode(\"cJbiuaENQvBuUexfhUuJRbvP\") == 'CjBKWCgnqVbWwGXFHwWjrBVp'", "assert encode(\"Sjf\") == 'sJF'", "assert encode(\"DZAXVXQ\") == 'dzcxvxq'", "assert encode(\"HNDsWbIhInLlAGVoRFZw\") == 'hndSwBkHkNlLcgvQrfzW'", "assert encode(\"YaFsT\") == 'yCfSt'", "assert encode(\"WNYEUHDUE\") == 'wnygwhdwg'", "assert encode(\"ROWVCETC\") == 'rqwvcgtc'", "assert encode(\"Hmj\") == 'hMJ'", "assert encode(\"ApBJTja\") == 'cPbjtJC'", "assert encode(\"NNoTLfuGwSHDJdTlRXSyC\") == 'nnQtlFWgWshdjDtLrxsYc'", "assert encode(\"pvQeerpuzVbW\") == 'PVqGGRPWZvBw'", "assert encode(\"LCLBDYXRN\") == 'lclbdyxrn'", "assert encode(\"RcQZkLoILujJnUJ BK lQgY\") == 'rCqzKlQklWJjNwj bk LqGy'", "assert encode(\"IzXkNbTRYEDDLFF\") == 'kZxKnBtrygddlff'", "assert encode(\"bBSM\") == 'Bbsm'", "assert encode(\"rhgAVJOAnVugEnMSSKWsc\") == 'RHGcvjqcNvWGgNmsskwSC'", "assert encode(\"KTBXLNF\") == 'ktbxlnf'", "assert encode(\"gEQTanRJKhLxXlJDZQHPwvbnq\") == 'GgqtCNrjkHlXxLjdzqhpWVBNQ'", "assert encode(\"EjhSPNSJMPQ\") == 'gJHspnsjmpq'", "assert encode(\"TLU\") == 'tlw'", "assert encode(\"rjXQvzxCjzaWcAuNeOiaXPpdYVoxCt\") == 'RJxqVZXcJZCwCcWnGqKCxpPDyvQXcT'", "assert encode(\"ZVS\") == 'zvs'", "assert encode(\"BODPGNO\") == 'bqdpgnq'", "assert encode('This is a message') == 'tHKS KS C MGSSCGG'", "assert encode(\"jZheceVgKgTLjRwOLeRrrtwbE\") == 'JzHGCGvGkGtlJrWqlGrRRTWBg'", "assert encode(\"AZOCBJD\") == 'czqcbjd'", "assert encode(\"HrRcDpPaxYYXID\") == 'hRrCdPpCXyyxkd'", "assert encode(\"DNHIUUVX\") == 'dnhkwwvx'", "assert encode(\"TEGPKXNB\") == 'tggpkxnb'", "assert encode(\"OBEcrSHMuaCS\") == 'qbgCRshmWCcs'", "assert encode(\"jAqqTMHiqs\") == 'JcQQtmhKQS'", "assert encode(\"IYS\") == 'kys'", "assert encode(\"HKWXPGN\") == 'hkwxpgn'", "assert encode(\"aZPgQ vnmhPPOLdLIutuJO\") == 'CzpGq VNMHppqlDlkWTWjq'", "assert encode(\"fZoHFcbTcLTUWG VdZ\") == 'FzQhfCBtCltwwg vDz'", "assert encode(\"SSMAQL\") == 'ssmcql'", "assert encode(\"ITNaCJiUmgbbsXbJggeE\") == 'ktnCcjKwMGBBSxBjGGGg'", "assert encode(\"PKKLGPQOY\") == 'pkklgpqqy'", "assert encode(\"XgnELkHHAAUiCCpSfJ\") == 'xGNglKhhccwKccPsFj'", "assert encode(\"jjHqlFViqHz\") == 'JJhQLfvKQhZ'", "assert encode('Mudasir') == 'mWDCSKR'", "assert encode(\"OpzdoaiWPrtwH\") == 'qPZDQCKwpRTWh'", "assert encode(\" dNVahxVjKzB JTneIFjKfXsk \") == ' DnvCHXvJkZb jtNGkfJkFxSK '", "assert encode(\"c XkUXkBchEddL\") == 'C xKwxKbCHgDDl'", "assert encode(\"PSBSBey\") == 'psbsbGY'", "assert encode(\"mejsPoZxTWVZINkltbTC\") == 'MGJSpQzXtwvzknKLTBtc'", "assert encode(\"RkeGn HyKwTJKYqIJSWnu\") == 'rKGgN hYkWtjkyQkjswNW'", "assert encode(\"JMFDUNNFN\") == 'jmfdwnnfn'", "assert encode(\"DWUOPpLjiGck\") == 'dwwqpPlJKgCK'", "assert encode(\"KtvgHCwhJPHhZoPrTShCCFjb\") == 'kTVGhcWHjphHzQpRtsHccfJB'", "assert encode(\"BGPB\") == 'bgpb'", "assert encode(\"FVABgUJcvAO\") == 'fvcbGwjCVcq'", "assert encode(\"LPVHOUZC\") == 'lpvhqwzc'", "assert encode(\"vFk rhQEfvOP ZgydPEhvIVWD\") == 'VfK RHqgFVqp zGYDpgHVkvwd'", "assert encode(\"QRX\") == 'qrx'", "assert encode(\"DXV\") == 'dxv'", "assert encode(\"qmjcLnfY lObRZrX\") == 'QMJClNFy LqBrzRx'", "assert encode('YES') == 'ygs'", "assert encode(\"lljsyoqvdrgHLkvty\") == 'LLJSYQQVDRGhlKVTY'", "assert encode(\"OSWDQFIR\") == 'qswdqfkr'", "assert encode(\"ZfDqK\") == 'zFdQk'", "assert encode(\"BYRAIVE\") == 'byrckvg'", "assert encode(\"AGMBICYE\") == 'cgmbkcyg'", "assert encode(\"kqmseH\") == 'KQMSGh'", "assert encode(\"WYLLSZM\") == 'wyllszm'", "assert encode(\"hgxUMf\") == 'HGXwmF'", "assert encode(\"xOzJhrPNcVCLkJeMgwsBcYm\") == 'XqZjHRpnCvclKjGmGWSbCyM'", "assert encode(\"rKELArbzBNVyXuUr\") == 'RkglcRBZbnvYxWwR'", "assert encode(\"WNRIIJWGO\") == 'wnrkkjwgq'", "assert encode(\"UNVEY\") == 'wnvgy'"], "nl": "\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    ", "func": "def encode(message):", "examples": "Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    ", "completions": ["from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    def is_vowel(char: str) -> bool:\n        \"\"\"\n        Checks if a character is a vowel.\n        \n        Args:\n            char (str): The character to check.\n            \n        Returns:\n            bool: True if the character is a vowel, False otherwise.\n        \"\"\"\n        vowels = \"aeiouAEIOU\"\n        return char in vowels\n\n    def swap_case(char: str) -> str:\n        \"\"\"\n        Swaps the case of a character.\n        \n        Args:\n            char (str): The character to swap the case of.\n            \n        Returns:\n            str: The character with swapped case.\n        \"\"\"\n        return char.lower() if char.isupper() else char.upper()\n\n    def shift_vowel(char: str) -> str:\n        \"\"\"\n        Substitutes a vowel with the character two positions forward in the alphabet.\n        \n        Args:\n            char (str): The vowel to substitute.\n            \n        Returns:\n            str: The substituted character.\n        \"\"\"\n        vowels = \"aeiou\"\n        if char in vowels:\n            index = vowels.index(char)\n            new_index = (index + 2) % len(vowels)\n            return vowels[new_index]\n        return char\n\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():\n            char = swap_case(char)\n            if is_vowel(char):\n                char = shift_vowel(char)\n        encoded_message += char\n    return encoded_message\n", "from typing import List\n## main.py\n\nimport string\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting vowels with the character that is two positions forward in the alphabet.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    def swap_case(char: str) -> str:\n        \"\"\"\n        Swaps the case of a character.\n        \n        Args:\n            char (str): The character to swap the case.\n            \n        Returns:\n            str: The character with swapped case.\n        \"\"\"\n        return char.lower() if char.isupper() else char.upper()\n\n    def shift_vowel(char: str) -> str:\n        \"\"\"\n        Substitutes a vowel with the character that is two positions forward in the alphabet.\n        \n        Args:\n            char (str): The vowel to be substituted.\n            \n        Returns:\n            str: The substituted character.\n        \"\"\"\n        vowels = \"aeiou\"\n        if char == 'a':\n            return 'c'\n        elif char == 'e':\n            return 'g'\n        elif char == 'i':\n            return 'k'\n        elif char == 'o':\n            return 'q'\n        elif char == 'u':\n            return 'w'\n        else:\n            return char\n\n    result = []\n    for char in message:\n        if char.isalpha():\n            result.append(swap_case(char))\n        elif char.lower() in \"aeiou\":\n            result.append(shift_vowel(char))\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n", "from typing import List\n## main.py\n\nimport string\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting all vowels with the character that is located 2 positions forward in the English alphabet.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the vowel substitution dictionary\n    vowels = 'aeiouAEIOU'\n    shifted_vowels = 'cgkqwCGKQW'\n    vowel_substitution = dict(zip(vowels, shifted_vowels))\n    \n    # Function to swap the case of a character\n    def swap_case(char: str) -> str:\n        if char.islower():\n            return char.upper()\n        else:\n            return char.lower()\n    \n    # Iterate through the message to swap cases and substitute vowels\n    encoded_message = \"\"\n    for char in message:\n        if char in vowels:\n            encoded_message += vowel_substitution[char]\n        elif char.isalpha():\n            encoded_message += swap_case(char)\n        else:\n            encoded_message += char\n    \n    return encoded_message\n\n# Example usage\nif __name__ == \"__main__\":\n    message = \"Hello World!\"\n    encoded_message = encode(message)\n    print(f\"Original message: {message}\")\n    print(f\"Encoded message: {encoded_message}\")\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes the input message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowels substitution\n    vowel_substitution_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    \n    # Initialize the encoded message\n    encoded_message = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():\n            # Swap the case of the character\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n            \n            # Substitute the character if it is a vowel\n            if new_char.lower() in vowel_substitution_map:\n                new_char = vowel_substitution_map[new_char.lower()]\n        else:\n            new_char = char\n        \n        # Append the new character to the encoded message\n        encoded_message.append(new_char)\n    \n    # Join the list of characters into a single string and return it\n    return ''.join(encoded_message)\n", "from typing import List\n## main.py\nimport string\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the substitution dictionary for vowels\n    vowel_substitution = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    \n    # Initialize the encoded message\n    encoded_message = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():\n            # Swap the case of the letter\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n            \n            # Substitute the vowel if applicable\n            if new_char.lower() in vowel_substitution:\n                new_char = vowel_substitution[new_char.lower()]\n        else:\n            new_char = char\n        \n        # Append the new character to the encoded message\n        encoded_message.append(new_char)\n    \n    # Join the list of characters into a single string and return\n    return ''.join(encoded_message)\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a given message by swapping the case of each character and substituting vowels.\n    \n    Args:\n        message (str): The input message to be encoded.\n        \n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowels and their substitutions\n    vowel_mapping = {\n        'a': 'A', 'e': 'E', 'i': 'I', 'o': 'O', 'u': 'U',\n        'A': 'a', 'E': 'e', 'I': 'i', 'O': 'o', 'U': 'u'\n    }\n    \n    # Initialize the encoded message\n    encoded_message = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            if char in vowel_mapping:\n                # Substitute the vowel according to the mapping\n                encoded_message.append(vowel_mapping[char])\n            else:\n                # Swap the case of the character\n                if char.islower():\n                    encoded_message.append(char.upper())\n                else:\n                    encoded_message.append(char.lower())\n        else:\n            # If not a letter, keep the character as is\n            encoded_message.append(char)\n    \n    # Join the list of characters into a single string\n    return ''.join(encoded_message)\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a given message by swapping the case of each letter, then substituting vowels according to a predefined mapping.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    def swap_case(char: str) -> str:\n        \"\"\"\n        Swaps the case of a given character.\n\n        Args:\n            char (str): The character to be swapped.\n\n        Returns:\n            str: The character with swapped case.\n        \"\"\"\n        return char.lower() if char.isupper() else char.upper()\n\n    def substitute_vowels(char: str) -> str:\n        \"\"\"\n        Substitutes vowels in the character according to a predefined mapping.\n\n        Args:\n            char (str): The character to be substituted.\n\n        Returns:\n            str: The substituted character.\n        \"\"\"\n        vowel_mapping = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a'}\n        return vowel_mapping.get(char, char)\n\n    # Initialize the encoded message\n    encoded_message = \"\"\n\n    # Iterate over each character in the message\n    for char in message:\n        # Swap the case of the character\n        swapped_char = swap_case(char)\n        # Substitute the vowels in the character\n        substituted_char = substitute_vowels(swapped_char)\n        # Append the substituted character to the encoded message\n        encoded_message += substituted_char\n\n    return encoded_message\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting vowels with characters that are two positions forward in the alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowel substitution\n    vowel_substitution_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    \n    # Function to swap the case of a character\n    def swap_case(char: str) -> str:\n        if char.islower():\n            return char.upper()\n        elif char.isupper():\n            return char.lower()\n        else:\n            return char\n    \n    # Process the message\n    encoded_message = []\n    for char in message:\n        if char.lower() in vowel_substitution_map:\n            # Substitute vowel with the mapped character\n            new_char = vowel_substitution_map[char.lower()]\n            if char.isupper():\n                new_char = new_char.upper()\n            else:\n                new_char = new_char.lower()\n            encoded_message.append(new_char)\n        else:\n            # Swap the case and add to the encoded message\n            encoded_message.append(swap_case(char))\n    \n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    message = \"Hello World\"\n    encoded_message = encode(message)\n    print(f\"Original message: {message}\")\n    print(f\"Encoded message: {encoded_message}\")\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes the input message by swapping the case of each letter,\n    substituting vowels with the character 2 positions forward in the alphabet,\n    and keeping non-alphabet characters unchanged.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n            \n            if new_char in vowels:\n                # Calculate the index of the new character\n                ascii_offset = ord('a') if new_char.islower() else ord('A')\n                new_index = (ord(new_char) - ascii_offset + 2) % 26\n                new_char = chr(ascii_offset + new_index)\n        else:\n            new_char = char\n        \n        encoded_message.append(new_char)\n\n    return ''.join(encoded_message)\n", "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting vowels with characters that are two positions forward in the alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowel substitution\n    vowel_substitution_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    \n    # Function to swap the case of a character\n    def swap_case(char: str) -> str:\n        if char.islower():\n            return char.upper()\n        elif char.isupper():\n            return char.lower()\n        else:\n            return char\n    \n    # Process the message\n    encoded_message = []\n    for char in message:\n        if char.lower() in vowel_substitution_map:\n            # Substitute vowel with the mapped character\n            new_char = vowel_substitution_map[char.lower()]\n            if char.isupper():\n                new_char = new_char.upper()\n            else:\n                new_char = new_char.lower()\n            encoded_message.append(new_char)\n        else:\n            # Swap the case and add to the encoded message\n            encoded_message.append(swap_case(char))\n    \n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    message = \"Hello World\"\n    encoded_message = encode(message)\n    print(f\"Original message: {message}\")\n    print(f\"Encoded message: {encoded_message}\")\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet. This function should handle only letters and maintain readability and efficiency.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels.\n- The function should handle only letters and ignore non-letter characters.\n- The output should be easily readable and visually appealing.\n- The function should be quick and efficient in processing the input message.\nTo implement the function that encodes a message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet, we will use Python's built-in string manipulation functions and a simple mapping for vowel substitution. The function will iterate through each character in the input message, check if it's a letter, and then apply the necessary transformations.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting vowels with the character that is two positions forward in the alphabet. This function should handle only letters and should be efficient and easy to use.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels.\n- The function should handle only letters.\n- The output should be easy to read and understand.\n- The tool should be quick and efficient to use.\n- The UI should be simple and intuitive.\nTo implement the function that encodes a message by swapping the case of all letters and substituting vowels with the character that is two positions forward in the alphabet, we will use Python's built-in string manipulation functions and a simple mapping for vowel substitution. The function will iterate through each character in the input message, check if it's a letter, and then swap its case. For vowels, it will substitute them according to the specified position shift in the alphabet.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting all vowels with the character that is located 2 positions forward in the English alphabet. This encoding should be efficient and easy to reverse.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels.\n- The function should be easy to reverse for decoding purposes.\n- The UI should be simple and intuitive for users to input and view encoded messages.\n- The encoding process should handle all letters and ignore non-letter characters.\n- The function should be optimized for performance and readability.\nTo implement the function that encodes a message by swapping the case of all letters and substituting all vowels with the character that is located 2 positions forward in the English alphabet, we will use Python's built-in string manipulation functions and a simple dictionary for vowel substitution. The function will be designed to be efficient and easy to reverse, ensuring that the encoding process is both simple and effective.\n", "requirement analysis:\nThe requirement involves creating a function that can swap the case of all letters in a message and substitute vowels with characters that are two positions forward in the alphabet. This function should only process letters and maintain the case of non-letter characters. The encoding should be reversible for easy decoding.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels as per the requirements.\n- The function should handle both uppercase and lowercase letters correctly.\n- Implement a mechanism to reverse the encoding process for easy decoding.\n- Ensure the function processes the message efficiently and handles edge cases.\nTo implement the function that swaps the case of all letters and substitutes vowels with characters two positions forward in the alphabet, we will use Python's built-in string manipulation methods and a simple mapping for vowel substitution. The function will iterate through each character in the input message, apply the case swap and vowel substitution, and then return the encoded message.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet. This function should only process letters and ignore non-letter characters.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The function should correctly substitute vowels with characters two positions forward.\n- Ensure the function handles edge cases, such as empty strings or strings with no vowels.\n- Implement the function in a way that is efficient and easy to understand.\n- Include tests to verify the correctness of the function.\nTo implement the function that encodes a message by swapping the case of all letters and substituting vowels with characters two positions forward in the alphabet, we will use Python's built-in string manipulation functions and a dictionary for the substitution. The function will iterate through each character in the input message, check if it's a letter, and then apply the case swap and vowel substitution as per the requirements. This approach ensures efficiency and clarity in the implementation.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting vowels with the character that is two positions forward in the alphabet. This function should handle only letters and maintain readability and efficiency.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels.\n- The function should handle only letters.\n- The output should be easy to read and maintain a clear structure.\n- The function should be quick and efficient in processing the message.\n- The product should be user-friendly and provide clear instructions.\nWe will implement the function by first defining a mapping for vowels and their substitutions. Then, we will iterate through the input message, swapping the case of each character and substituting vowels according to the mapping. The function will ensure that only letters are processed and will maintain readability and efficiency.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting vowels with characters that are two positions forward in the alphabet. This function should handle only letters and maintain readability for the user.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The function should substitute vowels with characters two positions forward in the alphabet.\n- Ensure the function is efficient and can handle various message lengths.\n- Develop a user-friendly interface for encoding messages.\n- Implement a decoding function to reverse the encoding process.\nTo implement the encoding function, we will use Python's built-in string manipulation methods and a simple mapping for vowel substitution. The function will first swap the case of each letter in the message, then substitute vowels according to a predefined mapping. This approach ensures efficiency and readability.\n", "requirement analysis:\nThe requirement involves creating a function that can swap the case of all letters in a message and substitute vowels with characters that are two positions forward in the alphabet. This function should be efficient and easy to use, catering to both casual and advanced users.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels.\n- The function should be easy to use and understand.\n- The UI should be clean and responsive.\n- The encoding process should be reversible for easy decoding.\n- The tool should handle various input lengths and types of messages.\nWe will implement the function by creating a Python script that takes a message as input, processes it to swap the case of all letters, and substitutes vowels with characters that are two positions forward in the alphabet. This will be achieved using basic Python string manipulation techniques and a predefined mapping for vowel substitution.\n", "requirement analysis:\nThe requirement is to create a function that encodes a message by swapping the case of all letters and substituting all vowels with the character that is located 2 positions forward in the English alphabet. This will enhance the message's complexity and provide a fun way to encode messages.\nrequirement pool:\n- The main code should correctly swap the case of all letters.\n- The code should correctly substitute vowels with the character 2 positions forward.\n- Ensure the function is efficient and can handle various message lengths.\n- Include error handling for non-letter characters.\n- Provide a user-friendly interface for easy message encoding.\nWe will implement the function by iterating through each character in the input message. For each character, we will check if it is a letter and then swap its case. If it is a vowel, we will substitute it with the character that is located 2 positions forward in the English alphabet. We will use Python's built-in string methods and a predefined list of vowels for simplicity and efficiency.\n", "requirement analysis:\nThe requirement involves creating a function that can swap the case of all letters in a message and substitute vowels with characters that are two positions forward in the alphabet. This function should be efficient and easy to use, catering to both casual and advanced users.\nrequirement pool:\n- The main code should efficiently swap case and substitute vowels.\n- The function should be easy to use and understand.\n- The UI should be clean and responsive.\n- The encoding process should be reversible for easy decoding.\n- The tool should handle various input lengths and types of messages.\nWe will implement the function by creating a Python script that takes a message as input, processes it to swap the case of all letters, and substitutes vowels with characters that are two positions forward in the alphabet. This will be achieved using basic Python string manipulation techniques and a predefined mapping for vowel substitution.\n"], "scores": [0.1462, 0.1462, 0.1462, 0.5462, 0.5462, 0.1462, 0.1462, 0.1462, 1.0, 0.1462], "pass_results": [false, false, false, false, false, false, false, false, true, false], "pass_test_cases_num": [19, 19, 19, 71, 71, 19, 19, 19, 130, 19], "completion": "from typing import List\n## main.py\n\ndef encode(message: str) -> str:\n    \"\"\"\n    Encodes a message by swapping the case of all letters and substituting vowels with characters that are two positions forward in the alphabet.\n\n    Args:\n        message (str): The input message to be encoded.\n\n    Returns:\n        str: The encoded message.\n    \"\"\"\n    # Define the mapping for vowel substitution\n    vowel_substitution_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    \n    # Function to swap the case of a character\n    def swap_case(char: str) -> str:\n        if char.islower():\n            return char.upper()\n        elif char.isupper():\n            return char.lower()\n        else:\n            return char\n    \n    # Process the message\n    encoded_message = []\n    for char in message:\n        if char.lower() in vowel_substitution_map:\n            # Substitute vowel with the mapped character\n            new_char = vowel_substitution_map[char.lower()]\n            if char.isupper():\n                new_char = new_char.upper()\n            else:\n                new_char = new_char.lower()\n            encoded_message.append(new_char)\n        else:\n            # Swap the case and add to the encoded message\n            encoded_message.append(swap_case(char))\n    \n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    message = \"Hello World\"\n    encoded_message = encode(message)\n    print(f\"Original message: {message}\")\n    print(f\"Encoded message: {encoded_message}\")\n", "passed": true, "pass": true, "pass_num": 1, "round": 349, "repair_prompt": ["def encode(message):\t\n'''Write a function that takes a message, and encodes in such a way that it swaps case of all letters, substitutes all vowels in the message with the character that is located 2 positions forward from that vowel in the English alphabet. Assume only letters.\nExamples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    '''"], "mutate_method": "rephrase_one", "parent_index": 72}
