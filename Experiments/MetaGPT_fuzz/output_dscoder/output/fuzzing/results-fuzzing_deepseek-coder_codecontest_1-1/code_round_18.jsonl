{"name": "1618_A. Polycarp and Sums of Subsequences", "description": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "tags": ["math", "sortings"], "difficulty": 7, "id": 1618, "sample_io": [{"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}], "test_list": [{"input": "1\n69696868 69696868 69696868 139393736 139393736 139393736 209090604\n", "output": ["69696868 69696868 69696868 \n"]}, {"input": "2\n1 1 2 69696874 69696875 69696875 69696876\n1 1 1 2 2 2 3\n", "output": ["1 1 69696874\n1 1 1\n"]}, {"input": "1\n1 1 2 69696880 69696881 69696881 69696882\n", "output": ["1 1 69696880\n"]}, {"input": "2\n1 1 2 69696967 69696968 69696968 69696969\n1 1 1 2 2 2 3\n", "output": ["1 1 69696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696868 69696869 69696869 69696870\n1 2 3 4 5 6 7\n", "output": ["1 1 69696868\n1 2 4\n"]}, {"input": "2\n1 1 2 696967 696968 696968 696969\n1 1 1 2 2 2 3\n", "output": ["1 1 696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696873 69696874 69696874 69696875\n1 1 1 2 2 2 3\n", "output": ["1 1 69696873\n1 1 1\n"]}, {"input": "2\n1 1 2 69696889 69696890 69696890 69696891\n1 1 1 2 2 2 3\n", "output": ["1 1 69696889\n1 1 1\n"]}, {"input": "1\n1 2 3 69696875 69696876 69696877 69696878\n", "output": ["1 2 69696875\n"]}, {"input": "2\n1 1 2 69696870 69696871 69696871 69696872\n1 1 1 2 2 2 3\n", "output": ["1 1 69696870\n1 1 1\n"]}, {"input": "2\n1 1 2 69696881 69696882 69696882 69696883\n1 1 1 2 2 2 3\n", "output": ["1 1 69696881\n1 1 1\n"]}, {"input": "2\n1 1 2 598989 598990 598990 598991\n1 3 4 4 5 7 8\n", "output": ["1 1 598989\n1 3 4\n"]}, {"input": "2\n1 1 2 69696875 69696876 69696876 69696877\n1 1 1 2 2 2 3\n", "output": ["1 1 69696875\n1 1 1\n"]}, {"input": "1\n1 1 2 69696884 69696885 69696885 69696886\n", "output": ["1 1 69696884\n"]}, {"input": "1\n1 1 2 69696883 69696884 69696884 69696885\n", "output": ["1 1 69696883\n"]}, {"input": "2\n1 1 2 69696885 69696886 69696886 69696887\n1 1 1 2 2 2 3\n", "output": ["1 1 69696885\n1 1 1\n"]}, {"input": "2\n1 1 2 69696879 69696880 69696880 69696881\n1 1 1 2 2 2 3\n", "output": ["1 1 69696879\n1 1 1\n"]}, {"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}, {"input": "2\n1 1 2 69696886 69696887 69696887 69696888\n1 1 1 2 2 2 3\n", "output": ["1 1 69696886\n1 1 1\n"]}, {"input": "2\n1 1 2 69696869 69696870 69696870 69696871\n1 1 1 2 2 2 3\n", "output": ["1 1 69696869\n1 1 1\n"]}, {"input": "2\n1 1 2 69696887 69696888 69696888 69696889\n1 1 1 2 2 2 3\n", "output": ["1 1 69696887\n1 1 1\n"]}, {"input": "2\n1 1 2 69696877 69696878 69696878 69696879\n1 1 1 2 2 2 3\n", "output": ["1 1 69696877\n1 1 1\n"]}, {"input": "2\n1 1 2 69696871 69696872 69696872 69696873\n1 1 1 2 2 2 3\n", "output": ["1 1 69696871\n1 1 1\n"]}, {"input": "2\n1 1 2 69696882 69696883 69696883 69696884\n1 1 1 2 2 2 3\n", "output": ["1 1 69696882\n1 1 1\n"]}, {"input": "1\n1 2 3 69696887 69696888 69696889 69696890\n", "output": ["1 2 69696887\n"]}, {"input": "2\n1 1 2 69696872 69696873 69696873 69696874\n1 1 1 2 2 2 3\n", "output": ["1 1 69696872\n1 1 1\n"]}, {"input": "2\n1 1 2 69696878 69696879 69696879 69696880\n1 1 1 2 2 2 3\n", "output": ["1 1 69696878\n1 1 1\n"]}], "task_id": "codecontest/132", "prompt": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, arranged them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "repair_prompt": ["Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, arranged them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # The smallest and largest elements of the original array a will be present in the sorted sums array b\n    b_sorted = sorted(b)\n    smallest = b_sorted[0]\n    largest = b_sorted[-1]\n    \n    # Find the two elements that are not the smallest or largest in b\n    a_elements = []\n    for num in b_sorted:\n        if num != smallest and num != largest:\n            a_elements.append(num)\n    \n    # The smallest and largest elements of a will be the first and last elements in b\n    a = [smallest] + a_elements + [largest]\n    return a\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # The array b contains all non-empty sums of the original array a.\n    # Since a has 3 elements, the smallest sum is a[0] + a[1] and the largest sum is a[1] + a[2].\n    # We can find these two sums and then deduce the original elements.\n    \n    # Find the smallest and largest sums in the array b\n    smallest = min(b)\n    largest = max(b)\n    \n    # Find the two sums that include the smallest and largest elements\n    for i in range(len(b)):\n        for j in range(i + 1, len(b)):\n            if b[i] + b[j] == smallest or b[i] + b[j] == largest:\n                a1, a2 = sorted([b[i], b[j]])\n                break\n    \n    # Find the third element by subtracting the sum of the first two from the largest sum\n    a3 = largest - a1 - a2\n    \n    return [a1, a2, a3]\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array b to find the smallest three sums\n    b.sort()\n    \n    # Initialize the result array\n    a = [0] * 3\n    \n    # The smallest three sums in b correspond to the elements of a\n    a[0] = b[0]\n    a[1] = b[1]\n    a[2] = b[6] - b[1]\n    \n    return a\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to make it easier to find the smallest and largest sums\n    b.sort()\n    \n    # The smallest sum is the sum of the two smallest elements in a\n    smallest_sum = b[0] + b[1]\n    \n    # The largest sum is the sum of all elements in a\n    largest_sum = sum(b)\n    \n    # The middle element in b is one of the elements in a\n    # It is the sum of the two largest elements in a\n    middle_element = b[6] - smallest_sum\n    \n    # The remaining two elements in a are the difference between the middle element and the sums in b\n    a = [smallest_sum - middle_element, middle_element, largest_sum - middle_element - (smallest_sum - middle_element)]\n    \n    return a\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to easily find the smallest three sums\n    b.sort()\n    \n    # The smallest three sums are the sums of the three smallest elements in the original array\n    a = [b[0], b[1], b[6] - b[0] - b[1]]\n    \n    # Ensure the third element is the smallest element in the original array\n    if a[2] > a[1]:\n        a[0], a[2] = a[2], a[0]\n    \n    return a\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array b to easily find the smallest elements\n    b_sorted = sorted(b)\n    \n    # The smallest three elements in b are the three integers from a\n    a = [b_sorted[0], b_sorted[1], b_sorted[2] - b_sorted[0] - b_sorted[1]]\n    \n    # Ensure the array a has positive integers\n    if any(x <= 0 for x in a):\n        raise ValueError(\"The elements of array a must be positive integers.\")\n    \n    return a\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to easily find the smallest three sums\n    b.sort()\n    \n    # The smallest three sums are the sums of the three smallest elements in the original array\n    a = [b[0], b[1], b[6] - b[0] - b[1]]\n    \n    # Ensure the third element is the sum of the first two elements\n    if a[0] + a[1] != a[2]:\n        raise ValueError(\"Invalid input: the sums do not match the constraints.\")\n    \n    return a\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array b to facilitate the identification of the original integers\n    b.sort()\n    \n    # Initialize the list to store the original integers\n    a = []\n    \n    # The smallest element in b is one of the original integers\n    a.append(b[0])\n    \n    # The second smallest element in b is the sum of the smallest and another original integer\n    a.append(b[1] - b[0])\n    \n    # The largest element in b is the sum of all three original integers\n    a.append(b[-1] - b[0] - a[1])\n    \n    return a\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to make it easier to find the three integers\n    b.sort()\n    \n    # Initialize a list to store the three integers\n    a = [0] * 3\n    \n    # The smallest element in b is one of the original integers\n    a[0] = b[0]\n    \n    # The largest element in b is the sum of the three original integers\n    a[2] = b[-1]\n    \n    # The middle element in b is the sum of two of the original integers\n    # We need to find which two original integers sum to this middle value\n    for i in range(1, 6):\n        for j in range(i + 1, 7):\n            if b[i] + b[j] == b[6]:\n                a[1] = b[i] if b[i] != a[0] else b[j]\n                break\n    \n    return a\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to make it easier to find the smallest and largest sums\n    b.sort()\n    \n    # The smallest sum is the sum of the two smallest elements in a\n    smallest_sum = b[0] + b[1]\n    \n    # The largest sum is the sum of all elements in a\n    largest_sum = sum(b)\n    \n    # The third element in a is the difference between the largest sum and the sum of the two largest sums in b\n    a = [smallest_sum, largest_sum - smallest_sum, largest_sum - 2 * smallest_sum]\n    \n    return a\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires the restoration of a 3-element array from its sorted sums. The sums are derived from all non-empty subsequences of the original array. This is a classic combinatorial problem that can be approached by identifying the smallest and largest elements of the original array and then using the properties of sums to deduce the remaining elements. The solution must handle multiple test cases efficiently, which implies the need for an optimized algorithm.\nrequirement pool:\n- Implement an algorithm to restore the original array from the sorted sums.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for performance, especially for large integers.\n- Provide a user-friendly interface for input and output.\nTo restore the original array a from the sorted sums array b, we can leverage the properties of sums and the fact that the array b contains all non-empty subsequences of a. The smallest and largest elements of a will appear in b, and by identifying these elements, we can deduce the rest of the array. We will use a combination of set operations and sorting to identify the elements efficiently.\n", "requirement analysis:\nThe problem requires the restoration of a 3-element array from its sums arranged in non-decreasing order. This involves identifying the three original elements from the given sums. The solution must be efficient and handle multiple test cases, which implies a need for a robust algorithm.\nrequirement pool:\n- Implement an algorithm to restore the original array from the given sums.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for handling large integers.\n- Provide a user-friendly interface for easy interaction.\nTo restore the original array a from the sorted sums array b, we can use a combinatorial approach. Given that the array b contains all non-empty sums of the original array a, we can deduce the original elements by identifying the smallest and largest sums and then finding the middle element. This approach leverages the fact that the sums are non-decreasing and the original array contains three elements. We will use Python's itertools to generate all possible combinations of the sums and then filter out the correct one.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the given array b. The array b contains the sums of all non-empty subsequences of a, sorted in non-decreasing order. The solution must handle multiple test cases efficiently. The input consists of 7 integers, and the output should be 3 integers that form the original array a.\nrequirement pool:\n- Implement a function to restore the original array a from the given array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm to handle large integers efficiently.\n- Provide a simple and user-friendly interface for the solution.\nTo restore the original array a from the given array b, we need to identify the three unique sums that form the array b. Given that the sums are sorted in non-decreasing order, the smallest three sums in b will correspond to the elements of a. We can achieve this by iteratively subtracting the smallest sum from the array b until we have identified all three elements of a.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the sorted sums array b. This involves identifying the three integers that, when summed in all possible combinations, yield the given array b. The solution must handle multiple test cases efficiently, making it suitable for large inputs.\nrequirement pool:\n- Implement a function to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for handling large integers efficiently.\n- Provide a user-friendly interface for easy interaction.\nTo restore the original array a from the sorted sums array b, we need to identify the three integers that, when summed in all possible combinations, yield the given array b. Given the constraints and the nature of the problem, we will use a combination of mathematical analysis and algorithmic optimization to achieve this. We will leverage Python's efficient handling of large integers and its built-in functions to process the input and output efficiently.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array a from the sorted sums array b. This involves identifying the three unique integers that could have been summed to produce the seven integers in array b. The solution must be efficient and capable of handling multiple test cases.\nrequirement pool:\n- Implement a function to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for handling large integers efficiently.\n- Provide a user-friendly interface for input and output.\nTo restore the original array a from the sorted sums array b, we need to identify the three unique integers that were summed to produce the seven integers in array b. Given that the sums are non-decreasing and the array b contains all possible sums of any two elements from a, we can deduce the original array by identifying the smallest three sums in b, which correspond to the smallest three elements of a.\n", "requirement analysis:\nThe requirement is to restore the original array a from the sorted sums array b. The input consists of multiple test cases, each with a unique array b. The output should be the original array a for each test case. The solution must handle up to 5000 test cases efficiently. The integers in the array b are positive and can be large.\nrequirement pool:\n- Implement a function to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm to handle large integers efficiently.\n- Provide a simple and clear solution that is easy to understand and use.\nTo restore the original array a from the sorted sums array b, we need to identify the three integers that were summed to produce each of the elements in b. Given that b is a sorted array of the sums of all non-empty subsequences of a, we can deduce the original integers by recognizing that the smallest three elements in b are the three integers from a. We can then iteratively subtract these smallest elements from the subsequent elements in b to identify the remaining elements of a. This approach leverages the sorted nature of b to efficiently determine the original array a.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array a from the sorted sums array b. This involves identifying the three unique integers that could have been summed to produce the seven integers in array b. The solution must be efficient and capable of handling multiple test cases.\nrequirement pool:\n- Implement a function to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for handling large integers efficiently.\n- Provide a user-friendly interface for easy interaction.\nTo restore the original array a from the sorted sums array b, we need to identify the three unique integers that were summed to produce the seven integers in array b. Given that the sums are non-decreasing and the array b contains all possible sums of any two elements from array a, we can deduce the original array by identifying the smallest three sums in array b, which correspond to the smallest three elements of array a.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the given array b. The array b contains the sums of all non-empty subsequences of a, sorted in non-decreasing order. The solution must handle multiple test cases efficiently. The algorithm should be robust and capable of handling large inputs.\nrequirement pool:\n- Implement an algorithm to restore the original array a from the given array b.\n- Ensure the solution can handle multiple test cases.\n- Optimize the algorithm for performance to handle large inputs.\n- Provide a user-friendly interface for easy interaction.\n- Include detailed error handling and logging for debugging.\nTo restore the original array a from the given array b, we need to identify the three integers that were summed to produce each element in b. Since b is sorted, the smallest element in b is one of the original integers, the second smallest is the sum of the smallest and another original integer, and so on. We can use this property to deduce the original integers.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the sorted sums array b. This involves identifying the three integers that, when summed in all possible combinations, yield the given array b. The solution must handle multiple test cases efficiently, making it suitable for large inputs.\nrequirement pool:\n- Implement a function to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for handling large integers efficiently.\n- Provide a user-friendly interface for easy interaction.\nTo restore the original array a from the sorted sums array b, we need to identify the three integers that, when summed in all possible combinations, yield the given array b. Given the constraints, we can use a combination of set operations and mathematical properties to deduce the original array. We will use Python due to its efficiency and ease of handling large integers.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array a from the sorted sums array b. This involves identifying the three unique integers that could have been summed to produce the seven integers in array b. The solution must be efficient and capable of handling multiple test cases.\nrequirement pool:\n- Implement a function to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for handling large integers efficiently.\n- Provide a user-friendly interface for easy interaction.\nTo restore the original array a from the sorted sums array b, we need to identify the three unique integers that were summed to produce the seven integers in array b. Given the constraints and the nature of the problem, we can use a combination of set operations and mathematical properties to deduce the original array. The approach involves identifying the smallest and largest sums, which will include two of the original numbers, and then finding the third number by subtracting the sum of these two numbers from the total sum of array b.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 18, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "mutate_method": "rephrase_one", "parent_index": 18}
