{"name": "1619_A. Square String?", "description": "A string is called square if it is some string written twice in a row. For example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square. But the strings \"aaa\", \"abaaab\" and \"abcdabc\" are not square.\n\nFor a given string s determine if it is square.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "tags": ["implementation", "strings"], "difficulty": 7, "id": 1619, "sample_io": [{"input": "10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}], "test_list": [{"input": "1\nacascnakcn\n", "output": ["NO\n"]}, {"input": "1\nababab\n", "output": ["NO\n"]}, {"input": "1\nzz\n", "output": ["YES\n"]}, {"input": "1\nacascnajcn\n", "output": ["NO\n"]}, {"input": "10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\n{{\n", "output": ["YES\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nabaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nxyxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\na\nba\naaa\nab`a\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\nb\nb`\na``\n_aba\nabbb\ncca`ba\nabacbca\nxyxx\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nd\n`c\nbab\ncaa_\nbaba\nccabc`\n_baceac\nwxxy\nwuwy\nw|wz\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n`babab\n", "output": ["NO\n"]}, {"input": "1\nz{\n", "output": ["NO\n"]}, {"input": "1\nacascankcn\n", "output": ["NO\n"]}, {"input": "1\n`babbb\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nacbscankcn\n", "output": ["NO\n"]}, {"input": "1\n_babbb\n", "output": ["NO\n"]}, {"input": "1\n{|\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxxyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nacbscakncn\n", "output": ["NO\n"]}, {"input": "1\n_baabb\n", "output": ["NO\n"]}, {"input": "1\n|{\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nabbscakncn\n", "output": ["NO\n"]}, {"input": "1\n^baabb\n", "output": ["NO\n"]}, {"input": "1\n||\n", "output": ["YES\n"]}, {"input": "1\nabbscakmcn\n", "output": ["NO\n"]}, {"input": "1\n^baacb\n", "output": ["NO\n"]}, {"input": "1\nz|\n", "output": ["NO\n"]}, {"input": "1\nncmkacsbba\n", "output": ["NO\n"]}, {"input": "1\n^b`acb\n", "output": ["NO\n"]}, {"input": "1\n|z\n", "output": ["NO\n"]}, {"input": "1\nncmkacsbca\n", "output": ["NO\n"]}, {"input": "1\nbca`b^\n", "output": ["NO\n"]}, {"input": "1\nz}\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nncmlacsbca\n", "output": ["NO\n"]}, {"input": "1\nbca`b_\n", "output": ["NO\n"]}, {"input": "1\n}z\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nccmlansbca\n", "output": ["NO\n"]}, {"input": "1\n`cabb_\n", "output": ["NO\n"]}, {"input": "1\n{}\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nccmlamsbca\n", "output": ["NO\n"]}, {"input": "1\n_bbac`\n", "output": ["NO\n"]}, {"input": "1\n{z\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacbaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlamsbca\n", "output": ["NO\n"]}, {"input": "1\n`bbac`\n", "output": ["NO\n"]}, {"input": "1\nyz\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlamsbda\n", "output": ["NO\n"]}, {"input": "1\n`cabb`\n", "output": ["NO\n"]}, {"input": "1\nzy\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`cabc`\n", "output": ["NO\n"]}, {"input": "1\nzx\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nab`a\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaalmcb\n", "output": ["NO\n"]}, {"input": "1\n_cabc`\n", "output": ["NO\n"]}, {"input": "1\nxz\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaakmcb\n", "output": ["NO\n"]}, {"input": "1\n_cbbc`\n", "output": ["NO\n"]}, {"input": "1\nyy\n", "output": ["YES\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaajmcb\n", "output": ["NO\n"]}, {"input": "1\n_cbbd`\n", "output": ["NO\n"]}, {"input": "1\ny{\n", "output": ["NO\n"]}, {"input": "1\nbcmjaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`dbbc_\n", "output": ["NO\n"]}, {"input": "1\ny|\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbbmjaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`dbbb_\n", "output": ["NO\n"]}, {"input": "1\nx|\n", "output": ["NO\n"]}, {"input": "10\na\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdmjaasbbm\n", "output": ["NO\n"]}, {"input": "1\nadbbb_\n", "output": ["NO\n"]}, {"input": "1\nx}\n", "output": ["NO\n"]}, {"input": "1\nbdmj`asbbm\n", "output": ["NO\n"]}, {"input": "1\na_bbbd\n", "output": ["NO\n"]}, {"input": "1\nw}\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdmj`ascbm\n", "output": ["NO\n"]}, {"input": "1\na_cbbd\n", "output": ["NO\n"]}, {"input": "1\n}w\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`cab\nabbcbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdma`jscbm\n", "output": ["NO\n"]}, {"input": "1\na_cbcd\n", "output": ["NO\n"]}, {"input": "1\n}x\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`cab\nabbcbaa\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdm`ajscbm\n", "output": ["NO\n"]}, {"input": "1\na_cbcc\n", "output": ["NO\n"]}, {"input": "1\ny}\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbaa\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdm`ajscbl\n", "output": ["NO\n"]}, {"input": "1\na_cbbc\n", "output": ["NO\n"]}, {"input": "1\n}y\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdl`ajscbl\n", "output": ["NO\n"]}, {"input": "1\na_cabc\n", "output": ["NO\n"]}, {"input": "1\n~y\n", "output": ["NO\n"]}, {"input": "1\nbbl`ajscdl\n", "output": ["NO\n"]}, {"input": "1\na`cabc\n", "output": ["NO\n"]}, {"input": "1\ny~\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcsja`lbb\n", "output": ["NO\n"]}, {"input": "1\na`cbbc\n", "output": ["NO\n"]}, {"input": "1\ny\u007f\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcrja`lbb\n", "output": ["NO\n"]}, {"input": "1\naacbbc\n", "output": ["NO\n"]}, {"input": "1\n\u007fy\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcrja`lab\n", "output": ["NO\n"]}, {"input": "1\naacbbb\n", "output": ["NO\n"]}, {"input": "1\nx\u007f\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nlddrja`lab\n", "output": ["NO\n"]}, {"input": "1\naadbbb\n", "output": ["NO\n"]}, {"input": "1\nx~\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbal`ajrddl\n", "output": ["NO\n"]}, {"input": "1\naaebbb\n", "output": ["NO\n"]}, {"input": "1\nz~\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajrddl\n", "output": ["NO\n"]}, {"input": "1\naaebab\n", "output": ["NO\n"]}, {"input": "1\n~z\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nlddrja`lac\n", "output": ["NO\n"]}, {"input": "1\nbabeaa\n", "output": ["NO\n"]}, {"input": "1\nz\u007f\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddrja`lac\n", "output": ["NO\n"]}, {"input": "1\naabeaa\n", "output": ["NO\n"]}, {"input": "1\n\u007fz\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajrddm\n", "output": ["NO\n"]}, {"input": "1\naaebaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\nab`cac\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajqddm\n", "output": ["NO\n"]}, {"input": "1\nbaebaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncac`ba\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`aiqddm\n", "output": ["NO\n"]}, {"input": "1\naabeab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncac`ba\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddqia`lac\n", "output": ["NO\n"]}, {"input": "1\nbaebab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmcdqia`lad\n", "output": ["NO\n"]}, {"input": "1\nbafbab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nxyxy\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmcdqia`mad\n", "output": ["NO\n"]}, {"input": "1\nbagbab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ndam`aiqdcm\n", "output": ["NO\n"]}, {"input": "1\nbagbaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncac`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`m`aiqdcm\n", "output": ["NO\n"]}, {"input": "1\naagbba\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncca`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`c`aiqdmm\n", "output": ["NO\n"]}, {"input": "1\na`gbba\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncca`ba\nabbcbba\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`b`aiqdmm\n", "output": ["NO\n"]}, {"input": "1\na`gbb`\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabbcbba\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nm`b`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`gb`b\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nm`c`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`hb`b\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabacbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmac`aiqddm\n", "output": ["NO\n"]}, {"input": "1\nb`hb`b\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnac`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`hbab\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbca\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddqia`can\n", "output": ["NO\n"]}, {"input": "1\na_hbab\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbca\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqia`cmn\n", "output": ["NO\n"]}, {"input": "1\nbabh_a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqia`cnn\n", "output": ["NO\n"]}, {"input": "1\nbabh^a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nwxyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnnc`aiqdda\n", "output": ["NO\n"]}, {"input": "1\nbbbh^a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnnc`ajqdda\n", "output": ["NO\n"]}, {"input": "1\nabbh^b\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\n_aba\nabbb\ncca`ba\nabacbca\nxyxy\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqja`cnn\n", "output": ["NO\n"]}], "task_id": "codecontest/139", "prompt": "A string is called square if it is some string written twice in a row. For example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square. But the strings \"aaa\", \"abaaab\", and \"abcdabc\" do not meet this criterion. They are not considered as square because they cannot be formed by writing any string twice in succession.\n\nFor a given string s determine if it is square.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "repair_prompt": ["A string is called square if it is some string written twice in a row. For example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square. But the strings \"aaa\", \"abaaab\", and \"abcdabc\" do not meet this criterion. They are not considered as square because they cannot be formed by writing any string twice in succession.\n\nFor a given string s determine if it is square.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef is_string_square(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by writing any string twice in succession.\n    This function checks if the first half of the string is equal to the second half.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    if len(s) % 2 != 0:\n        return 'NO'\n    \n    mid = len(s) // 2\n    if s[:mid] == s[mid:]:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_string_square(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by writing any string twice in succession.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    # Check if the length of the string is even\n    if len(s) % 2 != 0:\n        return 'NO'\n    \n    # Split the string into two halves\n    half_length = len(s) // 2\n    first_half = s[:half_length]\n    second_half = s[half_length:]\n    \n    # Check if the two halves are equal\n    if first_half == second_half:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by writing any string twice in succession.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    if len(s) % 2 != 0:\n        return 'NO'\n    \n    half_length = len(s) // 2\n    first_half = s[:half_length]\n    second_half = s[half_length:]\n    \n    if first_half == second_half:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    s = input()\n    result = is_square_string(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_string_square(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by writing any string twice in succession.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    n = len(s)\n    \n    # Check if the length of the string is even\n    if n % 2 != 0:\n        return 'NO'\n    \n    # Divide the string into two halves and compare them\n    half_length = n // 2\n    first_half = s[:half_length]\n    second_half = s[half_length:]\n    \n    if first_half == second_half:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_string_square(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be split into two identical halves.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    length = len(s)\n    if length % 2 != 0:\n        return 'NO'\n    \n    half_length = length // 2\n    first_half = s[:half_length]\n    second_half = s[half_length:]\n    \n    if first_half == second_half:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read the number of test cases\nn = int(input())\n\n# Loop through each test case\nfor _ in range(n):\n    s = input()\n    result = is_square_string(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_string_square(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be split into two identical halves.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    length = len(s)\n    if length % 2 != 0:\n        return 'NO'\n    \n    half_length = length // 2\n    first_half = s[:half_length]\n    second_half = s[half_length:]\n    \n    if first_half == second_half:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Provide the Interface\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    result = is_string_square(s)\n    print(result)\n", "from typing import List\n## main.py\nimport sys\n\ndef is_square_string(s: str) -> str:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if s[:i] * 2 == s:\n            return \"YES\"\n    return \"NO\"\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    s = input().strip()\n    result = is_square_string(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by writing any string twice in succession.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if s[:i] * 2 == s:\n            return 'YES'\n    return 'NO'\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> str:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by writing any string twice in succession.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    if len(s) % 2 != 0:\n        return 'NO'\n    \n    mid = len(s) // 2\n    first_half = s[:mid]\n    second_half = s[mid:]\n    \n    if first_half == second_half:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> str:\n    \"\"\"\n    Determines if a given string is square by comparing its first half with the second half.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        str: 'YES' if the string is square, 'NO' otherwise.\n    \"\"\"\n    length = len(s)\n    if length % 2 != 0:\n        return 'NO'\n    \n    half_length = length // 2\n    first_half = s[:half_length]\n    second_half = s[half_length:]\n    \n    return 'YES' if first_half == second_half else 'NO'\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    s = input()\n    result = is_square_string(s)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement to determine if a string is square involves checking if a given string can be formed by writing any string twice in succession. This can be achieved by comparing the first half of the string with the second half. If they are identical, the string is square. The solution should be able to handle up to 100 test cases, each with strings of lengths between 1 and 100. The output should be clear and concise, with 'YES' indicating a square string and 'NO' indicating otherwise.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases.\n- Provide clear and concise output for each test case.\n- Optimize the function for performance and scalability.\n- Include error handling for invalid inputs.\nTo determine if a string is square, we need to check if the string can be formed by writing any string twice in succession. This can be achieved by comparing the first half of the string with the second half. If they are identical, the string is square. We will use Python for this implementation as it provides easy string manipulation capabilities.\n", "requirement analysis:\nThe requirement analysis involves creating a function that can determine if a given string is square based on the definition provided. The function should be able to handle multiple test cases efficiently, with each test case consisting of a string of up to 100 characters. The output should be either 'YES' or 'NO' for each test case, indicating whether the string is square or not.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases.\n- Provide clear and concise output for each test case.\n- Optimize the function for performance and efficiency.\n- Include error handling for invalid inputs.\nTo determine if a string is square, we need to check if the string can be formed by writing any string twice in succession. This can be efficiently achieved by checking if the string's length is even and if the string is the same when read from the beginning to the middle and from the middle to the end. We will use Python's string manipulation capabilities to implement this.\n", "requirement analysis:\nThe requirement is to determine if a given string is a square string. A square string is defined as a string that can be formed by writing any string twice in succession. The solution should be efficient and handle up to 100 test cases with strings of lengths between 1 and 100 inclusive.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can process up to 100 test cases.\n- Optimize the function for performance on large datasets.\nTo determine if a string is square, we need to check if the string can be formed by writing any string twice in succession. This can be efficiently achieved by comparing the string with itself, specifically checking if the string is composed of two identical substrings. We will use Python's string manipulation capabilities to implement this check.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it can be formed by writing any string twice in succession. The solution should be efficient and capable of handling up to 100 test cases. The output should be in a clear and simple format, with options for YES and NO.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the solution can handle up to 100 test cases efficiently.\n- Provide a clear and simple output format for YES and NO.\nTo determine if a string is square, we need to check if the string can be formed by writing any string twice in succession. This can be achieved by dividing the string into possible halves and comparing them. If the string length is even and the first half matches the second half, then the string is square.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it can be formed by writing any string twice in succession. This involves checking if the string can be split into two identical halves. The solution should be efficient and handle strings of varying lengths up to 100 characters.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle strings of up to 100 characters.\n- Provide clear and consistent output for each test case.\n- Optimize the algorithm for performance and readability.\nTo determine if a string is square, we need to check if the string can be split into two identical halves. This can be efficiently achieved by comparing the first half of the string with the second half. If they are identical, the string is square. We will use Python's built-in string operations and a loop to iterate through each test case.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it can be formed by writing any string twice in succession. This involves checking if the string can be split into two identical halves. The solution should be efficient enough to handle up to 100 test cases, each with strings of length between 1 and 100. The output should be either 'YES' or 'NO' for each test case, with the latter being case-insensitive.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases efficiently.\n- Provide a clear and concise output format for each test case.\n- Add support for handling edge cases, such as very short strings.\n- Optimize the solution for large inputs to ensure performance.\nTo determine if a string is square, we need to check if the string can be split into two identical halves. This can be efficiently achieved by comparing the first half of the string with the second half. If they are identical, the string is square. We will use Python's built-in string operations and a loop to process each test case.\n", "requirement analysis:\nThe requirement to determine if a string is square involves checking if a given string can be formed by writing any string twice in succession. This requires a simple yet efficient algorithm that can handle up to 100 test cases with strings of lengths between 1 and 100. The output should be clear and concise, with 'YES' indicating a square string and 'NO' indicating otherwise.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for efficiency and scalability.\nWe will implement a Python function that checks if a given string is square. The function will iterate through the string and compare its substrings to determine if the string can be formed by writing any string twice in succession. The function will be designed to handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirement analysis shows that the primary goal is to determine if a string is square, which involves checking if a string can be formed by writing any string twice in succession. The input consists of multiple test cases, and the output should indicate whether each string is square or not. The solution should be efficient and handle up to 100 test cases.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Handle multiple test cases efficiently.\n- Ensure the solution is scalable to handle up to 100 test cases.\n- Provide a clear and concise output format.\nTo determine if a string is square, we need to check if the string can be formed by writing any string twice in succession. This can be efficiently achieved by comparing the string with itself, specifically checking if the string is composed of a substring that, when repeated, forms the original string. We will use Python's built-in string operations and a simple loop to achieve this.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it can be formed by writing any string twice in succession. The solution should be efficient and handle up to 100 test cases. The output should be clear and concise, with 'YES' indicating a square string and 'NO' indicating it is not.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases.\n- Provide clear and concise output for each test case.\nTo determine if a string is square, we need to check if the string can be formed by writing any string twice in succession. This can be achieved by comparing the first half of the string with the second half. If they are identical, the string is square. We will use Python for this implementation.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it can be formed by writing any string twice in succession. This involves checking if the string can be split into two identical halves. The solution should be efficient and handle up to 100 test cases with strings of length up to 100 characters each.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases.\n- Optimize the function for performance, especially for larger strings.\n- Provide clear and user-friendly output for each test case.\n- Test the function with various edge cases to ensure robustness.\nWe will implement a function that checks if a given string is square by comparing its first half with the second half. This approach leverages the simplicity of string slicing and comparison to determine if the string can be split into two identical halves.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 20, "examples": "\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "mutate_method": "expand_one2two", "parent_index": 20}
