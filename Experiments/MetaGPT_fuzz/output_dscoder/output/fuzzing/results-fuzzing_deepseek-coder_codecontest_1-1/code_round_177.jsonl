{"name": "1619_A. Square String?", "description": "A string is called square if it is some string written twice in a row. For example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square. But the strings \"aaa\", \"abaaab\" and \"abcdabc\" are not square.\n\nFor a given string s determine if it is square.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "tags": ["implementation", "strings"], "difficulty": 7, "id": 1619, "sample_io": [{"input": "10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}], "test_list": [{"input": "1\nacascnakcn\n", "output": ["NO\n"]}, {"input": "1\nababab\n", "output": ["NO\n"]}, {"input": "1\nzz\n", "output": ["YES\n"]}, {"input": "1\nacascnajcn\n", "output": ["NO\n"]}, {"input": "10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\n{{\n", "output": ["YES\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nabaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nxyxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\na\nba\naaa\nab`a\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "10\nb\nb`\na``\n_aba\nabbb\ncca`ba\nabacbca\nxyxx\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "10\nd\n`c\nbab\ncaa_\nbaba\nccabc`\n_baceac\nwxxy\nwuwy\nw|wz\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n`babab\n", "output": ["NO\n"]}, {"input": "1\nz{\n", "output": ["NO\n"]}, {"input": "1\nacascankcn\n", "output": ["NO\n"]}, {"input": "1\n`babbb\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nacbscankcn\n", "output": ["NO\n"]}, {"input": "1\n_babbb\n", "output": ["NO\n"]}, {"input": "1\n{|\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxxyx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nacbscakncn\n", "output": ["NO\n"]}, {"input": "1\n_baabb\n", "output": ["NO\n"]}, {"input": "1\n|{\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nyxxy\nxyxx\nxyxy\n", "output": ["NO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "1\nabbscakncn\n", "output": ["NO\n"]}, {"input": "1\n^baabb\n", "output": ["NO\n"]}, {"input": "1\n||\n", "output": ["YES\n"]}, {"input": "1\nabbscakmcn\n", "output": ["NO\n"]}, {"input": "1\n^baacb\n", "output": ["NO\n"]}, {"input": "1\nz|\n", "output": ["NO\n"]}, {"input": "1\nncmkacsbba\n", "output": ["NO\n"]}, {"input": "1\n^b`acb\n", "output": ["NO\n"]}, {"input": "1\n|z\n", "output": ["NO\n"]}, {"input": "1\nncmkacsbca\n", "output": ["NO\n"]}, {"input": "1\nbca`b^\n", "output": ["NO\n"]}, {"input": "1\nz}\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxx\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nncmlacsbca\n", "output": ["NO\n"]}, {"input": "1\nbca`b_\n", "output": ["NO\n"]}, {"input": "1\n}z\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaba\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nccmlansbca\n", "output": ["NO\n"]}, {"input": "1\n`cabb_\n", "output": ["NO\n"]}, {"input": "1\n{}\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacaaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nccmlamsbca\n", "output": ["NO\n"]}, {"input": "1\n_bbac`\n", "output": ["NO\n"]}, {"input": "1\n{z\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\nabc`bc\nabacbaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlamsbca\n", "output": ["NO\n"]}, {"input": "1\n`bbac`\n", "output": ["NO\n"]}, {"input": "1\nyz\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nxyxz\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlamsbda\n", "output": ["NO\n"]}, {"input": "1\n`cabb`\n", "output": ["NO\n"]}, {"input": "1\nzy\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nabaa\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nbcmlaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`cabc`\n", "output": ["NO\n"]}, {"input": "1\nzx\n", "output": ["NO\n"]}, {"input": "10\nc\naa\naaa\nab`a\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaalmcb\n", "output": ["NO\n"]}, {"input": "1\n_cabc`\n", "output": ["NO\n"]}, {"input": "1\nxz\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\naac`bc\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaakmcb\n", "output": ["NO\n"]}, {"input": "1\n_cbbc`\n", "output": ["NO\n"]}, {"input": "1\nyy\n", "output": ["YES\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxxy\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\n"]}, {"input": "1\nmdbsaajmcb\n", "output": ["NO\n"]}, {"input": "1\n_cbbd`\n", "output": ["NO\n"]}, {"input": "1\ny{\n", "output": ["NO\n"]}, {"input": "1\nbcmjaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`dbbc_\n", "output": ["NO\n"]}, {"input": "1\ny|\n", "output": ["NO\n"]}, {"input": "10\nb\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbbmjaasbdm\n", "output": ["NO\n"]}, {"input": "1\n`dbbb_\n", "output": ["NO\n"]}, {"input": "1\nx|\n", "output": ["NO\n"]}, {"input": "10\na\naa\naaa\nab`a\nabab\ncb`caa\nabacbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nYES\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdmjaasbbm\n", "output": ["NO\n"]}, {"input": "1\nadbbb_\n", "output": ["NO\n"]}, {"input": "1\nx}\n", "output": ["NO\n"]}, {"input": "1\nbdmj`asbbm\n", "output": ["NO\n"]}, {"input": "1\na_bbbd\n", "output": ["NO\n"]}, {"input": "1\nw}\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdmj`ascbm\n", "output": ["NO\n"]}, {"input": "1\na_cbbd\n", "output": ["NO\n"]}, {"input": "1\n}w\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`cab\nabbcbaa\nyxyx\nxyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdma`jscbm\n", "output": ["NO\n"]}, {"input": "1\na_cbcd\n", "output": ["NO\n"]}, {"input": "1\n}x\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`cab\nabbcbaa\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdm`ajscbm\n", "output": ["NO\n"]}, {"input": "1\na_cbcc\n", "output": ["NO\n"]}, {"input": "1\ny}\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbaa\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdm`ajscbl\n", "output": ["NO\n"]}, {"input": "1\na_cbbc\n", "output": ["NO\n"]}, {"input": "1\n}y\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nabab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzxyx\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbdl`ajscbl\n", "output": ["NO\n"]}, {"input": "1\na_cabc\n", "output": ["NO\n"]}, {"input": "1\n~y\n", "output": ["NO\n"]}, {"input": "1\nbbl`ajscdl\n", "output": ["NO\n"]}, {"input": "1\na`cabc\n", "output": ["NO\n"]}, {"input": "1\ny~\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\nab`a\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcsja`lbb\n", "output": ["NO\n"]}, {"input": "1\na`cbbc\n", "output": ["NO\n"]}, {"input": "1\ny\u007f\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxx\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcrja`lbb\n", "output": ["NO\n"]}, {"input": "1\naacbbc\n", "output": ["NO\n"]}, {"input": "1\n\u007fy\n", "output": ["NO\n"]}, {"input": "10\na\nba\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nldcrja`lab\n", "output": ["NO\n"]}, {"input": "1\naacbbb\n", "output": ["NO\n"]}, {"input": "1\nx\u007f\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naaa\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nlddrja`lab\n", "output": ["NO\n"]}, {"input": "1\naadbbb\n", "output": ["NO\n"]}, {"input": "1\nx~\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nzyxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nbal`ajrddl\n", "output": ["NO\n"]}, {"input": "1\naaebbb\n", "output": ["NO\n"]}, {"input": "1\nz~\n", "output": ["NO\n"]}, {"input": "10\na\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajrddl\n", "output": ["NO\n"]}, {"input": "1\naaebab\n", "output": ["NO\n"]}, {"input": "1\n~z\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\naa`\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nlddrja`lac\n", "output": ["NO\n"]}, {"input": "1\nbabeaa\n", "output": ["NO\n"]}, {"input": "1\nz\u007f\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddrja`lac\n", "output": ["NO\n"]}, {"input": "1\naabeaa\n", "output": ["NO\n"]}, {"input": "1\n\u007fz\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncb`caa\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajrddm\n", "output": ["NO\n"]}, {"input": "1\naaebaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\nab`cac\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`ajqddm\n", "output": ["NO\n"]}, {"input": "1\nbaebaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na`ba\nbaab\ncac`ba\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ncal`aiqddm\n", "output": ["NO\n"]}, {"input": "1\naabeab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncac`ba\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddqia`lac\n", "output": ["NO\n"]}, {"input": "1\nbaebab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nyxyx\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmcdqia`lad\n", "output": ["NO\n"]}, {"input": "1\nbafbab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nxyxy\nwyyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmcdqia`mad\n", "output": ["NO\n"]}, {"input": "1\nbagbab\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\nab`cac\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\ndam`aiqdcm\n", "output": ["NO\n"]}, {"input": "1\nbagbaa\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncac`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`m`aiqdcm\n", "output": ["NO\n"]}, {"input": "1\naagbba\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncca`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`c`aiqdmm\n", "output": ["NO\n"]}, {"input": "1\na`gbba\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nbaab\ncca`ba\nabbcbba\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nd`b`aiqdmm\n", "output": ["NO\n"]}, {"input": "1\na`gbb`\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabbcbba\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nm`b`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`gb`b\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabbcbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nm`c`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`hb`b\n", "output": ["NO\n"]}, {"input": "10\nb\nb`\na``\na_ba\nabab\ncca`ba\nabacbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmac`aiqddm\n", "output": ["NO\n"]}, {"input": "1\nb`hb`b\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbba\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnac`aiqddm\n", "output": ["NO\n"]}, {"input": "1\na`hbab\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbca\nxyxy\nwyxw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nmddqia`can\n", "output": ["NO\n"]}, {"input": "1\na_hbab\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabab\ncca`ba\nabacbca\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nYES\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqia`cmn\n", "output": ["NO\n"]}, {"input": "1\nbabh_a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nwxyw\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqia`cnn\n", "output": ["NO\n"]}, {"input": "1\nbabh^a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nwxyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnnc`aiqdda\n", "output": ["NO\n"]}, {"input": "1\nbbbh^a\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\na_ba\nabbb\ncca`ba\nabacbca\nxyxy\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\nnnc`ajqdda\n", "output": ["NO\n"]}, {"input": "1\nabbh^b\n", "output": ["NO\n"]}, {"input": "10\nb\n`b\na``\n_aba\nabbb\ncca`ba\nabacbca\nxyxy\nxwyv\nyzxy\n", "output": ["NO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\n"]}, {"input": "1\naddqja`cnn\n", "output": ["NO\n"]}], "task_id": "codecontest/139", "prompt": "A string is termed square if it consists of a substring repeated consecutively; for example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square, but the strings \"aaa\", \"abaaab\" and \"abcdabc\" are not square. For a given string s determine if it is square. Ensure to return a boolean value indicating whether the string is square or not.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "repair_prompt": ["A string is termed square if it consists of a substring repeated consecutively; for example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square, but the strings \"aaa\", \"abaaab\" and \"abcdabc\" are not square. For a given string s determine if it is square. Ensure to return a boolean value indicating whether the string is square or not.\n\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\ndef is_string_square(s: str) -> bool:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be constructed by repeating a substring.\n    This function checks if the given string can be constructed by repeating a substring.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Interface\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    result = is_string_square(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> bool:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be constructed by repeating a substring.\n    This function checks all possible substring lengths and verifies if repeating them forms the original string.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Interface\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    result = is_square_string(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\nimport sys\n\ndef is_square_string(s: str) -> bool:\n    \"\"\"\n    Check if a given string is square based on the definition provided.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> bool:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be constructed by repeating a substring.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Read the number of test cases\nt = int(input())\nresults = []\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    results.append('YES' if result else 'NO')\n\n# Output the results\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef is_square_string(s: str) -> bool:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be constructed by repeating a substring.\n    This function checks if the given string can be constructed by repeating a substring.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Interface\ninput = sys.stdin.readline\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    result = is_square_string(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> bool:\n    \"\"\"\n    Check if a string is a square string.\n\n    A string is considered square if it can be constructed by repeating a substring.\n    \n    Args:\n        s (str): The input string to check.\n    \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Interface\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    result = is_square_string(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> bool:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be formed by repeating a substring.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Interface\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    result = is_square_string(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\ndef is_string_square(s: str) -> bool:\n    \"\"\"\n    Determines if a string is square.\n    \n    A string is considered square if it can be constructed by repeating a substring.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string is square, False otherwise.\n    \"\"\"\n    n = len(s)\n    \n    # Iterate over all possible lengths of the substring\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    s = input()\n    result = is_string_square(s)\n    print('YES' if result else 'NO')\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Read the number of test cases\nt = int(input())\nresults = []\n\n# Process each test case\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    results.append('YES' if result else 'NO')\n\n# Output the results\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\ndef is_square_string(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    s = input()\n    result = is_square_string(s)\n    print('YES' if result else 'NO')\n"], "plans": ["requirement analysis:\nThe requirement is to determine if a given string is square based on the definition provided. The solution should be efficient and handle up to 100 test cases with strings of length between 1 and 100. The output should be clear and concise, using 'YES' for square strings and 'NO' for non-square strings.\nrequirement pool:\n- Implement a function to check if a string is square\n- Handle up to 100 test cases\n- Ensure the function works for strings of length between 1 and 100\n- Provide clear output 'YES' or 'NO' for each test case\nTo determine if a string is square, we need to check if it can be constructed by repeating a substring. This can be efficiently achieved by iterating through possible substring lengths and checking if repeating the substring forms the original string. We will use a simple and efficient approach to handle the input and output requirements.\n", "requirement analysis:\nThe requirement is to determine if a given string is square. A string is considered square if it can be constructed by repeating a substring. This requires checking all possible substring lengths and verifying if repeating them forms the original string. The solution should be efficient and handle up to 100 test cases with strings of length between 1 and 100.\nrequirement pool:\n- Implement a function to check if a string is square\n- Handle multiple test cases efficiently\n- Ensure the solution is optimized for performance\n- Provide clear and concise output\n- Include error handling for invalid inputs\nTo determine if a string is square, we need to check if it can be constructed by repeating a substring. This involves iterating through possible substring lengths and verifying if repeating them forms the original string. We will use Python's string manipulation functions for simplicity and efficiency.\n", "requirement analysis:\nThe requirement is to determine if a given string is square based on the definition provided. The solution should be able to handle multiple test cases efficiently. The output should be clear and concise, with the option to output YES or NO in any case.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases.\n- Provide clear and concise output for each test case.\n- Optimize the solution for efficiency.\nWe will implement a function that checks if a given string is square based on the definition provided. The function will iterate through possible substring lengths, checking if the string can be constructed by repeating a substring. This approach will ensure scalability to handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirement to determine if a string is square involves checking if a string can be constructed by repeating a substring. This can be efficiently achieved by iterating through possible substring lengths and checking if the entire string can be formed by repeating a substring of that length. The solution should handle up to 100 test cases, each with strings of length between 1 and 100, ensuring scalability and efficiency.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases efficiently.\n- Provide clear and concise output for each test case.\nTo determine if a string is square, we will implement a function that checks if a given string can be constructed by repeating a substring. The approach involves iterating through possible substring lengths and verifying if the entire string can be formed by repeating a substring of that length. This method ensures efficiency and scalability, capable of handling up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, i.e., if it consists of a substring repeated consecutively. This involves checking if any substring of the string can be repeated to form the original string. The solution should be efficient and handle strings of lengths between 1 and 100 inclusively.\nrequirement pool:\n- Implement a function to check if a string is square\n- Ensure the function can handle up to 100 test cases\n- Provide clear output YES or NO for each test case\n- Optimize the function for performance\n- Include error handling for invalid inputs\nTo determine if a string is square, we need to check if it can be constructed by repeating a substring. This can be efficiently achieved by iterating through possible substring lengths and checking if repeating the substring forms the original string. We will use a simple and efficient approach to ensure compatibility with a wide range of inputs and provide clear and concise output.\n", "requirement analysis:\nThe requirement is to determine if a given string is square based on the definition provided. The solution should be efficient and handle up to 100 test cases with strings of length between 1 and 100. The output should be clear and concise, using 'YES' for square strings and 'NO' for non-square strings.\nrequirement pool:\n- Implement a function to check if a string is square\n- Ensure the function can handle up to 100 test cases\n- Provide clear output for each test case\n- Optimize the function for performance\n- Add user-friendly output options\nTo implement a function that checks if a string is square, we will use a straightforward approach. The function will iterate through possible substring lengths, checking if the string can be constructed by repeating a substring. This approach is efficient and suitable for handling the given constraints.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it consists of a substring repeated consecutively. This involves checking if any substring of the string can be repeated to form the original string. The solution should be efficient and handle up to 100 test cases with strings of lengths between 1 and 100 inclusive.\nrequirement pool:\n- Implement a function to check if a string is square\n- Handle up to 100 test cases\n- Ensure the function works for strings of lengths between 1 and 100\n- Optimize the function for performance\n- Provide clear and concise output\nTo determine if a string is square, we need to check if any substring of the string can be repeated to form the original string. We can achieve this by iterating through possible substring lengths and checking if repeating the substring forms the original string. This approach is efficient and leverages Python's string manipulation capabilities.\n", "requirement analysis:\nThe requirement is to determine if a given string is square based on the definition provided. A string is considered square if it can be constructed by repeating a substring. This requires checking all possible substring lengths and comparing them to the original string. The solution should be efficient enough to handle up to 100 test cases, each with strings of length between 1 and 100.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for handling large input strings.\nTo determine if a string is square, we need to check if it can be constructed by repeating a substring. This involves iterating through all possible substring lengths and comparing them to the original string. We will use a simple and efficient approach to ensure scalability for up to 100 test cases.\n", "requirement analysis:\nThe requirement is to determine if a given string is square, meaning it consists of a substring repeated consecutively. This involves checking if any substring of the string can be repeated to form the original string. The solution should be efficient and handle up to 100 test cases, each with strings of length between 1 and 100. The output should be clear and concise, with 'YES' indicating a square string and 'NO' indicating otherwise.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the code for handling large inputs and multiple test cases.\n- Enhance user interaction and feedback for better usability.\nTo determine if a string is square, we need to check if any substring of the string can be repeated to form the original string. This involves iterating through possible substring lengths and checking if repeating the substring forms the original string. We will use a simple and efficient approach to ensure scalability and handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirement to determine if a string is square involves checking if a string can be constructed by repeating a substring. This can be efficiently achieved by iterating through possible substring lengths and checking if repeating the substring forms the original string. The solution should handle up to 100 test cases, each with strings of length between 1 and 100, ensuring scalability and efficiency.\nrequirement pool:\n- Implement a function to check if a string is square.\n- Ensure the function can handle up to 100 test cases efficiently.\n- Provide clear output YES or NO for each test case.\n- Optimize the algorithm for large inputs to handle up to 100 test cases.\n- Ensure the solution is easy to understand and maintain.\nTo determine if a string is square, we need to check if it can be constructed by repeating a substring. This can be efficiently achieved by iterating through possible substring lengths and checking if repeating the substring forms the original string. We will use a simple and efficient approach to solve this problem.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 177, "examples": "\nInput\n\nThe first line of input data contains an integer t (1 \u2264 t \u2264 100) \u2014the number of test cases.\n\nThis is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.\n\nOutput\n\nFor each test case, output on a separate line:\n\n  * YES if the string in the corresponding test case is square, \n  * NO otherwise. \n\n\n\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\n\nExample\n\nInput\n\n\n10\na\naa\naaa\naaaa\nabab\nabcabc\nabacaba\nxxyy\nxyyx\nxyxy\n\n\nOutput\n\n\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nYES", "mutate_method": "rephrase_one", "parent_index": 137}
