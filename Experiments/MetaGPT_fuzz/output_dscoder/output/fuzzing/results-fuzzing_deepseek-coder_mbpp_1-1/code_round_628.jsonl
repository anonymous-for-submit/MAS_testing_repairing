{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 244, "prompt": "Write a python function to find the next perfect square greater than a given number. Ensure to handle large input values efficiently. Consider edge cases where the input number is very close to the next perfect square.", "code": "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN ", "test_imports": [], "test_list": ["assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(37) == 49", "assert next_Perfect_Square(37) == 49", "assert next_Perfect_Square(33) == 36", "assert next_Perfect_Square(33) == 36", "assert next_Perfect_Square(33) == 36", "assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(34) == 36", "assert next_Perfect_Square(39) == 49", "assert next_Perfect_Square(32) == 36", "assert next_Perfect_Square(31) == 36", "assert next_Perfect_Square(37) == 49", "assert next_Perfect_Square(31) == 36", "assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(39) == 49", "assert next_Perfect_Square(34) == 36", "assert next_Perfect_Square(38) == 49", "assert next_Perfect_Square(36) == 49", "assert next_Perfect_Square(32) == 36", "assert next_Perfect_Square(32) == 36", "assert next_Perfect_Square(36) == 49", "assert next_Perfect_Square(38) == 49", "assert next_Perfect_Square(31) == 36", "assert next_Perfect_Square(31) == 36", "assert next_Perfect_Square(34) == 36", "assert next_Perfect_Square(33) == 36", "assert next_Perfect_Square(31) == 36", "assert next_Perfect_Square(31) == 36", "assert next_Perfect_Square(32) == 36", "assert next_Perfect_Square(40) == 49", "assert next_Perfect_Square(30) == 36", "assert next_Perfect_Square(37) == 49", "assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(37) == 49", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(3) == 4", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(2) == 4", "assert next_Perfect_Square(2) == 4", "assert next_Perfect_Square(5) == 9", "assert next_Perfect_Square(2) == 4", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(3) == 4", "assert next_Perfect_Square(1) == 4", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(2) == 4", "assert next_Perfect_Square(10) == 16", "assert next_Perfect_Square(4) == 9", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(8) == 9", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(8) == 9", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(5) == 9", "assert next_Perfect_Square(1) == 4", "assert next_Perfect_Square(10) == 16", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(4) == 9", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(2) == 4", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(14) == 16", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(14) == 16", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(12) == 16", "assert next_Perfect_Square(14) == 16", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(5) == 9", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(5) == 9", "assert next_Perfect_Square(14) == 16", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(13) == 16", "assert next_Perfect_Square(4) == 9", "assert next_Perfect_Square(13) == 16", "assert next_Perfect_Square(4) == 9", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(5) == 9", "assert next_Perfect_Square(13) == 16", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(4) == 9", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(9) == 16", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(14) == 16", "assert next_Perfect_Square(7) == 9", "assert next_Perfect_Square(11) == 16", "assert next_Perfect_Square(4) == 9", "assert next_Perfect_Square(13) == 16", "assert next_Perfect_Square(6) == 9"], "entry_point": "next_Perfect_Square", "repair_prompt": ["Write a python function next_Perfect_Square to find the next perfect square greater than a given number. Ensure to handle large input values efficiently. Consider edge cases where the input number is very close to the next perfect square.\nnext_Perfect_Square(35) == 36\n"], "completions": ["from typing import List\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Calculate the next perfect square greater than the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.isqrt(n)\n    next_root = root + 1\n    return next_root * next_root\n\n# Example usage:\n# print(next_Perfect_Square(9))  # Output: 16\n# print(next_Perfect_Square(10)) # Output: 16\n# print(next_Perfect_Square(16)) # Output: 25\n", "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Finds the next perfect square greater than the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.sqrt(n)\n    next_root = math.ceil(root)\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square\n", "from typing import List\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Calculate the next perfect square greater than or equal to the given integer n.\n\n    Args:\n        n (int): The integer for which the next perfect square is to be found.\n\n    Returns:\n        int: The next perfect square greater than or equal to n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    sqrt_val = math.sqrt(n)\n    next_perfect_square = math.ceil(sqrt_val) ** 2\n    return next_perfect_square\n", "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Finds the next perfect square greater than the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.sqrt(n)\n    next_root = math.ceil(root)\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square\n", "from typing import List\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Finds the next perfect square greater than the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.sqrt(n)\n    next_root = math.ceil(root)\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square\n", "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Calculate the next perfect square greater than the given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.sqrt(n)\n    next_root = math.ceil(root)\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square\n", "from typing import List\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Calculate the next perfect square greater than the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.isqrt(n)\n    next_root = root + 1\n    next_perfect_square = next_root * next_root\n    \n    return next_perfect_square\n\n# Example usage:\n# print(next_Perfect_Square(12))  # Output: 16\n", "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Calculate the next perfect square after the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    sqrt_n = math.sqrt(n)\n    next_int = math.ceil(sqrt_n)\n    next_perfect_square = next_int * next_int\n    \n    return next_perfect_square\n", "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Calculate the next perfect square greater than the given number n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    sqrt_n = math.sqrt(n)\n    next_int = math.ceil(sqrt_n)\n    next_perfect_square = next_int * next_int\n    \n    return next_perfect_square\n", "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Finds the next perfect square greater than the given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.sqrt(n)\n    next_root = math.ceil(root)\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square\n"], "plans": ["requirement analysis:\nThe requirement is to create a Python function that finds the next perfect square greater than a given number. The function should be efficient and capable of handling large input values. Edge cases such as numbers very close to the next perfect square should also be handled correctly. The function should be simple and easy to understand, providing a good user experience.\nrequirement pool:\n- The main code should be efficient and handle large input values.\n- The function should correctly identify the next perfect square, even for numbers very close to it.\n- The function should be easy to understand and use.\n- The function should be optimized for performance.\n- Considerations should be made for edge cases.\nTo create an efficient and user-friendly function for finding the next perfect square, we will utilize Python's built-in math library. This approach ensures that the function is optimized for performance and can handle large input values effectively. We will also consider edge cases to ensure the function works correctly even when the input number is very close to the next perfect square.\n", "requirement analysis:\nThe requirement is to create a Python function that finds the next perfect square greater than a given number. The function should be efficient and capable of handling large input values. Edge cases such as numbers very close to the next perfect square should also be considered.\nrequirement pool:\n- The function should return the next perfect square efficiently\n- The function should handle large input values without performance issues\n- The function should handle edge cases where the input number is very close to the next perfect square\n- The function should be easy to understand and use\nTo create a Python function that efficiently finds the next perfect square greater than a given number, we will utilize Python's built-in math library to handle the square root calculations. This approach ensures that the function can handle large input values and edge cases effectively. The function will first calculate the square root of the input number, round it up to the next whole number, and then square this value to find the next perfect square.\n", "requirement analysis:\nThe requirement is to create a Python function that finds the next perfect square greater than a given number. The function should be efficient and capable of handling large inputs. Edge cases to consider include numbers very close to the next perfect square. The function should return the next perfect square accurately and quickly.\nrequirement pool:\n- Implement the function to find the next perfect square accurately.\n- Ensure the function can handle large input values efficiently.\n- Include error handling for edge cases where the input number is very close to the next perfect square.\n- Optimize the function for performance to handle large inputs.\nTo implement the function efficiently, we will use Python's built-in math library to calculate square roots and then round up to the nearest integer to find the next perfect square. This approach leverages Python's speed and efficiency without the need for complex libraries.\n", "requirement analysis:\nThe requirement is to create a Python function that finds the next perfect square greater than a given number. The function should be efficient and capable of handling large inputs. Edge cases such as numbers very close to the next perfect square should also be considered. The function should be simple and easy to understand, providing a good user experience.\nrequirement pool:\n- The main code should be efficient in finding the next perfect square.\n- The function should handle large input values without performance issues.\n- The function should be easy to understand and use.\n- The function should handle edge cases where the input number is very close to the next perfect square.\n- The function should be optimized for readability and maintainability.\nTo create an efficient and user-friendly function that finds the next perfect square greater than a given number, we will utilize Python's built-in math library. This approach ensures compatibility with large input values and handles edge cases effectively. The function will be optimized for readability and maintainability, providing a simple interface for users.\n", "requirement analysis:\nThe function should be able to handle both small and large input values efficiently. It should accurately find the next perfect square, even if the input number is very close to the next perfect square. The function should be robust against edge cases and handle potential errors gracefully.\nrequirement pool:\n- The main code should be optimized for performance.\n- The function should accurately find the next perfect square.\n- The function should handle large input values efficiently.\n- The function should gracefully handle edge cases.\n- The function should include error handling for invalid inputs.\nTo create an efficient and user-friendly function that finds the next perfect square greater than a given number, we will leverage Python's built-in math functions for simplicity and performance. The function will use the square root of the input number to determine the next perfect square, ensuring efficiency even for large input values.\n", "requirement analysis:\nThe requirement is to create a Python function that finds the next perfect square greater than a given number. The function should be efficient and capable of handling large inputs. Edge cases to consider include numbers very close to the next perfect square.\nrequirement pool:\n- The main code should be optimized for performance.\n- The function should handle large numbers efficiently.\n- The function should return the next perfect square even when the input is very close to the next perfect square.\n- The function should be tested for accuracy and efficiency.\n- Considerations for edge cases should be thoroughly tested.\nTo create an efficient function that finds the next perfect square greater than a given number, we will leverage Python's built-in math functions for square roots. The approach involves calculating the square root of the input number, rounding it up to the next whole number, and then squaring this number to find the next perfect square. This method ensures that the function handles large numbers efficiently without the need for complex algorithms.\n", "requirement analysis:\nThe requirement is to create a Python function that finds the next perfect square greater than a given number. The function should be efficient and capable of handling large inputs. Edge cases to consider include numbers that are already close to the next perfect square.\nrequirement pool:\n- Implement the function to find the next perfect square\n- Ensure the function can handle large numbers efficiently\n- Test the function with edge cases\n- Optimize the function for performance\n- Document the function and provide examples of usage\nTo implement the function efficiently, we will use Python's built-in math library to calculate square roots and then manipulate these values to find the next perfect square. This approach leverages Python's speed and efficiency without the need for complex libraries.\n", "requirement analysis:\nThe function should be able to handle both small and large input values efficiently. It should be able to identify the next perfect square accurately, even if the input number is very close to the next perfect square. The function should be robust against edge cases and handle them gracefully.\nrequirement pool:\n- Implement the function to find the next perfect square greater than a given number.\n- Ensure the function can handle large input values efficiently.\n- Implement error handling for edge cases.\n- Optimize the function for performance.\n- Include documentation and examples for user guidance.\nTo implement the function efficiently, we will use Python's built-in math functions for square roots. The function will calculate the square root of the given number, round it up to the next whole number, and then square this number to find the next perfect square. This approach ensures that the function can handle large input values efficiently without the need for external libraries like NumPy.\n", "requirement analysis:\nThe function should be able to handle large numbers efficiently, returning the next perfect square greater than the given input. It should also handle edge cases where the input number is very close to the next perfect square. The function should be simple and easy to understand, providing a good user experience.\nrequirement pool:\n- Implement the function to find the next perfect square efficiently.\n- Ensure the function can handle large input values.\n- Include error handling for edge cases.\n- Optimize the function for performance.\n- Provide clear documentation and examples for user guidance.\nTo implement the `next_Perfect_Square` function efficiently, we will use Python's built-in math functions for square roots. The function will calculate the square root of the input number, round it up to the next whole number, and then square this number to find the next perfect square. This approach ensures that the function can handle large input values and edge cases effectively.\n", "requirement analysis:\nThe function should be able to handle both small and large input values efficiently. It should be able to identify the next perfect square accurately, even when the input number is very close to the next perfect square. The function should be robust against edge cases and handle them gracefully.\nrequirement pool:\n- The main code should be optimized for performance.\n- The function should accurately find the next perfect square.\n- The function should handle large input values without crashing.\n- The function should be able to handle edge cases effectively.\n- The function should have a user-friendly interface.\nTo create an efficient and user-friendly function that finds the next perfect square greater than a given number, we will utilize Python's built-in math functions for square roots. The function will first calculate the square root of the input number, then round it up to the next whole number, and finally square this number to get the next perfect square. This approach ensures that the function handles large input values efficiently and accurately identifies the next perfect square, even when the input number is very close to the next perfect square.\n"], "test": ["def check(next_Perfect_Square):\n\tassert next_Perfect_Square(35) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(37) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(37) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(33) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(33) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(33) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(35) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(34) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(39) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(32) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(31) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(37) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(31) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(35) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(39) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(34) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(38) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(36) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(32) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(32) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(36) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(38) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(31) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(31) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(34) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(33) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(31) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(31) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(32) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(40) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(30) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(37) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(35) == 36", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(37) == 49", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(3) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(2) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(2) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(5) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(2) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(3) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(1) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(2) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(10) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(4) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(8) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(8) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(5) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(1) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(10) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(4) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(2) == 4", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(14) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(14) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(12) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(14) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(5) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(5) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(14) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(13) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(4) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(13) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(4) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(5) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(13) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(4) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(9) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(14) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(7) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(11) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(4) == 9", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(13) == 16", "def check(next_Perfect_Square):\n\tassert next_Perfect_Square(6) == 9"], "scores": [1.0, 0.8333, 0.8333, 0.8333, 0.8333, 0.8333, 1.0, 0.8333, 0.8333, 0.8333], "pass_results": [true, false, false, false, false, false, true, false, false, false], "pass_test_cases_num": [102, 85, 85, 85, 85, 85, 102, 85, 85, 85], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef next_Perfect_Square(n: int) -> int:\n    \"\"\"\n    Finds the next perfect square greater than the given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The next perfect square greater than the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    root = math.sqrt(n)\n    next_root = math.ceil(root)\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square\n", "passed": true, "pass": true, "pass_num": 2, "round": 628, "mutate_method": "add_1_sentence_at_end", "parent_index": 339}
