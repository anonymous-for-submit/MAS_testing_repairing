{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 803, "prompt": "Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ Consider edge cases such as negative numbers and zero. Ensure that the function handles very large integers efficiently.", "code": "def is_perfect_square(n) :\n    i = 1\n    while (i * i<= n):\n        if ((n % i == 0) and (n / i == i)):\n            return True     \n        i = i + 1\n    return False", "test_imports": [], "test_list": ["assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(6) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(41) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(33) == False", "assert is_Perfect_Square(41) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(38) == False", "assert is_Perfect_Square(34) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(38) == False", "assert is_Perfect_Square(32) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(32) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(12) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(18) == False", "assert is_Perfect_Square(17) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(18) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(17) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(14) == False"], "entry_point": "is_Perfect_Square", "repair_prompt": ["Write a function is_Perfect_Square to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ Consider edge cases such as negative numbers and zero. Ensure that the function handles very large integers efficiently.\nis_Perfect_Square(10) == False\n"], "completions": ["from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given integer n is a perfect square.\n\n    Args:\n        n (int): The integer to check.\n\n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    \n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n <= 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n <= 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    \n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    The function takes an integer n as input and returns a boolean indicating whether n is a perfect square.\n    \n    Args:\n        n (int): The integer to check for perfect square.\n        \n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square.\n- The function should handle edge cases such as negative numbers and zero.\n- The function should be optimized for performance, especially for very large numbers.\n- The function should be easy to understand and maintain.\n- The function should be compatible with a wide range of Python versions.\nTo create an efficient and accurate function to check for perfect squares, we will utilize Python's built-in capabilities, specifically focusing on the math library for mathematical operations. This approach ensures that we leverage tested and optimized code for checking the square root and integer properties. We will also handle edge cases such as negative numbers and zero by explicitly checking for their validity before proceeding with the square root calculation.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers. The function should be written in Python, leveraging Python's capabilities for handling large integers.\nrequirement pool:\n- The function should accurately determine if a number is a perfect square\n- The function should handle negative numbers and zero correctly\n- The function should be efficient and capable of handling very large integers\n- The function should be well-documented and easy to understand\n- The function should be tested for various edge cases\nTo create an efficient and accurate function to check for perfect squares, we will leverage Python's built-in capabilities for handling large integers. The function will use the `math.isqrt` function to compute the integer square root of the given number. This function is efficient and handles very large integers well. We will also handle edge cases such as negative numbers and zero by returning False for such inputs.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers. The function should be written in Python, leveraging Python's capabilities for efficient numerical operations.\nrequirement pool:\n- The main code should be efficient and handle large integers\n- The function should correctly identify perfect squares and non-perfect squares\n- The function should handle edge cases such as negative numbers and zero\n- The function should be easy to understand and maintain\nTo create an efficient and accurate function to check for perfect squares, we will leverage Python's built-in capabilities for numerical operations. Specifically, we will use the `math.isqrt` function to compute the integer square root of the given number. This function is efficient and handles large integers well. We will also handle edge cases such as negative numbers and zero by returning False for such inputs. The function will return True if the square root is an integer, indicating that the number is a perfect square.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square\n- The function should handle negative numbers and zero correctly\n- The solution should be efficient and capable of handling large integers\n- The code should be well-documented for easy understanding\n- The function should be tested for a variety of inputs to ensure accuracy\nTo create a function that accurately determines if a number is a perfect square, we will leverage Python's built-in math library to calculate the square root of the given number. We will then check if the square root is an integer. This approach ensures efficiency and accuracy. For handling edge cases such as negative numbers and zero, we will include specific checks at the beginning of the function.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square.\n- The function should handle edge cases such as negative numbers and zero.\n- The function should be efficient enough to handle very large integers.\n- The function should be easy to understand and maintain.\n- The function should be compatible with Python's standard library.\nTo create an efficient and accurate function to check for perfect squares, we will utilize Python's built-in math library. This approach ensures that the function is both fast and reliable, leveraging Python's capabilities for handling large integers efficiently. The function will first check if the number is non-negative, as negative numbers cannot be perfect squares. For non-negative numbers, we will compute the square root and check if the result is an integer. This method ensures that the function can handle very large integers without performance issues.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers. The function should be written in Python, leveraging Python's capabilities for handling large integers.\nrequirement pool:\n- The function should accurately determine if a number is a perfect square\n- The function should handle negative numbers and zero correctly\n- The function should be efficient and capable of handling very large integers\n- The function should be well-documented and easy to understand\n- The function should be tested for various edge cases\nTo create an efficient and accurate function to check for perfect squares, we will leverage Python's built-in capabilities for handling large integers. The function will use the `math.isqrt` function to compute the integer square root of the given number. This function is efficient and well-suited for handling very large integers. We will also handle edge cases such as negative numbers and zero by returning False for such inputs.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers. The function should be written in Python, which supports large integers natively, making it suitable for handling very large numbers efficiently.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square.\n- The function should handle negative numbers and zero correctly.\n- The function should be efficient and capable of handling very large integers.\n- The function should be documented and easy to understand.\n- The function should be tested for various inputs to ensure reliability.\nTo create an efficient and accurate function to check for perfect squares, we will utilize Python's built-in capabilities for handling large integers and the math library for mathematical operations. The function will first check if the number is non-negative, as negative numbers cannot be perfect squares. For non-negative numbers, we will calculate the integer square root using Python's math.isqrt function, which is efficient and handles large integers well. If the square of this integer root equals the original number, then the number is a perfect square. Otherwise, it is not.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers. The function should be written in Python, leveraging Python's capabilities for efficient numerical computations.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square\n- The function should handle negative numbers and zero correctly\n- The function should be optimized for performance, especially with large integers\n- The function should be well-documented for easy understanding and use\n- The function should be tested for various edge cases to ensure reliability\nTo create an efficient and accurate function to check for perfect squares, we will leverage Python's built-in capabilities for numerical computations. Specifically, we will use the math library to calculate the integer square root of the given number. This approach ensures that we can handle very large integers efficiently. We will also handle edge cases such as negative numbers and zero by explicitly checking for these conditions.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square.\n- The function should handle edge cases such as negative numbers and zero.\n- The function should be optimized for performance, especially with very large integers.\n- The function should be easy to integrate into other projects.\n- The function should have a clear and simple user interface.\nWe will use Python's built-in math library to check if the square root of the given number is an integer. This approach is efficient and leverages Python's standard library for mathematical operations.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, and should be efficient enough to handle very large integers. The function should be simple and easy to understand, with clear documentation.\nrequirement pool:\n- The function should accurately determine if a number is a perfect square.\n- The function should handle negative numbers and zero correctly.\n- The function should be efficient and capable of handling very large integers.\n- The function should have clear and concise documentation.\n- The function should be easy to understand and use.\nWe will use Python's built-in 'math' module to calculate the integer square root of the given number. This method, 'math.isqrt', is efficient and handles large integers well. We will then check if the square of this integer root equals the original number. This approach ensures accuracy and efficiency.\n"], "test": ["def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(6) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(41) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(33) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(41) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(38) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(34) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(38) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(32) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(32) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(12) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(18) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(17) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(18) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(17) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n", "passed": true, "pass": true, "pass_num": 10, "round": 731, "mutate_method": "add_1_sentence_at_end", "parent_index": 608}
