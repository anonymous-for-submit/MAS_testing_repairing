{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 96, "prompt": "Craft a python function that computes the number of divisors for a given integer.", "code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x", "test_imports": [], "test_list": ["assert divisor(15) == 4 ", "assert divisor(12) == 6", "assert divisor(9) == 3", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(12) == 6", "assert divisor(19) == 2", "assert divisor(15) == 4", "assert divisor(10) == 4", "assert divisor(14) == 4", "assert divisor(14) == 4", "assert divisor(13) == 2", "assert divisor(10) == 4", "assert divisor(16) == 5", "assert divisor(11) == 2", "assert divisor(20) == 6", "assert divisor(18) == 6", "assert divisor(14) == 4", "assert divisor(18) == 6", "assert divisor(10) == 4", "assert divisor(10) == 4", "assert divisor(17) == 2", "assert divisor(12) == 6", "assert divisor(16) == 5", "assert divisor(14) == 4", "assert divisor(16) == 5", "assert divisor(13) == 2", "assert divisor(20) == 6", "assert divisor(20) == 6", "assert divisor(19) == 2", "assert divisor(15) == 4", "assert divisor(11) == 2", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(19) == 2", "assert divisor(12) == 6", "assert divisor(8) == 4", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(11) == 2", "assert divisor(10) == 4", "assert divisor(11) == 2", "assert divisor(12) == 6", "assert divisor(13) == 2", "assert divisor(17) == 2", "assert divisor(15) == 4", "assert divisor(14) == 4", "assert divisor(14) == 4", "assert divisor(9) == 3", "assert divisor(7) == 2", "assert divisor(15) == 4", "assert divisor(7) == 2", "assert divisor(9) == 3", "assert divisor(13) == 2", "assert divisor(7) == 2", "assert divisor(12) == 6", "assert divisor(15) == 4", "assert divisor(15) == 4", "assert divisor(14) == 4", "assert divisor(8) == 4", "assert divisor(11) == 2", "assert divisor(17) == 2", "assert divisor(9) == 3", "assert divisor(11) == 2", "assert divisor(9) == 3", "assert divisor(10) == 4", "assert divisor(15) == 4", "assert divisor(16) == 5", "assert divisor(8) == 4", "assert divisor(6) == 4", "assert divisor(14) == 4", "assert divisor(12) == 6", "assert divisor(9) == 3", "assert divisor(10) == 4", "assert divisor(10) == 4", "assert divisor(4) == 3", "assert divisor(10) == 4", "assert divisor(8) == 4", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(4) == 3", "assert divisor(12) == 6", "assert divisor(14) == 4", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(4) == 3", "assert divisor(13) == 2", "assert divisor(5) == 2", "assert divisor(13) == 2", "assert divisor(11) == 2", "assert divisor(12) == 6", "assert divisor(12) == 6", "assert divisor(10) == 4", "assert divisor(7) == 2", "assert divisor(13) == 2", "assert divisor(6) == 4", "assert divisor(14) == 4", "assert divisor(11) == 2", "assert divisor(4) == 3", "assert divisor(8) == 4"], "entry_point": "divisor", "repair_prompt": ["Craft a python function divisor that computes the number of divisors for a given integer.\ndivisor(15) == 4 \n"], "completions": ["from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Computes the number of divisors of a given integer n.\n    \n    Args:\n        n (int): The integer for which we need to compute the number of divisors.\n        \n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Compute the prime factorization of n\n    prime_factors = []\n    while n % 2 == 0:\n        prime_factors.append(2)\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    if n > 2:\n        prime_factors.append(n)\n    \n    # Count the frequency of each prime factor\n    from collections import Counter\n    prime_factor_count = Counter(prime_factors)\n    \n    # Calculate the number of divisors\n    num_divisors = 1\n    for count in prime_factor_count.values():\n        num_divisors *= (count + 1)\n    \n    return num_divisors\n\n# Example usage:\n# print(divisor(12))  # Output: 6\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n\n    Raises:\n        ValueError: If the input is not a valid integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n\n# Example usage:\nif __name__ == \"__main__\":\n    try:\n        print(divisor(12))  # Output: 6\n        print(divisor(15))  # Output: 4\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 0:\n        n = -n  # Handle negative numbers by considering their positive counterparts\n\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Computes the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to compute the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n", "from typing import List\n## main.py\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Computes the number of divisors of a given integer n.\n    \n    Args:\n        n (int): The integer to compute the divisors for.\n        \n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n    \n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n    return divisor_count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Computes the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to compute the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 2:\n        return 1\n\n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Computes the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to compute the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n    return divisor_count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 1\n    original_n = n\n    \n    # Check for the number of 2s that divide n\n    while n % 2 == 0:\n        count += 1\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(math.sqrt(original_n)) + 1, 2):\n        exp = 0\n        while n % i == 0:\n            exp += 1\n            n //= i\n        count *= (exp + 1)\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 1:\n        count *= 2\n    \n    return count\n", "from typing import List\nimport math\nfrom collections import Counter\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the number of divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize the count of divisors\n    divisor_count = 0\n\n    # Iterate through possible divisors up to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n\n# Example usage:\n# print(divisor(28))  # Output: 6\n"], "plans": ["requirement analysis:\nThe requirement is to create a Python function that computes the number of divisors for a given integer. This function should be efficient and capable of handling large integers. The user interface should be simple and straightforward, allowing users to input an integer and receive the number of divisors as output.\nrequirement pool:\n- Implement the divisor function to accurately compute the number of divisors for a given integer\n- Ensure the function is optimized for performance, especially for large integers\n- Develop a user-friendly interface for easy interaction with the divisor function\n- Include error handling for invalid inputs such as non-integer values\n- Provide documentation and examples to guide users on how to use the divisor function\nTo create an efficient and accurate divisor computation function, we will utilize the properties of prime factorization. The number of divisors of a number can be determined from its prime factorization. For a number n with prime factorization n = p1^e1 * p2^e2 * ... * pk^ek, the number of divisors is given by (e1 + 1) * (e2 + 1) * ... * (ek + 1). We will use this approach to compute the number of divisors efficiently.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This involves understanding the mathematical properties of numbers and implementing an efficient algorithm to count the divisors. The function should be simple to use and integrate, capable of handling basic to moderately large numbers.\nrequirement pool:\n- The main code should be concise and readable, using efficient algorithms for divisor counting.\n- The function should handle both small and large integers efficiently.\n- Include error handling for non-integer inputs to ensure robustness.\n- Provide clear documentation and examples for user guidance.\n- Optimize the function for performance, especially for large numbers.\nTo create an efficient and accurate divisor computation function, we will utilize the mathematical properties of numbers and implement an algorithm that counts the divisors. The function will be optimized for performance, ensuring it can handle both small and large integers efficiently. Error handling will be included for non-integer inputs to ensure robustness, and clear documentation and examples will be provided for user guidance.\n", "requirement analysis:\nThe requirement is to create a function that computes the number of divisors for a given integer. This involves understanding the mathematical properties of numbers and implementing an efficient algorithm to count divisors. The function should be simple to use and integrate, capable of handling a range of integers, and optimized for performance.\nrequirement pool:\n- Implement an efficient algorithm to count divisors\n- Ensure the function is easy to integrate into other projects\n- Optimize the function for handling large numbers\n- Provide clear documentation and examples for user guidance\n- Extend functionality to include divisor-related properties\nTo implement the divisor function efficiently, we will use a combination of mathematical properties and algorithmic optimizations. The function will iterate through possible divisors up to the square root of the given number, leveraging the fact that divisors come in pairs. This approach significantly reduces the number of iterations needed for large numbers, ensuring optimal performance.\n", "requirement analysis:\nThe requirement is to create a Python function that computes the number of divisors for a given integer. This function should be efficient and handle both small and large numbers. The function should be easy to integrate into other projects and provide clear and accurate results.\nrequirement pool:\n- The main code should be efficient in computing the number of divisors\n- The function should handle large integers efficiently\n- The function should be easy to integrate into other Python projects\n- The function should provide clear and accurate results\n- The function should be optimized for performance\nTo create an efficient and accurate divisor computation function, we will utilize the 'math' module in Python, which provides a 'sqrt' function that can help reduce the number of iterations needed to compute the divisors. This approach will ensure that the function handles large numbers efficiently. Additionally, we will optimize the function by avoiding unnecessary computations and leveraging Python's built-in functions for simplicity and readability.\n", "requirement analysis:\nThe requirement is to create a Python function that computes the number of divisors for a given integer. The function should be efficient and handle large integers. The user interface should be simple and easy to use.\nrequirement pool:\n- Implement the divisor function efficiently\n- Ensure the function can handle large integers\n- Develop a user-friendly interface for easy interaction\n- Test and validate the function with various test cases\n- Optimize the code for better performance\nTo create an efficient and accurate divisor computation function, we will utilize the 'math' module in Python, which provides a method to compute the greatest common divisor (GCD). This will help in optimizing the divisor computation by leveraging the properties of divisors. We will also use a simple brute-force approach for counting the divisors, which is efficient enough for typical use cases.\n", "requirement analysis:\nThe requirement is to create a Python function that computes the number of divisors for a given integer. The function should be efficient and handle large integers. The user interface should be simple and easy to use.\nrequirement pool:\n- Implement the divisor function efficiently\n- Ensure the function can handle large integers\n- Develop a user-friendly interface for easy interaction\n- Test and validate the function with various test cases\n- Optimize the code for performance\nTo implement the divisor function efficiently and handle large integers, we will use a combination of mathematical algorithms and Python's built-in capabilities. The function will use the trial division method to count divisors, which is simple and effective for this purpose. We will also optimize the algorithm to handle large numbers efficiently by reducing the number of iterations through mathematical properties of divisors.\n", "requirement analysis:\nThe requirement is to create a Python function that computes the number of divisors for a given integer. This function should be efficient and handle basic cases well. It should be easy to integrate into other projects and provide clear results.\nrequirement pool:\n- The main code should be efficient in computing divisors\n- The function should handle basic cases correctly\n- The function should be easy to integrate into other projects\n- The output should be clear and easy to understand\n- The function should be optimized for performance\nTo create an efficient and accurate divisor computation function, we will utilize the properties of prime factorization. The function will first determine if a number is prime, and if not, it will iterate through potential divisors up to the square root of the number. This approach minimizes the number of operations needed to find divisors, ensuring optimal performance. The function will be designed to handle basic cases correctly and will be easy to integrate into other projects.\n", "requirement analysis:\nThe requirement is to create a function that computes the number of divisors for a given integer. This involves understanding the mathematical properties of numbers and implementing an efficient algorithm to count the divisors. The function should be simple to use and integrate, capable of handling a range of integers, and optimized for performance.\nrequirement pool:\n- The main code should be efficient in computing the number of divisors\n- The function should be easy to integrate into other projects\n- The function should handle a wide range of integers\n- The function should provide clear and accurate results\n- The function should be optimized for performance\nTo create an efficient and accurate divisor computation function, we will utilize the mathematical properties of numbers and implement an algorithm that counts the divisors. We will leverage Python's built-in functions and libraries to ensure the function is optimized for performance and easy to integrate into other projects. The function will handle a wide range of integers, providing clear and accurate results.\n", "requirement analysis:\nThe requirement is to create a Python function that calculates the number of divisors for a given integer. This is a fundamental mathematical operation that can be used in various applications, including number theory, cryptography, and statistics. The function should be efficient and capable of handling large integers.\nrequirement pool:\n- The main code should be optimized for speed and accuracy\n- The function should handle edge cases such as negative numbers and zero\n- Implement a user-friendly interface for easy input and output\n- Ensure the function is tested for various inputs to verify correctness\n- Include documentation and examples to guide users\nTo create an efficient and accurate divisor computation function, we will utilize the properties of prime factorization. The number of divisors of a number can be determined from its prime factorization. For a number n with prime factorization n = p1^e1 * p2^e2 * ... * pk^ek, the number of divisors is given by (e1 + 1) * (e2 + 1) * ... * (ek + 1). We will implement this approach in Python, leveraging the math library for efficient prime factorization.\n", "requirement analysis:\nThe requirement is to create a Python function that computes the number of divisors for a given integer. The function should be efficient and handle large integers. The user interface should be simple and easy to use.\nrequirement pool:\n- Implement the divisor function efficiently\n- Ensure the function can handle large integers\n- Develop a user-friendly interface for easy interaction\n- Test and validate the function with various test cases\n- Optimize the function for performance\nTo implement the divisor function efficiently and handle large integers, we will utilize the 'math' module for mathematical operations and 'collections.Counter' for counting the frequency of divisors. The function will iterate through possible divisors up to the square root of the given integer, counting the divisors efficiently.\n"], "test": ["def check(divisor):\n\tassert divisor(15) == 4 ", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(18) == 6", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(18) == 6", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(6) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(5) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(6) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(8) == 4"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\nimport math\nfrom collections import Counter\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the number of divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize the count of divisors\n    divisor_count = 0\n\n    # Iterate through possible divisors up to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n\n# Example usage:\n# print(divisor(28))  # Output: 6\n", "passed": true, "pass": true, "pass_num": 10, "round": 751, "mutate_method": "rephrase_one", "parent_index": 571}
