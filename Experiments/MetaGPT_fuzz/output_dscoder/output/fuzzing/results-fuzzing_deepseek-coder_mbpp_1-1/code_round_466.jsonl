{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 96, "prompt": "Write a python function to determine the count of divisors for a specified integer.", "code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x", "test_imports": [], "test_list": ["assert divisor(15) == 4 ", "assert divisor(12) == 6", "assert divisor(9) == 3", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(12) == 6", "assert divisor(19) == 2", "assert divisor(15) == 4", "assert divisor(10) == 4", "assert divisor(14) == 4", "assert divisor(14) == 4", "assert divisor(13) == 2", "assert divisor(10) == 4", "assert divisor(16) == 5", "assert divisor(11) == 2", "assert divisor(20) == 6", "assert divisor(18) == 6", "assert divisor(14) == 4", "assert divisor(18) == 6", "assert divisor(10) == 4", "assert divisor(10) == 4", "assert divisor(17) == 2", "assert divisor(12) == 6", "assert divisor(16) == 5", "assert divisor(14) == 4", "assert divisor(16) == 5", "assert divisor(13) == 2", "assert divisor(20) == 6", "assert divisor(20) == 6", "assert divisor(19) == 2", "assert divisor(15) == 4", "assert divisor(11) == 2", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(19) == 2", "assert divisor(12) == 6", "assert divisor(8) == 4", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(11) == 2", "assert divisor(10) == 4", "assert divisor(11) == 2", "assert divisor(12) == 6", "assert divisor(13) == 2", "assert divisor(17) == 2", "assert divisor(15) == 4", "assert divisor(14) == 4", "assert divisor(14) == 4", "assert divisor(9) == 3", "assert divisor(7) == 2", "assert divisor(15) == 4", "assert divisor(7) == 2", "assert divisor(9) == 3", "assert divisor(13) == 2", "assert divisor(7) == 2", "assert divisor(12) == 6", "assert divisor(15) == 4", "assert divisor(15) == 4", "assert divisor(14) == 4", "assert divisor(8) == 4", "assert divisor(11) == 2", "assert divisor(17) == 2", "assert divisor(9) == 3", "assert divisor(11) == 2", "assert divisor(9) == 3", "assert divisor(10) == 4", "assert divisor(15) == 4", "assert divisor(16) == 5", "assert divisor(8) == 4", "assert divisor(6) == 4", "assert divisor(14) == 4", "assert divisor(12) == 6", "assert divisor(9) == 3", "assert divisor(10) == 4", "assert divisor(10) == 4", "assert divisor(4) == 3", "assert divisor(10) == 4", "assert divisor(8) == 4", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(4) == 3", "assert divisor(12) == 6", "assert divisor(14) == 4", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(4) == 3", "assert divisor(13) == 2", "assert divisor(5) == 2", "assert divisor(13) == 2", "assert divisor(11) == 2", "assert divisor(12) == 6", "assert divisor(12) == 6", "assert divisor(10) == 4", "assert divisor(7) == 2", "assert divisor(13) == 2", "assert divisor(6) == 4", "assert divisor(14) == 4", "assert divisor(11) == 2", "assert divisor(4) == 3", "assert divisor(8) == 4"], "entry_point": "divisor", "repair_prompt": ["Write a python function divisor to determine the count of divisors for a specified integer.\ndivisor(15) == 4 \n"], "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The count of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The count of divisors of the given integer.\n\n    Raises:\n        ValueError: If the input is not a valid integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    if n == 0:\n        return 0\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\n# Example usage:\n# print(divisor(12))  # Output: 6\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The integer for which to calculate the number of divisors.\n\n    Returns:\n        int: The count of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 2  # i and n // i are both divisors\n        i += 1\n\n    if i * i == n:\n        count -= 1  # Adjust for the square root being counted twice\n\n    return count\n", "from typing import List\n## main.py\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The count of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The count of divisors of the given integer.\n    \"\"\"\n    if n <= 0:\n        return 0\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n\n    return count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer efficiently.\n    \n    Args:\n        n (int): The integer for which to calculate the number of divisors.\n        \n    Returns:\n        int: The count of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n    \n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    Args:\n        n (int): The integer for which we need to find the number of divisors.\n\n    Returns:\n        int: The number of divisors of the given integer.\n\n    Raises:\n        ValueError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError('Input must be an integer')\n    \n    n = abs(n)  # Handle both positive and negative integers\n    count = 0\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    \n    return count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The count of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 1\n            if i != n // i:\n                divisor_count += 1\n\n    return divisor_count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    The function takes an integer n and returns the count of its divisors.\n    \n    Args:\n        n (int): The integer to count the divisors of.\n        \n    Returns:\n        int: The count of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The input number must be a positive integer.\")\n    \n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 2  # i and n // i are both divisors\n            if i == n // i:  # If i is the square root of n, only count it once\n                divisor_count -= 1\n    \n    return divisor_count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    The function takes an integer n and returns the count of its divisors.\n    \n    Args:\n        n (int): The integer to count the divisors of.\n        \n    Returns:\n        int: The count of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The input number must be greater than or equal to 1.\")\n    \n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 2  # i and n // i are both divisors\n    \n    # If n is a perfect square, we have counted the square root twice, so subtract one\n    if sqrt_n * sqrt_n == n:\n        divisor_count -= 1\n    \n    return divisor_count\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should accurately calculate the number of divisors for a given integer.\n- The function should be optimized for performance, especially for large integers.\n- The function should handle edge cases, such as negative numbers and zero.\n- The function should include proper documentation and comments for easy understanding.\n- The function should be tested with various test cases to ensure accuracy and robustness.\nTo create a function that calculates the number of divisors for a given integer efficiently, we will use a straightforward approach. The function will iterate through possible divisors up to the square root of the given number, checking if they divide the number without a remainder. This method is efficient and suitable for both small and large integers.\n", "requirement analysis:\nThe requirement is to create a Python function that calculates the number of divisors for a given integer. The function should be efficient and handle both small and potentially large numbers. The user interface should be simple and intuitive, allowing users to input an integer and receive the count of its divisors instantly.\nrequirement pool:\n- Implement a function that accurately counts divisors for any given integer.\n- Ensure the function is optimized for performance, especially for large numbers.\n- Develop a user-friendly interface for easy input and output of divisor counts.\n- Include error handling to manage invalid inputs, such as non-integer values.\n- Design a clean and modern UI for the application.\nTo implement the function that calculates the number of divisors for a given integer efficiently, we will use a combination of Python's built-in functions and a simple algorithm. The function will iterate through possible divisors up to the square root of the given number, which is an efficient approach for large numbers. We will also handle edge cases, such as negative numbers and zero, by returning an error message or a specific count based on the definition of divisors.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should be efficient in calculating divisors.\n- The function should handle both positive and negative integers.\n- Implement error handling for non-integer inputs.\n- Include a function to test the divisor function with various test cases.\n- Optimize the function for large numbers to ensure performance.\nTo create a function that calculates the number of divisors for a given integer efficiently, we will utilize the properties of divisors and the mathematical nature of numbers. We will iterate through possible divisors up to the square root of the given number, which significantly reduces the number of iterations needed for large numbers. This approach will be implemented in Python, leveraging its efficient handling of large integers.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should accurately calculate the number of divisors for a given integer.\n- The function should be optimized for performance, especially for large integers.\n- The function should handle edge cases, such as negative numbers and zero.\n- The function should include proper documentation and comments for easy understanding.\n- The function should be tested with various test cases to ensure accuracy and robustness.\nTo create a function that calculates the number of divisors for a given integer efficiently, we will use a straightforward approach. The function will iterate through possible divisors up to the square root of the given number, checking if they divide the number without a remainder. This method is efficient and suitable for both small and large integers.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should accurately count the divisors of a given integer.\n- The function should be optimized for performance, especially for large numbers.\n- The function should handle edge cases, such as negative numbers and zero.\n- The function should be well-documented and include a clear description of its purpose and usage.\n- The function should be tested thoroughly to ensure accuracy and reliability.\nTo create a function that calculates the number of divisors for a given integer efficiently, we will use a straightforward approach that iterates through possible divisors up to the square root of the given number. This method is efficient and suitable for handling both small and large integers. We will also handle edge cases such as negative numbers and zero by returning appropriate results based on the definition of divisors.\n", "requirement analysis:\nThe original requirement is to create a function that calculates the number of divisors for a given integer. This is a fundamental mathematical operation that can be useful in various applications, including number theory and cryptography. The function should be efficient and able to handle large numbers. The user interface should be simple and intuitive, making it easy for users to input the number and view the result.\nrequirement pool:\n- The main code should be efficient in calculating the number of divisors.\n- The user interface should be simple and easy to use.\n- The function should handle large numbers efficiently.\n- The product should include basic error handling for invalid inputs.\n- The product should include a feature to display the divisors list.\nTo create a function that calculates the number of divisors for a given integer efficiently, we will use a combination of mathematical optimization techniques and Python's built-in libraries. The function will iterate through possible divisors up to the square root of the given number, which significantly reduces the number of iterations for large numbers. This approach leverages the mathematical property that a divisor larger than the square root would have a corresponding divisor smaller than the square root.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should be efficient in calculating divisors.\n- The function should handle both positive and negative integers.\n- The function should be able to handle large integers efficiently.\n- The function should provide a clear and concise output.\n- The function should include basic error handling for non-integer inputs.\nTo create an efficient function that calculates the number of divisors for a given integer, we will use a straightforward approach. The function will iterate through possible divisors up to the square root of the given number, checking if they divide the number without a remainder. This method is efficient and suitable for handling both small and large integers.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should accurately count the divisors of a given integer.\n- The function should be optimized for performance, especially for large numbers.\n- The function should handle edge cases, such as negative numbers and zero.\n- The function should be well-documented and include comments for clarity.\n- The function should be tested thoroughly to ensure accuracy and reliability.\nTo create a function that calculates the number of divisors for a given integer efficiently, we will use a straightforward approach. The function will iterate through possible divisors up to the square root of the given number, checking if they divide the number without a remainder. This method is efficient and suitable for both small and large integers.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should accurately count the divisors of a given integer.\n- The function should be optimized for performance, especially for large numbers.\n- The function should handle edge cases, such as negative numbers and zero.\n- The function should be well-documented and include comments for clarity.\n- The function should be tested thoroughly to ensure accuracy and reliability.\nWe will use a straightforward approach to implement the divisor function. The function will iterate through possible divisors up to the square root of the given number to efficiently count the divisors. This method minimizes the number of iterations needed for large numbers.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for a given integer. This is a basic mathematical function that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both small and large integers.\nrequirement pool:\n- The main code should accurately count the divisors of a given integer.\n- The function should be optimized for performance, especially for large numbers.\n- The function should handle edge cases, such as negative numbers and zero.\n- The function should be well-documented and include comments for clarity.\n- The function should be tested thoroughly to ensure accuracy and reliability.\nWe will use a straightforward approach to implement the divisor function. The function will iterate through possible divisors up to the square root of the given number to efficiently count the divisors. This method minimizes the number of iterations needed for large numbers.\n"], "test": ["def check(divisor):\n\tassert divisor(15) == 4 ", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(18) == 6", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(18) == 6", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(6) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(5) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(6) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(8) == 4"], "scores": [1.0, 1.0, 0.8627, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, false, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 88, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    The function takes an integer n and returns the count of its divisors.\n    \n    Args:\n        n (int): The integer to count the divisors of.\n        \n    Returns:\n        int: The count of divisors of the given integer.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The input number must be greater than or equal to 1.\")\n    \n    divisor_count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 2  # i and n // i are both divisors\n    \n    # If n is a perfect square, we have counted the square root twice, so subtract one\n    if sqrt_n * sqrt_n == n:\n        divisor_count -= 1\n    \n    return divisor_count\n", "passed": true, "pass": true, "pass_num": 9, "round": 466, "mutate_method": "rephrase_one", "parent_index": 41}
