{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 96, "prompt": "Write a python function to find the number of divisors. Your function should handle any given integer and perform necessary calculations.", "code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x", "test_imports": [], "test_list": ["assert divisor(15) == 4 ", "assert divisor(12) == 6", "assert divisor(9) == 3", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(12) == 6", "assert divisor(19) == 2", "assert divisor(15) == 4", "assert divisor(10) == 4", "assert divisor(14) == 4", "assert divisor(14) == 4", "assert divisor(13) == 2", "assert divisor(10) == 4", "assert divisor(16) == 5", "assert divisor(11) == 2", "assert divisor(20) == 6", "assert divisor(18) == 6", "assert divisor(14) == 4", "assert divisor(18) == 6", "assert divisor(10) == 4", "assert divisor(10) == 4", "assert divisor(17) == 2", "assert divisor(12) == 6", "assert divisor(16) == 5", "assert divisor(14) == 4", "assert divisor(16) == 5", "assert divisor(13) == 2", "assert divisor(20) == 6", "assert divisor(20) == 6", "assert divisor(19) == 2", "assert divisor(15) == 4", "assert divisor(11) == 2", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(19) == 2", "assert divisor(12) == 6", "assert divisor(8) == 4", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(11) == 2", "assert divisor(10) == 4", "assert divisor(11) == 2", "assert divisor(12) == 6", "assert divisor(13) == 2", "assert divisor(17) == 2", "assert divisor(15) == 4", "assert divisor(14) == 4", "assert divisor(14) == 4", "assert divisor(9) == 3", "assert divisor(7) == 2", "assert divisor(15) == 4", "assert divisor(7) == 2", "assert divisor(9) == 3", "assert divisor(13) == 2", "assert divisor(7) == 2", "assert divisor(12) == 6", "assert divisor(15) == 4", "assert divisor(15) == 4", "assert divisor(14) == 4", "assert divisor(8) == 4", "assert divisor(11) == 2", "assert divisor(17) == 2", "assert divisor(9) == 3", "assert divisor(11) == 2", "assert divisor(9) == 3", "assert divisor(10) == 4", "assert divisor(15) == 4", "assert divisor(16) == 5", "assert divisor(8) == 4", "assert divisor(6) == 4", "assert divisor(14) == 4", "assert divisor(12) == 6", "assert divisor(9) == 3", "assert divisor(10) == 4", "assert divisor(10) == 4", "assert divisor(4) == 3", "assert divisor(10) == 4", "assert divisor(8) == 4", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(4) == 3", "assert divisor(12) == 6", "assert divisor(14) == 4", "assert divisor(11) == 2", "assert divisor(13) == 2", "assert divisor(13) == 2", "assert divisor(4) == 3", "assert divisor(13) == 2", "assert divisor(5) == 2", "assert divisor(13) == 2", "assert divisor(11) == 2", "assert divisor(12) == 6", "assert divisor(12) == 6", "assert divisor(10) == 4", "assert divisor(7) == 2", "assert divisor(13) == 2", "assert divisor(6) == 4", "assert divisor(14) == 4", "assert divisor(11) == 2", "assert divisor(4) == 3", "assert divisor(8) == 4"], "entry_point": "divisor", "repair_prompt": ["Write a python function divisor to find the number of divisors. Your function should handle any given integer and perform necessary calculations.\ndivisor(15) == 4 \n"], "completions": ["from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n\n    return count\n\n# Example usage:\n# print(divisor(12))  # Output: 6\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The integer for which we need to find the number of divisors.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    count = 0\n    abs_n = abs(n)\n    for i in range(1, abs_n + 1):\n        if abs_n % i == 0:\n            count += 1\n    return count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n", "from typing import List\n## main.py\n\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer.\n\n    Args:\n        n (int): The integer to find the number of divisors for.\n\n    Returns:\n        int: The number of divisors of the given integer.\n    \"\"\"\n    # Take the absolute value of n to handle negative integers\n    n = abs(n)\n    \n    # Initialize the count of divisors\n    divisor_count = 0\n    \n    # Calculate the square root of n\n    sqrt_n = int(math.sqrt(n))\n    \n    # Iterate through possible divisors from 1 to the square root of n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            # If i is a divisor, increment the count\n            divisor_count += 1\n            # If i is not the square root of n, count the corresponding divisor\n            if i != n // i:\n                divisor_count += 1\n    \n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 2  # i and n // i are both divisors\n\n    # If n is a perfect square, we have counted the square root twice, so subtract one\n    if sqrt_n * sqrt_n == n:\n        divisor_count -= 1\n\n    return divisor_count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n\n    return count\n\n# Example usage:\n# print(divisor(12))  # Output: 6\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n    \n    Args:\n        n (int): The integer for which to calculate the number of divisors.\n        \n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Function to find prime factors and their powers\n    def prime_factors(n: int) -> List[int]:\n        factors = []\n        # Check for number of 2s that divide n\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n        for i in range(3, int(math.sqrt(n)) + 1, 2):\n            # While i divides n, append i and divide n\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        # If n is a prime number greater than 2\n        if n > 2:\n            factors.append(n)\n        return factors\n    \n    # Get the prime factors\n    factors = prime_factors(n)\n    \n    # Count the frequency of each prime factor\n    factor_count = {}\n    for factor in factors:\n        if factor in factor_count:\n            factor_count[factor] += 1\n        else:\n            factor_count[factor] = 1\n    \n    # Calculate the number of divisors using the formula:\n    # (e1 + 1) * (e2 + 1) * ... * (ek + 1)\n    # where e1, e2, ..., ek are the exponents of the prime factors\n    num_divisors = 1\n    for exponent in factor_count.values():\n        num_divisors *= (exponent + 1)\n    \n    return num_divisors\n\n# Example usage:\n# print(divisor(12))  # Output: 6\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The integer for which to calculate the number of divisors.\n\n    Returns:\n        int: The total number of divisors of the integer.\n\n    Raises:\n        ValueError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError('Input must be an integer')\n    \n    n = abs(n)\n    divisors_count = 0\n    \n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors_count += 1\n    \n    return divisors_count\n", "from typing import List\nimport math\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n    \n    Args:\n        n (int): The integer to calculate the divisors for.\n        \n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    \n    return count\n", "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 2  # i and n // i are both divisors\n\n    # If n is a perfect square, we have counted the square root twice, so subtract one\n    if sqrt_n * sqrt_n == n:\n        divisor_count -= 1\n\n    return divisor_count\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for any given integer. This involves understanding the mathematical properties of numbers and implementing an efficient algorithm to count divisors. The function should handle both small and large integers, ensuring performance is not compromised for large inputs.\nrequirement pool:\n- Implement a function to count divisors of a given integer\n- Ensure the function can handle large integers efficiently\n- Implement unit tests to verify the correctness of the divisor counting function\n- Include error handling for non-integer inputs\n- Optimize the algorithm for performance\nTo implement the divisor function efficiently, we will use a mathematical approach that leverages the properties of numbers. The function will iterate through possible divisors up to the square root of the given number, counting both the divisor and its complement. This approach minimizes the number of iterations, making it suitable for handling large integers efficiently.\n", "requirement analysis:\nThe original requirement is to write a Python function that calculates the number of divisors for any given integer. This is a fundamental mathematical operation that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both positive and negative integers.\nrequirement pool:\n- The main code should efficiently calculate the number of divisors for any given integer.\n- The function should handle both positive and negative integers.\n- The function should be optimized for performance to handle large integers.\nTo create a Python function that calculates the number of divisors for any given integer, we will use a straightforward approach. The function will iterate through possible divisors up to the absolute value of the given integer, checking if they divide the integer without a remainder. This method is efficient for small to moderately large integers. For very large integers, optimizations such as checking divisors up to the square root of the number can be implemented to improve performance.\n", "requirement analysis:\nThe requirement is to create a simple function that calculates the number of divisors for any given integer. The function should be efficient and handle large integers without performance issues. The solution should be straightforward and easy to understand, suitable for a wide range of users.\nrequirement pool:\n- The main code should be written in Python for simplicity and readability.\n- The function should be able to handle any integer input efficiently.\n- Implement a method to count the divisors of a given number.\n- Ensure the function can handle large integers without significant performance degradation.\n- Include error handling for non-integer inputs to ensure robustness.\nTo create an efficient and accurate divisor function, we will leverage Python's capabilities, focusing on simplicity and performance. We will use a straightforward approach to count divisors by iterating through possible factors up to the square root of the given number. This method is efficient and avoids unnecessary computations, making it suitable for handling large integers.\n", "requirement analysis:\nThe original requirement is to create a function that calculates the number of divisors for any given integer. This is a fundamental mathematical operation that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both positive and negative integers.\nrequirement pool:\n- The main code should efficiently calculate the number of divisors for any given integer.\n- The function should handle both positive and negative integers.\n- The function should be optimized for performance to handle large integers.\nTo create a function that calculates the number of divisors for any given integer efficiently, we will utilize a straightforward approach. This approach will involve iterating through possible divisors up to the square root of the given number, which significantly reduces the number of iterations needed for large integers. We will also handle both positive and negative integers by taking the absolute value of the input.\n", "requirement analysis:\nThe requirement is to create a Python function that calculates the number of divisors for any given integer. The function should be efficient and capable of handling large integers. The algorithm should be simple yet effective, ensuring accuracy and performance.\nrequirement pool:\n- The main code should be clear and easy to understand.\n- The function should handle any integer input efficiently.\n- Implement optimizations to handle large integers.\n- Ensure the function returns accurate results for all inputs.\n- Include comments and documentation for easier understanding and maintenance.\nTo create an efficient and accurate divisor function in Python, we will leverage the power of mathematical operations and optimization techniques. We will use a straightforward approach that calculates the number of divisors by iterating through possible factors up to the square root of the given number. This method ensures efficiency and handles large integers effectively.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for any given integer. This involves understanding the mathematical properties of numbers and implementing an efficient algorithm to count divisors. The function should handle both positive and negative integers, with special consideration for zero.\nrequirement pool:\n- Implement a function to count divisors of a given integer.\n- Ensure the function works correctly for all integers, including negative numbers and zero.\n- Optimize the algorithm to handle large integers efficiently.\n- Include error handling for non-integer inputs.\n- Provide documentation and examples for user guidance.\nTo implement the divisor function efficiently, we will use a mathematical approach that leverages the properties of divisors. The function will iterate through possible divisors up to the square root of the given number, counting both the divisor and its complement. This approach ensures that the function can handle large integers efficiently.\n", "requirement analysis:\nThe requirement is to create a Python function that calculates the number of divisors for any given integer. The function should be efficient and capable of handling large integers. The solution should be robust and accurate, ensuring that it meets the needs of both users and developers.\nrequirement pool:\n- Implement a function to count divisors of a given integer\n- Ensure the function works efficiently with large integers\n- Include error handling for non-integer inputs\n- Provide documentation and examples for user guidance\n- Optimize the algorithm for performance\nTo implement the divisor function efficiently, we will leverage the properties of prime factorization. The number of divisors of a number can be determined from its prime factorization. We will use a straightforward approach to find the prime factors and then calculate the number of divisors based on these factors. This method ensures that the function can handle large integers effectively.\n", "requirement analysis:\nThe requirement is to create a function that calculates the number of divisors for any given integer. This is a fundamental mathematical operation that can be used in various applications, including number theory and cryptography. The function should be efficient and handle both positive and negative integers.\nrequirement pool:\n- The main code should be able to calculate the number of divisors for any given integer.\n- The function should handle both positive and negative integers.\n- The function should be optimized for performance to handle large integers efficiently.\n- The function should include error handling to manage invalid inputs such as non-integer values.\nTo create a function that calculates the number of divisors for any given integer, we will use a straightforward approach. The function will iterate through all possible divisors up to the absolute value of the given integer, checking if they divide the integer without leaving a remainder. This method is efficient for small to moderately large integers. For very large integers, more advanced algorithms such as the Sieve of Eratosthenes could be considered to optimize performance.\n", "requirement analysis:\nThe requirement is to create a Python function that calculates the number of divisors for any given integer. The function should be efficient and capable of handling large integers. The solution should be simple and easy to understand, ensuring clarity and ease of use.\nrequirement pool:\n- The main code should be simple and easy to understand\n- The function should handle large integers efficiently\n- Ensure the function is accurate and reliable\n- Provide clear and concise documentation\n- Include tests to verify the function's correctness\nTo create an efficient and accurate divisor function, we will leverage Python's built-in math library for basic number theory functions and optimize the algorithm to handle large integers. The approach involves iterating through possible divisors up to the square root of the given number, which significantly reduces the number of operations needed for large numbers.\n", "requirement analysis:\nThe requirement is to create a Python function that calculates the number of divisors for any given integer. The function should be efficient and capable of handling large integers. The algorithm should be simple yet effective, ensuring accuracy and performance.\nrequirement pool:\n- The main code should be clear and easy to understand.\n- The function should handle any integer input efficiently.\n- Implement optimizations to handle large integers.\n- Ensure the function returns accurate results for all inputs.\n- Include comments and documentation for easier understanding and maintenance.\nTo create an efficient and accurate divisor function in Python, we will leverage the power of mathematical operations and optimization techniques. We will use a straightforward approach that calculates the number of divisors by iterating through possible factors up to the square root of the given number. This method ensures efficiency and handles large integers effectively.\n"], "test": ["def check(divisor):\n\tassert divisor(15) == 4 ", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(18) == 6", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(18) == 6", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(20) == 6", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(19) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(17) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(15) == 4", "def check(divisor):\n\tassert divisor(16) == 5", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(6) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(9) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(8) == 4", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(5) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(12) == 6", "def check(divisor):\n\tassert divisor(10) == 4", "def check(divisor):\n\tassert divisor(7) == 2", "def check(divisor):\n\tassert divisor(13) == 2", "def check(divisor):\n\tassert divisor(6) == 4", "def check(divisor):\n\tassert divisor(14) == 4", "def check(divisor):\n\tassert divisor(11) == 2", "def check(divisor):\n\tassert divisor(4) == 3", "def check(divisor):\n\tassert divisor(8) == 4"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    divisor_count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            divisor_count += 2  # i and n // i are both divisors\n\n    # If n is a perfect square, we have counted the square root twice, so subtract one\n    if sqrt_n * sqrt_n == n:\n        divisor_count -= 1\n\n    return divisor_count\n", "passed": true, "pass": true, "pass_num": 10, "round": 41, "mutate_method": "expand_one2two", "parent_index": 41}
