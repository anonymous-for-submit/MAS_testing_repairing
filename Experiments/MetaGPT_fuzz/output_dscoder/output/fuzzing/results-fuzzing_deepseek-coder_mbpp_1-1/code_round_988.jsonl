{"source_file": "Ellen's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 295, "prompt": "Write a function to return the sum of all divisors. The divisors being considered are those of a specified number. Consider edge cases such as when the input number is zero or negative.", "code": "def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)", "test_imports": [], "test_list": ["assert sum_div(8)==7", "assert sum_div(12)==16", "assert sum_div(7)==1", "assert sum_div(9) == 4", "assert sum_div(5) == 1", "assert sum_div(12) == 16", "assert sum_div(13) == 1", "assert sum_div(3) == 1", "assert sum_div(7) == 1", "assert sum_div(10) == 8", "assert sum_div(11) == 1", "assert sum_div(10) == 8", "assert sum_div(9) == 4", "assert sum_div(13) == 1", "assert sum_div(4) == 3", "assert sum_div(5) == 1", "assert sum_div(12) == 16", "assert sum_div(7) == 1", "assert sum_div(6) == 6", "assert sum_div(4) == 3", "assert sum_div(11) == 1", "assert sum_div(4) == 3", "assert sum_div(12) == 16", "assert sum_div(11) == 1", "assert sum_div(6) == 6", "assert sum_div(11) == 1", "assert sum_div(13) == 1", "assert sum_div(10) == 8", "assert sum_div(5) == 1", "assert sum_div(11) == 1", "assert sum_div(6) == 6", "assert sum_div(3) == 1", "assert sum_div(12) == 16", "assert sum_div(10) == 8", "assert sum_div(13) == 1", "assert sum_div(6) == 6", "assert sum_div(16) == 15", "assert sum_div(7) == 1", "assert sum_div(15) == 9", "assert sum_div(13) == 1", "assert sum_div(14) == 10", "assert sum_div(10) == 8", "assert sum_div(13) == 1", "assert sum_div(9) == 4", "assert sum_div(8) == 7", "assert sum_div(13) == 1", "assert sum_div(16) == 15", "assert sum_div(12) == 16", "assert sum_div(14) == 10", "assert sum_div(16) == 15", "assert sum_div(8) == 7", "assert sum_div(8) == 7", "assert sum_div(13) == 1", "assert sum_div(7) == 1", "assert sum_div(17) == 1", "assert sum_div(9) == 4", "assert sum_div(11) == 1", "assert sum_div(16) == 15", "assert sum_div(12) == 16", "assert sum_div(16) == 15", "assert sum_div(16) == 15", "assert sum_div(17) == 1", "assert sum_div(15) == 9", "assert sum_div(10) == 8", "assert sum_div(16) == 15", "assert sum_div(14) == 10", "assert sum_div(10) == 8", "assert sum_div(16) == 15", "assert sum_div(10) == 8", "assert sum_div(10) == 8", "assert sum_div(11) == 1", "assert sum_div(5) == 1", "assert sum_div(7) == 1", "assert sum_div(5) == 1", "assert sum_div(8) == 7", "assert sum_div(9) == 4", "assert sum_div(2) == 1", "assert sum_div(9) == 4", "assert sum_div(2) == 1", "assert sum_div(5) == 1", "assert sum_div(2) == 1", "assert sum_div(6) == 6", "assert sum_div(5) == 1", "assert sum_div(10) == 8", "assert sum_div(4) == 3", "assert sum_div(8) == 7", "assert sum_div(12) == 16", "assert sum_div(4) == 3", "assert sum_div(9) == 4", "assert sum_div(2) == 1", "assert sum_div(9) == 4", "assert sum_div(9) == 4", "assert sum_div(3) == 1", "assert sum_div(8) == 7", "assert sum_div(5) == 1", "assert sum_div(12) == 16", "assert sum_div(3) == 1", "assert sum_div(8) == 7", "assert sum_div(5) == 1", "assert sum_div(9) == 4", "assert sum_div(10) == 8", "assert sum_div(2) == 1"], "entry_point": "sum_div", "repair_prompt": ["Write a function sum_div to return the sum of all divisors. The divisors being considered are those of a specified number. Consider edge cases such as when the input number is zero or negative.\nsum_div(8)==7\n"], "completions": ["from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all divisors of a given number.\n\n    Args:\n        n (int): The number to calculate the sum of its divisors.\n\n    Returns:\n        int: The sum of all divisors of the given number.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    sum_of_divisors = 1  # Start with 1 because 1 is a divisor of every number\n    sqrt_n = int(n**0.5)\n\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n\n    if n > 1:\n        sum_of_divisors += n\n\n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of divisors of a given integer n.\n\n    Args:\n        n (int): The integer for which the sum of divisors is to be calculated.\n\n    Returns:\n        int: The sum of divisors of n.\n    \"\"\"\n    if n <= 0:\n        return 0  # Return 0 for non-positive integers as they do not have proper divisors\n\n    sum_of_divisors = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n\n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    The function takes an integer n and returns the sum of its divisors.\n    If n is zero or negative, it returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    \n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of divisors of a given integer n.\n\n    Args:\n        n (int): The integer for which to calculate the sum of divisors.\n\n    Returns:\n        int: The sum of divisors of n.\n\n    Raises:\n        ValueError: If n is zero or negative.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    \n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of divisors of a given integer n.\n\n    Args:\n        n (int): The integer for which the sum of divisors is to be calculated.\n\n    Returns:\n        int: The sum of divisors of n.\n    \"\"\"\n    if n <= 0:\n        return 0  # Return 0 for non-positive integers\n\n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n\n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculates the sum of all divisors of a given number.\n    \n    Args:\n        n (int): The number to calculate the sum of its divisors.\n        \n    Returns:\n        int: The sum of all divisors of the given number.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    sum_of_divisors = 0\n    for i in range(1, abs(n) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n    \n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all divisors of a given integer n.\n\n    Args:\n        n (int): The integer to calculate the sum of divisors for.\n\n    Returns:\n        int: The sum of all divisors of n.\n\n    Raises:\n        ValueError: If the input is zero or negative.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    \n    return sum_of_divisors\n", "from typing import List\n## main.py\n\nimport math\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    The function takes an integer 'n' and returns the sum of its divisors.\n    \"\"\"\n    if n <= 0:\n        return 0  # Return 0 for non-positive numbers as they don't have proper divisors\n\n    sum_of_divisors = 1  # Start with 1 because 1 is a divisor of every number\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n\n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all positive divisors of a given number n.\n    \n    Args:\n        n (int): The number to find the sum of its divisors.\n        \n    Returns:\n        int: The sum of all positive divisors of n.\n        \n    Raises:\n        ValueError: If the input number is not positive.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Number must be positive\")\n    \n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    \n    return sum_of_divisors\n", "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all divisors of a given number n.\n    \n    Args:\n        n (int): The number to calculate the sum of its divisors.\n        \n    Returns:\n        int: The sum of all divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    \n    return sum_of_divisors\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The solution should be efficient and accurate.\nrequirement pool:\n- Implement the function to calculate the sum of divisors.\n- Ensure the function handles zero and negative numbers correctly.\n- Optimize the function for performance, especially for large numbers.\n- Add documentation and tests to ensure reliability.\n- Consider adding a feature to handle large inputs efficiently.\nTo implement the function `sum_div` that calculates the sum of all divisors of a given number, we will use a straightforward approach. We will iterate through all possible divisors up to the square root of the number, check if they are divisors, and sum them up. This method is efficient and handles both positive and negative numbers, including zero.\n", "requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The product should be efficient and reliable, providing accurate results for any positive integer input.\nrequirement pool:\n- Implement the sum_div function to accurately calculate the sum of divisors for any positive integer.\n- Ensure the function gracefully handles zero and negative numbers.\n- Optimize the function for performance to handle large inputs efficiently.\n- Include comprehensive testing to verify the accuracy and reliability of the function.\n- Document the function and provide clear examples of usage.\nTo implement the sum_div function efficiently and accurately, we will use Python's built-in capabilities along with a simple algorithm to calculate the sum of divisors. The function will first handle edge cases such as zero and negative numbers by returning an appropriate value. For positive numbers, the function will iterate through possible divisors, summing them up. This approach ensures both correctness and performance.\n", "requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The function should be efficient and easy to use.\nrequirement pool:\n- Implement the sum_div function to accurately calculate the sum of divisors.\n- Ensure the function handles zero and negative numbers correctly.\n- Optimize the function for performance to handle large numbers efficiently.\n- Document the function with clear instructions and examples.\n- Test the function with various edge cases to ensure accuracy.\nTo implement the sum_div function, we will use a straightforward approach that iterates through all possible divisors of the given number up to its square root. This method ensures efficiency while handling the task effectively. We will also handle edge cases such as zero and negative numbers by returning appropriate values or using conditional checks.\n", "requirement analysis:\nThe requirement to write a function that returns the sum of all divisors of a given number is clear. The function should handle edge cases such as zero and negative numbers. The performance of the function is crucial, especially for large numbers, to ensure it is efficient and fast. The user experience should be considered to ensure the function is easy to use and understand.\nrequirement pool:\n- Implement the sum_div function to accurately calculate the sum of divisors for any given number.\n- Ensure the function handles zero and negative numbers correctly.\n- Optimize the function for performance, especially for large numbers.\n- Design a user-friendly interface for the function.\n- Provide documentation and examples to help users understand how to use the function.\nTo implement the sum_div function, we will use a straightforward approach that calculates the sum of divisors by iterating through all possible divisors up to the number itself. We will handle edge cases such as zero and negative numbers by returning an appropriate value or error. Performance optimization will be achieved by limiting the range of divisors to the square root of the number for efficiency.\n", "requirement analysis:\nThe function 'sum_div' needs to be able to calculate the sum of all divisors of a given number. This includes handling both positive and negative numbers, with special attention to zero. The function should be efficient and able to handle large numbers without significant performance degradation.\nrequirement pool:\n- Implement the sum_div function to accurately calculate the sum of divisors for any given number.\n- Ensure the function correctly handles zero and negative numbers.\n- Optimize the function for performance to handle large numbers efficiently.\n- Include detailed documentation and examples to guide users on how to use the function.\n- Test the function with various edge cases to ensure robustness.\nTo implement the 'sum_div' function, we will use Python's built-in capabilities along with a simple and efficient approach to calculate the sum of divisors. The function will first handle edge cases such as zero and negative numbers by returning an appropriate value. For positive numbers, the function will iterate through possible divisors, summing them up until the square of the current divisor exceeds the number. This method ensures efficiency without unnecessary computations.\n", "requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The product should be efficient and reliable, providing accurate results quickly.\nrequirement pool:\n- Implement the function to calculate the sum of divisors accurately.\n- Ensure the function handles zero and negative numbers correctly.\n- Optimize the function for performance to handle large numbers efficiently.\n- Include comprehensive testing to ensure the function works as expected.\n- Provide clear documentation and examples for user guidance.\nTo implement the function `sum_div` that calculates the sum of all divisors of a given number, we will use a straightforward approach. We will iterate through all possible divisors up to the number itself and sum them up. Special care will be taken to handle edge cases such as zero and negative numbers efficiently.\n", "requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The performance should be efficient, especially for large numbers. The user experience should be straightforward and clear.\nrequirement pool:\n- Implement the function to correctly calculate the sum of divisors for any given number, including zero and negative numbers.\n- Ensure the function is optimized for performance, especially for large numbers.\n- Develop a user-friendly interface for easy interaction with the function.\n- Include detailed documentation and examples to guide users effectively.\n- Conduct thorough testing to ensure the function handles all edge cases correctly.\nTo implement the sum_div function efficiently, we will use a straightforward approach that iterates through all possible divisors of the given number up to its square root. This method ensures that we efficiently find all divisors without unnecessary computations. We will also handle edge cases such as zero and negative numbers by returning appropriate results or raising exceptions as needed.\n", "requirement analysis:\nThe function 'sum_div' needs to be able to calculate the sum of all divisors of a given number. This includes handling both positive and negative numbers, with a special focus on zero. The function should be efficient and able to handle large numbers without significant performance degradation.\nrequirement pool:\n- Implement the function to calculate the sum of divisors for a given number.\n- Ensure the function can handle zero and negative numbers correctly.\n- Optimize the function for performance to handle large numbers efficiently.\n- Add documentation and tests to ensure reliability and correctness.\n- Include error handling to manage unexpected inputs gracefully.\nTo implement the 'sum_div' function, we will use Python's built-in capabilities and leverage the 'math' library for efficient divisor summation. The function will first handle edge cases such as zero and negative numbers by returning an appropriate value. For positive numbers, it will iterate through possible divisors up to the square root of the number, summing both the divisor and its complement. This approach ensures efficiency and avoids unnecessary computations.\n", "requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The product should be efficient and easy to use.\nrequirement pool:\n- Implement the sum_div function to accurately calculate the sum of divisors.\n- Ensure the function handles zero and negative numbers correctly.\n- Optimize the function for performance to handle large numbers efficiently.\n- Provide clear documentation and examples for user guidance.\n- Test the function for accuracy and edge cases.\nTo implement the sum_div function, we will use a straightforward approach that iterates through all possible divisors of the given number up to its square root. This method ensures efficiency while handling the task effectively. We will also handle edge cases such as zero and negative numbers by returning appropriate values or handling them gracefully.\n", "requirement analysis:\nThe requirement is to create a function that calculates the sum of all divisors of a given number. The function should handle edge cases such as zero and negative numbers. The product should be efficient and reliable, providing accurate results for any positive integer input.\nrequirement pool:\n- Implement the function to calculate the sum of divisors\n- Handle zero and negative numbers gracefully\n- Ensure the function is efficient and fast\n- Test the function for accuracy and edge cases\n- Optimize the function for better performance\nTo implement the function `sum_div` that calculates the sum of all divisors of a given number, we will use Python's built-in capabilities and optimize for performance. The function will handle edge cases such as zero and negative numbers gracefully. We will ensure the function is efficient and fast by using an optimized algorithm that minimizes the number of operations required to find divisors.\n"], "test": ["def check(sum_div):\n\tassert sum_div(8)==7", "def check(sum_div):\n\tassert sum_div(12)==16", "def check(sum_div):\n\tassert sum_div(7)==1", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(3) == 1", "def check(sum_div):\n\tassert sum_div(7) == 1", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(4) == 3", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(7) == 1", "def check(sum_div):\n\tassert sum_div(6) == 6", "def check(sum_div):\n\tassert sum_div(4) == 3", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(4) == 3", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(6) == 6", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(6) == 6", "def check(sum_div):\n\tassert sum_div(3) == 1", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(6) == 6", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(7) == 1", "def check(sum_div):\n\tassert sum_div(15) == 9", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(14) == 10", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(14) == 10", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(13) == 1", "def check(sum_div):\n\tassert sum_div(7) == 1", "def check(sum_div):\n\tassert sum_div(17) == 1", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(17) == 1", "def check(sum_div):\n\tassert sum_div(15) == 9", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(14) == 10", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(16) == 15", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(11) == 1", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(7) == 1", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(2) == 1", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(2) == 1", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(2) == 1", "def check(sum_div):\n\tassert sum_div(6) == 6", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(4) == 3", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(4) == 3", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(2) == 1", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(3) == 1", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(12) == 16", "def check(sum_div):\n\tassert sum_div(3) == 1", "def check(sum_div):\n\tassert sum_div(8) == 7", "def check(sum_div):\n\tassert sum_div(5) == 1", "def check(sum_div):\n\tassert sum_div(9) == 4", "def check(sum_div):\n\tassert sum_div(10) == 8", "def check(sum_div):\n\tassert sum_div(2) == 1"], "scores": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "pass_results": [false, false, false, false, false, false, false, true, false, false], "pass_test_cases_num": [0, 0, 0, 0, 0, 0, 0, 102, 0, 0], "completion": "from typing import List\n## main.py\n\ndef sum_div(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all divisors of a given number n.\n    \n    Args:\n        n (int): The number to calculate the sum of its divisors.\n        \n    Returns:\n        int: The sum of all divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    sum_of_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i != n // i:\n                sum_of_divisors += n // i\n    \n    return sum_of_divisors\n", "passed": true, "pass": true, "pass_num": 1, "round": 988, "mutate_method": "add_1_sentence_at_end", "parent_index": 723}
