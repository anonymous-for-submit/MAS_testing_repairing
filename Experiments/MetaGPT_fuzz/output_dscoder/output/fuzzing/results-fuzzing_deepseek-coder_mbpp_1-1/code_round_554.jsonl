{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 803, "prompt": "Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ Consider edge cases such as negative numbers and zero.", "code": "def is_perfect_square(n) :\n    i = 1\n    while (i * i<= n):\n        if ((n % i == 0) and (n / i == i)):\n            return True     \n        i = i + 1\n    return False", "test_imports": [], "test_list": ["assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(6) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(41) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(33) == False", "assert is_Perfect_Square(41) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(38) == False", "assert is_Perfect_Square(34) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(38) == False", "assert is_Perfect_Square(32) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(32) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(12) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(18) == False", "assert is_Perfect_Square(17) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(18) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(17) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(14) == False"], "entry_point": "is_Perfect_Square", "repair_prompt": ["Write a function is_Perfect_Square to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ Consider edge cases such as negative numbers and zero.\nis_Perfect_Square(10) == False\n"], "completions": ["from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    i = 1\n    while i * i <= n:\n        if i * i == n:\n            return True\n        i += 1\n    return False\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    i = 1\n    while i * i <= n:\n        if i * i == n:\n            return True\n        i += 1\n    return False\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    \n    root = int(n**0.5)\n    return root * root == n\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root\n", "from typing import List\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    \n    root = int(n**0.5)\n    return root * root == n\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    i = 1\n    while i * i <= n:\n        if i * i == n:\n            return True\n        i += 1\n    \n    return False\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        mid_squared = mid * mid\n        \n        if mid_squared == n:\n            return True\n        elif mid_squared < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given integer n is a perfect square.\n\n    Args:\n        n (int): The integer to check.\n\n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    i = 1\n    while i * i <= n:\n        if i * i == n:\n            return True\n        i += 1\n    \n    return False\n", "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    i = 1\n    while i * i <= n:\n        if i * i == n:\n            return True\n        i += 1\n    return False\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. The function should handle edge cases such as negative numbers and zero. The function should return False for numbers that are not perfect squares and True for numbers that are perfect squares.\nrequirement pool:\n- The main code should include a function is_Perfect_Square that takes an integer as input and returns a boolean value.\n- The function should correctly identify perfect squares and non-perfect squares.\n- The function should handle edge cases such as negative numbers and zero.\n- The function should be efficient and suitable for large inputs.\nTo implement the function is_Perfect_Square, we will use a straightforward approach by leveraging the properties of perfect squares. We will iterate through possible divisors of the given number and check if any of them, when squared, equals the given number. This method is efficient and suitable for handling both small and large inputs.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This includes handling edge cases such as negative numbers and zero. The function should return a boolean value indicating whether the number is a perfect square.\nrequirement pool:\n- The main code should include a function is_Perfect_Square that takes an integer as input and returns True if it is a perfect square, otherwise False.\n- The function should handle edge cases such as negative numbers and zero.\n- Implement the function in Python.\n- Ensure the function is efficient and handles large numbers.\nTo implement the function is_Perfect_Square, we will use a straightforward approach that leverages the properties of perfect squares. We will iterate through possible divisors of the given number and check if any of them, when squared, equals the given number. This method is efficient and handles edge cases such as negative numbers and zero effectively.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This includes handling edge cases such as negative numbers and zero. The function should return a boolean value indicating whether the number is a perfect square.\nrequirement pool:\n- The main code should include a function is_Perfect_Square that takes an integer as input and returns True if it is a perfect square, otherwise False.\n- The function should handle edge cases such as negative numbers and zero.\n- Implement the function in Python.\n- Ensure the function is efficient and handles large numbers.\nWe will use a straightforward approach to implement the function is_Perfect_Square in Python. The function will check if a given number is a perfect square by iterating through possible square roots and comparing the square of the integer to the given number. This method will handle edge cases such as negative numbers and zero efficiently.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This involves checking if the square root of the number is an integer. The function should handle edge cases such as negative numbers and zero, returning False for these inputs. The function should be efficient and clear, providing accurate results based on the input.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square.\n- The function should handle edge cases like negative numbers and zero.\n- The function should be efficient in terms of time complexity.\n- The function should be easy to understand and maintain.\n- The product should include clear documentation and examples.\nWe will use Python's built-in math library to calculate the square root of the given number. If the square root is an integer (i.e., the remainder when divided by 1 is zero), then the number is a perfect square. We will handle edge cases such as negative numbers and zero by returning False for these inputs.\n", "requirement analysis:\nThe requirement is to create a function that checks if a given number is a perfect square. This includes handling edge cases such as negative numbers and zero. The function should be efficient and provide clear results. The product should be user-friendly and accessible.\nrequirement pool:\n- The main code should accurately determine if a number is a perfect square.\n- The function should handle negative numbers and zero correctly.\n- The product should be user-friendly and provide clear feedback.\n- The function should be efficient and fast in its operations.\n- The product should be accessible and work well on different devices.\nTo create a function that checks if a given number is a perfect square, we will use Python's built-in capabilities and leverage the math library for efficient computation. The function will handle edge cases such as negative numbers and zero by returning False for such inputs. The approach will be straightforward and efficient, ensuring that the function meets the user's need for quick and accurate results.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This includes handling edge cases such as negative numbers and zero. The function should return a boolean value indicating whether the number is a perfect square.\nrequirement pool:\n- The main code should include a function is_Perfect_Square that takes an integer as input and returns True if it is a perfect square, otherwise False.\n- The function should handle edge cases such as negative numbers and zero.\n- Implement the function in Python.\n- Ensure the function is efficient and handles large numbers.\nWe will use a straightforward approach to implement the function is_Perfect_Square in Python. The function will check if a given number is a perfect square by iterating through possible square roots and comparing the square of the integer to the given number. This method will handle edge cases such as negative numbers and zero efficiently.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. The function should handle edge cases such as negative numbers and zero. The function should return False for numbers that are not perfect squares and True for numbers that are perfect squares.\nrequirement pool:\n- The function should correctly identify perfect squares.\n- The function should handle negative numbers and zero appropriately.\n- The function should be efficient in terms of time complexity.\n- The function should be easy to understand and maintain.\n- The function should be integrated into a larger application if necessary.\nTo implement the function is_Perfect_Square, we will use a straightforward approach by leveraging the properties of perfect squares. We will iterate through possible divisors of the given number and check if any of them, when squared, equals the given number. This method is efficient and easy to understand. We will also handle edge cases such as negative numbers and zero by immediately returning False for them.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. The function should handle edge cases such as negative numbers and zero. The function should return False for numbers that are not perfect squares and True for numbers that are perfect squares.\nrequirement pool:\n- The function should correctly identify perfect squares.\n- The function should handle negative numbers and zero appropriately.\n- The function should be efficient in terms of time complexity.\n- The function should be easy to understand and maintain.\n- The function should be integrated into a larger application if necessary.\nTo implement the function is_Perfect_Square, we will use a straightforward approach by leveraging the properties of perfect squares. We will iterate through possible divisors of the given number and check if any of them, when squared, equals the given number. This method is efficient and easy to understand. We will also handle edge cases such as negative numbers and zero by immediately returning False for them.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This includes handling edge cases such as negative numbers and zero. The function should return a boolean value indicating whether the number is a perfect square.\nrequirement pool:\n- The main code should include a function is_Perfect_Square that takes an integer as input and returns True if it is a perfect square, otherwise False.\n- The function should handle edge cases such as negative numbers and zero.\n- Implement the function in Python.\n- Ensure the function is efficient and handles large numbers.\nTo implement the function is_Perfect_Square, we will use a straightforward approach that leverages the properties of perfect squares. We will iterate through possible divisors of the given number and check if any of them, when squared, equals the given number. This method is efficient for small to moderately large numbers. For very large numbers, a more sophisticated approach involving binary search or mathematical properties might be necessary to ensure performance.\n", "requirement analysis:\nThe requirement is to create a function that determines if a given number is a perfect square. This includes handling edge cases such as negative numbers and zero. The function should return a boolean value indicating whether the number is a perfect square.\nrequirement pool:\n- The main code should include a function is_Perfect_Square that takes an integer as input and returns True if it is a perfect square, otherwise False.\n- The function should handle negative numbers and zero appropriately.\n- The function should be efficient and handle large numbers.\nTo implement the function is_Perfect_Square, we will use a straightforward approach that leverages the properties of perfect squares. We will iterate through possible divisors of the given number and check if any of them, when squared, equals the given number. This method is efficient for small to moderately large numbers. For very large numbers, a more sophisticated approach involving binary search or mathematical properties might be more appropriate, but for simplicity and clarity, we will stick to this method.\n"], "test": ["def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(6) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(41) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(33) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(41) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(38) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(34) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(38) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(32) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(32) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(12) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(18) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(17) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(18) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(17) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    i = 1\n    while i * i <= n:\n        if i * i == n:\n            return True\n        i += 1\n    return False\n", "passed": true, "pass": true, "pass_num": 10, "round": 554, "mutate_method": "add_1_sentence_at_end", "parent_index": 259}
