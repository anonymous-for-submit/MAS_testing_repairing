{"task_id": "HumanEval/139", "prompt": "def special_factorial(n):\t\n'''The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\nFor example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''", "entry_point": "special_factorial", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "test": ["def check(special_factorial):\n\tassert special_factorial(7) == 125411328000", "def check(special_factorial):\n\tassert special_factorial(9) == 1834933472251084800000", "def check(special_factorial):\n\tassert special_factorial(1) == 1, \"Test 1\"", "def check(special_factorial):\n\tassert special_factorial(3) == 12", "def check(special_factorial):\n\tassert special_factorial(10) == 6658606584104736522240000000", "def check(special_factorial):\n\tassert special_factorial(12) == 127313963299399416749559771247411200000000000", "def check(special_factorial):\n\tassert special_factorial(4) == 288", "def check(special_factorial):\n\tassert special_factorial(1) == 1", "def check(special_factorial):\n\tassert special_factorial(6) == 24883200", "def check(special_factorial):\n\tassert special_factorial(8) == 5056584744960000", "def check(special_factorial):\n\tassert special_factorial(5) == 34560", "def check(special_factorial):\n\tassert special_factorial(4) == 288, \"Test 4\"", "def check(special_factorial):\n\tassert special_factorial(2) == 2", "def check(special_factorial):\n\tassert special_factorial(5) == 34560, \"Test 5\"", "def check(special_factorial):\n\tassert special_factorial(11) == 265790267296391946810949632000000000", "def check(special_factorial):\n\tassert special_factorial(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand."], "test_case_list": ["assert special_factorial(7) == 125411328000", "assert special_factorial(9) == 1834933472251084800000", "assert special_factorial(1) == 1, \"Test 1\"", "assert special_factorial(3) == 12", "assert special_factorial(10) == 6658606584104736522240000000", "assert special_factorial(12) == 127313963299399416749559771247411200000000000", "assert special_factorial(4) == 288", "assert special_factorial(1) == 1", "assert special_factorial(6) == 24883200", "assert special_factorial(8) == 5056584744960000", "assert special_factorial(5) == 34560", "assert special_factorial(4) == 288, \"Test 4\"", "assert special_factorial(2) == 2", "assert special_factorial(5) == 34560, \"Test 5\"", "assert special_factorial(11) == 265790267296391946810949632000000000", "assert special_factorial(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand."], "nl": "The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    ", "func": "def special_factorial(n):", "examples": "For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    ", "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n    For example:\n        >>> special_factorial(4)\n        288\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n    \n    if n == 0:\n        return 1\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n", "from typing import List\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function receives an integer 'n' as input and returns the special factorial of 'n'.\n    '''\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n\n# Test the function\nprint(special_factorial(4))  # Output should be 288\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    \"\"\"\n    Calculate the special factorial of a given integer using the Brazilian factorial method.\n\n    Args:\n        n: An integer for which the special factorial needs to be calculated\n\n    Returns:\n        int: The special factorial of the input integer\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n\n    return result\n", "from typing import List\ndef factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\ndef special_factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result\n", "from typing import List\n## main.py\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    This operation involves multiplying n! with the consecutive (n-1)!,\n    and further multiplying with subsequent factorials until 1!. The result is the Brazilian factorial of n.\n    '''\n    if n == 0:\n        return 1\n    \n    result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    \n    return result\n\ndef factorial(num: int) -> int:\n    if num == 0:\n        return 1\n    \n    result = 1\n    for i in range(1, num+1):\n        result *= i\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n\n    :param n: The input integer for which Brazilian factorial needs to be calculated\n    :return: The Brazilian factorial of n\n    '''\n    if n == 0:\n        return 1\n    \n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The special factorial is defined as the product of factorials from n down to 1, where n is a positive integer.\n    \n    Args:\n        n (int): The input integer\n    \n    Returns:\n        int: The special factorial of n\n    '''\n    if n <= 0:\n        return None\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n    The function will receive an integer as input and should return the special factorial of this integer.\n    \n    >>> special_factorial(4)\n    288\n    '''\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result\n", "from typing import List\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\n    The function will receive an integer as input and should return the special factorial of this integer.\n    \n    >>> special_factorial(4)\n    288\n    '''\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    \"\"\"\n    Calculate the special factorial of n using the Brazilian factorial algorithm.\n\n    Args:\n        n: An integer to calculate the special factorial for.\n\n    Returns:\n        The special factorial of n as an integer.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    result = 1\n    for i in range(n, 1, -1):\n        result *= math.factorial(i)  ## Multiply each factorial term with the previous factorial result\n\n    return result\n"], "plans": ["requirement pool:\n- Implement the special factorial calculation logic\n- Optimize the algorithm for efficient computation\n- Handle edge cases and input validation\nWe will use the math library in Python to handle factorial calculations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the math library for factorial calculations, the code logic would involve iterating from n down to 1 and multiplying each factorial term with the previous factorial result.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the Brazilian factorial is 1! = 1.\n    special_factorial(4) = 288\n    Explanation: For n=4, the Brazilian factorial is 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n    special_factorial(0) = 1\n    Explanation: For n=0, the Brazilian factorial is defined as 1 by convention.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 0:\n            return 1\n        (other code)\n", "requirement analysis:\nThe special factorial function needs to efficiently calculate the product of factorials for a given integer. It should handle positive integers greater than zero and provide accurate results. Edge cases such as input validation and performance optimization are crucial for a successful implementation.\nrequirement pool:\n- Implement the special factorial calculation algorithm\n- Handle edge cases like input validation and large integers\n- Optimize the algorithm for better performance\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the special factorial for a given integer.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using open-source libraries, you can utilize the math library in Python to calculate factorials efficiently. Here is a sample logic:\n    \n```python\nimport math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n\n# Test the function\nprint(special_factorial(4))  # Output should be 288\n```\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the Brazilian factorial is simply 1! = 1.\n    \n    special_factorial(0) = 1\n    Explanation: For n=0, the Brazilian factorial is defined as the product of factorials from 1 to 0, which is 1.\n    \n    special_factorial(5) = 34560\n    Explanation: For n=5, the Brazilian factorial is calculated as 5! * 4! * 3! * 2! * 1! = 120 * 24 * 6 * 2 * 1 = 34560.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers all scenarios effectively.\n", "requirement analysis:\nThe main requirement is to implement a function that efficiently calculates the special factorial of a given integer. It should handle large input values and provide accurate results.\nrequirement pool:\n- Implement special factorial calculation logic\n- Optimize the algorithm for performance\n- Write test cases to ensure correctness\nWe will implement the special_factorial function using the math library in Python to efficiently calculate the special factorial of a given integer.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the math library, the code logic would involve importing the math library and then calculating the special factorial using a loop to multiply the factorials of each number from n to 1.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the special factorial is 1! = 1\n    special_factorial(4) = 288\n    Explanation: For n=4, the special factorial is 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n    special_factorial(0) = 1\n    Explanation: For n=0, the special factorial is defined as 1 according to the Brazilian factorial definition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of calculating the special factorial covers all scenarios.\n", "requirement pool:\n- Implement efficient algorithm for Brazilian factorial calculation\n- Ensure the function handles edge cases like n=0 or negative values\n- Optimize the function to handle large values of n without performance degradation\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the Brazilian factorial as per the given requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial involves multiplying n! with consecutive (n-1)!, and further multiplying with subsequent factorials until 1!.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    As the plan suggests, we need to design a static Python function using appropriate open-source libraries to efficiently calculate the Brazilian factorial as per the given requirements.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the Brazilian factorial is simply 1! = 1\n    special_factorial(4) = 288\n    Explanation: For n=4, the Brazilian factorial is calculated as 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n    special_factorial(0) = 1\n    Explanation: For n=0, the Brazilian factorial is defined as 1 by convention.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the Brazilian factorial covers all scenarios.\n", "requirement pool:\n- The main code ...\n- The game algorithm ...\nWe will design a static Python function using appropriate open-source libraries to calculate the Brazilian factorial as per the user requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial involves multiplying n! with consecutive (n-1)!, and further multiplying with subsequent factorials until 1!.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    As the plan suggests, we need to design a static Python function using appropriate open-source libraries to calculate the Brazilian factorial as per the user requirements.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: When n=1, the Brazilian factorial is equal to 1! = 1.\n    special_factorial(2) = 2\n    Explanation: When n=2, the Brazilian factorial is equal to 2! * 1! = 2.\n    special_factorial(0) = 1\n    Explanation: When n=0, the Brazilian factorial is defined as 1 according to the requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of calculating the Brazilian factorial covers these cases.\n", "requirement analysis:\nThe special_factorial function needs to efficiently calculate the Brazilian factorial by multiplying n! with (n-1)! and so on until 1!. It should handle large numbers and edge cases effectively.\nrequirement pool:\n- Implement the core logic for calculating Brazilian factorial\n- Write test cases to validate the special_factorial function\n- Optimize the algorithm for better performance\nWe will design a static Python function 'special_factorial' that efficiently calculates the Brazilian factorial as per the given requirements. We will leverage the math library in Python for factorial calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial involves multiplying n! with consecutive (n-1)!, and further multiplying with subsequent factorials until 1!.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests leveraging the math library in Python for factorial calculation, the code logic would involve using the math library functions to calculate the Brazilian factorial efficiently.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: When n=1, the Brazilian factorial is equal to 1! = 1.\n    special_factorial(4) = 288\n    Explanation: For n=4, the Brazilian factorial is calculated as 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n    special_factorial(0) = 1\n    Explanation: When n=0, the Brazilian factorial is defined as 1 by convention.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The math library functions can handle factorial calculations efficiently.\n", "requirement analysis:\nThe main goal is to efficiently calculate the special factorial of a given positive integer while ensuring accuracy and handling edge cases effectively.\nrequirement pool:\n- Implement the core special factorial calculation logic\n- Handle input validation for positive integers only\n- Optimize the algorithm for efficiency\n- Include comprehensive test cases for accuracy validation\n- Implement error handling for edge cases\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the special factorial of a given positive integer while ensuring accuracy and handling edge cases effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special factorial'\n    Explanation: The special factorial is defined as the product of factorials from n down to 1, where n is a positive integer.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using open-source libraries for efficient calculation, you can implement the special factorial function using the math library in Python. Here is a sample logic:\n    \n```python\nimport math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result\n\n# Test the function\nprint(special_factorial(4))  # Output: 288\n```\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the special factorial is equal to 1! = 1.\n    \n    special_factorial(0) = 1\n    Explanation: For n=0, the special factorial is defined as the product of factorials from 0 down to 1, which results in 1.\n    \n    special_factorial(5) = 34560\n    Explanation: For n=5, the special factorial is calculated as 5! * 4! * 3! * 2! * 1! = 120 * 24 * 6 * 2 * 1 = 34560.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers handling edge cases effectively.\n", "requirement analysis:\nThe main goal is to efficiently calculate the special factorial of an integer while ensuring accuracy and handling edge cases. The function should be able to handle large integers and provide clear error messages for invalid inputs.\nrequirement pool:\n- Implement the special factorial calculation logic\n- Optimize the algorithm for efficiency\n- Implement input validation and error handling\nWe will use the math library in Python to efficiently calculate the special factorial by multiplying the factorials of each number from n to 1.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special factorial'\n    Explanation: The special factorial is defined as the product of factorials of each number from n to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already suggests using the math library to calculate the special factorial efficiently, the implementation can follow the steps provided in the plan.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: When n is 1, the special factorial is equal to 1! = 1.\n    special_factorial(0) = 1\n    Explanation: When n is 0, the special factorial is defined as the product of factorials from n to 1, which results in 1.\n    special_factorial(5) = 34560\n    Explanation: The special factorial of 5 is calculated as 5! * 4! * 3! * 2! * 1! = 120 * 24 * 6 * 2 * 1 = 34560.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n <= 0:\n            return 1\n        (other code)\n", "requirement pool:\n- Implement the special_factorial function according to the defined Brazilian factorial formula\n- Handle input validation to ensure n is a positive integer\n- Optimize the function for better performance, especially for large values of n\nWe will design a static Python function using the math library to efficiently calculate the special factorial as per the Brazilian factorial formula.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already mentions using the math library to calculate the special factorial efficiently, the code logic can be implemented as follows:\n```python\nimport math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n```\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the special factorial is 1! = 1.\n    \n    special_factorial(0) = 1\n    Explanation: For n=0, the special factorial is defined as the product of factorials from 1 to 0, which is 1.\n    \n    special_factorial(4) = 288\n    Explanation: For n=4, the special factorial calculation is 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers all scenarios including edge cases.\n", "requirement pool:\n- Implement the special factorial calculation algorithm\n- Handle edge cases such as negative integers or zero\n- Optimize the special factorial function for large integer inputs\nWe will implement the special factorial calculation algorithm using Python's math library to handle factorial calculations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using Python's math library for factorial calculations, the code logic would involve iterating from n down to 1 and multiplying each factorial term with the previous factorial result.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the Brazilian factorial is 1! = 1.\n    special_factorial(4) = 288\n    Explanation: For n=4, the Brazilian factorial is 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n    special_factorial(0) = 1\n    Explanation: For n=0, the Brazilian factorial is defined as the product of factorials from n down to 1, which results in 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of calculating the Brazilian factorial covers all scenarios.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [16, 16, 16, 16, 16, 16, 16, 16, 16, 16], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    \"\"\"\n    Calculate the special factorial of n using the Brazilian factorial algorithm.\n\n    Args:\n        n: An integer to calculate the special factorial for.\n\n    Returns:\n        The special factorial of n as an integer.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    result = 1\n    for i in range(n, 1, -1):\n        result *= math.factorial(i)  ## Multiply each factorial term with the previous factorial result\n\n    return result\n", "passed": true, "pass": true, "pass_num": 10, "round": 742, "repair_prompt": ["def special_factorial(n):\t\n'''The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\nFor example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''", "def special_factorial(n):\t\n'''The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\nFor example:\n    >>> special_factorial(4)\n    288\n\n    This operation involves multiplying n! with the consecutive (n-1)!,\n    and further multiplying with subsequent factorials until 1!. The result is the Brazilian factorial of n.\n    '''", "def special_factorial(n):\n'''The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0\nThe function will receive an integer as input and should return the special factorial of this integer.\n    >>> special_factorial(4)\n    288 '''"], "mutate_method": "condense_two2one", "parent_index": 712}
