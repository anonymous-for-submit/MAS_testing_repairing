{"task_id": "HumanEval/139", "prompt": "def special_factorial(n):\t\n'''The Brazilian factorial is described as: \n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\nFor example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''", "entry_point": "special_factorial", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "test": ["def check(special_factorial):\n\tassert special_factorial(7) == 125411328000", "def check(special_factorial):\n\tassert special_factorial(9) == 1834933472251084800000", "def check(special_factorial):\n\tassert special_factorial(1) == 1, \"Test 1\"", "def check(special_factorial):\n\tassert special_factorial(3) == 12", "def check(special_factorial):\n\tassert special_factorial(10) == 6658606584104736522240000000", "def check(special_factorial):\n\tassert special_factorial(12) == 127313963299399416749559771247411200000000000", "def check(special_factorial):\n\tassert special_factorial(4) == 288", "def check(special_factorial):\n\tassert special_factorial(1) == 1", "def check(special_factorial):\n\tassert special_factorial(6) == 24883200", "def check(special_factorial):\n\tassert special_factorial(8) == 5056584744960000", "def check(special_factorial):\n\tassert special_factorial(5) == 34560", "def check(special_factorial):\n\tassert special_factorial(4) == 288, \"Test 4\"", "def check(special_factorial):\n\tassert special_factorial(2) == 2", "def check(special_factorial):\n\tassert special_factorial(5) == 34560, \"Test 5\"", "def check(special_factorial):\n\tassert special_factorial(11) == 265790267296391946810949632000000000", "def check(special_factorial):\n\tassert special_factorial(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand."], "test_case_list": ["assert special_factorial(7) == 125411328000", "assert special_factorial(9) == 1834933472251084800000", "assert special_factorial(1) == 1, \"Test 1\"", "assert special_factorial(3) == 12", "assert special_factorial(10) == 6658606584104736522240000000", "assert special_factorial(12) == 127313963299399416749559771247411200000000000", "assert special_factorial(4) == 288", "assert special_factorial(1) == 1", "assert special_factorial(6) == 24883200", "assert special_factorial(8) == 5056584744960000", "assert special_factorial(5) == 34560", "assert special_factorial(4) == 288, \"Test 4\"", "assert special_factorial(2) == 2", "assert special_factorial(5) == 34560, \"Test 5\"", "assert special_factorial(11) == 265790267296391946810949632000000000", "assert special_factorial(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand."], "nl": "The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    ", "func": "def special_factorial(n):", "examples": "For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    ", "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n    if n <= 0:\n        return None  # Handle invalid input\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as: \n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''\n    if n == 0:\n        return 1\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n", "from typing import List\n## main.py\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''\n    \n    if n <= 0:\n        return 1\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= i\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as: \n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    It is a special way of calculating factorials in Brazil.\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result\n", "from typing import List\n## main.py\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    It is a special way of calculating factorials in Brazil.\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n    result = 1\n    for i in range(n, 0, -1):\n        result *= i\n    return result\n", "from typing import List\n## main.py\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    It is a special way of calculating factorials in Brazil.\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n    if n == 0 or n == 1:\n        return 1\n    \n    result = 1\n    for i in range(2, n+1):\n        result *= i\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n\n# Test the function\nprint(special_factorial(4))  # Output should be 288\n", "from typing import List\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n    if n == 0 or n == 1:\n        return 1\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    The function will receive an integer as input and should return the special factorial of this integer.\n    '''\n\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n", "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''\n    \n    if n <= 0:\n        return 0\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n"], "plans": ["requirement analysis:\nThe main focus is on efficiently calculating the special factorial for large integers while ensuring accuracy and performance optimization.\nrequirement pool:\n- Implement the special factorial calculation logic\n- Optimize the algorithm for better performance\n- Handle edge cases such as negative inputs\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the special factorial for large integers while ensuring accuracy and performance optimization.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    'greater than 0': Indicates that the input integer should be positive.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using open-source libraries for efficiency and accuracy, you can implement the special_factorial function using the math library in Python to calculate factorials.\n\n```python\nimport math\n\ndef special_factorial(n):\n    if n <= 0:\n        return None  # Handle invalid input\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n```\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the special factorial is 1! = 1.\n    \n    special_factorial(0) = None\n    Explanation: Since n should be greater than 0, returning None for invalid input.\n    \n    special_factorial(4) = 288\n    Explanation: For n=4, the calculation is 1! * 2! * 3! * 4! = 1 * 2 * 6 * 24 = 288.\n\n# [extra code for edge case]\n    No extra code needed to handle the edge cases. The logic covers handling invalid inputs and calculating the special factorial efficiently.\n", "requirement analysis:\nThe main goal is to efficiently calculate the special factorial of an integer while ensuring accuracy and handling edge cases effectively.\nrequirement pool:\n- Implement the special_factorial function to calculate the special factorial of an integer\n- Optimize the algorithm for efficient computation of factorials\n- Include error handling for invalid input values\nWe will use the math library in Python to efficiently calculate factorials and implement the special_factorial function as requested.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special type of factorial where each term is the factorial of the current number multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    'greater than': Indicates that the input integer should be greater than 0.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the math library to calculate factorials efficiently, the code logic would involve iterating from n to 1 and multiplying the factorials of each number.\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the Brazilian factorial is 1! = 1.\n    special_factorial(2) = 2\n    Explanation: For n=2, the Brazilian factorial is 2! * 1! = 2.\n    special_factorial(0) = 1\n    Explanation: For n=0, the Brazilian factorial is defined as 1 according to the formula.\n\n# [extra code for edge case]\n    No extra code is needed to handle the edge cases as the logic of calculating factorials already accounts for these scenarios.\n", "requirement analysis:\nThe function should efficiently calculate the special factorial by multiplying factorials from n down to 1. It should handle large integers and edge cases like 0 gracefully. Performance optimization is crucial for better user experience.\nrequirement pool:\n- Implement the special_factorial function to calculate the special factorial of a given integer\n- Handle edge cases such as 0 input and large integers for accurate results\n- Optimize the algorithm for better performance and scalability\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the special factorial as per the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    'greater than 0': Indicates that the input integer should be positive.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the code logic for special_factorial(n):\n    - Check if n is greater than 0\n    - Initialize a variable to store the result\n    - Iterate from n to 1 and calculate the factorial of each number, multiplying it with the result\n    - Return the final result\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the special factorial is 1! = 1\n    special_factorial(4) = 288\n    Explanation: For n=4, the special factorial is 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n    special_factorial(0) = 1\n    Explanation: For n=0, the special factorial is defined as 1 according to the formula.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic covers handling positive integers and calculating the special factorial accordingly.\n", "requirement analysis:\nThe special_factorial function needs to efficiently calculate the Brazilian factorial by multiplying factorials from n down to 1. It should handle large integer inputs and provide accurate results.\nrequirement pool:\n- Implement the special_factorial function to calculate the Brazilian factorial\n- Optimize the algorithm for performance and scalability\n- Include error handling for invalid inputs\nWe will use the math library in Python to calculate factorials and implement the special_factorial function as a static function without defining any class.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special way of calculating factorials where each factorial is multiplied by the previous factorials.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the math library to calculate factorials, the code logic would involve iterating from n down to 1 and multiplying each factorial with the previous ones.\n\n# [edge case] \n    special_factorial(0) = 1\n    Explanation: The Brazilian factorial of 0 is defined as 1.\n    special_factorial(1) = 1\n    Explanation: The Brazilian factorial of 1 is also 1.\n    special_factorial(4) = 288\n    Explanation: The Brazilian factorial of 4 is calculated as 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the Brazilian factorial covers all scenarios.\n", "requirement pool:\n- The main code ...\n- The game algorithm ...\nWe will design a simple static Python function using appropriate open-source libraries to calculate the Brazilian factorial as described in the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special way of calculating factorials where each factorial is multiplied by the previous factorials.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the Brazilian factorial function:\n    1. Initialize a variable to store the result as 1.\n    2. Iterate from n down to 1.\n    3. For each iteration, multiply the current result by the factorial of the current number.\n    4. Return the final result.\n\n# [edge case] \n    special_factorial(0) = 1\n    Explanation: The factorial of 0 is defined as 1 in mathematics.\n    special_factorial(1) = 1\n    Explanation: The factorial of 1 is also 1.\n    special_factorial(4) = 288\n    Explanation: Calculating the Brazilian factorial for 4 results in 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic covers all scenarios including edge cases.\n", "requirement analysis:\nThe main focus is to implement a function that efficiently calculates the Brazilian factorial by multiplying factorials in a specific order. Accuracy and performance optimization are crucial for handling large integer inputs.\nrequirement pool:\n- Implement the special_factorial function following the Brazilian factorial formula\n- Perform thorough testing to ensure accurate results for various integer inputs\n- Optimize the algorithm for better performance, especially with large integers\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the Brazilian factorial as per the given formula.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special way of calculating factorials in Brazil where each factorial is multiplied by the previous factorials.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already mentions using appropriate open-source libraries to efficiently calculate the Brazilian factorial, the code logic should involve importing necessary libraries and implementing the factorial calculation based on the given formula.\n\n# [edge case] \n    special_factorial(0) = 1\n    Explanation: By definition, 0! = 1, so the expected output is 1.\n    special_factorial(1) = 1\n    Explanation: 1! = 1, so the expected output is 1.\n    special_factorial(2) = 2\n    Explanation: 2! * 1! = 2, so the expected output is 2.\n\n# [extra code for edge case]\n    No extra code needed to handle the edge cases. The logic for calculating the Brazilian factorial should cover these cases.\n", "requirement analysis:\nThe main goal is to efficiently calculate the special factorial of an integer while ensuring accuracy and handling large values. The product should outperform competitors in both efficiency and accuracy.\nrequirement pool:\n- Implement special factorial calculation algorithm\n- Optimize algorithm for efficiency and speed\n- Test and validate special factorial results for accuracy\nWe will design a static Python function using appropriate open-source libraries to efficiently calculate the special factorial of an integer while ensuring accuracy and handling large values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special factorial'\n    Explanation: The special factorial is calculated by multiplying the factorial of the input integer with the factorial of all integers less than the input integer down to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using open-source libraries for efficiency and accuracy, we can implement the special factorial function using the math library in Python. Here is a sample code logic:\n    \n```python\nimport math\n\ndef special_factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    return result\n\n# Test the function\nprint(special_factorial(4))  # Output should be 288\n```\n\n# [edge case] \n    special_factorial(0) = 1\n    Explanation: The special factorial of 0 is 1 because it is defined as the product of factorials from 1 to 0.\n    special_factorial(1) = 1\n    Explanation: The special factorial of 1 is also 1 as it is the factorial of 1.\n    special_factorial(2) = 2\n    Explanation: The special factorial of 2 is 2 as it is the factorial of 2 multiplied by the factorial of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers all scenarios including edge cases.\n", "requirement analysis:\nThe main goal is to create a Python function that efficiently calculates the special factorial of a given integer. The function should handle large integers accurately and optimize performance for faster computation.\nrequirement pool:\n- Implement the special_factorial function to calculate the special factorial of a given integer\n- Optimize the algorithm for efficient computation, especially for large integers\n- Ensure the function is well-documented and easy to understand for users\nWe will use the math library in Python to efficiently calculate the factorial of each number in the special factorial sequence and multiply them together to get the final result.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special factorial'\n    Explanation: The special factorial is calculated by multiplying the factorial of each number from n down to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already suggests using the math library to calculate factorials efficiently, the implementation can follow the steps mentioned in the plan.\n\n# [edge case] \n    special_factorial(0) = 1\n    Explanation: The special factorial of 0 is 1 because it is defined as the product of factorials from n down to 1, and 0! is 1.\n    special_factorial(1) = 1\n    Explanation: The special factorial of 1 is also 1 because it is the product of factorials from n down to 1, and 1! is 1.\n    special_factorial(4) = 288\n    Explanation: The special factorial of 4 is calculated as 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan and the implementation should cover all scenarios.\n", "requirement pool:\n- Implement the special_factorial function to correctly calculate the special factorial of an integer\n- Optimize the algorithm to handle large integer inputs efficiently\n- Ensure the function is well-documented and easy to understand for users\nWe will use the math library in Python to efficiently calculate the special factorial by multiplying the factorials of each number from n to 1.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special factorial'\n    Explanation: The special factorial is calculated by multiplying the factorials of each number from n to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already suggests using the math library to calculate the special factorial efficiently, the code logic would involve importing the math library and using the factorial function to calculate the special factorial.\n\n# [edge case] \n    special_factorial(0) = 1\n    Explanation: The special factorial of 0 is defined as 1.\n    special_factorial(1) = 1\n    Explanation: The special factorial of 1 is also 1.\n    special_factorial(4) = 288\n    Explanation: The special factorial of 4 is calculated as 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n\n# [extra code for edge case]\n    No extra code is needed to handle the edge cases as the math library's factorial function already handles these cases.\n", "requirement pool:\n- Implement the special_factorial function according to the provided formula\n- Handle input validation to ensure n is a positive integer\n- Optimize the factorial calculation algorithm for efficiency\nWe will design a static Python function using the math library to efficiently calculate the special factorial as per the provided formula.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Brazilian factorial'\n    Explanation: The Brazilian factorial is a special factorial calculation where each factorial term is multiplied by the factorial of the previous number.\n\n# [phrase showing quantity relationship]\n    'greater than': Indicates that the input integer should be greater than 0.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the code, we can follow these steps:\n    - Check if the input integer is greater than 0\n    - Calculate the Brazilian factorial by multiplying each factorial term from n to 1\n    - Return the result of the Brazilian factorial\n\n# [edge case] \n    special_factorial(1) = 1\n    Explanation: For n=1, the Brazilian factorial is 1! = 1.\n    special_factorial(4) = 288\n    Explanation: For n=4, the Brazilian factorial is 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\n    special_factorial(0) = 0\n    Explanation: Since n should be greater than 0, for n=0, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n <= 0:\n            return 0\n        (other code)\n"], "scores": [1.0, 1.0, 0.1875, 1.0, 0.1875, 0.1875, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, false, true, false, false, true, true, true, true], "pass_test_cases_num": [16, 16, 3, 16, 3, 3, 16, 16, 16, 16], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef special_factorial(n: int) -> int:\n    '''\n    The Brazilian factorial is described as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\n    For example:\n        >>> special_factorial(4)\n        288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''\n    \n    if n <= 0:\n        return 0\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result\n", "passed": true, "pass": true, "pass_num": 7, "round": 172, "repair_prompt": ["def special_factorial(n):\t\n'''The Brazilian factorial is described as: \n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n is greater than 0\nFor example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''", "def special_factorial(n):\t\n'''The Brazilian factorial is described as: \n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    It is a special way of calculating factorials in Brazil.\nFor example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    '''", "def special_factorial(n):\t\n'''The Brazilian factorial is described as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    The function will receive an integer as input and should return the special factorial of this integer.\n    >>> special_factorial(4)\n    288\n    '''"], "mutate_method": "rephrase_one", "parent_index": 216}
