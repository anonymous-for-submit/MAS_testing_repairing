{"task_id": "HumanEval/160", "prompt": "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations: Addition ( + ), Subtraction ( - ), Multiplication ( * ), Floor division ( // ), Exponentiation ( ** )\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": ["def check(do_algebra):\n\tassert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [8, 8, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [5, 1, 6]) == 5", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [12, 1, 6]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [2, 5, 7]) == 17", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [2, 3, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [6, 2, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [8, 2, 7]) == -120", "def check(do_algebra):\n\tassert do_algebra(['//', '**'], [4, 4, 4]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [5, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 2, 7]) == 71", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [9, 3, 8]) == 35", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "def check(do_algebra):\n\tassert do_algebra(['*', '-'], [6, 5, 7]) == 23", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "def check(do_algebra):\n\tassert do_algebra(['-', '*'], [3, 3, 6]) == -15", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 5, 2]) == -22", "def check(do_algebra):\n\tassert do_algebra(['+', '*'], [7, 3, 6]) == 25", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [3, 2, 8]) == 768", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [7, 3, 3]) == 189", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [8, 4, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [8, 2, 2]) == 128", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [3, 4, 4]) == 3", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [10, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [7, 3, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '-'], [6, 1, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [3, 7, 6]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "def check(do_algebra):\n\tassert do_algebra(['*', '*'], [5, 2, 7]) == 70", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 3, 4]) == -78", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [2, 7, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [10, 2, 8]) == 800", "def check(do_algebra):\n\tassert do_algebra(['+', '//'], [3, 6, 4]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 3, 5]) == 250", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [7, 3, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [3, 2, 4]) == 19", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "def check(do_algebra):\n\tassert do_algebra(['**', '-'], [3, 2, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "def check(do_algebra):\n\tassert do_algebra(['+', '+'], [4, 4, 1]) == 9", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [10, 7, 1]) == 4", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [8, 4, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [4, 8, 4]) == 36", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "test_case_list": ["assert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "assert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "assert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "assert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "assert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "assert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "assert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "assert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "assert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "assert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "assert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "assert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "assert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "assert do_algebra(['//', '//'], [8, 8, 7]) == 0", "assert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "assert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "assert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "assert do_algebra(['*', '**'], [5, 1, 6]) == 5", "assert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "assert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "assert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "assert do_algebra(['**', '//'], [12, 1, 6]) == 2", "assert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "assert do_algebra(['*', '+'], [2, 5, 7]) == 17", "assert do_algebra(['**', '*'], [2, 3, 1]) == 8", "assert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "assert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "assert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "assert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "assert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "assert do_algebra(['-', '**'], [6, 2, 2]) == 2", "assert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "assert do_algebra(['-', '**'], [8, 2, 7]) == -120", "assert do_algebra(['//', '**'], [4, 4, 4]) == 0", "assert do_algebra(['-', '//'], [5, 3, 8]) == 5", "assert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "assert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "assert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "assert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "assert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "assert do_algebra(['**', '+'], [8, 2, 7]) == 71", "assert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "assert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "assert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "assert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "assert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "assert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "assert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "assert do_algebra(['*', '+'], [9, 3, 8]) == 35", "assert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "assert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "assert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "assert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "assert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "assert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "assert do_algebra(['*', '-'], [6, 5, 7]) == 23", "assert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "assert do_algebra(['-', '*'], [3, 3, 6]) == -15", "assert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "assert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "assert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "assert do_algebra(['-', '**'], [3, 5, 2]) == -22", "assert do_algebra(['+', '*'], [7, 3, 6]) == 25", "assert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "assert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "assert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "assert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "assert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "assert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "assert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "assert do_algebra(['*', '**'], [3, 2, 8]) == 768", "assert do_algebra(['*', '**'], [7, 3, 3]) == 189", "assert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "assert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "assert do_algebra(['-', '+'], [8, 4, 3]) == 7", "assert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "assert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "assert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "assert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "assert do_algebra(['**', '*'], [8, 2, 2]) == 128", "assert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "assert do_algebra(['-', '+'], [3, 4, 4]) == 3", "assert do_algebra(['+', '-'], [10, 3, 8]) == 5", "assert do_algebra(['//', '*'], [7, 3, 4]) == 8", "assert do_algebra(['//', '-'], [6, 1, 2]) == 4", "assert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "assert do_algebra(['+', '-'], [3, 7, 6]) == 4", "assert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "assert do_algebra(['*', '*'], [5, 2, 7]) == 70", "assert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "assert do_algebra(['-', '**'], [3, 3, 4]) == -78", "assert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "assert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "assert do_algebra(['//', '//'], [2, 7, 1]) == 0", "assert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "assert do_algebra(['**', '*'], [10, 2, 8]) == 800", "assert do_algebra(['+', '//'], [3, 6, 4]) == 4", "assert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "assert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "assert do_algebra(['+', '**'], [7, 3, 5]) == 250", "assert do_algebra(['-', '//'], [7, 3, 2]) == 6", "assert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "assert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "assert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "assert do_algebra(['+', '**'], [3, 2, 4]) == 19", "assert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "assert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "assert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "assert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "assert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "assert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "assert do_algebra(['**', '-'], [3, 2, 9]) == 0", "assert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "assert do_algebra(['+', '+'], [4, 4, 1]) == 9", "assert do_algebra(['-', '+'], [10, 7, 1]) == 4", "assert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "assert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "assert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "assert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "assert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "assert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "assert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "assert do_algebra(['//', '*'], [8, 4, 2]) == 4", "assert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "assert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "assert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "assert do_algebra(['*', '+'], [4, 8, 4]) == 36", "assert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "nl": "\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    ", "func": "def do_algebra(operator, operand):", "examples": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    ", "completions": ["from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build and evaluate the algebraic expression.\n    Args:\n        operator (list): List of basic algebra operations.\n        operand (list): List of integers.\n    Returns:\n        int: Result of the evaluated expression.\n    '''\n    expression = ''\n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    return eval(expression)\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build and evaluate the algebraic expression.\n    \n    Parameters:\n        operator (List[str]): List of basic algebra operations\n        operand (List[int]): List of integers\n    \n    Returns:\n        int: Result of the algebraic expression evaluation\n    '''\n    \n    def apply_operation(op, num1, num2):\n        if op == '+':\n            return num1 + num2\n        elif op == '-':\n            return num1 - num2\n        elif op == '*':\n            return num1 * num2\n        elif op == '/':\n            return num1 / num2\n        elif op == '**':\n            return num1 ** num2\n        else:\n            raise ValueError(f'Invalid operator: {op}')\n    \n    result = operand[0]\n    current_op = None\n    \n    for i in range(1, len(operand)):\n        if current_op is None:\n            current_op = operator[i - 1]\n            result = apply_operation(current_op, result, operand[i])\n        else:\n            if operator[i - 1] in ['*', '/']:\n                result = apply_operation(operator[i - 1], result, operand[i])\n            else:\n                result = apply_operation(current_op, result, operand[i])\n                current_op = operator[i - 1]\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build and evaluate the algebraic expression.\n    The operator list contains basic algebra operations, and the operand list contains integers.\n    Returns the evaluation result of the expression.\n    '''\n    \n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    result = eval(expression)\n    \n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef construct_algebraic_expression(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Construct and evaluate the algebraic expression based on the given operators and operands.\n\n    Args:\n    operators (List[str]): List of operators representing the mathematical operations to be performed.\n    operands (List[int]): List of operands representing the values on which the operations are performed.\n\n    Returns:\n    int: Result of the evaluated algebraic expression.\n    \"\"\"\n\n    expression = ''\n    for i in range(len(operators)):\n        expression += str(operands[i]) + operators[i]\n    expression += str(operands[-1])\n    \n    result = eval(expression)\n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport operator\n\ndef construct_algebraic_expression(operators: List[str], operands: List[int]) -> int:\n    ## Constructing the algebraic expression based on the given operators and operands\n    expression = ''\n    for i in range(len(operators)):\n        expression += str(operands[i])\n        expression += operators[i]\n    expression += str(operands[-1])\n    \n    ## Computing the value of the algebraic expression using the operators\n    return eval(expression)\n\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef construct_algebraic_expression(operators: List[str], operands: List[int]) -> int:\n    def evaluate_expression(op1, op2, operator):\n        if operator == '+':\n            return op1 + op2\n        elif operator == '-':\n            return op1 - op2\n        elif operator == '*':\n            return op1 * op2\n        elif operator == '/':\n            return op1 / op2\n        elif operator == '**':\n            return op1 ** op2\n        elif operator == '//':\n            return op1 // op2\n        else:\n            raise ValueError(\"Invalid operator\")\n\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Number of operators should be one less than number of operands\")\n\n    result = operands[0]\n    for i in range(len(operators)):\n        result = evaluate_expression(result, operands[i + 1], operators[i])\n\n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    '''\n    Given two lists operator and operand, build the algebraic expression and return the evaluation of this expression.\n    The basic algebra operations: Addition (+), Subtraction (-), Multiplication (*), Floor division (//), Exponentiation (**)\n    Example:\n        operator['+', '*', '-']\n        array = [2, 3, 4, 5]\n        result = 2 + 3 * 4 - 5\n        => result = 9\n    Note:\n        The length of the operator list is equal to the length of the operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and the operand list has at least two operands.\n    '''\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i+1])\n    return eval(expression)\n", "from typing import List\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build the algebraic expression and return the evaluation of this expression.\n    \n    Args:\n        operator (list): List of operators (+, -, *, //, **)\n        operand (list): List of non-negative integers\n    Returns:\n        int: Result of the algebraic expression evaluation\n    '''\n    \n    # Check if the number of operators is one less than the number of operands\n    if len(operator) != len(operand) - 1:\n        return \"Invalid input: Number of operators should be one less than the number of operands.\"\n    \n    # Initialize result with the first operand\n    result = operand[0]\n    \n    # Iterate through the operators and operands to evaluate the expression\n    for i in range(1, len(operand)):\n        if operator[i-1] == '+':\n            result += operand[i]\n        elif operator[i-1] == '-':\n            result -= operand[i]\n        elif operator[i-1] == '*':\n            result *= operand[i]\n        elif operator[i-1] == '//':\n            result //= operand[i]\n        elif operator[i-1] == '**':\n            result **= operand[i]\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build the algebraic expression and return the evaluation of this expression.\n    \n    Args:\n        operator (list): List of algebra operators\n        operand (list): List of non-negative integers\n    \n    Returns:\n        int: Result of the evaluated algebraic expression\n    '''\n    \n    # Constructing the algebraic expression\n    expression = ''\n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    # Using the 'eval' function to evaluate the expression\n    result = eval(expression)\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build and evaluate the algebraic expression.\n    Args:\n        operator (list): List of basic algebra operations\n        operand (list): List of integers\n    Returns:\n        int: Result of the evaluated expression\n    '''\n    expression = ''\n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    return eval(expression)\n"], "plans": ["requirement pool:\n- Support all basic algebra operations\n- Handle edge cases like division by zero\n- Optimize performance for large input lists\nWe will use the built-in eval function in Python to evaluate the algebraic expression formed by the given operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: The requirement involves building and evaluating an algebraic expression using given operators and operands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the built-in eval function in Python, the detailed logic is not needed as it handles the evaluation of algebraic expressions.\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: With only two operands and one operator, the expression is evaluated as 2 + 3 * 4 = 10.\n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression is evaluated as 5 - 3 + 2 * 4 = 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval function can handle different algebraic expressions effectively.\n", "requirement pool:\n- Implement the core algebraic expression evaluation function\n- Ensure support for all basic algebraic operations\n- Optimize the function for performance\nWe will design a simple static Python function using basic arithmetic operations to evaluate algebraic expressions efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: It refers to a mathematical expression involving variables, numbers, and arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Check if there are steps should be considered simultaneously\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: The expression is 2 + 3 * 4 = 10\n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression is 5 - 3 + 2 * 4 = 3\n    do_algebra(['**'], [2, 3]) = 8\n    Explanation: The expression is 2 ** 3 = 8\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement the core algebraic expression evaluation function\n- Handle different operator precedence levels\n- Include support for parentheses in expressions\nWe will use the built-in eval function in Python to evaluate the algebraic expression. No external libraries are needed for this simple function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: The requirement involves building and evaluating an algebraic expression using given operators and operands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the built-in eval function in Python, the code logic can be implemented as follows:\n```python\ndef do_algebra(operator, operand):\n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    result = eval(expression)\n    \n    return result\n```\n\n# [edge case] \n    do_algebra(['+', '*', '-'], [2, 3, 4, 5]) = 9\n    Explanation: The algebraic expression is 2 + 3 * 4 - 5, which evaluates to 9.\n\n    do_algebra(['*', '+', '-'], [2, 3, 4, 5]) = 13\n    Explanation: The algebraic expression is 2 * 3 + 4 - 5, which evaluates to 13.\n\n    do_algebra(['-', '+'], [2, 3, 4]) = -5\n    Explanation: The algebraic expression is 2 - 3 + 4, which evaluates to -5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The built-in eval function can handle various algebraic expressions.\n", "requirement pool:\n- Support addition, subtraction, multiplication, floor division, and exponentiation\n- Handle division by zero scenarios\n- Optimize performance for large operand lists\nWe will use the eval function in Python to construct and evaluate the algebraic expression based on the given operators and operands.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'operators': represent the mathematical operations to be performed\n    'operands': represent the values on which the operations are performed\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the eval function in Python, the detailed logic to implement the code would involve constructing the algebraic expression using the given operators and operands, and then evaluating it using the eval function.\n\n    Here is a sample code logic:\n    ```python\n    def construct_algebraic_expression(operators: List[str], operands: List[int]) -> int:\n        expression = ''\n        for i in range(len(operators)):\n            expression += str(operands[i]) + operators[i]\n        expression += str(operands[-1])\n        \n        result = eval(expression)\n        return result\n    ```\n\n# [edge case] \n    construct_algebraic_expression(['+', '-', '*'], [1, 2, 3, 4]) = 3\n    Explanation: The expression would be '1+2-3*4' which evaluates to 3.\n    \n    construct_algebraic_expression(['**'], [2, 3]) = 8\n    Explanation: The expression would be '2**3' which evaluates to 8.\n    \n    construct_algebraic_expression(['//'], [10, 3]) = 3\n    Explanation: The expression would be '10//3' which evaluates to 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The eval function can handle various algebraic expressions effectively.\n", "requirement pool:\n- Support addition, subtraction, multiplication, floor division, and exponentiation\n- Handle division by zero scenarios\n- Optimize performance for large operand lists\nWe will design a static Python function using basic arithmetic operations and the 'operator' module for efficient computation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: It refers to a mathematical expression involving variables, constants, and arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already mentions using basic arithmetic operations and the 'operator' module, the code logic should involve:\n    - Importing the 'operator' module\n    - Constructing the algebraic expression based on the given operators and operands\n    - Computing the value of the algebraic expression using the operators\n\n# [edge case] \n    construct_algebraic_expression(['+', '-', '*'], [1, 2, 3]) = 5\n    Explanation: The expression is 1 + 2 - 3 = 5\n    construct_algebraic_expression(['**', '//'], [2, 3, 2]) = 1\n    Explanation: The expression is 2 ** 3 // 2 = 1\n    construct_algebraic_expression(['+', '*'], [2, 3, 4]) = 14\n    Explanation: The expression is 2 + 3 * 4 = 14\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The existing logic should cover all scenarios.\n", "requirement pool:\n- Support addition, subtraction, multiplication, floor division, and exponentiation\n- Handle division by zero scenarios\n- Implement input validation for operators and operands\nWe will design a static Python function using basic arithmetic operations to construct and evaluate algebraic expressions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic operations'\n    Explanation: The core concept here is to perform arithmetic operations like addition, subtraction, multiplication, etc., on the given operands using the specified operators.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan is to design a static Python function using basic arithmetic operations, the code logic would involve:\n    - Parsing the input lists of operators and operands\n    - Constructing the algebraic expression based on the operators and operands\n    - Evaluating the expression to compute its value\n    - Returning the computed value\n\n# [edge case] \n    construct_algebraic_expression(['+', '-', '*'], [2, 3, 4]) = 14\n    Explanation: The expression would be 2 + 3 - 4 * 4 = 14\n    construct_algebraic_expression(['**', '+'], [2, 3, 4]) = 4096\n    Explanation: The expression would be 2 ** 3 + 4 = 4096\n    construct_algebraic_expression(['//'], [10, 2]) = 5\n    Explanation: The expression would be 10 // 2 = 5\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic should cover all scenarios.\n", "requirement pool:\n- Support all basic algebraic operations: +, -, *, //, **\n- Handle complex expressions with multiple operators\n- Ensure input validation for operand lists\nWe will design a static Python function using basic arithmetic operations and the eval() function to evaluate algebraic expressions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: The requirement involves building and evaluating algebraic expressions using basic arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using basic arithmetic operations and the eval() function, the code logic can be implemented as follows:\n    \n```python\ndef do_algebra(operator, operand):\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i+1])\n    return eval(expression)\n\n# Test the function\noperator = ['+', '*', '-']\noperand = [2, 3, 4, 5]\nresult = do_algebra(operator, operand)\nprint(result)  # Output: 9\n```\n\n# [edge case] \n    do_algebra(['+'], [5]) = 5\n    Explanation: With only one operand and no operator, the result should be the single operand value.\n    \n    do_algebra(['*', '-'], [2, 3]) = 6\n    Explanation: With two operands and one operator, the result should be the multiplication of the operands followed by subtraction.\n    \n    do_algebra(['+', '*', '-'], [2, 3, 4, 5]) = 9\n    Explanation: The provided example in the requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers scenarios with different numbers of operators and operands.\n", "requirement pool:\n- Implement the core algebraic expression evaluation function\n- Handle edge cases such as division by zero\n- Optimize the evaluation algorithm for efficiency\nWe will design a static Python function using basic arithmetic operations to evaluate algebraic expressions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: It refers to a mathematical expression involving variables, constants, and arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already mentions using basic arithmetic operations to evaluate algebraic expressions, the detailed logic can be implemented based on the provided plan.\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: With only two operands and one operator, the expression is evaluated as 2 + 3 * 4 = 10.\n    do_algebra(['-'], [5, 3, 2]) = 0\n    Explanation: With one operand and one operator, the expression is evaluated as 5 - 3 = 2, then 2 - 2 = 0.\n    do_algebra(['**'], [2, 3]) = 8\n    Explanation: With one operand and one operator, the expression is evaluated as 2 ** 3 = 8.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if len(operator) != len(operand) - 1:\n            return \"Invalid input: Number of operators should be one less than the number of operands.\"\n        (other code)\n", "requirement analysis:\nThe main goal is to create a function that can efficiently handle algebraic expressions using the provided operators and operands. Accuracy in evaluating the expressions is crucial to ensure the tool's reliability. Additionally, clear documentation will help users understand how to use the function effectively.\nrequirement pool:\n- Implement the core logic to parse and evaluate algebraic expressions\n- Handle edge cases such as division by zero and invalid input\n- Optimize the function for performance to handle large expressions efficiently\nWe will design a static Python function without defining any class that can efficiently handle algebraic expressions using the provided operators and operands. We will leverage the 'eval' function in Python to evaluate the algebraic expression.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: It refers to a mathematical expression involving variables, constants, and mathematical operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already suggests using the 'eval' function in Python to evaluate the algebraic expression, the detailed logic would involve:\n    - Constructing the algebraic expression using the provided operators and operands\n    - Using the 'eval' function to evaluate the expression\n    - Returning the result\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: With only two operands and one operator, the expression is 2 + 3 * 4 = 10.\n    \n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression is 5 - 3 + 2 * 4 = 3.\n\n    do_algebra(['**'], [2, 3]) = 8\n    Explanation: With one operator and two operands, the expression is 2 ** 3 = 8.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The plan already suggests using the 'eval' function which can handle different algebraic expressions efficiently.\n", "requirement pool:\n- Support all basic algebra operations: +, -, *, //, **\n- Handle operator precedence correctly\n- Implement error handling for invalid inputs\nWe will use the built-in eval function in Python to evaluate the algebraic expression created from the given operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: It refers to a mathematical expression involving variables and operations like addition, subtraction, multiplication, etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the built-in eval function in Python, the detailed logic is not needed.\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: With only two operands and one operator, the expression is evaluated as 2 + 3 = 5.\n    do_algebra(['-', '+', '*'], [2, 3, 4, 5]) = 5\n    Explanation: The expression is evaluated as 2 - 3 + 4 * 5 = 5.\n    do_algebra(['**'], [2, 3]) = 8\n    Explanation: With one operator and two operands, the expression is evaluated as 2 ** 3 = 8.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval function can handle different algebraic expressions.\n"], "scores": [1.0, 0.0698, 1.0, 0.0, 0.0, 0.0, 1.0, 0.6124, 1.0, 1.0], "pass_results": [true, false, true, false, false, false, true, false, true, true], "pass_test_cases_num": [129, 9, 129, 0, 0, 0, 129, 79, 129, 129], "completion": "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, build and evaluate the algebraic expression.\n    Args:\n        operator (list): List of basic algebra operations\n        operand (list): List of integers\n    Returns:\n        int: Result of the evaluated expression\n    '''\n    expression = ''\n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    return eval(expression)\n", "passed": true, "pass": true, "pass_num": 5, "round": 988, "repair_prompt": ["def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations: Addition ( + ), Subtraction ( - ), Multiplication ( * ), Floor division ( // ), Exponentiation ( ** )\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Using these lists, construct an algebraic expression and compute its value.\nThe basic algebra operations supported are Addition, Subtraction, Multiplication, Floor division, and Exponentiation.", "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand, build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations: Addition ( + ), Subtraction ( - ), Multiplication ( * ), Floor division ( // ), Exponentiation ( ** )\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''"], "mutate_method": "condense_two2one", "parent_index": 816}
