{"task_id": "HumanEval/160", "prompt": "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list consists of fundamental algebraic operations, and the second list is a list of integers. Use the two provided lists to form the algebraic expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": ["def check(do_algebra):\n\tassert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [8, 8, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [5, 1, 6]) == 5", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [12, 1, 6]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [2, 5, 7]) == 17", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [2, 3, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [6, 2, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [8, 2, 7]) == -120", "def check(do_algebra):\n\tassert do_algebra(['//', '**'], [4, 4, 4]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [5, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 2, 7]) == 71", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [9, 3, 8]) == 35", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "def check(do_algebra):\n\tassert do_algebra(['*', '-'], [6, 5, 7]) == 23", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "def check(do_algebra):\n\tassert do_algebra(['-', '*'], [3, 3, 6]) == -15", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 5, 2]) == -22", "def check(do_algebra):\n\tassert do_algebra(['+', '*'], [7, 3, 6]) == 25", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [3, 2, 8]) == 768", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [7, 3, 3]) == 189", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [8, 4, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [8, 2, 2]) == 128", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [3, 4, 4]) == 3", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [10, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [7, 3, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '-'], [6, 1, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [3, 7, 6]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "def check(do_algebra):\n\tassert do_algebra(['*', '*'], [5, 2, 7]) == 70", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 3, 4]) == -78", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [2, 7, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [10, 2, 8]) == 800", "def check(do_algebra):\n\tassert do_algebra(['+', '//'], [3, 6, 4]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 3, 5]) == 250", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [7, 3, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [3, 2, 4]) == 19", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "def check(do_algebra):\n\tassert do_algebra(['**', '-'], [3, 2, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "def check(do_algebra):\n\tassert do_algebra(['+', '+'], [4, 4, 1]) == 9", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [10, 7, 1]) == 4", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [8, 4, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [4, 8, 4]) == 36", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "test_case_list": ["assert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "assert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "assert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "assert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "assert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "assert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "assert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "assert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "assert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "assert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "assert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "assert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "assert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "assert do_algebra(['//', '//'], [8, 8, 7]) == 0", "assert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "assert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "assert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "assert do_algebra(['*', '**'], [5, 1, 6]) == 5", "assert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "assert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "assert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "assert do_algebra(['**', '//'], [12, 1, 6]) == 2", "assert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "assert do_algebra(['*', '+'], [2, 5, 7]) == 17", "assert do_algebra(['**', '*'], [2, 3, 1]) == 8", "assert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "assert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "assert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "assert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "assert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "assert do_algebra(['-', '**'], [6, 2, 2]) == 2", "assert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "assert do_algebra(['-', '**'], [8, 2, 7]) == -120", "assert do_algebra(['//', '**'], [4, 4, 4]) == 0", "assert do_algebra(['-', '//'], [5, 3, 8]) == 5", "assert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "assert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "assert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "assert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "assert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "assert do_algebra(['**', '+'], [8, 2, 7]) == 71", "assert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "assert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "assert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "assert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "assert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "assert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "assert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "assert do_algebra(['*', '+'], [9, 3, 8]) == 35", "assert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "assert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "assert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "assert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "assert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "assert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "assert do_algebra(['*', '-'], [6, 5, 7]) == 23", "assert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "assert do_algebra(['-', '*'], [3, 3, 6]) == -15", "assert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "assert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "assert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "assert do_algebra(['-', '**'], [3, 5, 2]) == -22", "assert do_algebra(['+', '*'], [7, 3, 6]) == 25", "assert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "assert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "assert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "assert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "assert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "assert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "assert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "assert do_algebra(['*', '**'], [3, 2, 8]) == 768", "assert do_algebra(['*', '**'], [7, 3, 3]) == 189", "assert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "assert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "assert do_algebra(['-', '+'], [8, 4, 3]) == 7", "assert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "assert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "assert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "assert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "assert do_algebra(['**', '*'], [8, 2, 2]) == 128", "assert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "assert do_algebra(['-', '+'], [3, 4, 4]) == 3", "assert do_algebra(['+', '-'], [10, 3, 8]) == 5", "assert do_algebra(['//', '*'], [7, 3, 4]) == 8", "assert do_algebra(['//', '-'], [6, 1, 2]) == 4", "assert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "assert do_algebra(['+', '-'], [3, 7, 6]) == 4", "assert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "assert do_algebra(['*', '*'], [5, 2, 7]) == 70", "assert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "assert do_algebra(['-', '**'], [3, 3, 4]) == -78", "assert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "assert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "assert do_algebra(['//', '//'], [2, 7, 1]) == 0", "assert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "assert do_algebra(['**', '*'], [10, 2, 8]) == 800", "assert do_algebra(['+', '//'], [3, 6, 4]) == 4", "assert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "assert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "assert do_algebra(['+', '**'], [7, 3, 5]) == 250", "assert do_algebra(['-', '//'], [7, 3, 2]) == 6", "assert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "assert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "assert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "assert do_algebra(['+', '**'], [3, 2, 4]) == 19", "assert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "assert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "assert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "assert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "assert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "assert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "assert do_algebra(['**', '-'], [3, 2, 9]) == 0", "assert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "assert do_algebra(['+', '+'], [4, 4, 1]) == 9", "assert do_algebra(['-', '+'], [10, 7, 1]) == 4", "assert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "assert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "assert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "assert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "assert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "assert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "assert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "assert do_algebra(['//', '*'], [8, 4, 2]) == 4", "assert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "assert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "assert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "assert do_algebra(['*', '+'], [4, 8, 4]) == 36", "assert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "nl": "\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    ", "func": "def do_algebra(operator, operand):", "examples": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    ", "completions": ["from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation.\n    '''\n    expression = ''\n    \n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    return eval(expression)\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation.\n    \n    Args:\n        operator (list): List of algebraic operators.\n        operand (list): List of integers.\n    Returns:\n        int: Result of the algebraic expression evaluation.\n    '''\n    \n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    return eval(expression)\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation.\n    Args:\n        operator (list): List of algebraic operators.\n        operand (list): List of integers.\n    Returns:\n        int: Result of the algebraic expression evaluation.\n    '''\n    expression = ''\n    \n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    return eval(expression)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef evaluate_expression(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluate an algebraic expression based on the provided operators and operands.\n\n    Args:\n    operators: A list of strings representing operators (+, -, *, /).\n    operands: A list of integers representing operands.\n\n    Returns:\n    An integer result after evaluating the expression.\n\n    Example:\n    >>> evaluate_expression(['+', '-', '*'], [1, 2, 3])\n    5\n    \"\"\"\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Number of operators should be one less than number of operands\")\n\n    operator_map = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '/': lambda x, y: x / y\n    }\n\n    result = operands[0]\n    for i in range(1, len(operands)):\n        if operators[i-1] in operator_map:\n            result = operator_map[operators[i-1]](result, operands[i])\n        else:\n            raise ValueError(\"Invalid operator\")\n\n    return int(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef evaluate_expression(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand, form the algebraic expression and return the evaluation of this expression for the given test cases.\n    \"\"\"\n    expression = ''.join([str(operands[i]) + operators[i] for i in range(len(operators))]) + str(operands[-1])\n    result = eval(expression)\n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef evaluate_expression(operators: List[str], operands: List[int]) -> int:\n    expression = \"\"\n    \n    for i in range(len(operators)):\n        expression += str(operands[i]) + operators[i]\n    \n    expression += str(operands[-1])\n    \n    return eval(expression)\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation result.\n    The operator list must have at least one operator, and the operand list must have at least two operands.\n    '''\n\n    ## Handle edge cases\n    if len(operator) < 1 or len(operand) < 2:\n        return None\n\n    ## Evaluate the algebraic expression\n    result = operand[0]\n    for i in range(1, len(operand)):\n        if operator[i - 1] == '+':\n            result += operand[i]\n        elif operator[i - 1] == '-':\n            result -= operand[i]\n        elif operator[i - 1] == '*':\n            result *= operand[i]\n        elif operator[i - 1] == '/':\n            result //= operand[i]\n        elif operator[i - 1] == '**':\n            result **= operand[i]\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation.\n    The operator list must have at least one operator, and the operand list must have at least two operands.\n    '''\n\n    if len(operator) < 1 or len(operand) < 2:\n        raise ValueError(\"Operator list must have at least one operator and operand list must have at least two operands\")\n\n    expression = str(operand[0])\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n\n    return eval(expression)\n", "from typing import List\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation result.\n    Args:\n        operator (list): List of operators\n        operand (list): List of operands\n    Returns:\n        int: Result of the algebraic expression evaluation\n    '''\n    \n    # Check if the length of operator list is at least one and operand list is at least two\n    if len(operator) < 1 or len(operand) < 2:\n        return None\n    \n    # Construct the algebraic expression using the operator and operand lists\n    expression = ''\n    for i in range(len(operand)):\n        expression += str(operand[i])\n        if i < len(operator):\n            expression += operator[i]\n    \n    # Evaluate the expression using the eval() function\n    try:\n        result = eval(expression)\n        return result\n    except:\n        return None\n", "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation.\n    \n    Args:\n        operator (list): List of algebraic operators.\n        operand (list): List of integers.\n    \n    Returns:\n        int: Result of the evaluated expression.\n    '''\n    \n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    return eval(expression)\n"], "plans": ["requirement pool:\n- Implement the core algebraic expression evaluation function\n- Handle edge cases like division by zero\n- Optimize the algorithm for faster computation\nWe will use the built-in eval() function in Python to evaluate the algebraic expression formed using the provided operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'fundamental algebraic operations': These are basic mathematical operations like addition, subtraction, multiplication, floor division, and exponentiation used in algebraic expressions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the built-in eval() function in Python to evaluate the algebraic expression, the code logic would involve forming the expression using the provided operator and operand lists and then evaluating it using eval().\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: With only two operands and one operator, the expression would be 2 + 3 * 4 = 10.\n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression would be 5 - 3 + 2 * 4 = 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval() function can handle different algebraic expressions effectively.\n", "requirement analysis:\nThe function should efficiently handle algebraic expressions using the provided operators and operands. It must accurately evaluate the expressions following the standard rules of algebra. Clear and concise documentation should be provided to guide users on utilizing the function effectively.\nrequirement pool:\n- Implement the core algebraic expression evaluation logic\n- Ensure support for various operator combinations\n- Create detailed documentation for the function usage\nWe will use the eval() function in Python to evaluate the algebraic expression formed using the provided operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'fundamental algebraic operations': These are basic mathematical operations like addition, subtraction, multiplication, floor division, and exponentiation used in algebraic expressions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the eval() function in Python to evaluate the algebraic expression, the code logic can be implemented as follows:\n\n```python\ndef do_algebra(operator, operand):\n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    return eval(expression)\n```\n\n# [edge case] \n    do_algebra(['+', '*', '-'], [2, 3, 4, 5]) = 9\n    Explanation: The expression formed is 2 + 3 * 4 - 5 which evaluates to 9.\n\n    do_algebra(['*', '+'], [2, 3, 4]) = 14\n    Explanation: The expression formed is 2 * 3 + 4 which evaluates to 10.\n\n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression formed is 5 - 3 + 2 * 4 which evaluates to 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval() function can handle various algebraic expressions.\n", "requirement analysis:\nThe main goal is to create a robust algebraic expression evaluator that can handle various operations and operands efficiently while ensuring accurate results. Error handling for invalid inputs is crucial to provide a seamless user experience.\nrequirement pool:\n- Implement the core logic to parse and evaluate algebraic expressions\n- Develop error handling mechanisms for invalid inputs\n- Optimize the evaluation process for better performance\nWe will use the eval() function in Python to evaluate the algebraic expression formed using the provided operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'fundamental algebraic operations': These are basic mathematical operations like addition, subtraction, multiplication, floor division, and exponentiation used in algebraic expressions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the eval() function in Python to evaluate the algebraic expression, the code logic would involve forming the expression using the provided operator and operand lists and then evaluating it using eval().\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3, 4]) = 10\n    Explanation: With only two operands and one operator, the expression would be 2 + 3 * 4 = 10.\n    \n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression would be 5 - 3 + 2 * 4 = 3.\n    \n    do_algebra(['//', '**'], [8, 2, 3]) = 64\n    Explanation: The expression would be 8 // 2 ** 3 = 64.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval() function can handle different algebraic expressions effectively.\n", "requirement analysis:\nThe main goal is to create a Python function that can efficiently evaluate algebraic expressions based on the provided operators and operands. The function should handle different algebraic operations such as addition, subtraction, multiplication, floor division, and exponentiation. It should also consider edge cases like division by zero and invalid inputs.\nrequirement pool:\n- Implement the core logic to parse operators and operands and evaluate the expression\n- Handle division by zero and invalid operator scenarios\n- Optimize the evaluation process for large sets of operands\nWe will design a static Python function using basic Python libraries to efficiently evaluate algebraic expressions based on the provided operators and operands.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: The requirement involves evaluating an algebraic expression formed by operators and operands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No edge case provided\n\n# [extra code for edge case]\n    No extra code needed for handling edge cases.\n", "requirement analysis:\nThe project aims to efficiently evaluate algebraic expressions using the provided operators and operands. It should handle various arithmetic operations and return accurate results. Error handling for invalid inputs is crucial to provide a seamless user experience.\nrequirement pool:\n- Implement the core logic to parse operators and operands and evaluate the expression\n- Ensure the function supports all basic algebraic operations\n- Implement error handling for division by zero and invalid operator inputs\nWe will design a static Python function using basic arithmetic operations to evaluate the algebraic expression provided by the user. We will leverage the 'eval' function in Python to handle the evaluation of the expression.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: Refers to a mathematical expression involving variables, constants, and arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No specific edge cases mentioned in the requirement.\n\n# [extra code for edge case]\n    No extra code needed for handling edge cases.\n", "requirement pool:\n- Implement function to evaluate algebraic expressions\n- Handle division by zero scenarios\n- Support additional algebraic operations like modulus\nWe will use the built-in eval function in Python to evaluate the algebraic expressions formed from the input operators and operands.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: The requirement involves forming and evaluating algebraic expressions using the provided operators and operands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the built-in eval function in Python, the code logic would involve constructing the algebraic expression from the operators and operands lists and then evaluating it using the eval function.\n\n# [edge case] \n    evaluate_expression(['+', '*'], [2, 3, 4]) = 14\n    Explanation: The expression formed is 2 + 3 * 4 = 14.\n    evaluate_expression(['-', '/'], [10, 2, 5]) = 8\n    Explanation: The expression formed is 10 - 2 / 5 = 8.\n    evaluate_expression(['+', '-'], [5, 3, 2]) = 4\n    Explanation: The expression formed is 5 + 3 - 2 = 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval function can handle basic arithmetic operations effectively.\n", "We will design a static Python function to evaluate algebraic expressions using the operator and operand lists provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: Refers to a mathematical expression involving variables, numbers, and arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already provides steps to evaluate algebraic expressions, we can follow those steps to implement the code.\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3]) = 6\n    Explanation: The expression is 2 + 3 = 5, then 5 * 2 = 10.\n    \n    do_algebra(['-', '/'], [10, 5]) = 2\n    Explanation: The expression is 10 - 5 = 5, then 5 / 2 = 2.5 (integer division gives 2).\n    \n    do_algebra(['**', '+'], [3, 2]) = 11\n    Explanation: The expression is 3 ** 2 = 9, then 9 + 2 = 11.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if len(operator) < 1 or len(operand) < 2:\n            return None\n        (other code)\n", "We will use the eval() function in Python to evaluate the algebraic expressions formed using the given operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: The core concept is to form and evaluate algebraic expressions using the provided operators and operands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the eval() function in Python to evaluate the algebraic expressions, the detailed logic would involve forming the expression string based on the given operators and operands, and then using eval() to calculate the result.\n\n# [edge case] \n    do_algebra(['+', '*'], [2, 3]) = 6\n    Explanation: The expression formed is 2 + 3 = 6.\n    \n    do_algebra(['-', '/'], [10, 5]) = 8\n    Explanation: The expression formed is 10 - 5 = 5.\n\n    do_algebra(['*', '**'], [2, 3]) = 8\n    Explanation: The expression formed is 2 * 3 = 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The eval() function can handle different algebraic expressions effectively.\n", "We will design a static Python function using basic arithmetic operations and the eval() function to evaluate algebraic expressions efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'algebraic expression'\n    Explanation: Refers to a mathematical expression involving variables, constants, and arithmetic operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already suggests using basic arithmetic operations and the eval() function, the following detailed logic can be implemented:\n    - Check if the length of operator list is at least one and operand list is at least two\n    - Construct the algebraic expression using the operator and operand lists\n    - Evaluate the expression using the eval() function\n    - Return the result of the evaluation\n\n# [edge case] \n    do_algebra(['+', '*'], [2]) = None\n    Explanation: The operator list has only one operator, which is not enough to form an algebraic expression with two operands.\n    do_algebra(['-', '+'], [5, 3]) = None\n    Explanation: The operand list has only two operands, but the operator list does not have enough operators to form an algebraic expression.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if len(operator) < 1 or len(operand) < 2:\n            return None\n        (other code)\n", "requirement analysis:\nThe function should efficiently handle algebraic expressions by correctly evaluating them based on the provided operators and operands. It should also include robust error handling to deal with invalid inputs and edge cases.\nrequirement pool:\n- Implement the core logic to parse and evaluate algebraic expressions\n- Ensure support for all basic algebra operations: addition, subtraction, multiplication, division, and exponentiation\n- Develop comprehensive test cases to validate the function's accuracy and error handling\nWe will use the eval() function in Python to evaluate the algebraic expression formed using the provided operator and operand lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'fundamental algebraic operations': These are basic mathematical operations like addition, subtraction, multiplication, floor division, and exponentiation used in algebraic expressions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan suggests using the eval() function in Python to evaluate the algebraic expression, the code logic can be implemented as follows:\n\n```python\ndef do_algebra(operator, operand):\n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    return eval(expression)\n```\n\n# [edge case] \n    do_algebra(['+', '*', '-'], [2, 3, 4, 5]) = 9\n    Explanation: The expression formed is 2 + 3 * 4 - 5 which evaluates to 9.\n\n    do_algebra(['*', '+'], [2, 3, 4]) = 14\n    Explanation: The expression formed is 2 * 3 + 4 which evaluates to 10.\n\n    do_algebra(['-', '+', '*'], [5, 3, 2, 4]) = 3\n    Explanation: The expression formed is 5 - 3 + 2 * 4 which evaluates to 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the eval() function can handle various algebraic expressions.\n"], "scores": [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.3798, 1.0, 1.0, 1.0], "pass_results": [true, true, true, false, false, false, false, true, true, true], "pass_test_cases_num": [129, 129, 129, 0, 0, 0, 49, 129, 129, 129], "completion": "from typing import List\n## main.py\n\ndef do_algebra(operator, operand) -> int:\n    '''\n    Given two lists operator and operand, form the algebraic expression and return the evaluation.\n    \n    Args:\n        operator (list): List of algebraic operators.\n        operand (list): List of integers.\n    \n    Returns:\n        int: Result of the evaluated expression.\n    '''\n    \n    expression = ''\n    for i in range(len(operand) - 1):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    return eval(expression)\n", "passed": true, "pass": true, "pass_num": 6, "round": 119, "repair_prompt": ["def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list consists of fundamental algebraic operations, and the second list is a list of integers. Use the two provided lists to form the algebraic expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "Given two lists operator, and operand. The first list consists of fundamental algebraic operations, and the second list is a list of integers. Use the two provided lists to form the algebraic expression and return the evaluation of this expression for the given test cases.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['-', '*', '+']\n    array = [4, 2, 3, 7]\n    result = 4 - 2 * 3 + 7\n    => result = 9\n\n    operator['+', '/', '-']\n    array = [10, 2, 5, 3]\n    result = 10 + 2 / 5 - 3\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.", "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand, use them to form the algebraic expression and return the evaluation of this expression given that operator has at least one operator, and operand list has at least two operands.''' \n\n    # Test cases\n    assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert do_algebra(['*', '//'], [4, 2, 5]) == 8\n    assert do_algebra(['-', '+', '**'], [10, 5, 2, 3]) == 12"], "mutate_method": "rephrase_one", "parent_index": 230}
