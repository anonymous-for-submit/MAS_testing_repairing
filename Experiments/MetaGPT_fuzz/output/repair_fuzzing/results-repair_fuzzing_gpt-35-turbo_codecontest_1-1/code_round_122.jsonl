{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You possess a list of integers (starting off empty). You have to carry out q queries. Each query is of one of two kinds:\n\n  * \"1 x\" \u2014 append the element x to the conclusion of the array; \n  * \"2 x y\" \u2014 substitute all occurrences of x in the array. Replace them with y.\n\nFind the resulting array after performing all the queries. Ensure all operations are optimized for performance and completed in linear time wherever possible.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You possess a list of integers (starting off empty). You have to carry out q queries. Each query is of one of two kinds:\n\n  * \"1 x\" \u2014 append the element x to the conclusion of the array; \n  * \"2 x y\" \u2014 substitute all occurrences of x in the array. Replace them with y.\n\nFind the resulting array after performing all the queries. Ensure all operations are optimized for performance and completed in linear time wherever possible.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You possess a list of integers (starting off empty). You have to carry out q queries. Each query is of one of two kinds: append the element x to the conclusion of the array or substitute all occurrences of x in the array with y. Find the resulting array after performing all the queries. Ensure all operations are optimized for performance and completed in linear time wherever possible.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You possess a list of integers (starting off empty) and have to carry out q queries; each query is of one of two kinds: \"1 x\" \u2014 append the element x to the conclusion of the array or \"2 x y\" \u2014 substitute all occurrences of x in the array with y. Find the resulting array after performing all the queries. Ensure all operations are optimized for performance and completed in linear time wherever possible.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        query_type, *args = query.split()\n        \n        if query_type == '1':\n            x = int(args[0])\n            arr.append(x)\n        elif query_type == '2':\n            x, y = map(int, args)\n            arr = [y if num == x else num for num in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    indices = {}\n    \n    for query in queries:\n        query_type, *values = query.split()\n        \n        if query_type == \"1\":\n            x = int(values[0])\n            arr.append(x)\n        elif query_type == \"2\":\n            x = int(values[0])\n            y = int(values[1])\n            for i in range(len(arr)):\n                if arr[i] == x:\n                    arr[i] = y\n    \n    return arr\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    resulting_array = []\n    substitutions = {}\n\n    for query in queries:\n        query_type, *values = query.split()\n        \n        if query_type == \"1\":\n            x = int(values[0])\n            resulting_array.append(x)\n        elif query_type == \"2\":\n            x, y = map(int, values)\n            substitutions[x] = y\n\n    for i in range(len(resulting_array)):\n        if resulting_array[i] in substitutions:\n            resulting_array[i] = substitutions[resulting_array[i]]\n\n    return resulting_array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    result_array = []\n    substitutions = {}\n\n    for query_type, *args in queries:\n        if query_type == 1:\n            result_array.append(args[0])\n        elif query_type == 2:\n            substitutions[args[0]] = args[1]\n\n    for i in range(len(result_array)):\n        if result_array[i] in substitutions:\n            result_array[i] = substitutions[result_array[i]]\n\n    return result_array\n\n# Input interface using input() and print()\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    result = []\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            arr = [query[2] if x == query[1] else x for x in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, int]]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            arr = [y if num == x else num for num in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    result = []\n    elements = {}\n    \n    for query in queries:\n        query_type, *values = query.split()\n        \n        if query_type == '1':\n            element = int(values[0])\n            result.append(element)\n            elements[element] = elements.get(element, 0) + 1\n        elif query_type == '2':\n            x, y = map(int, values)\n            if x in elements:\n                count = elements[x]\n                result = [y if ele == x else ele for ele in result]\n                elements[y] = elements.get(y, 0) + count\n                del elements[x]\n    \n    return result\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        else:\n            x, y = query[1], query[2]\n            arr = [y if num == x else num for num in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '1':\n        queries.append((1, int(query[1]), None))\n    else:\n        queries.append((2, int(query[1]), int(query[2])))\n\n# Output interface\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    integers = []\n    replacements = {}\n\n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            integers.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            for i in range(len(integers)):\n                if integers[i] == x:\n                    integers[i] = y\n\n    return integers\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    index_dict = {}\n    \n    for query in queries:\n        query_type, *values = query.split()\n        \n        if query_type == '1':\n            x = int(values[0])\n            arr.append(x)\n        elif query_type == '2':\n            x, y = map(int, values)\n            for i in range(len(arr)):\n                if arr[i] == x:\n                    arr[i] = y\n    \n    return arr\n\n"], "plans": ["requirement pool:\n- Optimize performance for all operations\n- Ensure linear time complexity\n- Handle both append and substitution efficiently\nWe will use Python built-in list data structure to efficiently handle the append and substitution operations. We will optimize the performance by using list comprehension for substitution and append operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves iterating through each query and performing the corresponding action on the list of integers. For \"1 x\" queries, append x to the list. For \"2 x y\" queries, substitute all occurrences of x with y in the list.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: The first query appends 5 to the empty list, resulting in [5].\n\n    query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: The second query substitutes all occurrences of 5 with 3 in the list [5], resulting in [3].\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: The third query appends 2 to the list [3], resulting in [3, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided can efficiently handle all types of queries and operations.\n", "requirement pool:\n- Optimize append and substitution operations\n- Ensure accurate output after all queries\n- Handle at least 5 * 10^5 queries efficiently\nWe will use the built-in list data structure in Python to efficiently handle the append and substitution operations. We will optimize the performance by using dictionary to store the indices of elements for quick substitution. The linear time complexity will be achieved by iterating through the queries only once.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves using a list to store the integers and a dictionary to store the indices of elements for quick substitution. \n    1. Initialize an empty list to store the integers.\n    2. Initialize an empty dictionary to store the indices of elements for quick substitution.\n    3. Iterate through each query:\n        - If the query is of type \"1 x\", append x to the list.\n        - If the query is of type \"2 x y\", substitute all occurrences of x in the list with y using the indices stored in the dictionary.\n    4. Print the resulting array after performing all the queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: The query appends 5 to the conclusion of the array.\n\n    query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: The query substitutes all occurrences of 5 in the array with 3.\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: The query appends 2 to the conclusion of the array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement efficient list append operation\n- Develop query substitution functionality\n- Ensure linear time complexity for all operations\nWe will use Python and the built-in list data structure to efficiently handle list operations. For query optimization, we will utilize a dictionary to keep track of the substitutions. The goal is to achieve linear time complexity for all operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider the following steps simultaneously:\n    - Initialize an empty list to store the resulting array.\n    - Initialize an empty dictionary to keep track of substitutions.\n    - Iterate through each query:\n        - If the query is of type \"1 x\", append x to the resulting array.\n        - If the query is of type \"2 x y\", update the substitutions dictionary with x as key and y as value.\n    - Iterate through the resulting array and apply substitutions if needed.\n    - Print the resulting array after performing all queries.\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    2 5 3\n    1 3\n    Resulting array: [3]\n    Explanation: \n    - Initially, the array is empty.\n    - First query appends 5 to the array.\n    - Second query replaces all occurrences of 5 with 3 in the array.\n    - Third query appends 3 to the array.\n    \n    Query 2:\n    2\n    1 2\n    1 3\n    Resulting array: [2, 3]\n    Explanation:\n    - Initially, the array is empty.\n    - First query appends 2 to the array.\n    - Second query appends 3 to the array.\n\n    Query 3:\n    1\n    1 1\n    Resulting array: [1]\n    Explanation:\n    - Initially, the array is empty.\n    - The only query appends 1 to the array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement efficient append operation\n- Develop substitution functionality\n- Ensure linear time complexity for all operations\nWe will use the built-in list data structure in Python to efficiently handle list operations. For query processing, we will use a dictionary to keep track of the elements and their substitutions. We will ensure linear time complexity for all operations by optimizing the query processing logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the list of integers.\n\n    'append': adding an element to the end of the array.\n    \n    'substitute': replacing all occurrences of a specific element in the array with another element.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests using a dictionary to keep track of elements and their substitutions. \n    - Initialize an empty list to store the resulting array.\n    - Initialize an empty dictionary to store substitutions.\n    - Iterate through each query:\n        - If the query is of type 1 (append), simply append the element to the resulting array.\n        - If the query is of type 2 (substitute), update the dictionary with the substitution.\n    - Finally, iterate through the resulting array and apply substitutions if needed.\n\n# [edge case] \n    query 1: 1 5\n    query 2: 1 3\n    query 3: 2 5 2\n    query 4: 1 2\n    query 5: 2 3 4\n    Expected output: [5, 2]\n    Explanation: \n    - After query 1: [5]\n    - After query 2: [5, 3]\n    - After query 3 (substitute 5 with 2): [2, 3]\n    - After query 4: [2, 3, 2]\n    - After query 5 (substitute 3 with 4): [2, 4, 2]\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement efficient list append operation\n- Develop optimized element replacement function\n- Ensure accurate and linear time complexity for all operations\nWe will use Python built-in list data structure to efficiently handle list operations and optimize performance for query processing. We will iterate through the queries and update the list accordingly based on the query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the list, which can be either appending an element or substituting occurrences.\n    'linear time': indicates that the operations should be completed in a time complexity of O(n).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the code:\n    - Initialize an empty list to store the resulting array.\n    - Iterate through each query:\n        - If the query is of type 1, append the element x to the list.\n        - If the query is of type 2, substitute all occurrences of x in the list with y.\n    - Return the resulting array after processing all queries.\n\n# [edge case] \n    Query 1: \"1 5\"\n    Query 2: \"1 3\"\n    Query 3: \"2 5 2\"\n    Expected output: [5, 3]\n    Explanation: \n    - Query 1 appends 5 to the list.\n    - Query 2 appends 3 to the list.\n    - Query 3 substitutes all occurrences of 5 with 2 in the list.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided can handle both appending elements and substituting occurrences efficiently.\n", "requirement pool:\n- Optimize performance for all operations\n- Ensure linear time complexity\n- Accurately handle both append and substitution queries\nWe will use the built-in list data structure in Python to efficiently handle the array operations. To optimize performance, we will utilize the dictionary data structure for substitution queries to achieve linear time complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the list of integers.\n\n    'append': Adding an element to the end of the array.\n    \n    'substitute': Replacing all occurrences of a specific element in the array with another element.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the code, we can follow these steps:\n    1. Initialize an empty list to store the integers.\n    2. Iterate through each query:\n        - If it is of type 1, append the element x to the list.\n        - If it is of type 2, substitute all occurrences of x in the list with y.\n    3. Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"1 3\"\n    query 3: \"2 5 2\"\n    query 4: \"1 7\"\n    query 5: \"2 3 7\"\n    Expected output: [5, 3, 2, 7]\n    Explanation: \n    - Initially, the array is empty.\n    - After query 1, the array becomes [5].\n    - After query 2, the array becomes [5, 3].\n    - After query 3, substitute all occurrences of 5 with 2, resulting in [2, 3].\n    - After query 4, append 7 to the array, resulting in [2, 3, 7].\n    - After query 5, substitute all occurrences of 3 with 7, resulting in [2, 7, 7].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided can handle both append and substitution queries efficiently.\n", "requirement pool:\n- Optimize performance for all operations\n- Support query substitution feature\n- Ensure linear time complexity\nWe will use Python and the built-in list data structure to efficiently handle the array operations. We will optimize the performance by using a dictionary to keep track of the elements and their occurrences for quick substitution. The linear time complexity will be ensured by iterating through the queries only once.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves using a dictionary to keep track of the elements and their occurrences for quick substitution. We will iterate through the queries and perform the required actions accordingly.\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"1 3\"\n    query 3: \"2 5 2\"\n    query 4: \"2 3 4\"\n    Resulting array: [2, 4]\n    Explanation: \n    - Initially, the array is empty.\n    - Query 1 appends 5 to the array: [5]\n    - Query 2 appends 3 to the array: [5, 3]\n    - Query 3 substitutes all occurrences of 5 with 2: [2, 3]\n    - Query 4 substitutes all occurrences of 3 with 4: [2, 4]\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- The main code ...\n- The game algorithm ...\nWe will use the built-in list data structure in Python to store the integers and efficiently perform the required operations. We will optimize the implementation to ensure linear time complexity for each query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves using a list to store the integers and efficiently perform the required operations. For query type 1, we will append the element x to the end of the list. For query type 2, we will substitute all occurrences of x in the list with y.\n\n    Here is a high-level logic:\n    - Initialize an empty list to store integers.\n    - Iterate through each query:\n        - If the query is of type 1, append x to the list.\n        - If the query is of type 2, substitute all occurrences of x with y in the list.\n    - Print the resulting array after performing all the queries.\n\n# [edge case] \n    query 1:\n    3\n    1 1\n    1 2\n    2 1 3\n    Resulting array: [2]\n    Explanation: Initially empty list, then append 1 and 2. Finally, substitute all occurrences of 1 with 3.\n    \n    query 2:\n    2\n    1 5\n    2 5 3\n    Resulting array: [3]\n    Explanation: Initially empty list, then append 5. Finally, substitute all occurrences of 5 with 3.\n\n    query 3:\n    4\n    1 2\n    1 3\n    2 2 4\n    1 5\n    Resulting array: [3, 4, 5]\n    Explanation: Initially empty list, then append 2 and 3. Substitute all occurrences of 2 with 4. Finally, append 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers the scenarios effectively.\n", "requirement pool:\n- Optimize performance for all operations\n- Support both query types efficiently\n- Ensure accurate handling of queries\nWe will utilize the built-in list data structure in Python to efficiently handle the array operations. For query substitution, we will use a dictionary to keep track of the replacements for each element.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves using a list to store the integers and a dictionary to keep track of replacements for each element. \n    1. Initialize an empty list to store the integers.\n    2. Initialize an empty dictionary to store replacements for each element.\n    3. Iterate through each query:\n        - If the query is of type 1, append the element x to the list.\n        - If the query is of type 2, substitute all occurrences of x in the list with y.\n    4. Print the resulting array after performing all the queries.\n\n# [edge case] \n    query 1: 1 5\n    query 2: 1 3\n    query 3: 2 5 2\n    query 4: 1 2\n    query 5: 2 3 4\n    Expected output: [3, 2, 4]\n    Explanation: \n    - After query 1: [5]\n    - After query 2: [5, 3]\n    - After query 3: [2, 3]\n    - After query 4: [2, 3, 2]\n    - After query 5: [4, 2]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle all types of queries efficiently.\n", "requirement pool:\n- Optimize performance for all operations\n- Ensure linear time complexity\n- Handle both append and substitution efficiently\nWe will use Python's built-in list data structure to efficiently handle the append and substitution operations. We will optimize the performance by using a dictionary to store the indices of elements for quick substitution. The goal is to achieve linear time complexity for all operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the list of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider the following steps simultaneously:\n    1. Initialize an empty list to store the integers.\n    2. Initialize an empty dictionary to store the indices of elements for quick substitution.\n    3. Iterate through each query:\n        - If the query is of type \"1 x\", append x to the list.\n        - If the query is of type \"2 x y\", substitute all occurrences of x in the list with y using the dictionary.\n    4. Print the resulting array after performing all the queries.\n\n# [edge case] \n    query 1: \n        3\n        1 1\n        1 2\n        2 1 3\n    Expected output: [2]\n    Explanation: Initially, the list is empty. After the first query, it becomes [1]. After the second query, it becomes [1, 2]. After the third query, all occurrences of 1 are replaced with 3, resulting in [2].\n\n    query 2:\n        2\n        1 5\n        2 5 7\n    Expected output: [7]\n    Explanation: Initially, the list is empty. After the first query, it becomes [5]. After the second query, all occurrences of 5 are replaced with 7, resulting in [7].\n\n    query 3:\n        4\n        1 3\n        1 4\n        2 3 5\n        1 6\n    Expected output: [4, 5, 6]\n    Explanation: Initially, the list is empty. After the first query, it becomes [3]. After the second query, it becomes [3, 4]. After the third query, all occurrences of 3 are replaced with 5, resulting in [4, 5]. After the fourth query, it appends 6 to the list, resulting in [4, 5, 6].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios efficiently.\n"], "scores": [], "pass_results": [false, false, true, true, true, true, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 122, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "add_1_sentence_at_end", "parent_index": 109}
