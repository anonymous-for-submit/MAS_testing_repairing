{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You have an array of integers (initially empty). You have to perform q queries, each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\nMake sure to handle cases where the array could be modified multiple times throughout the queries. Consider edge cases such as when the array is empty or when the element to be replaced does not exist in the array.\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You have an array of integers (initially empty). You have to perform q queries, each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\nMake sure to handle cases where the array could be modified multiple times throughout the queries. Consider edge cases such as when the array is empty or when the element to be replaced does not exist in the array.\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You have to perform q queries, each query is of one of two types: \"1 x\" \u2014 add the element x to the end of the array, and \"2 x y\" \u2014 replace all occurrences of x in the array with y. It is important to consider cases where the array could be modified multiple times during the queries. Find the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You have an array of integers (initially empty) and have to perform q queries, each query is of one of two types: \"1 x\" to add x to the end, and \"2 x y\" to replace x with y. Make sure to handle edge cases like empty arrays or when the element to be replaced doesn't exist in the array. Find the resulting array after all queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            arr.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            for i in range(len(arr)):\n                if arr[i] == x:\n                    arr[i] = y\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = process_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    for query in queries:\n        query_type = query.split()[0]\n        if query_type == '1':\n            x = int(query.split()[1])\n            array.append(x)\n        elif query_type == '2':\n            x, y = map(int, query.split()[1:])\n            array = [y if elem == x else elem for elem in array]\n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    elements = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            elements.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            elements = [y if element == x else element for element in elements]\n    \n    return elements\n\n# Input\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Process queries\nresult = process_queries(q, queries)\n\n# Output\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    elements = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            elements.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            elements = [y if element == x else element for element in elements]\n    \n    return elements\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    # Initialize an empty dictionary to store elements and their replacements\n    elements = {}\n    \n    # Process each query\n    for query in queries:\n        query_type, *args = query.split()\n        \n        if query_type == '1':\n            x = int(args[0])\n            elements[x] = x\n        \n        elif query_type == '2':\n            x, y = map(int, args)\n            for key in elements:\n                if elements[key] == x:\n                    elements[key] = y\n    \n    # Create the resulting array\n    result = [elements.get(i, i) for i in range(1, max(elements.keys()) + 1)]\n    \n    return result\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(q: int, queries: List[Tuple[int, int, int]]) -> List[int]:\n    arr = []\n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            arr = [y if num == x else num for num in arr]\n    return arr\n\n# Input\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '1':\n        queries.append((1, int(query[1]), 0))\n    else:\n        queries.append((2, int(query[1]), int(query[2])))\n\n# Process queries\nresult = process_queries(q, queries)\n\n# Output\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef manipulate_array(q: int, queries: List[str]) -> List[int]:\n    array = []\n    \n    if not queries:\n        return []\n    \n    for query in queries:\n        if query.startswith('1'):\n            _, x = map(int, query.split())\n            array.append(x)\n        elif query.startswith('2'):\n            _, x, y = map(int, query.split())\n            if len(array) >= x:\n                array[x-1] = y\n            else:\n                print(\"Error: Element to be replaced does not exist.\")\n    \n    return array\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef manipulate_array(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    array = []\n    \n    if not queries:  # Handle empty arrays\n        return []\n    \n    for query_type, x, y in queries:\n        if query_type == 1:\n            array.append(x)\n        elif query_type == 2:\n            if x < len(array):  # Check if index x exists in the array\n                array[x] = y\n    \n    return array\n\n# Input interface using input()\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '1':\n        queries.append((1, int(query[1]), None))\n    else:\n        queries.append((2, int(query[1]), int(query[2]))\n\n# Output interface using print()\nresult = manipulate_array(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query[0] == 1:\n            array.append(query[1])\n        elif query[0] == 2:\n            if query[1] - 1 < len(array):\n                array[query[1] - 1] = query[2]\n    \n    result = array\n    return result\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            arr.append(values[0])\n        elif query_type == 2:\n            if arr:\n                x, y = values[0], values[1]\n                arr = [y if num == x else num for num in arr]\n    \n    return arr\n\n"], "plans": ["requirement pool:\n- Efficiently process queries and handle array modifications\n- Ensure correct replacement of elements in the array\n- Handle edge cases such as empty array and non-existing elements gracefully\nWe will use a simple approach by maintaining a list to store the elements and process each query efficiently using Python built-in functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, either adding elements or replacing existing elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider handling both types of queries efficiently. \n    - Initialize an empty list to store the elements.\n    - Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, replace all occurrences of x with y in the list.\n    - Return the resulting array after performing all queries.\n\n# [edge case] \n    Query 1: \"1 5\"\n    Query 2: \"1 3\"\n    Query 3: \"2 5 2\"\n    Expected output: [3, 2]\n    Explanation: Initially, the array is empty. After Query 1 and Query 2, the array becomes [5, 3]. Then, in Query 3, all occurrences of 5 are replaced with 2, resulting in [3, 2].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the element to be replaced does not exist in the array.\n        for i in range(len(arr)):\n            if arr[i] == x:\n                arr[i] = y\n        (other code)\n", "requirement pool:\n- Efficiently process queries and handle array modifications\n- Ensure correct replacement of elements in the array\n- Optimize for performance and scalability\nWe will use a simple approach by maintaining a list to store the elements and process each query efficiently using Python built-in functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, which can be either adding elements or replacing existing elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store the elements and processing each query efficiently using Python built-in functions. \n    1. Initialize an empty list to store the elements.\n    2. Iterate through each query:\n        - If the query is of type \"1 x\", append x to the end of the list.\n        - If the query is of type \"2 x y\", replace all occurrences of x in the list with y.\n    3. Return the resulting array after performing all the queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"1 3\"\n    query 3: \"2 5 2\"\n    query 4: \"1 7\"\n    Expected output: [3, 2, 7]\n    Explanation: \n    - Initially, the array is empty.\n    - After query 1, the array becomes [5].\n    - After query 2, the array becomes [5, 3].\n    - After query 3, all occurrences of 5 are replaced with 2, resulting in [3, 2].\n    - After query 4, 7 is added to the end of the array, resulting in the final array [3, 2, 7].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - To handle the case where the array is empty, we can check if the list is empty before performing any operations.\n        - To handle the case where the element to be replaced does not exist in the array, we can check if x exists in the list before replacing it with y.\n        (code for handling the edge cases)\n", "requirement pool:\n- Efficiently process queries and handle array modifications\n- Ensure correct replacement of elements in the array\n- Optimize for speed and memory usage\nWe will use a simple approach by maintaining a list to store the elements and process each query efficiently using Python built-in functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, either adding elements or replacing existing elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider handling both types of queries efficiently. \n    - Initialize an empty list to store the elements.\n    - Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, replace all occurrences of x with y in the list.\n    - Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"2 5 3\"\n    query 3: \"1 3\"\n    Expected output: [3]\n    Explanation: Initially empty array, add 5, replace all occurrences of 5 with 3, add 3. Final array is [3].\n\n    query 1: \"1 2\"\n    query 2: \"2 2 4\"\n    Expected output: [4]\n    Explanation: Initially empty array, add 2, replace all occurrences of 2 with 4. Final array is [4].\n\n    query 1: \"1 1\"\n    query 2: \"2 2 3\"\n    Expected output: [1]\n    Explanation: Initially empty array, add 1, no occurrence of 2 to replace. Final array is [1].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the array is empty before performing any replacement queries.\n        - Handle cases where the element to be replaced does not exist in the array.\n        - Ensure that the resulting array contains only elements from type 1 queries.\n", "requirement pool:\n- Handle array modification queries efficiently\n- Ensure accurate replacement of elements\n- Optimize for multiple modifications\nWe will use a simple approach by maintaining a list to store the elements and updating it based on the queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array, which can be of two types: adding an element to the end of the array or replacing occurrences of a specific element with another.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store the elements and updating it based on the queries. \n    1. Initialize an empty list to store the elements.\n    2. Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, replace all occurrences of x in the list with y.\n    3. Return the resulting array after performing all the queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: The query adds the element 5 to the end of the array.\n\n    query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: The query replaces all occurrences of 5 in the array with 3, resulting in [3].\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: The query adds the element 2 to the end of the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n", "requirement pool:\n- Handle array modifications efficiently\n- Ensure accurate processing of query types\n- Optimize for multiple modifications\nWe will use a simple approach by maintaining a dictionary to store the elements and their replacements. We will iterate through the queries and update the dictionary accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array, which can be either adding an element or replacing occurrences of an element.\n    'array': Refers to the data structure that stores elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty array to store the elements.\n    2. Initialize an empty dictionary to store the elements and their replacements.\n    3. Iterate through each query:\n        - If the query is of type 1, add the element to the end of the array.\n        - If the query is of type 2, replace all occurrences of x in the array with y.\n    4. Print the resulting array after performing all the queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding element 5 to the empty array.\n    \n    query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: Replacing all occurrences of 5 with 3 in the array [5].\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding element 2 to the existing array [3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the array is empty before performing any replacement queries.\n        - Handle cases where x or y are not within the specified range.\n        - Consider scenarios where multiple replacement queries might affect each other.\n", "requirement pool:\n- Handle both query types accurately\n- Optimize for multiple modifications\n- Ensure efficient array processing\nWe will use Python and the built-in list data structure to efficiently handle array modifications and query processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations to be performed on the array.\n\n    'array': represents the data structure that will be modified based on the queries.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan mentions using Python and the built-in list data structure, we can implement the logic as follows:\n\n```python\ndef perform_queries(q, queries):\n    arr = []\n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            arr = [y if num == x else num for num in arr]\n    return arr\n\n# Example usage\nq = 4\nqueries = [(1, 5), (1, 3), (2, 5, 2), (1, 7)]\nresulting_array = perform_queries(q, queries)\nprint(resulting_array)\n```\n\n# [edge case] \n    Query: 1 5\n    Query: 2 5 2\n    Query: 1 7\n    Resulting Array: [3, 2, 7]\n    Explanation: \n    - Initially, the array is empty.\n    - After the first query (1 5), the array becomes [5].\n    - The second query (2 5 2) replaces all occurrences of 5 with 2, resulting in [2].\n    - Finally, the third query (1 7) appends 7 to the array, resulting in [2, 7].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n", "requirement analysis:\nThe requirements specify handling two types of queries for array manipulation, ensuring correct behavior for edge cases, and providing the final array as output. Performance optimization and error handling are crucial.\nrequirement pool:\n- Handle '1 x' queries to add elements to the array\n- Implement '2 x y' queries to replace elements in the array\n- Ensure proper handling of empty arrays and non-existent elements\n- Optimize for large numbers of queries efficiently\n- Implement error messages for edge cases\nWe will use a simple approach by defining a static function in Python without using any class. We will handle the array manipulation queries efficiently by using built-in list functions. To ensure correct behavior for edge cases, we will implement proper checks for empty arrays and non-existent elements. For optimizing performance, we will use Python's efficient list operations. Error handling will be implemented by providing informative messages for edge cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the operations that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the code logic, we will follow these steps simultaneously:\n    1. Initialize an empty array to store the integers.\n    2. Iterate through each query:\n        - If the query is of type \"1 x\", append x to the array.\n        - If the query is of type \"2 x y\", replace the element at index x with y if x exists in the array.\n    3. Handle edge cases:\n        - Check for empty arrays and provide appropriate error messages.\n        - Check if the element to be replaced exists in the array before performing the replacement.\n    4. Return the resulting array after all queries of the first type.\n\n# [edge case] \n    query 1: \n    1 5\n    2 1 3\n    1 2\n    Expected output: [5, 3]\n    Explanation: Initially, the array is empty. After the first query, the array becomes [5]. In the second query, we replace the element at index 1 (which is 5) with 3. Finally, after the third query, we append 2 to the array.\n\n    query 2:\n    1 10\n    Expected output: [10]\n    Explanation: Only one query to add 10 to the array.\n\n    query 3:\n    2 1 7\n    Expected output: Error message - Element to be replaced does not exist.\n    Explanation: Trying to replace an element at index 1 when the array is empty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not queries:\n            return []\n        for query in queries:\n            if query.startswith('1'):\n                _, x = map(int, query.split())\n                array.append(x)\n            elif query.startswith('2'):\n                _, x, y = map(int, query.split())\n                if len(array) >= x:\n                    array[x-1] = y\n                else:\n                    print(\"Error: Element to be replaced does not exist.\")\n        return array\n", "requirement analysis:\nThe requirements involve efficiently handling array manipulation queries, ensuring correct behavior in edge cases, and optimizing performance for large input sizes. The program needs to accurately process both types of queries and output the resulting array.\nrequirement pool:\n- Handle array manipulation queries efficiently\n- Ensure correct behavior in edge cases\n- Optimize performance for large input sizes\nWe will use Python's built-in list data structure to efficiently handle array manipulation queries. We will iterate through each query and update the array accordingly, ensuring correct behavior in edge cases such as empty arrays and invalid replacements. To optimize performance for large input sizes, we will use a simple and straightforward approach without introducing unnecessary complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array based on the input provided.\n    'array manipulation': Involves adding elements to the array and replacing existing elements based on the query type.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic involves iterating through each query and updating the array based on the query type. \n    - For query type 1: Append the element x to the end of the array.\n    - For query type 2: Replace the element at index x with y if x exists in the array.\n    - Handle edge cases like empty arrays and invalid replacements.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding 5 to the empty array results in [5].\n\n    query 2: \"2 1 3\"\n    Resulting array: [3]\n    Explanation: Replacing element at index 1 (if it exists) with 3 in the array [5] results in [3].\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding 2 to the existing array [3] results in [3, 2].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - To handle empty arrays:\n            if not queries:\n                return []\n        - To handle replacement of non-existing elements:\n            if query_type == 2 and x >= len(array):\n                continue\n        (other code for handling edge cases)\n", "requirement analysis:\nThe requirements involve efficiently processing array manipulation queries, handling edge cases, and providing the resulting array. It's crucial to optimize performance for large input sizes and ensure proper error handling.\nrequirement pool:\n- Handle array manipulation queries efficiently\n- Implement proper error handling for edge cases\n- Optimize performance for large input sizes\nWe will use a simple approach by maintaining a list to store the elements and updating it based on the queries. We will handle edge cases such as empty arrays and non-existing elements by checking conditions before performing operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, either adding an element or replacing an existing element.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store elements and updating it based on the queries. \n    - Initialize an empty list to store elements.\n    - Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, replace the element at index x with y if x exists in the list.\n    - Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding element 5 to the empty array.\n    \n    query 2: \"2 1 3\"\n    Resulting array: [3]\n    Explanation: Replacing element at index 1 with 3 in the array [5].\n    \n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding element 2 to the end of the array.\n    \n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the array is empty before performing any operations.\n        - Check if the element to be replaced exists in the array before replacing it.\n        - Handle cases where the index provided for replacement is out of bounds.\n        (code for handling the edge cases)\n", "requirement pool:\n- Efficiently handle array modifications\n- Correctly handle edge cases\n- Optimize query processing\nWe will use a simple approach by maintaining a list to store the elements and process each query accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, either adding elements or replacing existing elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider handling both types of queries:\n    - For query type 1: Append the element x to the end of the array.\n    - For query type 2: Replace all occurrences of x in the array with y.\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"2 5 3\"\n    query 3: \"1 3\"\n    Expected output: [3, 3]\n    Explanation: Initially empty array, add 5, then replace all occurrences of 5 with 3, and finally add 3.\n    \n    query 1: \"1 2\"\n    query 2: \"2 2 4\"\n    Expected output: [4]\n    Explanation: Initially empty array, add 2, then replace all occurrences of 2 with 4. \n\n    query 1: \"1 1\"\n    query 2: \"2 2 3\"\n    Expected output: [1]\n    Explanation: Initially empty array, add 1, then try to replace all occurrences of 2 with 3 (which doesn't exist), resulting in no change.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the array is empty before performing any replacement queries.\n        - Handle cases where the element to be replaced does not exist in the array.\n"], "scores": [], "pass_results": [true, true, false, true, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 255, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "condense_two2one", "parent_index": 134}
