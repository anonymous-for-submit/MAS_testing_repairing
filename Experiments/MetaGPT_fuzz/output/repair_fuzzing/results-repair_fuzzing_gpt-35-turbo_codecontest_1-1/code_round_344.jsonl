{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. You need to change every instance of x that you find. You must replace each occurrence with the element y instead.\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. You need to change every instance of x that you find. You must replace each occurrence with the element y instead.\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You have to perform q queries, and each query is of one of two types: Replace all occurrences of x in the array with y, changing every instance of x found.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You have an array of integers (initially empty) and need to perform q queries, where query type 1 adds element x to the end of the array and query type 2 replaces all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, int]]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query[0] == 1:\n            array.append(query[1])\n        elif query[0] == 2:\n            array = [query[2] if x == query[1] else x for x in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    \"\"\"\n    Perform queries on an array of integers based on the given input queries.\n\n    Args:\n    q: An integer representing the number of queries.\n    queries: A list of strings representing the queries to be performed.\n\n    Returns:\n    A list of integers representing the resulting array after performing all the queries.\n    \"\"\"\n\n    # Initialize an empty array\n    arr = []\n\n    # Process each query\n    for query in queries:\n        query_type = query.split()[0]\n        if query_type == '1':\n            x = int(query.split()[1])\n            arr.append(x)\n        elif query_type == '2':\n            x = int(query.split()[1])\n            y = int(query.split()[2])\n            arr = [y if elem == x else elem for elem in arr]\n\n    return arr\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Output interface\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, int]]) -> List[int]:\n    elements = []\n    \n    for query_type, *values in queries:\n        if query_type == 1:\n            elements.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            elements = [y if element == x else element for element in elements]\n    \n    return elements\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            x = query[1]\n            arr = [x if elem == x else elem for elem in arr]\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            arr = [y if elem == x else elem for elem in arr]\n    \n    return arr\n\n# Input interface\ndef main():\n    q = int(input())\n    queries = []\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        queries.append(tuple(query))\n\n    # Output interface\n    result = process_queries(q, queries)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    array = []\n    replacements = {}\n    result = []\n    \n    for query in queries:\n        if query[0] == 1:\n            x = query[1]\n            if x in replacements:\n                array = [replacements[x] if elem == x else elem for elem in array]\n        else:\n            x, y = query[1], query[2]\n            replacements[x] = y\n        \n        result.append(len([elem for elem in array if elem not in replacements]))\n    \n    return result\n\n# Input interface using input()\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface using print()\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    elements = []\n    \n    for query_type, x, y in queries:\n        if query_type == 1:\n            elements = [y if element == x else element for element in elements]\n        elif query_type == 2:\n            elements.append(y)\n    \n    return [element for element in elements if element != x]\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            arr = [query[2] if x == query[1] else x for x in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    array = []\n    \n    for query_type, x, y in queries:\n        if query_type == 1:\n            array.append(x)\n        elif query_type == 2:\n            array = [y if num == x else num for num in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef manipulate_array(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            arr = [query[2] if x == query[1] else x for x in arr]\n    \n    return arr\n\n# Input interface\ndef main():\n    q = int(input())\n    queries = []\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if len(query) == 2:\n            queries.append((query[0], query[1], None))\n        else:\n            queries.append((query[0], query[1], query[2]))\n\n    # Output interface\n    result = manipulate_array(q, queries)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    for query in queries:\n        query_type = query.split()[0]\n        if query_type == '1':\n            x = int(query.split()[1])\n            array.append(x)\n        elif query_type == '2':\n            x, y = map(int, query.split()[1:])\n            array = [y if elem == x else elem for elem in array]\n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n"], "plans": ["requirement pool:\n- Handle array manipulation efficiently\n- Correctly implement both query types\n- Optimize for large input sizes\nWe will use Python and the built-in list data structure to efficiently handle array manipulation queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, which can be of two types: adding an element or replacing occurrences of a specific element.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty list to store the resulting array.\n    2. Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the array.\n        - If the query is of type 2, replace all occurrences of x with y in the array.\n    3. Return the resulting array after performing all queries.\n\n# [edge case] \n    Query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding element 5 to the empty array.\n    \n    Query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: Replacing all occurrences of 5 with 3 in the array [5].\n\n    Query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding element 2 to the existing array [3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the query type is valid (either 1 or 2).\n        - Handle cases where x or y are out of the specified range.\n        - Implement logic to replace all occurrences of x with y in the array.\n        (other code)\n", "requirement pool:\n- Handle array manipulation efficiently\n- Ensure accurate element replacement\nWe will use a simple approach by defining a static function in Python without using any class. We will utilize the built-in list data structure to store the array elements and efficiently handle the array manipulation queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array based on the input provided.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code would involve:\n    - Initialize an empty array to store the elements.\n    - Iterate through each query and perform the corresponding action:\n        - For query type 1: Append the element x to the end of the array.\n        - For query type 2: Replace all occurrences of x with y in the array.\n    - Return the resulting array after performing all queries.\n\n# [edge case] \n    Query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding element 5 to the empty array.\n    \n    Query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: Replacing all occurrences of 5 with 3 in the array [5].\n\n    Query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding element 2 to the existing array [3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check for invalid queries or incorrect input format.\n        - Handle scenarios where the query type is not 1 or 2.\n        - Ensure proper error handling for out-of-range values of x and y.\n", "requirement pool:\n- Efficiently handle array manipulation queries\n- Ensure accurate replacement of elements\n- Optimize for large query sets\nWe will use a simple approach by maintaining a list to store the elements and updating it based on the queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array based on the input queries.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store the elements and updating it based on the queries. \n    1. Initialize an empty list to store the elements.\n    2. Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, replace all occurrences of x in the list with y.\n    3. Return the resulting array after performing all the queries.\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    1 3\n    2 5 2\n    Resulting array: [3, 2]\n    Explanation: \n    - Initially, the array is empty.\n    - First query adds 5 to the array: [5]\n    - Second query adds 3 to the array: [5, 3]\n    - Third query replaces all occurrences of 5 with 2: [3, 2]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n", "requirement pool:\n- Efficiently process array queries\n- Accurately replace elements in the array\n- Optimize for large query sets\nWe will use Python and the built-in list data structure to efficiently handle array queries and perform accurate replacements of elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Check if there are steps should be considered simultaneously\n\n# [edge case] \n    query 1: 1 5\n    query 2: 2 5 3\n    query 3: 1 3\n    query 4: 2 3 7\n    query 5: 1 7\n    Expected output: 7 7\n    Explanation: \n    - Initially, the array is empty.\n    - Query 1 replaces all occurrences of 5 with itself, resulting in [5].\n    - Query 2 replaces all occurrences of 5 with 3, but since there are no occurrences of 5, the array remains [5].\n    - Query 3 replaces all occurrences of 3 with itself, resulting in [5].\n    - Query 4 replaces all occurrences of 3 with 7, resulting in [5].\n    - Query 5 replaces all occurrences of 7 with itself, resulting in [7].\n    \n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Efficiently process array queries\n- Ensure accurate replacement of elements\n- Optimize for large query sets\nWe will use Python built-in functions and data structures to efficiently handle array queries and replacements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations to be performed on the array.\n    'Replace': indicates the action of substituting all occurrences of a specific element in the array with another element.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should involve:\n    - Reading the number of queries\n    - Iterating through each query\n    - Handling two types of queries:\n        - If query type is 1, replace all occurrences of x with y in the array\n        - If query type is 2, update x to y in the array\n    - Printing the resulting array after all queries of the first type have been performed\n\n# [edge case] \n    query 1: 3\n    1 2\n    2 2 3\n    1 3\n    Resulting array: 3\n    Explanation: Initially, the array is [2]. After the first query, it becomes [3]. After the second query, there are no occurrences of 2 to replace, so the array remains [3].\n    \n    query 2: 4\n    1 1\n    1 2\n    2 1 3\n    1 3\n    Resulting array: 3\n    Explanation: Initially, the array is [1, 2]. After the first query, it becomes [3, 2]. After the second query, it becomes [3]. After the third query, there are no occurrences of 1 to replace, so the array remains [3].\n\n    query 3: 2\n    1 5\n    Resulting array: 5\n    Explanation: Initially, the array is [5]. After the query, there are no occurrences of any element to replace, so the array remains [5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios effectively.\n", "requirement pool:\n- Handle array queries efficiently\n- Ensure accurate replacement of elements\n- Optimize performance for large query sets\nWe will use Python and the built-in list data structure to efficiently handle array queries and perform accurate replacements of elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store the elements and performing replacements based on the query type. \n    - Initialize an empty list to store the elements.\n    - Iterate through each query:\n        - If the query is of type 1, replace all occurrences of x with y in the list.\n        - If the query is of type 2, append y to the list.\n    - Print the resulting array after performing all type 1 queries.\n\n# [edge case] \n    query 1: 3\n    1 2\n    2 3 4\n    1 4\n    Resulting array: [3]\n    Explanation: Initially, the array is empty. The first query replaces all occurrences of 2 with 3, then appends 4 to the array, and finally replaces all occurrences of 4 with 3. The resulting array is [3].\n\n    query 2: 2\n    1 5\n    1 5\n    Resulting array: []\n    Explanation: Initially, the array is empty. Both queries replace all occurrences of 5, but since there are no elements in the array, the resulting array is empty.\n\n    query 3: 4\n    2 1 2\n    2 2 3\n    1 3\n    1 1\n    Resulting array: [3, 3]\n    Explanation: Initially, the array is empty. The first two queries append elements to the array. The third query replaces all occurrences of 2 with 3, and the fourth query replaces all occurrences of 1 with 3. The resulting array is [3, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Handle array addition and replacement efficiently\n- Ensure accurate replacement of elements in the array\n- Optimize for performance with large query sets\nWe will use Python and the built-in list data structure to efficiently handle array manipulation queries. We will iterate through the queries and update the array accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array based on the input queries.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves iterating through the queries and updating the array based on the type of query. For query type 1, we will add the element x to the end of the array. For query type 2, we will replace all occurrences of x in the array with y.\n\n# [edge case] \n    query 1: 3\n    1 1\n    1 2\n    2 1 3\n    Expected output: [1, 2]\n    Explanation: \n    - Query 1: Add 1 to the array -> [1]\n    - Query 2: Add 2 to the array -> [1, 2]\n    - Query 3: Replace all occurrences of 1 with 3 -> [3, 2]\n\n    query 2: 4\n    1 5\n    2 5 3\n    1 3\n    2 3 4\n    Expected output: [5, 4]\n    Explanation:\n    - Query 1: Add 5 to the array -> [5]\n    - Query 2: Replace all occurrences of 5 with 3 (no change) -> [5]\n    - Query 3: Add 3 to the array -> [5, 3]\n    - Query 4: Replace all occurrences of 3 with 4 -> [5, 4]\n\n    query 3: 2\n    1 10\n    2 10 20\n    Expected output: [10]\n    Explanation:\n    - Query 1: Add 10 to the array -> [10]\n    - Query 2: Replace all occurrences of 10 with 20 -> [20]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers the scenarios effectively.\n", "requirement pool:\n- Handle array addition and replacement efficiently\n- Ensure accurate replacement of elements\n- Optimize for performance with large input sizes\nWe will use Python's built-in list data structure to efficiently handle array manipulation queries. We will iterate through the queries and update the array accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty list to store the array.\n    2. Iterate through each query:\n        - If the query is of type 1, append the element x to the end of the array.\n        - If the query is of type 2, replace all occurrences of x with y in the array.\n    3. Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: 1 5\n    query 2: 1 3\n    query 3: 2 5 2\n    query 4: 1 2\n    query 5: 2 2 4\n    Expected output: [5, 3, 4]\n    Explanation: \n    - After query 1: [5]\n    - After query 2: [5, 3]\n    - After query 3: [3, 2]\n    - After query 4: [3, 2, 4]\n    - After query 5: [4, 4]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers all scenarios effectively.\n", "requirement pool:\n- Handle query type 1 to add elements to the array\n- Implement query type 2 to replace elements in the array\n- Optimize the algorithm for efficient processing of a large number of queries\nWe will use a simple approach by maintaining a list to store the elements and updating it based on the queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the actions that need to be performed on the array based on the input queries.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store elements and updating it based on the queries. \n    1. Initialize an empty list to store elements.\n    2. Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, replace all occurrences of x with y in the list.\n    3. Print the resulting array after performing all the queries of type 1.\n\n# [edge case] \n    query 1: 3\n    1 1\n    1 2\n    2 2 3\n    Expected output: [1, 3]\n    Explanation: Initially empty array, add 1 and then 2. Replace all occurrences of 2 with 3.\n    \n    query 2: 4\n    1 5\n    2 5 6\n    1 7\n    1 8\n    Expected output: [7, 8]\n    Explanation: Initially empty array, add 5. Replace all occurrences of 5 with 6 (no effect). Add 7 and then 8.\n    \n    query 3: 2\n    1 10\n    2 10 20\n    Expected output: [20]\n    Explanation: Initially empty array, add 10. Replace all occurrences of 10 with 20.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers the requirements effectively.\n", "requirement analysis:\nThe main focus is on efficiently handling array manipulation queries and ensuring correct replacement of elements in the array.\nrequirement pool:\n- Handle array manipulation queries efficiently\n- Ensure accurate replacement of elements in the array\nWe will use a simple approach by creating a static Python function to handle the array manipulation queries efficiently and accurately without the need for defining a class. We will utilize basic list operations to add elements and replace occurrences in the array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves:\n    - Initialize an empty array to store the elements.\n    - Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the array.\n        - If the query is of type 2, replace all occurrences of x with y in the array.\n    - Return the resulting array after performing all queries.\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    1 3\n    2 5 2\n    Resulting array: [3, 2]\n    Explanation: \n    - First query adds 5 to the array: [5]\n    - Second query adds 3 to the array: [5, 3]\n    - Third query replaces all occurrences of 5 with 2: [3, 2]\n\n    Query 2:\n    2\n    1 4\n    2 4 1\n    Resulting array: [1]\n    Explanation:\n    - First query adds 4 to the array: [4]\n    - Second query replaces all occurrences of 4 with 1: [1]\n\n    Query 3:\n    1\n    1 2\n    Resulting array: [2]\n    Explanation:\n    - Only one query adding 2 to the array: [2]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n"], "scores": [], "pass_results": [false, true, true, true, true, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 344, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "expand_one2two", "parent_index": 249}
