{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You possess an integer array (originally vacant). You are tasked with executing q operations, with each query being of one of two types: * \"1 x\" \u2014 add the element x to the end of the array; * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. Determine the resulting array after executing all the queries, making sure the operations follow the provided sequence.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You possess an integer array (originally vacant). You are tasked with executing q operations, with each query being of one of two types: * \"1 x\" \u2014 add the element x to the end of the array; * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. Determine the resulting array after executing all the queries, making sure the operations follow the provided sequence.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You possess an integer array (originally vacant). Now, determine the resulting array after executing all the queries, making sure the operations follow the provided sequence. You are tasked with executing q operations, with each query being of one of two types: * \"1 x\" \u2014 add the element x to the end of the array; * \"2 x y\" \u2014 substitute every occurrence of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You possess an integer array (originally vacant) and are tasked with executing q operations, with each query being of one of two types: * \"1 x\" \u2014 add the element x to the end of the array; * \"2 x y\" \u2014 substitute every occurrence of x in the array with y. Determine the resulting array after executing all the queries, making sure the operations follow the provided sequence.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef execute_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            array.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            array = [y if num == x else num for num in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = execute_queries(q, queries)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef execute_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    resulting_array = []\n    \n    for query_type, x, y in queries:\n        if query_type == 1:\n            resulting_array.append(x)\n        elif query_type == 2:\n            resulting_array = [y if num == x else num for num in resulting_array]\n    \n    return resulting_array\n\n# Input interface using input() and output interface using print()\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '1':\n        queries.append((1, int(query[1]), None))\n    else:\n        queries.append((2, int(query[1]), int(query[2]))\n\nresult = execute_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef execute_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    for query in queries:\n        query_type = query.split()[0]\n        if query_type == '1':\n            x = int(query.split()[1])\n            array.append(x)\n        elif query_type == '2':\n            x, y = map(int, query.split()[1:])\n            array = [y if num == x else num for num in array]\n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Output interface\nresult = execute_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    result = []\n    \n    for query in queries:\n        query_type, *values = query.split()\n        \n        if query_type == '1':\n            result.append(int(values[0]))\n        elif query_type == '2':\n            x, y = map(int, values)\n            substituted = False\n            for i in range(len(result)):\n                if result[i] == x and not substituted:\n                    result[i] = y\n                    substituted = True\n    \n    return result\n\ndef main():\n    # Input\n    q = int(input())\n    queries = [input() for _ in range(q)]\n\n    # Process queries\n    result = process_queries(q, queries)\n\n    # Output\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        query_type = query.split()[0]\n        \n        if query_type == '1':\n            x = int(query.split()[1])\n            array.append(x)\n        elif query_type == '2':\n            x, y = map(int, query.split()[1:])\n            array = [y if num == x else num for num in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_queries(q: int, queries: List[str]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query.startswith('1'):\n            _, x = query.split()\n            array.append(int(x))\n        elif query.startswith('2'):\n            _, x, y = query.split()\n            array = [int(y) if num == int(x) else num for num in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\n\n# Output interface\nresult = process_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef execute_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    for query in queries:\n        query_type = query.split()[0]\n        if query_type == '1':\n            x = int(query.split()[1])\n            array.append(x)\n        elif query_type == '2':\n            x, y = map(int, query.split()[1:])\n            array = [y if num == x else num for num in array]\n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = execute_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef execute_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            array.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            array = [y if num == x else num for num in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = execute_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef execute_queries(q: int, queries: List[str]) -> List[int]:\n    elements = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            elements.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            elements = [y if element == x else element for element in elements]\n    \n    return elements\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = execute_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef execute_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            x = values[0]\n            arr.append(x)\n        elif query_type == 2:\n            x, y = values\n            arr = [y if num == x else num for num in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = execute_queries(q, queries)\n\n# Output interface\nprint(*result)\n"], "plans": ["requirement pool:\n- Efficiently handle array operations\n- Ensure correct sequence of query execution\n- Optimize for large input sizes\nWe will use Python built-in data structures like lists to efficiently handle array operations. We will iterate through the queries and update the array accordingly based on the query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'operations': refers to the actions that need to be performed on the array based on the query type.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code would involve iterating through the queries and updating the array based on the query type. For \"1 x\" queries, we would simply append x to the array. For \"2 x y\" queries, we would substitute every occurrence of x with y in the array.\n\n# [edge case] \n    Edge Case 1: \n    3\n    1 5\n    1 3\n    2 5 2\n    Expected Output: [5, 3]\n    Explanation: Initially, the array is empty. After the first two queries, the array becomes [5, 3]. The third query substitutes all occurrences of 5 with 2, resulting in the final array [2, 3].\n\n    Edge Case 2:\n    2\n    1 10\n    2 10 5\n    Expected Output: [5]\n    Explanation: The first query adds 10 to the array. The second query substitutes all occurrences of 10 with 5, resulting in the final array [5].\n\n    Edge Case 3:\n    4\n    1 1\n    1 2\n    1 3\n    2 1 4\n    Expected Output: [4, 2, 3]\n    Explanation: The first three queries add elements to the array. The last query substitutes all occurrences of 1 with 4, resulting in the final array [4, 2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle all scenarios effectively.\n", "requirement pool:\n- Implement array operation functions\n- Ensure correct order of query execution\n- Optimize for large number of queries\nWe will use the built-in list data structure in Python to efficiently handle array operations. To ensure correct sequence of operations, we will process each query in the order provided. For optimizing for large input sizes, we will leverage Python's efficient list manipulation capabilities.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'operations': refers to the actions that need to be performed on the array based on the queries provided.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan already mentions using Python's list data structure and processing queries in order, the following logic can be implemented:\n    \n    1. Initialize an empty list to store the resulting array.\n    2. Iterate through each query in the order provided.\n    3. For each \"1 x\" query, append x to the resulting array.\n    4. For each \"2 x y\" query, substitute every occurrence of x with y in the resulting array.\n    5. Finally, print the resulting array after processing all queries of the first type.\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    1 3\n    2 5 2\n    Resulting Array: [3, 2]\n    Explanation: \n    - First query adds 5 to the array: [5]\n    - Second query adds 3 to the array: [5, 3]\n    - Third query substitutes every occurrence of 5 with 2: [3, 2]\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Handle add and substitute operations efficiently\n- Maintain the correct sequence of operations\n- Optimize for large input sizes\nWe will use the built-in list data structure in Python to efficiently handle the array operations. We will iterate through the queries and update the array accordingly based on the query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'integer array': An array containing integers.\n    'q operations': A series of operations to be performed on the integer array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves iterating through the queries and updating the array based on the query type. For \"1 x\", we append x to the array. For \"2 x y\", we substitute every occurrence of x in the array with y.\n\n# [edge case] \n    q = 1\n    1 5\n    Output: 5\n    Explanation: Only one query to add 5 to the array, resulting in [5].\n\n    q = 3\n    1 2\n    1 3\n    2 2 4\n    Output: 4\n    Explanation: After the first two queries, the array is [2, 3]. The third query substitutes all occurrences of 2 with 4, resulting in [4, 3].\n\n    q = 2\n    2 3 5\n    1 5\n    Output: 5\n    Explanation: The first query substitutes all occurrences of 3 with 5, but since the array is initially empty, it has no effect. The second query adds 5 to the array, resulting in [5].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement query processing for adding elements to the array\n- Develop logic for substituting elements in the array based on queries\n- Optimize the algorithm for efficient handling of a large number of queries\nWe will use Python and the built-in list data structure to efficiently process and execute array manipulation queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'integer array': An array containing integers that can be modified based on the queries provided.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan mentions using Python and the built-in list data structure, we can implement the logic as follows:\n    \n    1. Initialize an empty list to store the resulting array.\n    2. Iterate through each query:\n        - If the query is of type \"1 x\", append x to the end of the resulting array.\n        - If the query is of type \"2 x y\", substitute every occurrence of x in the resulting array with y.\n    3. Print the resulting array after processing all queries.\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    2 5 3\n    1 2\n    Expected output: [3, 2]\n    Explanation: \n    - First query adds 5 to the array -> [5]\n    - Second query substitutes all occurrences of 5 with 3 -> [3]\n    - Third query adds 2 to the array -> [3, 2]\n\n    Query 2:\n    2\n    1 10\n    Expected output: [10]\n    Explanation:\n    - First query adds 10 to the array -> [10]\n\n    Query 3:\n    4\n    1 1\n    1 2\n    2 1 3\n    1 4\n    Expected output: [3, 4]\n    Explanation:\n    - First query adds 1 to the array -> [1]\n    - Second query adds 2 to the array -> [1, 2]\n    - Third query substitutes all occurrences of 1 with 3 -> [3, 2]\n    - Fourth query adds 4 to the array -> [3, 2, 4]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n", "requirement pool:\n- Efficiently process and execute array manipulation queries\n- Ensure correct sequence of operations\n- Handle large input sizes effectively\nWe will use the built-in list data structure in Python to efficiently process and execute array manipulation queries. We will iterate through the queries and update the array accordingly based on the query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the operations that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code would involve iterating through the queries and updating the array based on the query type. For \"1 x\", we would append x to the array. For \"2 x y\", we would substitute every occurrence of x in the array with y.\n\n# [edge case] \n    query 1: 1 5\n    query 2: 1 3\n    query 3: 2 5 2\n    query 4: 1 2\n    Expected output: [5, 3, 2]\n    Explanation: \n    - Initially, the array is empty.\n    - After query 1, the array becomes [5].\n    - After query 2, the array becomes [5, 3].\n    - After query 3, substituting all occurrences of 5 with 2, the array becomes [2, 3].\n    - After query 4, the array becomes [2, 3, 2].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement query processing for adding elements to the array\n- Develop logic for substituting elements in the array based on queries\n- Optimize the algorithm for efficient array manipulation\nWe will use Python and the built-in list data structure to efficiently process and execute the array manipulation queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'integer array': Refers to a list of integers that can be modified based on the queries provided.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code would involve iterating through the queries and updating the integer array based on the type of query. For \"1 x\", we would simply append x to the end of the array. For \"2 x y\", we would substitute every occurrence of x in the array with y.\n\n# [edge case] \n    Query 1: \"1 5\"\n    Query 2: \"1 3\"\n    Query 3: \"2 5 2\"\n    Query 4: \"1 7\"\n    Expected output: [3, 2, 7]\n    Explanation: Initially, the array is empty. After Query 1 and Query 2, the array becomes [5, 3]. Then, in Query 3, all occurrences of 5 are replaced with 2, resulting in [3, 2]. Finally, Query 4 appends 7 to the end of the array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Handle array operations efficiently\n- Preserve the correct sequence of operations\n- Optimize for large input sizes\nWe will use the built-in list data structure in Python to efficiently handle array operations. We will iterate through the queries and update the array accordingly based on the query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'operations': refers to the actions that need to be performed on the array based on the query type.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves iterating through the queries and updating the array based on the query type. For \"1 x\" queries, we append x to the end of the array. For \"2 x y\" queries, we substitute every occurrence of x in the array with y.\n\n# [edge case] \n    q = 1\n    1 5\n    Output: 5\n    Explanation: With only one query of type \"1 x\", the resulting array will contain only the element 5.\n    \n    q = 3\n    1 2\n    1 3\n    2 2 4\n    Output: 3 4\n    Explanation: After the first two queries, the array is [2, 3]. The third query substitutes all occurrences of 2 with 4, resulting in [3, 4].\n\n    q = 2\n    1 1\n    2 1 2\n    Output: 2\n    Explanation: After the second query, all occurrences of 1 are replaced with 2, resulting in a single element array [2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers the scenarios effectively.\n", "requirement pool:\n- Handle array operations efficiently\n- Maintain correct sequence of operations\n- Optimize for large input sizes\nWe will use Python and the built-in list data structure to efficiently handle the array operations. We will iterate through the queries and update the array accordingly based on the query type.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'integer array': Refers to a list data structure in Python that stores integers.\n    'q operations': Refers to a series of queries that need to be executed on the integer array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves iterating through the queries and updating the array based on the query type. \n    - For query type 1: Append the element x to the end of the array.\n    - For query type 2: Substitute every occurrence of x in the array with y.\n\n# [edge case] \n    Query 1: \"1 5\"\n    Query 2: \"2 5 3\"\n    Query 3: \"1 3\"\n    Expected output: [5, 3]\n    Explanation: Initially, the array is empty. After query 1, the array becomes [5]. Then, in query 2, all occurrences of 5 are replaced with 3, resulting in [3]. Finally, in query 3, 3 is added to the end of the array, resulting in the final array [5, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Handle array operations efficiently\n- Maintain correct sequence of operations\n- Optimize for large input sizes\nWe will use a simple approach by maintaining a list to store the elements and updating it based on the queries provided. We will iterate through each query and perform the required operation on the list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'operations': refers to the actions that need to be performed on the array, which can be either adding elements or substituting elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves maintaining a list to store the elements and updating it based on the queries provided. \n    1. Initialize an empty list to store the elements.\n    2. Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the list.\n        - If the query is of type 2, substitute every occurrence of x in the list with y.\n    3. Print the resulting array after performing all the queries.\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    1 3\n    2 5 2\n    Resulting array: [3, 2]\n    Explanation: \n    - First query adds 5 to the array: [5]\n    - Second query adds 3 to the array: [5, 3]\n    - Third query substitutes every occurrence of 5 with 2: [3, 2]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n", "requirement pool:\n- Implement array operations efficiently\n- Ensure accurate execution of query types\n- Optimize array manipulation for performance\nWe will use the built-in list data structure in Python to efficiently handle array operations. For query type 1, we will simply append the element to the list. For query type 2, we will iterate through the list and substitute every occurrence of x with y.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'operations': refers to the actions that need to be performed on the array, which includes adding elements and substituting values.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code:\n    - Initialize an empty list to store the array\n    - Iterate through each query:\n        - If the query is of type 1, append the element x to the list\n        - If the query is of type 2, substitute every occurrence of x with y in the list\n    - Print the resulting array after performing all the queries\n\n# [edge case] \n    Query 1: \n    3\n    1 5\n    1 3\n    2 5 2\n    Resulting array: [3, 2]\n    Explanation: \n    - First query adds 5 to the array: [5]\n    - Second query adds 3 to the array: [5, 3]\n    - Third query substitutes every occurrence of 5 with 2: [3, 2]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic covers all scenarios effectively.\n"], "scores": [], "pass_results": [true, false, false, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 297, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "rephrase_one", "parent_index": 220}
