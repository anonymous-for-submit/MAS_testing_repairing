{"name": "1620_E. Replace the Numbers", "description": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types: \n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. \n\n\n\nFind the resulting array after performing all the queries.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "tags": ["constructive algorithms", "data structures", "dsu", "implementation"], "difficulty": 11, "id": 1620, "sample_io": [{"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7 \n"]}, {"input": "4\n1 1\n1 2\n1 1\n2 2 2\n", "output": ["1 2 1 \n"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n", "output": ["3 2 2 3 2 \n"]}], "test_list": [{"input": "1\n1 50\n", "output": ["50 \n"]}, {"input": "1\n1 114514\n", "output": ["114514 \n"]}, {"input": "1\n1 2002\n", "output": ["2002 \n"]}, {"input": "1\n1 500\n", "output": ["500 \n"]}, {"input": "1\n1 28\n", "output": ["28"]}, {"input": "1\n1 2887\n", "output": ["2887"]}, {"input": "1\n1 228\n", "output": ["228"]}, {"input": "1\n1 29\n", "output": ["29"]}, {"input": "1\n1 1270\n", "output": ["1270"]}, {"input": "1\n1 182\n", "output": ["182"]}, {"input": "1\n1 2279\n", "output": ["2279"]}, {"input": "1\n1 979\n", "output": ["979"]}, {"input": "1\n1 1719\n", "output": ["1719"]}, {"input": "1\n1 1163\n", "output": ["1163"]}, {"input": "1\n1 1134\n", "output": ["1134"]}, {"input": "1\n1 2216\n", "output": ["2216"]}, {"input": "1\n1 810\n", "output": ["810"]}, {"input": "1\n1 1162\n", "output": ["1162"]}, {"input": "1\n1 8\n", "output": ["8"]}, {"input": "1\n1 176923\n", "output": ["176923"]}, {"input": "1\n1 346\n", "output": ["346"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 3 7"]}, {"input": "4\n1 1\n1 2\n1 1\n2 3 2\n", "output": ["1 2 1"]}, {"input": "7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 2 2 3 3"]}, {"input": "1\n1 192\n", "output": ["192"]}, {"input": "1\n1 6\n", "output": ["6"]}, {"input": "1\n1 1566\n", "output": ["1566"]}, {"input": "1\n1 1612\n", "output": ["1612"]}, {"input": "1\n1 391\n", "output": ["391"]}, {"input": "1\n1 1904\n", "output": ["1904"]}, {"input": "1\n1 12\n", "output": ["12"]}, {"input": "1\n1 455\n", "output": ["455"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 7\n", "output": ["1 3 6 7"]}, {"input": "4\n1 2\n1 2\n1 1\n2 3 2\n", "output": ["2 2 1"]}, {"input": "1\n1 61\n", "output": ["61"]}, {"input": "1\n1 3\n", "output": ["3"]}, {"input": "1\n1 107\n", "output": ["107"]}, {"input": "1\n1 537\n", "output": ["537"]}, {"input": "1\n1 520\n", "output": ["520"]}, {"input": "1\n1 72\n", "output": ["72"]}, {"input": "1\n1 415\n", "output": ["415"]}, {"input": "1\n1 639\n", "output": ["639"]}, {"input": "1\n1 705\n", "output": ["705"]}, {"input": "1\n1 34\n", "output": ["34"]}, {"input": "1\n1 42\n", "output": ["42"]}, {"input": "1\n1 91\n", "output": ["91"]}, {"input": "1\n1 123055\n", "output": ["123055"]}, {"input": "1\n1 408\n", "output": ["408"]}, {"input": "8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 1 7\n", "output": ["7 3 3 2"]}, {"input": "1\n1 10\n", "output": ["10"]}, {"input": "1\n1 5175\n", "output": ["5175"]}, {"input": "1\n1 37\n", "output": ["37"]}, {"input": "1\n1 2219\n", "output": ["2219"]}, {"input": "1\n1 205\n", "output": ["205"]}, {"input": "1\n1 1536\n", "output": ["1536"]}, {"input": "1\n1 1539\n", "output": ["1539"]}, {"input": "1\n1 1784\n", "output": ["1784"]}, {"input": "1\n1 147\n", "output": ["147"]}, {"input": "1\n1 825\n", "output": ["825"]}, {"input": "1\n1 3545\n", "output": ["3545"]}, {"input": "1\n1 14\n", "output": ["14"]}, {"input": "7\n1 3\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["3 3 2 3 3"]}, {"input": "1\n1 212\n", "output": ["212"]}, {"input": "1\n1 416\n", "output": ["416"]}, {"input": "1\n1 1055\n", "output": ["1055"]}, {"input": "1\n1 341\n", "output": ["341"]}, {"input": "1\n1 3564\n", "output": ["3564"]}, {"input": "1\n1 5\n", "output": ["5"]}, {"input": "8\n2 2 4\n1 1\n1 4\n1 2\n2 2 6\n2 4 3\n1 2\n2 2 5\n", "output": ["1 3 6 5"]}, {"input": "1\n1 1\n", "output": ["1"]}, {"input": "1\n1 115\n", "output": ["115"]}, {"input": "1\n1 727\n", "output": ["727"]}, {"input": "1\n1 98\n", "output": ["98"]}, {"input": "1\n1 55\n", "output": ["55"]}, {"input": "1\n1 284\n", "output": ["284"]}, {"input": "1\n1 4\n", "output": ["4"]}, {"input": "1\n1 9\n", "output": ["9"]}, {"input": "1\n1 583\n", "output": ["583"]}, {"input": "1\n1 16\n", "output": ["16"]}, {"input": "1\n1 2794\n", "output": ["2794"]}, {"input": "1\n1 59\n", "output": ["59"]}, {"input": "1\n1 300\n", "output": ["300"]}, {"input": "1\n1 388\n", "output": ["388"]}, {"input": "1\n1 1084\n", "output": ["1084"]}, {"input": "1\n1 2314\n", "output": ["2314"]}, {"input": "1\n1 736\n", "output": ["736"]}, {"input": "1\n1 4527\n", "output": ["4527"]}, {"input": "1\n1 2\n", "output": ["2"]}, {"input": "1\n1 439\n", "output": ["439"]}, {"input": "1\n1 86\n", "output": ["86"]}, {"input": "1\n1 5588\n", "output": ["5588"]}, {"input": "1\n1 152\n", "output": ["152"]}, {"input": "1\n1 41\n", "output": ["41"]}, {"input": "1\n1 260\n", "output": ["260"]}, {"input": "1\n1 551\n", "output": ["551"]}, {"input": "1\n1 2765\n", "output": ["2765"]}, {"input": "1\n1 1371\n", "output": ["1371"]}, {"input": "1\n1 127\n", "output": ["127"]}, {"input": "1\n1 8623\n", "output": ["8623"]}, {"input": "1\n1 49\n", "output": ["49"]}, {"input": "1\n1 874\n", "output": ["874"]}, {"input": "1\n1 376\n", "output": ["376"]}, {"input": "1\n1 58\n", "output": ["58"]}, {"input": "1\n1 6215\n", "output": ["6215"]}, {"input": "1\n1 1464\n", "output": ["1464"]}, {"input": "1\n1 33\n", "output": ["33"]}, {"input": "1\n1 4800\n", "output": ["4800"]}, {"input": "1\n1 6121\n", "output": ["6121"]}, {"input": "1\n1 121267\n", "output": ["121267"]}, {"input": "1\n1 3093\n", "output": ["3093"]}, {"input": "1\n1 19\n", "output": ["19"]}, {"input": "1\n1 202\n", "output": ["202"]}, {"input": "1\n1 1050\n", "output": ["1050"]}, {"input": "1\n1 2535\n", "output": ["2535"]}, {"input": "1\n1 1306\n", "output": ["1306"]}, {"input": "1\n1 1571\n", "output": ["1571"]}, {"input": "1\n1 1578\n", "output": ["1578"]}, {"input": "1\n1 142\n", "output": ["142"]}, {"input": "1\n1 2055\n", "output": ["2055"]}, {"input": "1\n1 53\n", "output": ["53"]}, {"input": "1\n1 3184\n", "output": ["3184"]}, {"input": "1\n1 21\n", "output": ["21"]}, {"input": "1\n1 642\n", "output": ["642"]}, {"input": "1\n1 15\n", "output": ["15"]}, {"input": "1\n1 23\n", "output": ["23"]}, {"input": "1\n1 169\n", "output": ["169"]}, {"input": "1\n1 861\n", "output": ["861"]}, {"input": "1\n1 139\n", "output": ["139"]}, {"input": "1\n1 552\n", "output": ["552"]}, {"input": "1\n1 247\n", "output": ["247"]}, {"input": "1\n1 40\n", "output": ["40"]}, {"input": "1\n1 46\n", "output": ["46"]}, {"input": "1\n1 173\n", "output": ["173"]}, {"input": "1\n1 171905\n", "output": ["171905"]}, {"input": "1\n1 509\n", "output": ["509"]}, {"input": "1\n1 7014\n", "output": ["7014"]}, {"input": "1\n1 47\n", "output": ["47"]}, {"input": "1\n1 335\n", "output": ["335"]}, {"input": "1\n1 3035\n", "output": ["3035"]}, {"input": "1\n1 237\n", "output": ["237"]}, {"input": "1\n1 4338\n", "output": ["4338"]}, {"input": "7\n1 6\n1 1\n2 1 1\n1 2\n1 1\n1 1\n2 1 3\n", "output": ["6 3 2 3 3"]}, {"input": "1\n1 528\n", "output": ["528"]}, {"input": "1\n1 1192\n", "output": ["1192"]}, {"input": "1\n1 210\n", "output": ["210"]}, {"input": "1\n1 1402\n", "output": ["1402"]}, {"input": "1\n1 195\n", "output": ["195"]}, {"input": "1\n1 347\n", "output": ["347"]}, {"input": "1\n1 208\n", "output": ["208"]}, {"input": "1\n1 525\n", "output": ["525"]}, {"input": "1\n1 413\n", "output": ["413"]}, {"input": "1\n1 4000\n", "output": ["4000"]}, {"input": "1\n1 587\n", "output": ["587"]}, {"input": "1\n1 6510\n", "output": ["6510"]}, {"input": "1\n1 209\n", "output": ["209"]}, {"input": "1\n1 430\n", "output": ["430"]}, {"input": "1\n1 1080\n", "output": ["1080"]}, {"input": "1\n1 56\n", "output": ["56"]}, {"input": "1\n1 483\n", "output": ["483"]}, {"input": "1\n1 12268\n", "output": ["12268"]}, {"input": "1\n1 1439\n", "output": ["1439"]}, {"input": "1\n1 9124\n", "output": ["9124"]}, {"input": "1\n1 9067\n", "output": ["9067"]}, {"input": "1\n1 34301\n", "output": ["34301"]}, {"input": "1\n1 553\n", "output": ["553"]}, {"input": "1\n1 35\n", "output": ["35"]}, {"input": "1\n1 4704\n", "output": ["4704"]}, {"input": "1\n1 994\n", "output": ["994"]}, {"input": "1\n1 1751\n", "output": ["1751"]}, {"input": "1\n1 702\n", "output": ["702"]}, {"input": "1\n1 224\n", "output": ["224"]}, {"input": "4\n1 1\n1 1\n1 1\n2 6 2\n", "output": ["1 1 1"]}, {"input": "1\n1 278\n", "output": ["278"]}, {"input": "1\n1 70\n", "output": ["70"]}, {"input": "1\n1 26\n", "output": ["26"]}, {"input": "1\n1 99\n", "output": ["99"]}, {"input": "1\n1 487\n", "output": ["487"]}, {"input": "1\n1 502\n", "output": ["502"]}, {"input": "1\n1 145712\n", "output": ["145712"]}, {"input": "1\n1 4942\n", "output": ["4942"]}, {"input": "1\n1 7\n", "output": ["7"]}, {"input": "1\n1 2767\n", "output": ["2767"]}, {"input": "1\n1 340\n", "output": ["340"]}, {"input": "1\n1 8530\n", "output": ["8530"]}, {"input": "1\n1 63\n", "output": ["63"]}, {"input": "1\n1 1575\n", "output": ["1575"]}, {"input": "1\n1 2756\n", "output": ["2756"]}, {"input": "1\n1 821\n", "output": ["821"]}, {"input": "1\n1 2667\n", "output": ["2667"]}, {"input": "1\n1 25\n", "output": ["25"]}, {"input": "1\n1 11\n", "output": ["11"]}, {"input": "1\n1 2714\n", "output": ["2714"]}, {"input": "1\n1 4721\n", "output": ["4721"]}, {"input": "1\n1 369\n", "output": ["369"]}, {"input": "1\n1 4188\n", "output": ["4188"]}, {"input": "1\n1 103\n", "output": ["103"]}, {"input": "1\n1 87\n", "output": ["87"]}, {"input": "1\n1 18\n", "output": ["18"]}, {"input": "1\n1 679\n", "output": ["679"]}, {"input": "1\n1 423\n", "output": ["423"]}, {"input": "1\n1 13\n", "output": ["13"]}, {"input": "1\n1 2163\n", "output": ["2163"]}, {"input": "1\n1 494\n", "output": ["494"]}, {"input": "1\n1 223\n", "output": ["223"]}], "task_id": "codecontest/151", "prompt": "You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. Make sure that every occurrence of the integer x is consistently removed and replaced with y throughout the array.\n\nYour task is to efficiently implement the query system and ensure the operations adhere to the specified constraints and order.\n\nFind the resulting array after performing all the queries. Make sure to handle large inputs within time and space limits efficiently.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "repair_prompt": ["You have an array of integers (initially empty).\n\nYou have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" \u2014 add the element x to the end of the array; \n  * \"2 x y\" \u2014 replace all occurrences of x in the array with y. Make sure that every occurrence of the integer x is consistently removed and replaced with y throughout the array.\n\nYour task is to efficiently implement the query system and ensure the operations adhere to the specified constraints and order.\n\nFind the resulting array after performing all the queries. Make sure to handle large inputs within time and space limits efficiently.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You have to perform q queries; each query is of one of two types. Implement the query system efficiently and ensure that every occurrence of integer x is consistently replaced with y throughout the array.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You have to perform q queries, either add an element x to the end of the array or replace occurrences of x with y in the array, efficiently implementing the query system and ensuring operations adhere to specified constraints and order. Find the resulting array after performing all queries, handling large inputs within time and space limits efficiently.\n\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    \n    for query in queries:\n        query_type, *args = map(int, query.split())\n        \n        if query_type == 1:\n            x = args[0]\n            if 1 <= x <= 5 * 10**5:\n                array.append(x)\n        elif query_type == 2:\n            x, y = args\n            if 1 <= x <= 5 * 10**5 and 1 <= y <= 5 * 10**5:\n                array = [y if num == x else num for num in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    occurrences = {}\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            x = values[0]\n            array.append(x)\n        elif query_type == 2:\n            x, y = values\n            for i in range(len(array)):\n                if array[i] == x:\n                    array[i] = y\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    arr = []\n    for query in queries:\n        query_type = query.split()[0]\n        if query_type == '1':\n            arr.append(int(query.split()[1]))\n        elif query_type == '2':\n            x, y = map(int, query.split()[1:])\n            arr = [y if elem == x else elem for elem in arr]\n    return arr\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, int]]) -> List[int]:\n    mapping = {}  # Initialize an empty dictionary to store the mappings of integers to be replaced\n    result = []  # Initialize an empty list to store the resulting array\n\n    for query_type, x, y in queries:\n        if query_type == 1:\n            mapping[x] = y  # Update the dictionary with the mapping of x to y\n        elif query_type == 2:\n            result = [mapping.get(num, num) for num in result]  # Replace all occurrences of x with y in the array\n\n    return result\n\n# Input and Output interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\nresult = perform_queries(q, queries)\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef perform_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    mapping = {}  # Initialize an empty dictionary to store the mapping of integers to be replaced\n    \n    for query_type, x, y in queries:\n        if query_type == 1:\n            mapping[x] = None  # Update the dictionary with the integer to be replaced as the key and None as the value\n        elif query_type == 2:\n            mapping[x] = y  # Update the dictionary with the new mapping of x to y\n    \n    resulting_array = []  # Initialize an empty list to store the resulting array after replacements\n    \n    for integer in mapping:\n        resulting_array.append(mapping[integer] if mapping[integer] is not None else integer)\n    \n    return resulting_array\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = perform_queries(q, queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    mapping = {}\n    resulting_array = []\n\n    for query in queries:\n        if query[0] == 1:\n            mapping[query[1]] = None\n        elif query[0] == 2:\n            mapping[query[1]] = query[2]\n\n    for key in mapping:\n        resulting_array.append(mapping[key])\n\n    return resulting_array\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\n# Output interface\nresult = process_queries(q, queries)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query[0] == 1:\n            array.append(query[1])\n        elif query[0] == 2:\n            if array:  # Check if array is not empty\n                x, y = query[1], query[2]\n                array = [y if elem == x else elem for elem in array]\n    \n    return array\n\n# Input\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\nresult = process_queries(q, queries)\n\n# Output\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query[0] == 1:\n            array.append(query[1])\n        elif query[0] == 2:\n            array = [query[2] if x == query[1] else x for x in array]\n    \n    return array\n\n# Input\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n    \n# Process queries\nresult = process_queries(q, queries)\n\n# Output\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Optional\n\ndef process_queries(q: int, queries: List[Tuple[int, int, Optional[int]]]) -> List[int]:\n    arr = []\n    \n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            arr = [y if ele == x else ele for ele in arr]\n    \n    return arr\n\n# Input interface\nq = int(input())\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(tuple(query))\n\nresult = process_queries(q, queries)\n\n# Output interface\nprint(*result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef perform_queries(q: int, queries: List[str]) -> List[int]:\n    array = []\n    \n    for query in queries:\n        query_type, *values = map(int, query.split())\n        \n        if query_type == 1:\n            array.append(values[0])\n        elif query_type == 2:\n            x, y = values\n            if x in array:\n                array = [y if elem == x else elem for elem in array]\n    \n    return array\n\n# Input interface\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = perform_queries(q, queries)\n\n# Output interface\nprint(*result)\n"], "plans": ["requirement pool:\n- Efficiently handle array queries\n- Ensure consistent replacement of array elements\n- Optimize array update operations\nWe will use Python built-in data structures like lists to efficiently implement the query system. We will handle the queries sequentially and update the array accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array based on the input provided.\n    'constraints': refers to the limitations or conditions that need to be followed while implementing the query system.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty list to store the array.\n    2. Iterate through each query:\n        - If the query type is 1, append the element x to the end of the array.\n        - If the query type is 2, replace all occurrences of x with y in the array.\n    3. Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding element 5 to the empty array.\n    \n    query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: Replacing all occurrences of 5 with 3 in the array [5].\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding element 2 to the existing array [3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check for empty array before replacing occurrences in query type 2.\n        - Handle cases where x or y values are out of bounds (less than 1 or greater than 5*10^5).\n        - Implement efficient algorithms for large inputs to ensure time and space limits are met.\n", "requirement pool:\n- Efficiently implement query system\n- Handle large inputs efficiently\n- Ensure operations adhere to specified order\nWe will use Python and the built-in list data structure to efficiently implement the query system for adding elements and replacing occurrences in the array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the operations that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider handling both types of queries efficiently. \n    - For query type 1: Append the element x to the end of the array.\n    - For query type 2: Replace all occurrences of x with y in the array.\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"2 5 3\"\n    query 3: \"1 3\"\n    Expected output: [5, 3]\n    Explanation: \n    - Initially, the array is empty.\n    - Query 1 adds 5 to the array -> [5]\n    - Query 2 replaces all occurrences of 5 with 3 -> [3]\n    - Query 3 adds 3 to the end of the array -> [5, 3]\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - To efficiently handle query type 2, we can maintain a dictionary to store the indices of all occurrences of x in the array. This will help in replacing x with y in O(1) time complexity.\n        - We can optimize the replacement process by updating the dictionary and array simultaneously.\n", "requirement pool:\n- Efficiently handle array queries\n- Ensure consistent element replacement\n- Optimize for large input sizes\nWe will use Python and the built-in list data structure to efficiently implement the query system for adding elements and replacing occurrences in the array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the operations that need to be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code should consider handling two types of queries efficiently:\n    - For query type 1: Append the element x to the end of the array.\n    - For query type 2: Replace all occurrences of x in the array with y.\n\n    Here is a sample code logic to implement the query system:\n    \n```python\ndef query_system(q, queries):\n    arr = []\n    for query in queries:\n        if query[0] == 1:\n            arr.append(query[1])\n        elif query[0] == 2:\n            arr = [y if elem == query[1] else elem for elem in arr]\n    return arr\n\n# Sample input handling\nq = 4\nqueries = [(1, 5), (1, 3), (2, 5, 2), (1, 7)]\n\nresulting_array = query_system(q, queries)\nprint(resulting_array)\n```\n\n# [edge case] \n    query_system(3, [(1, 5), (2, 5, 2), (1, 5)]) = [2]\n    Explanation: Initially, the array is empty. After the first query (1, 5), the array becomes [5]. Then, the second query (2, 5, 2) replaces all occurrences of 5 with 2, resulting in [2]. Finally, the third query (1, 5) appends 5 to the array, but since we only return the resulting array after performing all queries of the first type, the output is [2].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        To handle large inputs efficiently within time and space limits, consider using a dictionary to store the indices of elements in the array for quick replacement during query type 2 operations.\n        (code for handling the edge case)\n", "requirement pool:\n- Implement efficient query system\n- Ensure consistent replacement of integers\n- Handle both query types effectively\nWe will use a simple dictionary to store the mappings of integers to be replaced. We will iterate through the queries and update the dictionary accordingly to ensure consistent replacements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations to be performed on the array.\n    'types': two types of queries - one to replace all occurrences of integer x with y, and the other to query the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty dictionary to store the mappings of integers to be replaced.\n    2. Iterate through each query:\n        - If the query is of type 1, update the dictionary with the mapping of x to y.\n        - If the query is of type 2, replace all occurrences of x with y in the array.\n    3. Print the resulting array after performing all type 2 queries.\n\n# [edge case] \n    query 1: 3\n    1 2\n    2 2 3\n    1 3\n    Output: 3\n    Explanation: Initially, the array is [2]. After the first query, it becomes [3]. After the second query, it remains [3]. So, the final array is [3].\n\n    query 2: 4\n    1 1\n    1 2\n    2 1 3\n    1 3\n    Output: 3\n    Explanation: Initially, the array is [1]. After the first query, it becomes [2]. After the second query, it remains [2]. After the third query, it becomes [3]. So, the final array is [3].\n\n    query 3: 2\n    1 5\n    2 5 6\n    Output: 6\n    Explanation: Initially, the array is [5]. After the first query, it becomes [6]. So, the final array is [6].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers all scenarios efficiently.\n", "requirement pool:\n- Efficiently handle both query types\n- Ensure consistent replacement of integers\n- Optimize performance for large arrays\nWe will use a dictionary to store the mapping of integers to be replaced. For each query, we will update the dictionary accordingly and then iterate through the array to perform the replacements efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations to be performed on the array.\n    'types': two different types of queries - one to replace all occurrences of a specific integer with another, and the other to update the mapping of integers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty dictionary to store the mapping of integers to be replaced.\n    2. Iterate through each query:\n        - If the query type is 1, update the dictionary with the integer to be replaced as the key and None as the value.\n        - If the query type is 2, update the dictionary with the new mapping of x to y.\n    3. Initialize an empty list to store the resulting array after replacements.\n    4. Iterate through the array:\n        - If the integer is in the dictionary keys, append the corresponding value to the resulting array.\n        - Otherwise, append the integer itself to the resulting array.\n    5. Print the resulting array after performing all queries of the first type.\n\n# [edge case] \n    query 1: 1 5\n    query 2: 2 5 10\n    query 3: 1 10\n    query 4: 2 10 15\n    query 5: 1 15\n    Resulting array: [15, 15]\n    Explanation: Initially, all occurrences of integer 5 are replaced with 10, then all occurrences of 10 are replaced with 15. The final array after performing all queries is [15, 15].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided can efficiently handle all types of queries and replacements.\n", "requirement pool:\n- Implement efficient query processing\n- Ensure consistent integer replacement\n- Optimize performance and accuracy\nWe will use a dictionary to store the mapping of integers to be replaced. For each query, we will update the dictionary accordingly and then iterate through the array to perform the replacements efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the number of operations to be performed on the array.\n    'types of queries': Refers to the two different types of operations that can be performed on the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty dictionary to store the mapping of integers to be replaced.\n    2. Iterate through each query:\n        - If the query is of type 1, update the dictionary with the integer x as key and None as value.\n        - If the query is of type 2, update the dictionary with integer x as key and y as value.\n    3. Initialize an empty list to store the resulting array after performing all type 1 queries.\n    4. Iterate through the resulting array and replace each occurrence of integer x with y based on the dictionary mapping.\n    5. Print the resulting array after all type 1 queries have been applied.\n\n# [edge case] \n    query 1: 1 5\n    query 2: 2 5 10\n    query 3: 1 10\n    query 4: 2 10 20\n    query 5: 1 20\n    Resulting array: [10, 20]\n    Explanation: \n    - Initially, we have an empty array.\n    - After query 1, we have [5].\n    - After query 2, we update the mapping to {5: 10}.\n    - After query 3, we have [10].\n    - After query 4, we update the mapping to {5: 10, 10: 20}.\n    - After query 5, we have [20].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Efficiently handle array queries\n- Ensure query operations are in specified order\n- Optimize space usage for large inputs\nWe will use Python and implement a static function to efficiently handle array queries by using a dictionary to store elements and their occurrences.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the number of operations to be performed on the array.\n    'add an element x to the end of the array': means appending x to the array.\n    'replace occurrences of x with y in the array': means replacing all occurrences of x with y in the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the code involves using a dictionary to store elements and their occurrences. \n    - Initialize an empty array to store the final result.\n    - Iterate through each query:\n        - If it is of type 1, append the element x to the array.\n        - If it is of type 2, replace all occurrences of x with y in the array.\n    - Print the resulting array after performing all queries.\n\n# [edge case] \n    query 1: 3\n    1 1\n    1 2\n    2 1 3\n    Expected output: [2]\n    Explanation: Initially, the array is empty. After the first query, it becomes [1]. After the second query, it becomes [1, 2]. After the third query, all occurrences of 1 are replaced with 3, resulting in [2].\n\n    query 2: 4\n    1 1\n    1 2\n    2 1 3\n    1 4\n    Expected output: [2, 4]\n    Explanation: Similar to the previous case, but after the fourth query, element 4 is added to the array.\n\n    query 3: 2\n    2 1 3\n    2 3 5\n    Expected output: []\n    Explanation: Both queries are of type 2 and involve replacing occurrences, but since there are no elements in the array initially, the resulting array is empty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the array is empty before performing a replacement operation.\n        - Handle cases where x or y are not within the specified constraints.\n        - Ensure efficient implementation to handle large inputs within time and space limits.\n", "requirement pool:\n- Efficiently handle query additions and replacements\n- Ensure accurate and ordered resulting array\nWe will use Python and implement a simple function to efficiently handle the array queries using a list data structure.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, which can be either adding an element or replacing occurrences of a specific element with another.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Since the plan is to implement a function to handle array queries efficiently, the logic should include:\n    - Initialize an empty list to store the resulting array\n    - Iterate through each query\n    - For query type 1, add the element x to the end of the resulting array\n    - For query type 2, replace all occurrences of x with y in the resulting array\n    - Return the resulting array after all queries have been processed\n\n# [edge case] \n    query 1: \"1 5\"\n    query 2: \"2 5 3\"\n    query 3: \"1 3\"\n    Expected output: [5, 3]\n    Explanation: \n    - Query 1 adds 5 to the array -> [5]\n    - Query 2 replaces all occurrences of 5 with 3 -> [3]\n    - Query 3 adds 3 to the array -> [5, 3]\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Efficiently handle array queries\n- Ensure query operations are in specified order\n- Optimize space usage for large inputs\nWe will use a simple approach by maintaining a list to store the elements and efficiently process the queries using Python built-in functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': Refers to the number of operations to be performed on the array.\n\n    'add an element x to the end of the array': Indicates adding a new element to the end of the array.\n\n    'replace occurrences of x with y in the array': Involves replacing all occurrences of a specific element x with another element y in the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty list to store the elements of the array.\n    2. Iterate through each query:\n        - If the query is of type 1, add the element x to the end of the array.\n        - If the query is of type 2, replace all occurrences of x with y in the array.\n    3. Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: 3\n    1 1\n    1 2\n    2 1 3\n    Expected output: [1, 2]\n    Explanation: Initially, the array is empty. After the first two queries, the array becomes [1, 2]. In the third query, all occurrences of 1 are replaced with 3, resulting in [3, 2].\n\n    query 2: 4\n    1 5\n    2 5 6\n    1 6\n    2 6 7\n    Expected output: [6]\n    Explanation: Initially, the array is empty. After the first query, it becomes [5]. In the second query, all occurrences of 5 are replaced with 6, resulting in [6]. The third query adds 6 to the end of the array. Finally, in the last query, all occurrences of 6 are replaced with 7, resulting in [7].\n\n    query 3: 2\n    1 10\n    2 10 20\n    Expected output: [20]\n    Explanation: Initially, the array is empty. After the first query, it becomes [10]. In the second query, all occurrences of 10 are replaced with 20, resulting in [20].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n", "requirement pool:\n- Efficiently add elements to the array\n- Replace all occurrences of a number in the array\n- Handle large inputs efficiently\nWe will use Python and the built-in list data structure to efficiently implement the query system for adding elements and replacing occurrences in the array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'queries': refers to the actions that need to be performed on the array, which can be either adding elements or replacing occurrences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The logic to implement the query system involves maintaining a list to store the elements and efficiently handle the two types of queries. \n    1. Initialize an empty list to store the elements.\n    2. Iterate through each query:\n        - If the query is of type 1, append the element x to the end of the list.\n        - If the query is of type 2, replace all occurrences of x with y in the list.\n    3. Return the resulting array after performing all queries.\n\n# [edge case] \n    query 1: \"1 5\"\n    Resulting array: [5]\n    Explanation: Adding element 5 to the empty array.\n    \n    query 2: \"2 5 3\"\n    Resulting array: [3]\n    Explanation: Replacing all occurrences of 5 with 3 in the array [5].\n\n    query 3: \"1 2\"\n    Resulting array: [3, 2]\n    Explanation: Adding element 2 to the existing array [3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - To handle the case where x does not exist in the array for query type 2, we can add a check before replacing occurrences:\n            if x in array:\n                # Replace occurrences\n            else:\n                # Do nothing or raise an exception\n        (other code)\n"], "scores": [], "pass_results": [true, true, true, false, false, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 172, "examples": "\nInput\n\nThe first line contains a single integer q (1 \u2264 q \u2264 5 \u22c5 10^5) \u2014 the number of queries.\n\nNext q lines contain queries (one per line). Each query is of one of two types: \n\n  * \"1 x\" (1 \u2264 x \u2264 5 \u22c5 10^5); \n  * \"2 x y\" (1 \u2264 x, y \u2264 5 \u22c5 10^5). \n\n\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers \u2014 the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\n\nOutput\n\n\n3 2 2 3 2 \n\nInput\n\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\n\nOutput\n\n\n1 2 1 \n\nInput\n\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\n\nOutput\n\n\n1 3 3 7 \n\nNote\n\nIn the first example, the array changes as follows:\n\n[] \u2192 [3] \u2192 [3, 1] \u2192 [3, 2] \u2192 [3, 2, 2] \u2192 [3, 2, 2, 1] \u2192 [3, 2, 2, 1, 2] \u2192 [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] \u2192 [1] \u2192 [1, 2] \u2192 [1, 2, 1] \u2192 [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] \u2192 [] \u2192 [1] \u2192 [1, 4] \u2192 [1, 4, 2] \u2192 [1, 4, 4] \u2192 [1, 3, 3] \u2192 [1, 3, 3, 2] \u2192 [1, 3, 3, 7].", "mutate_method": "expand_one2two", "parent_index": 145}
