{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 129, "prompt": "Write a function to calculate whether the matrix is a magic square. A magic square is a square matrix where the sum of every row, column, and diagonal is the same. Ensure to handle matrices of varying sizes and element types gracefully.", "code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True", "test_imports": [], "test_list": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False", "assert magic_square_test([[8, 9, 3, 14], [7, 10, 9, 11], [16, 6, 13, 6], [9, 11, 17, 2]]) == False", "assert magic_square_test([[9, 10, 6, 17], [5, 8, 4, 11], [13, 1, 5, 9], [11, 10, 17, 8]]) == False", "assert magic_square_test([[2, 8, 3, 9], [3, 16, 5, 7], [12, 7, 5, 2], [12, 11, 12, 6]]) == False", "assert magic_square_test([[12, 12, 6, 10], [7, 10, 4, 9], [20, 8, 9, 8], [14, 8, 16, 3]]) == False", "assert magic_square_test([[12, 10, 1, 13], [4, 12, 3, 6], [18, 7, 5, 1], [4, 2, 15, 7]]) == False", "assert magic_square_test([[12, 17, 3, 9], [7, 9, 11, 8], [19, 1, 11, 1], [10, 9, 15, 7]]) == False", "assert magic_square_test([[11, 7, 2, 16], [7, 18, 4, 12], [16, 7, 13, 6], [10, 1, 18, 6]]) == False", "assert magic_square_test([[8, 7, 5, 15], [7, 13, 6, 8], [20, 2, 11, 9], [13, 6, 15, 4]]) == False", "assert magic_square_test([[10, 8, 3, 10], [1, 9, 7, 13], [16, 7, 14, 4], [7, 10, 18, 1]]) == False", "assert magic_square_test([[2, 17, 1, 10], [4, 15, 5, 11], [15, 6, 5, 7], [5, 1, 14, 8]]) == False", "assert magic_square_test([[6, 13, 5, 14], [5, 15, 11, 14], [12, 4, 15, 2], [13, 9, 13, 5]]) == False", "assert magic_square_test([[12, 14, 5, 9], [1, 11, 9, 14], [13, 5, 14, 8], [11, 7, 13, 4]]) == False", "assert magic_square_test([[2, 9, 2, 16], [7, 15, 4, 11], [21, 2, 13, 4], [10, 9, 20, 9]]) == False", "assert magic_square_test([[7, 11, 2, 16], [6, 10, 9, 8], [15, 4, 12, 6], [14, 10, 18, 9]]) == False", "assert magic_square_test([[9, 8, 3, 12], [6, 14, 5, 7], [13, 3, 6, 10], [12, 11, 15, 6]]) == False", "assert magic_square_test([[4, 10, 4, 17], [1, 14, 3, 12], [17, 6, 13, 1], [4, 8, 12, 8]]) == False", "assert magic_square_test([[9, 7, 6, 9], [6, 10, 8, 10], [19, 3, 5, 1], [8, 7, 18, 5]]) == False", "assert magic_square_test([[5, 13, 1, 12], [6, 16, 7, 10], [18, 4, 8, 5], [8, 5, 16, 4]]) == False", "assert magic_square_test([[8, 12, 3, 13], [4, 13, 13, 8], [17, 7, 15, 9], [14, 5, 14, 7]]) == False", "assert magic_square_test([[10, 9, 2, 18], [7, 9, 13, 13], [18, 7, 9, 4], [5, 9, 14, 8]]) == False", "assert magic_square_test([[5, 8, 5, 16], [6, 14, 9, 15], [20, 2, 13, 5], [7, 4, 18, 1]]) == False", "assert magic_square_test([[7, 14, 6, 9], [7, 14, 13, 8], [11, 6, 9, 5], [10, 3, 10, 6]]) == False", "assert magic_square_test([[7, 15, 5, 9], [2, 17, 7, 8], [21, 8, 8, 1], [10, 11, 15, 8]]) == False", "assert magic_square_test([[9, 14, 5, 19], [4, 15, 11, 16], [19, 6, 13, 7], [9, 7, 10, 1]]) == False", "assert magic_square_test([[12, 11, 6, 15], [6, 16, 5, 13], [19, 8, 11, 1], [13, 10, 11, 2]]) == False", "assert magic_square_test([[10, 11, 5, 11], [3, 18, 10, 15], [18, 6, 5, 3], [12, 5, 18, 3]]) == False", "assert magic_square_test([[7, 11, 4, 17], [2, 15, 4, 11], [17, 5, 5, 3], [8, 2, 20, 7]]) == False", "assert magic_square_test([[6, 16, 4, 15], [2, 15, 11, 8], [20, 6, 14, 3], [14, 3, 20, 7]]) == False", "assert magic_square_test([[8, 11, 3, 11], [2, 12, 9, 7], [21, 5, 9, 10], [14, 7, 11, 1]]) == False", "assert magic_square_test([[12, 17, 4, 14], [6, 9, 4, 16], [15, 5, 14, 5], [13, 3, 10, 7]]) == False", "assert magic_square_test([[11, 14, 2, 17], [5, 17, 4, 10], [14, 1, 8, 6], [4, 7, 14, 2]]) == False", "assert magic_square_test([[7, 16, 2, 10], [2, 17, 6, 13], [12, 5, 10, 5], [7, 1, 15, 1]]) == False", "assert magic_square_test([[12, 7, 4, 14], [7, 18, 5, 9], [17, 4, 12, 1], [10, 7, 17, 4]]) == False", "assert magic_square_test([[2, 2, 4], [5, 9, 5], [8, 2, 6]]) == False", "assert magic_square_test([[7, 10, 8], [14, 9, 6], [1, 1, 13]]) == False", "assert magic_square_test([[7, 2, 3], [4, 1, 1], [7, 2, 9]]) == False", "assert magic_square_test([[4, 10, 11], [7, 5, 3], [5, 1, 4]]) == False", "assert magic_square_test([[3, 7, 1], [12, 5, 3], [1, 7, 6]]) == False", "assert magic_square_test([[6, 11, 4], [8, 1, 2], [9, 8, 11]]) == False", "assert magic_square_test([[4, 3, 8], [4, 5, 6], [4, 4, 10]]) == False", "assert magic_square_test([[5, 2, 11], [10, 4, 1], [3, 6, 4]]) == False", "assert magic_square_test([[3, 7, 9], [5, 5, 6], [6, 2, 7]]) == False", "assert magic_square_test([[2, 3, 7], [5, 1, 5], [6, 3, 8]]) == False", "assert magic_square_test([[1, 11, 3], [11, 10, 3], [5, 8, 3]]) == False", "assert magic_square_test([[4, 9, 4], [8, 8, 4], [2, 8, 10]]) == False", "assert magic_square_test([[2, 11, 3], [9, 8, 3], [9, 5, 11]]) == False", "assert magic_square_test([[5, 8, 3], [7, 10, 4], [3, 2, 11]]) == False", "assert magic_square_test([[3, 9, 11], [13, 1, 3], [6, 3, 9]]) == False", "assert magic_square_test([[6, 4, 2], [13, 2, 2], [6, 1, 12]]) == False", "assert magic_square_test([[1, 2, 7], [13, 10, 3], [3, 6, 7]]) == False", "assert magic_square_test([[7, 2, 9], [10, 8, 5], [2, 8, 13]]) == False", "assert magic_square_test([[4, 8, 4], [14, 10, 3], [2, 1, 9]]) == False", "assert magic_square_test([[4, 10, 10], [5, 6, 5], [1, 2, 11]]) == False", "assert magic_square_test([[7, 3, 2], [6, 5, 4], [6, 1, 9]]) == False", "assert magic_square_test([[6, 3, 2], [11, 2, 6], [2, 7, 11]]) == False", "assert magic_square_test([[4, 8, 2], [6, 8, 5], [6, 6, 4]]) == False", "assert magic_square_test([[1, 7, 4], [9, 2, 3], [5, 8, 9]]) == False", "assert magic_square_test([[1, 8, 7], [4, 3, 4], [3, 1, 6]]) == False", "assert magic_square_test([[2, 6, 5], [5, 3, 3], [5, 2, 4]]) == False", "assert magic_square_test([[6, 5, 4], [6, 7, 1], [7, 1, 5]]) == False", "assert magic_square_test([[1, 7, 2], [10, 4, 6], [6, 4, 6]]) == False", "assert magic_square_test([[1, 12, 5], [7, 3, 1], [7, 3, 4]]) == False", "assert magic_square_test([[1, 10, 1], [13, 4, 6], [4, 7, 12]]) == False", "assert magic_square_test([[1, 7, 9], [7, 2, 2], [7, 5, 12]]) == False", "assert magic_square_test([[1, 10, 3], [5, 2, 2], [7, 6, 4]]) == False", "assert magic_square_test([[7, 5, 7], [6, 6, 2], [2, 1, 13]]) == False", "assert magic_square_test([[5, 9, 3], [8, 8, 2], [7, 6, 3]]) == False", "assert magic_square_test([[4, 2, 10], [10, 6, 4], [3, 4, 3]]) == False", "assert magic_square_test([[4, 6, 10], [11, 4, 6], [3, 6, 2]]) == False", "assert magic_square_test([[7, 11, 5], [5, 6, 2], [8, 4, 10]]) == False", "assert magic_square_test([[7, 5, 4], [12, 10, 1], [1, 3, 6]]) == False", "assert magic_square_test([[6, 7, 11], [7, 6, 5], [3, 8, 4]]) == False", "assert magic_square_test([[6, 10, 11], [10, 5, 4], [2, 4, 4]]) == False", "assert magic_square_test([[2, 5, 3], [4, 6, 1], [7, 1, 10]]) == False", "assert magic_square_test([[4, 7, 4], [4, 8, 4], [7, 3, 2]]) == False", "assert magic_square_test([[5, 2, 11], [12, 7, 4], [7, 2, 6]]) == False", "assert magic_square_test([[7, 7, 6], [7, 2, 2], [6, 7, 11]]) == False", "assert magic_square_test([[4, 8, 8], [7, 8, 3], [8, 3, 6]]) == False", "assert magic_square_test([[6, 6, 2], [13, 9, 4], [6, 4, 4]]) == False", "assert magic_square_test([[6, 11, 6], [8, 8, 4], [8, 7, 2]]) == False", "assert magic_square_test([[5, 11, 2], [14, 5, 2], [7, 5, 5]]) == False", "assert magic_square_test([[3, 12, 11], [13, 9, 2], [2, 8, 12]]) == False", "assert magic_square_test([[5, 7, 1], [9, 7, 6], [4, 2, 2]]) == False", "assert magic_square_test([[2, 3, 9], [14, 8, 5], [6, 1, 7]]) == False", "assert magic_square_test([[3, 6, 7], [14, 5, 6], [8, 8, 5]]) == False", "assert magic_square_test([[3, 8, 2], [9, 7, 3], [4, 8, 9]]) == False", "assert magic_square_test([[7, 2, 6], [4, 3, 2], [9, 8, 7]]) == False", "assert magic_square_test([[4, 10, 9], [11, 9, 3], [1, 3, 2]]) == False", "assert magic_square_test([[4, 5, 7], [5, 6, 2], [8, 2, 5]]) == False", "assert magic_square_test([[6, 8, 5], [10, 5, 3], [7, 6, 7]]) == False", "assert magic_square_test([[4, 7, 11], [13, 8, 6], [8, 6, 3]]) == False", "assert magic_square_test([[4, 5, 3], [11, 7, 5], [9, 1, 7]]) == False", "assert magic_square_test([[1, 7, 1], [7, 9, 1], [2, 1, 11]]) == False", "assert magic_square_test([[3, 7, 9], [13, 4, 3], [1, 3, 11]]) == False", "assert magic_square_test([[5, 4, 9], [12, 4, 1], [4, 4, 9]]) == False", "assert magic_square_test([[1, 4, 7], [9, 1, 3], [1, 8, 10]]) == False", "assert magic_square_test([[2, 11, 2], [11, 4, 4], [3, 5, 2]]) == False", "assert magic_square_test([[4, 2, 1], [14, 1, 3], [3, 4, 9]]) == False", "assert magic_square_test([[7, 4, 8], [8, 2, 3], [1, 7, 11]]) == False"], "entry_point": "magic_square_test", "repair_prompt": ["Write a function magic_square_test to calculate whether the matrix is a magic square. A magic square is a square matrix where the sum of every row, column, and diagonal is the same. Ensure to handle matrices of varying sizes and element types gracefully.\nmagic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n", "Write a function magic_square_test to calculate whether the matrix is a magic square. A magic square is a square matrix. The sum of every row, column, and diagonal in this matrix is the same. Ensure to handle matrices of varying sizes and element types gracefully.\nmagic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n", "Write a function magic_square_test to calculate whether the matrix is a magic square by ensuring the sum of every row, column, and diagonal is the same. Ensure to handle matrices of varying sizes and element types gracefully.\nmagic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n"], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    '''\n    Checks if the given matrix is a magic square.\n    \n    Parameters:\n    matrix (list[list[float]]): A square matrix of numbers.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    '''\n    \n    # Check if the matrix is square\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n    \n    # Ensure all elements in the matrix are numeric\n    if not all(isinstance(x, (int, float)) for row in matrix for x in row):\n        return False\n    \n    # Convert the matrix to a numpy array for easier manipulation\n    np_matrix = np.array(matrix)\n    \n    # Calculate the sum of the first row to use as a reference sum\n    reference_sum = np.sum(np_matrix[0, :])\n    \n    # Check if all rows have the same sum as the reference sum\n    for row in np_matrix:\n        if np.sum(row) != reference_sum:\n            return False\n    \n    # Check if all columns have the same sum as the reference sum\n    for col in np_matrix.T:\n        if np.sum(col) != reference_sum:\n            return False\n    \n    # Check if the main diagonal has the same sum as the reference sum\n    if np.sum(np.diag(np_matrix)) != reference_sum:\n        return False\n    \n    # Check if the secondary diagonal has the same sum as the reference sum\n    if np.sum(np.diag(np.fliplr(np_matrix))) != reference_sum:\n        return False\n    \n    # If all checks pass, the matrix is a magic square\n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    Checks if the given matrix is a magic square.\n\n    Parameters:\n    matrix (list[list[float]]): A square matrix of numbers.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n\n    Raises:\n    ValueError: If the matrix is not square or contains non-numeric elements.\n    \"\"\"\n    # Validate matrix dimensions\n    if not matrix or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Matrix must be a list of lists.\")\n    \n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            raise ValueError(\"Matrix must be square (same number of rows and columns).\")\n        if not all(isinstance(element, (int, float)) for element in row):\n            raise ValueError(\"Matrix must contain only numeric elements.\")\n\n    # Calculate the target sum using the first row\n    target_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != target_sum:\n        return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"Check if a given square matrix is a magic square.\n\n    A magic square is a square matrix where the sum of every row, column,\n    and diagonal is the same.\n\n    Args:\n        matrix: A list of lists where each sublist represents a row of the matrix.\n                Each element in the matrix should be a numeric type (int or float).\n\n    Returns:\n        A boolean indicating whether the matrix is a magic square.\n    \"\"\"\n    # Check if matrix is square\n    if not matrix or any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    \n    # Calculate the reference sum using the first row\n    ref_sum = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(row[i] for row in matrix)\n        if row_sum != ref_sum or col_sum != ref_sum:\n            return False\n\n    # Check diagonals\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if main_diagonal_sum != ref_sum or anti_diagonal_sum != ref_sum:\n        return False\n\n    return True\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    This function takes a square matrix (list of lists) as input and returns True if it is a magic square, otherwise False.\n    \n    Args:\n        matrix (list[list[float]]): A list of lists where each sublist represents a row of the matrix.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    # Check if the matrix is empty or not square\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False\n    \n    # Handle the edge case of a 1x1 matrix\n    if len(matrix) == 1:\n        return True\n    \n    # Convert the matrix to a numpy array for efficient operations\n    np_matrix = np.array(matrix)\n    \n    # Calculate the reference sum using the first row\n    reference_sum = np.sum(np_matrix[0, :])\n    \n    # Check sums of all rows\n    for row in np_matrix:\n        if np.sum(row) != reference_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in np_matrix.T:\n        if np.sum(col) != reference_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if np.sum(np.diag(np_matrix)) != reference_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if np.sum(np.diag(np.fliplr(np_matrix))) != reference_sum:\n        return False\n    \n    # If all checks pass, the matrix is a magic square\n    return True\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    Determines if the given matrix is a magic square.\n\n    Parameters:\n    matrix (list[list[float]]): A square matrix of numbers.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n\n    Raises:\n    ValueError: If the matrix is not square or contains non-numeric elements.\n    \"\"\"\n    # Check if all elements are integers\n    if not all(isinstance(item, int) for row in matrix for item in row):\n        raise ValueError(\"Matrix contains non-integer elements.\")\n\n    # Convert the matrix to a NumPy array for efficient operations\n    np_matrix = np.array(matrix)\n\n    # Check if the matrix is square\n    if np_matrix.shape[0] != np_matrix.shape[1]:\n        raise ValueError(\"Matrix is not square.\")\n\n    # Calculate the target sum using the first row\n    target_sum = np.sum(np_matrix[0, :])\n\n    # Check sums of all rows\n    for row in np_matrix:\n        if np.sum(row) != target_sum:\n            return False\n\n    # Check sums of all columns\n    for col in np_matrix.T:\n        if np.sum(col) != target_sum:\n            return False\n\n    # Check sums of both diagonals\n    if np.sum(np.diag(np_matrix)) != target_sum:\n        return False\n    if np.sum(np.diag(np.fliplr(np_matrix))) != target_sum:\n        return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"Check if a given square matrix is a magic square.\n\n    Args:\n        matrix: A square matrix (list of lists) where each element is a float or integer.\n\n    Returns:\n        True if the matrix is a magic square, otherwise False.\n    \"\"\"\n    # Check if the matrix is square\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n\n    # Check if all elements are numeric\n    if not all(isinstance(element, (int, float)) for row in matrix for element in row):\n        return False\n\n    # Calculate the sum of the first row to use as a reference sum\n    reference_sum = sum(matrix[0])\n\n    # Check if all rows have the same sum as the reference sum\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n\n    # Check if all columns have the same sum as the reference sum\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != reference_sum:\n            return False\n\n    # Check if the main diagonal has the same sum as the reference sum\n    if sum(matrix[i][i] for i in range(len(matrix))) != reference_sum:\n        return False\n\n    # Check if the secondary diagonal has the same sum as the reference sum\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != reference_sum:\n        return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    Determine if the given matrix is a magic square.\n\n    Parameters:\n    matrix (list[list[float]]): A 2D list representing the matrix.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    # Check for non-numeric elements\n    for row in matrix:\n        for element in row:\n            if not isinstance(element, (int, float)):\n                return False\n\n    # Calculate reference sum from the first row\n    reference_sum = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != reference_sum or sum(row[i] for row in matrix) != reference_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != reference_sum or sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != reference_sum:\n        return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    This function takes a matrix as input and returns True if it is a magic square, otherwise False.\n    \n    Args:\n        matrix: A list of lists where each sublist represents a row of the matrix.\n        \n    Returns:\n        A boolean indicating whether the matrix is a magic square.\n    \"\"\"\n    if not matrix or not all(isinstance(row, list) for row in matrix):\n        return False  # Invalid input, not a list of lists\n\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    # Calculate the sum of the first row to use as a reference sum\n    reference_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != reference_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != reference_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != reference_sum:\n        return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    Checks if the given matrix is a magic square.\n\n    Parameters:\n    matrix (list[list[float]]): A 2D list representing the matrix.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n\n    Raises:\n    ValueError: If the matrix contains non-numeric elements or is not square.\n    \"\"\"\n    # Validate the matrix is a square matrix\n    if not matrix or any(len(row) != len(matrix) for row in matrix):\n        raise ValueError(\"Input must be a square matrix\")\n    \n    # Validate all elements are numbers\n    if any(not all(isinstance(x, (int, float)) for x in row) for row in matrix):\n        raise ValueError(\"All elements must be numbers\")\n    \n    # Calculate the reference sum using the first row\n    reference_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != reference_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != reference_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != reference_sum:\n        return False\n    \n    return True\n", "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    Checks if the given matrix is a magic square.\n\n    Parameters:\n    matrix (list[list[float]]): A 2D list representing the matrix.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n\n    Raises:\n    ValueError: If the matrix is not square or contains non-numeric elements.\n    \"\"\"\n    # Check if the matrix is square\n    if not all(len(row) == len(matrix) for row in matrix):\n        raise ValueError(\"The matrix is not square.\")\n    \n    # Check if all elements are numeric\n    if not all(isinstance(item, (int, float)) for row in matrix for item in row):\n        raise ValueError(\"The matrix contains non-numeric elements.\")\n    \n    n = len(matrix)\n    \n    # Calculate the reference sum using the first row\n    reference_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != reference_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != reference_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != reference_sum:\n        return False\n    \n    return True\n"], "plans": ["requirement analysis:\nThe function must accurately determine if a matrix is a magic square by checking the sums of rows, columns, and diagonals. It should handle matrices of different sizes and types, ensuring robustness and flexibility.\nrequirement pool:\n- Accurate detection of magic squares\n- Support for varying matrix sizes\n- Handle different element types\n- Provide clear output\n- Optimize for performance\nWe will implement a function named magic_square_test that checks if a given matrix is a magic square. The function will handle matrices of varying sizes and element types by ensuring all elements are numeric. We will use the numpy library to facilitate matrix operations, which will help in efficiently calculating the sums of rows, columns, and diagonals. The function will return a boolean value indicating whether the matrix is a magic square.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'same': means that the sum of every row, column, and diagonal should be equal.\n\n# [code logic]\n    1. Check if the matrix is square (i.e., number of rows equals number of columns).\n    2. Ensure all elements in the matrix are numeric.\n    3. Calculate the sum of the first row to use as a reference sum.\n    4. Check if all rows have the same sum as the reference sum.\n    5. Check if all columns have the same sum as the reference sum.\n    6. Check if both diagonals have the same sum as the reference sum.\n    7. Return True if all conditions are met; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A 1x1 matrix is trivially a magic square since there's only one element, and all sums are equal to that element.\n\n    magic_square_test([[1, 2], [3, 4]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n\n    magic_square_test([[2, 2], [2, 2]]) = True\n    Explanation: All rows, columns, and diagonals sum to 4, so it is a magic square.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not all(isinstance(x, (int, float)) for row in matrix for x in row):\n            return False\n        if len(matrix) != len(matrix[0]):\n            return False\n        (other code)\n", "requirement analysis:\nThe function should be able to determine if a matrix is a magic square by checking the sums of rows, columns, and diagonals. It should handle different sizes and types of elements, providing feedback for invalid inputs.\nrequirement pool:\n- Implement the main function to check for magic square properties.\n- Handle different data types within the matrix gracefully.\n- Provide informative error messages for invalid inputs.\n- Optimize the function for performance with large matrices.\n- Include unit tests to ensure function reliability.\nWe will implement a function to check if a given matrix is a magic square by verifying the sums of rows, columns, and diagonals. We will use Python's built-in capabilities to handle different data types and provide informative error messages for invalid inputs. NumPy can be used for efficient matrix operations, especially for large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same. This concept is crucial for determining whether the given matrix meets the criteria of a magic square.\n\n# [phrase showing quantity relationship]\n    'sum of every row, column, and diagonal is the same': This indicates that the sum of elements in each row, each column, and both diagonals must be equal. In code, this can be implemented by calculating the sum of each row, column, and diagonal and comparing them.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the matrix is square (i.e., number of rows equals number of columns).\n    2. Calculate the sum of the first row to set as the target sum.\n    3. Verify that all rows have the same sum as the target sum.\n    4. Verify that all columns have the same sum as the target sum.\n    5. Verify that both diagonals have the same sum as the target sum.\n    6. Return True if all checks pass; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A single element matrix is trivially a magic square since all sums are equal.\n    \n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n    \n    magic_square_test([[2, 2], [2, 2]]) = True\n    Explanation: All rows, columns, and diagonals have the same sum (4), so it is a magic square.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic checks for square matrices and compares sums across rows, columns, and diagonals, which inherently handles these cases.\n", "requirement analysis:\nThe function should accurately determine if a matrix is a magic square by checking the sums of rows, columns, and diagonals. It must handle matrices of different sizes and types, ensuring robustness and flexibility.\nrequirement pool:\n- Accurate calculation of magic square status\n- Support for varying matrix sizes\n- Handle different element types within the matrix\n- Provide clear True/False output\n- Optimize performance for large matrices\nWe will implement a function called magic_square_test that checks if a given square matrix is a magic square. The function will handle matrices of varying sizes and element types by ensuring all elements are numeric. We will use Python's built-in capabilities to iterate over the matrix and calculate the sums of rows, columns, and diagonals. The function will return True if all these sums are equal, otherwise False. We will ensure the function is robust and flexible to handle different matrix sizes and types.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same. This means that for a matrix to be considered a magic square, all these sums must be equal.\n\n# [phrase showing quantity relationship]\n    'sum of every row, column, and diagonal is the same': This indicates that the sum of elements in each row, each column, and both main diagonals must be equal. In code, this can be implemented by calculating these sums and comparing them.\n\n# [degree adverb] \n    'same': This means that all calculated sums (rows, columns, diagonals) must be equal to each other.\n\n# [code logic]\n    1. Check if the matrix is square (i.e., number of rows equals number of columns).\n    2. Calculate the sum of the first row to use as a reference sum.\n    3. Iterate through each row and column to ensure their sums match the reference sum.\n    4. Calculate the sums of both main diagonals and ensure they match the reference sum.\n    5. Return True if all sums are equal; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A 1x1 matrix is trivially a magic square since there's only one element, so all sums are equal.\n\n    magic_square_test([[1, 2], [3, 4]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n\n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) = True\n    Explanation: This is a classic 3x3 magic square where all rows, columns, and diagonals sum to 15.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def magic_square_test(matrix):\n        # Check if matrix is square\n        if not matrix or any(len(row) != len(matrix) for row in matrix):\n            return False\n        \n        n = len(matrix)\n        # Calculate the reference sum using the first row\n        ref_sum = sum(matrix[0])\n        \n        # Check rows and columns\n        for i in range(n):\n            if sum(matrix[i]) != ref_sum or sum(row[i] for row in matrix) != ref_sum:\n                return False\n        \n        # Check diagonals\n        if sum(matrix[i][i] for i in range(n)) != ref_sum or sum(matrix[i][n-i-1] for i in range(n)) != ref_sum:\n            return False\n        \n        return True\n    ```\n", "requirement analysis:\nThe function needs to accurately determine if a matrix is a magic square by checking the sum of rows, columns, and diagonals. It should handle matrices of varying sizes and element types, ensuring performance optimization for larger matrices.\nrequirement pool:\n- Accurate detection of magic squares\n- Graceful handling of varying matrix sizes and element types\n- Performance optimization for large matrices\n- User-friendly interface for input and output\n- Documentation and examples for user guidance\nWe will implement a function called magic_square_test that checks if a given matrix is a magic square. The function will handle matrices of varying sizes and element types, such as integers and floats. We will use the numpy library to efficiently handle matrix operations, which will help optimize performance for larger matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'same': means that the sum of every row, column, and diagonal should be equal.\n\n# [code logic]\n    1. Check if the matrix is square (i.e., the number of rows equals the number of columns).\n    2. Calculate the sum of the first row to use as the reference sum.\n    3. Iterate through each row and check if its sum matches the reference sum.\n    4. Iterate through each column and check if its sum matches the reference sum.\n    5. Calculate the sums of both diagonals and check if they match the reference sum.\n    6. If all checks pass, return True; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A 1x1 matrix is trivially a magic square since there's only one element, and all sums are equal to that element.\n\n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n\n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) = True\n    Explanation: This is a classic 3x3 magic square where all rows, columns, and diagonals sum to 15.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not matrix or len(matrix) != len(matrix[0]):\n            return False\n        if len(matrix) == 1:\n            return True\n        (other code)\n", "requirement analysis:\nThe function should determine if a matrix is a magic square by checking the sums of rows, columns, and diagonals. It should handle different data types and provide feedback for invalid inputs.\nrequirement pool:\n- The function must correctly identify magic squares of any size.\n- The function should handle non-integer elements gracefully.\n- The function should provide informative error messages for invalid inputs.\n- Optimize the function for performance with large matrices.\n- Ensure compatibility with various Python versions.\nWe will implement a function that checks if a given matrix is a magic square by verifying the sums of rows, columns, and diagonals. We will use NumPy for efficient matrix operations, which will help optimize performance for large matrices. The function will handle non-integer elements by returning an error message, as these elements cannot be part of a valid magic square.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same. This property must hold for the matrix to be considered a magic square.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the matrix is square (i.e., the number of rows equals the number of columns).\n    2. Calculate the sum of the first row to use as the target sum.\n    3. Verify that each row's sum equals the target sum.\n    4. Verify that each column's sum equals the target sum.\n    5. Verify that both diagonals' sums equal the target sum.\n    6. Return True if all checks pass; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A single element matrix is trivially a magic square since all sums (row, column, diagonal) are equal to the element itself.\n    \n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n    \n    magic_square_test([[2, 2], [2, 2]]) = True\n    Explanation: All rows, columns, and diagonals have the same sum (4), so it is a magic square.\n\n# [extra code for edge case]\n    We need extra code to handle non-integer elements gracefully.\n        if not all(isinstance(item, int) for row in matrix for item in row):\n            raise ValueError(\"Matrix contains non-integer elements.\")\n        (other code)\n", "requirement analysis:\nThe function should accurately determine if a given matrix is a magic square by checking the sum of rows, columns, and diagonals. It should handle matrices of varying sizes and element types, providing a boolean output.\nrequirement pool:\n- Accurate calculation of magic square properties\n- Support for varying matrix sizes\n- Graceful handling of different element types\n- Clear output format\n- Optimization for large matrices\nWe will implement a function named magic_square_test that checks if a given square matrix is a magic square. The function will handle matrices of varying sizes and element types by ensuring all elements are numeric. We will use Python's built-in capabilities to iterate over the matrix and calculate the sums of rows, columns, and diagonals. The function will return a boolean value indicating whether the matrix is a magic square.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same. This property must hold for the matrix to be considered a magic square.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    'same': means that the sum of every row, column, and diagonal must be equal.\n\n# [code logic]\n    1. Verify that the input is a square matrix (i.e., the number of rows equals the number of columns).\n    2. Ensure all elements in the matrix are numeric.\n    3. Calculate the sum of the first row to use as a reference sum.\n    4. Check if all rows have the same sum as the reference sum.\n    5. Check if all columns have the same sum as the reference sum.\n    6. Check if both diagonals have the same sum as the reference sum.\n    7. Return True if all conditions are met; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A 1x1 matrix is trivially a magic square since there is only one element, and thus all sums are equal.\n    \n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n    \n    magic_square_test([[2, 2], [2, 2]]) = True\n    Explanation: All rows, columns, and diagonals sum to 4, so it is a magic square.\n\n# [extra code for edge case]\n    We need extra code to handle non-square matrices and non-numeric elements.\n        if not all(len(row) == len(matrix) for row in matrix):\n            return False\n        if not all(isinstance(element, (int, float)) for row in matrix for element in row):\n            return False\n        (other code)\n", "requirement analysis:\nThe function should accurately determine if a matrix is a magic square by checking the sums of rows, columns, and diagonals. It must handle matrices of different sizes and element types, ensuring robustness and flexibility.\nrequirement pool:\n- Accurate calculation of magic square properties\n- Support for varying matrix sizes\n- Graceful handling of different element types\n- Clear output indicating magic square status\n- Performance optimization for large matrices\nWe will implement a function named `magic_square_test` that checks if a given matrix is a magic square. The function will calculate the sum of each row, column, and both diagonals, and compare these sums to determine if they are equal. We will handle matrices of varying sizes and ensure the function can gracefully handle different element types by checking if all elements are numeric. If non-numeric elements are present, the function will return False. We will use Python's built-in capabilities without additional libraries to keep the solution simple and efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix in which the sum of every row, column, and both diagonals is the same. It is a concept from mathematics often used in puzzles and recreational mathematics.\n\n# [phrase showing quantity relationship]\n    'sum of every row, column, and diagonal is the same': This indicates that the sum of elements in each row, each column, and both diagonals should be equal. In code, this can be implemented by calculating the sum of each row, column, and diagonal and comparing them.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if all elements in the matrix are numeric. If not, return False.\n    2. Calculate the sum of the first row to use as a reference sum.\n    3. Iterate through each row and column to ensure their sums match the reference sum.\n    4. Calculate the sums of both diagonals and ensure they match the reference sum.\n    5. Return True if all sums are equal; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A single element matrix is trivially a magic square since all sums (row, column, diagonal) are equal to the element itself.\n    \n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows and columns are equal (3), but the diagonals do not match (3 vs 2), so it is not a magic square.\n    \n    magic_square_test([[1, 'a'], [2, 1]]) = False\n    Explanation: The matrix contains non-numeric elements ('a'), so it cannot be a magic square.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving non-numeric elements.\n        def magic_square_test(matrix):\n            # Check for non-numeric elements\n            for row in matrix:\n                for element in row:\n                    if not isinstance(element, (int, float)):\n                        return False\n            \n            # Calculate reference sum from the first row\n            reference_sum = sum(matrix[0])\n            \n            # Check rows and columns\n            for i in range(len(matrix)):\n                if sum(matrix[i]) != reference_sum or sum(row[i] for row in matrix) != reference_sum:\n                    return False\n            \n            # Check diagonals\n            if sum(matrix[i][i] for i in range(len(matrix))) != reference_sum or sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != reference_sum:\n                return False\n            \n            return True\n", "requirement analysis:\nThe function needs to accurately determine if a matrix is a magic square by checking the sums of rows, columns, and diagonals. It should handle matrices of different sizes and element types, providing clear feedback on the result.\nrequirement pool:\n- Accurate magic square validation\n- Support for varying matrix sizes\n- Graceful handling of different element types\n- User-friendly feedback\n- Efficient processing\nWe will implement a function that checks if a given matrix is a magic square by verifying that the sums of all rows, columns, and diagonals are equal. We will use Python's built-in capabilities to handle different element types and matrix sizes gracefully. The function will provide clear feedback on whether the matrix is a magic square or not.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix in which the sum of every row, column, and diagonal is the same. The concept is important because it defines the condition that must be met for the matrix to be considered a magic square.\n\n# [phrase showing quantity relationship]\n    'sum of every row, column, and diagonal is the same': This indicates that the sum of elements in each row, each column, and both diagonals must be equal. In code, this can be implemented by calculating the sum of each row, column, and diagonal and comparing them.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Calculate the sum of the first row to use as a reference sum.\n    2. Iterate through each row and check if its sum matches the reference sum.\n    3. Iterate through each column and check if its sum matches the reference sum.\n    4. Calculate the sum of both diagonals and check if they match the reference sum.\n    5. Return True if all sums match; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A single-element matrix is trivially a magic square because all sums (row, column, diagonal) are equal to the element itself.\n    \n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal (row sums: 3, column sums: 3, diagonal sums: 2), so it is not a magic square.\n    \n    magic_square_test([[2, 2], [2, 2]]) = True\n    Explanation: All rows, columns, and diagonals have the same sum (4), so it is a magic square.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking sums for rows, columns, and diagonals will naturally handle these cases.\n", "requirement analysis:\nThe function should be able to handle matrices of any size and type, ensuring that the sum of rows, columns, and diagonals are equal. It should also provide meaningful feedback for invalid inputs and be optimized for performance.\nrequirement pool:\n- The function must correctly identify magic squares of any size.\n- The function should handle different data types gracefully.\n- Provide clear error messages for invalid inputs.\n- Optimize the function for performance with large matrices.\n- Ensure the function is easy to use and integrate.\nWe will implement a function that checks if a given matrix is a magic square by verifying that the sum of each row, column, and both diagonals are equal. We will use Python's built-in capabilities to handle different data types and provide clear error messages for invalid inputs. The function will be optimized for performance by minimizing redundant calculations and using efficient data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix in which the sum of every row, column, and both diagonals is the same.\n\n# [phrase showing quantity relationship]\n    'sum of every row, column, and diagonal is the same': This means that for the matrix to be a magic square, the sum of the elements in each row, each column, and both main diagonals must be equal.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the input is a valid square matrix (i.e., all rows have the same length as the number of rows).\n    2. Calculate the sum of the first row to use as a reference sum.\n    3. Iterate through each row and check if its sum matches the reference sum.\n    4. Iterate through each column and check if its sum matches the reference sum.\n    5. Calculate the sum of the main diagonal and check if it matches the reference sum.\n    6. Calculate the sum of the secondary diagonal and check if it matches the reference sum.\n    7. If all sums match, return True; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A 1x1 matrix is trivially a magic square since there is only one element, and all sums are equal to that element.\n    \n    magic_square_test([[1, 2], [2, 1]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it is not a magic square.\n    \n    magic_square_test([[2, 2], [2, 2]]) = True\n    Explanation: All rows, columns, and diagonals have the same sum (4), so it is a magic square.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the input is not a valid square matrix or contains non-numeric elements.\n        if not matrix or any(len(row) != len(matrix) for row in matrix):\n            raise ValueError(\"Input must be a square matrix\")\n        if any(not all(isinstance(x, (int, float)) for x in row) for row in matrix):\n            raise ValueError(\"All elements must be numbers\")\n        (other code)\n", "requirement analysis:\nThe function should determine if a matrix is a magic square by checking the sum of rows, columns, and diagonals. It should handle different sizes and types of elements, providing feedback for invalid inputs.\nrequirement pool:\n- Implement the main logic to check if a matrix is a magic square.\n- Handle matrices of varying sizes and element types.\n- Provide informative error messages for invalid inputs.\n- Optimize the function for performance with large matrices.\n- Include unit tests to ensure the function works as expected.\nWe will implement a function that checks if a given matrix is a magic square by verifying the sum of rows, columns, and diagonals. We will use Python's built-in capabilities to handle different data types and sizes. The function will provide informative error messages for invalid inputs, such as non-square matrices or matrices with non-numeric elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'magic square'\n    Explanation: A magic square is a square matrix where the sum of every row, column, and diagonal is the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the matrix is square (i.e., the number of rows equals the number of columns).\n    2. Calculate the sum of the first row to use as a reference sum.\n    3. Verify that each row's sum matches the reference sum.\n    4. Verify that each column's sum matches the reference sum.\n    5. Verify that both diagonals' sums match the reference sum.\n    6. Return True if all checks pass; otherwise, return False.\n\n# [edge case] \n    magic_square_test([[1]]) = True\n    Explanation: A 1x1 matrix is trivially a magic square since there's only one element.\n    \n    magic_square_test([[1, 2], [3, 4]]) = False\n    Explanation: The sums of rows, columns, and diagonals are not equal, so it's not a magic square.\n    \n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) = True\n    Explanation: This is a classic 3x3 magic square where all rows, columns, and diagonals sum to 15.\n\n# [extra code for edge case]\n    We need extra code to handle non-square matrices and matrices with non-numeric elements.\n        if not all(len(row) == len(matrix) for row in matrix):\n            raise ValueError(\"The matrix is not square.\")\n        if not all(isinstance(item, (int, float)) for row in matrix for item in row):\n            raise ValueError(\"The matrix contains non-numeric elements.\")\n        (other code)\n"], "test": ["def check(magic_square_test):\n\tassert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True", "def check(magic_square_test):\n\tassert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True", "def check(magic_square_test):\n\tassert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False", "def check(magic_square_test):\n\tassert magic_square_test([[8, 9, 3, 14], [7, 10, 9, 11], [16, 6, 13, 6], [9, 11, 17, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[9, 10, 6, 17], [5, 8, 4, 11], [13, 1, 5, 9], [11, 10, 17, 8]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 8, 3, 9], [3, 16, 5, 7], [12, 7, 5, 2], [12, 11, 12, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 12, 6, 10], [7, 10, 4, 9], [20, 8, 9, 8], [14, 8, 16, 3]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 10, 1, 13], [4, 12, 3, 6], [18, 7, 5, 1], [4, 2, 15, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 17, 3, 9], [7, 9, 11, 8], [19, 1, 11, 1], [10, 9, 15, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[11, 7, 2, 16], [7, 18, 4, 12], [16, 7, 13, 6], [10, 1, 18, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[8, 7, 5, 15], [7, 13, 6, 8], [20, 2, 11, 9], [13, 6, 15, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[10, 8, 3, 10], [1, 9, 7, 13], [16, 7, 14, 4], [7, 10, 18, 1]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 17, 1, 10], [4, 15, 5, 11], [15, 6, 5, 7], [5, 1, 14, 8]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 13, 5, 14], [5, 15, 11, 14], [12, 4, 15, 2], [13, 9, 13, 5]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 14, 5, 9], [1, 11, 9, 14], [13, 5, 14, 8], [11, 7, 13, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 9, 2, 16], [7, 15, 4, 11], [21, 2, 13, 4], [10, 9, 20, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 11, 2, 16], [6, 10, 9, 8], [15, 4, 12, 6], [14, 10, 18, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[9, 8, 3, 12], [6, 14, 5, 7], [13, 3, 6, 10], [12, 11, 15, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 10, 4, 17], [1, 14, 3, 12], [17, 6, 13, 1], [4, 8, 12, 8]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[9, 7, 6, 9], [6, 10, 8, 10], [19, 3, 5, 1], [8, 7, 18, 5]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 13, 1, 12], [6, 16, 7, 10], [18, 4, 8, 5], [8, 5, 16, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[8, 12, 3, 13], [4, 13, 13, 8], [17, 7, 15, 9], [14, 5, 14, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[10, 9, 2, 18], [7, 9, 13, 13], [18, 7, 9, 4], [5, 9, 14, 8]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 8, 5, 16], [6, 14, 9, 15], [20, 2, 13, 5], [7, 4, 18, 1]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 14, 6, 9], [7, 14, 13, 8], [11, 6, 9, 5], [10, 3, 10, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 15, 5, 9], [2, 17, 7, 8], [21, 8, 8, 1], [10, 11, 15, 8]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[9, 14, 5, 19], [4, 15, 11, 16], [19, 6, 13, 7], [9, 7, 10, 1]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 11, 6, 15], [6, 16, 5, 13], [19, 8, 11, 1], [13, 10, 11, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[10, 11, 5, 11], [3, 18, 10, 15], [18, 6, 5, 3], [12, 5, 18, 3]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 11, 4, 17], [2, 15, 4, 11], [17, 5, 5, 3], [8, 2, 20, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 16, 4, 15], [2, 15, 11, 8], [20, 6, 14, 3], [14, 3, 20, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[8, 11, 3, 11], [2, 12, 9, 7], [21, 5, 9, 10], [14, 7, 11, 1]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 17, 4, 14], [6, 9, 4, 16], [15, 5, 14, 5], [13, 3, 10, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[11, 14, 2, 17], [5, 17, 4, 10], [14, 1, 8, 6], [4, 7, 14, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 16, 2, 10], [2, 17, 6, 13], [12, 5, 10, 5], [7, 1, 15, 1]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[12, 7, 4, 14], [7, 18, 5, 9], [17, 4, 12, 1], [10, 7, 17, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 2, 4], [5, 9, 5], [8, 2, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 10, 8], [14, 9, 6], [1, 1, 13]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 2, 3], [4, 1, 1], [7, 2, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 10, 11], [7, 5, 3], [5, 1, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 7, 1], [12, 5, 3], [1, 7, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 11, 4], [8, 1, 2], [9, 8, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 3, 8], [4, 5, 6], [4, 4, 10]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 2, 11], [10, 4, 1], [3, 6, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 7, 9], [5, 5, 6], [6, 2, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 3, 7], [5, 1, 5], [6, 3, 8]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 11, 3], [11, 10, 3], [5, 8, 3]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 9, 4], [8, 8, 4], [2, 8, 10]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 11, 3], [9, 8, 3], [9, 5, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 8, 3], [7, 10, 4], [3, 2, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 9, 11], [13, 1, 3], [6, 3, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 4, 2], [13, 2, 2], [6, 1, 12]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 2, 7], [13, 10, 3], [3, 6, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 2, 9], [10, 8, 5], [2, 8, 13]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 8, 4], [14, 10, 3], [2, 1, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 10, 10], [5, 6, 5], [1, 2, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 3, 2], [6, 5, 4], [6, 1, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 3, 2], [11, 2, 6], [2, 7, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 8, 2], [6, 8, 5], [6, 6, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 7, 4], [9, 2, 3], [5, 8, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 8, 7], [4, 3, 4], [3, 1, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 6, 5], [5, 3, 3], [5, 2, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 5, 4], [6, 7, 1], [7, 1, 5]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 7, 2], [10, 4, 6], [6, 4, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 12, 5], [7, 3, 1], [7, 3, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 10, 1], [13, 4, 6], [4, 7, 12]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 7, 9], [7, 2, 2], [7, 5, 12]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 10, 3], [5, 2, 2], [7, 6, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 5, 7], [6, 6, 2], [2, 1, 13]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 9, 3], [8, 8, 2], [7, 6, 3]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 2, 10], [10, 6, 4], [3, 4, 3]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 6, 10], [11, 4, 6], [3, 6, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 11, 5], [5, 6, 2], [8, 4, 10]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 5, 4], [12, 10, 1], [1, 3, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 7, 11], [7, 6, 5], [3, 8, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 10, 11], [10, 5, 4], [2, 4, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 5, 3], [4, 6, 1], [7, 1, 10]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 7, 4], [4, 8, 4], [7, 3, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 2, 11], [12, 7, 4], [7, 2, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 7, 6], [7, 2, 2], [6, 7, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 8, 8], [7, 8, 3], [8, 3, 6]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 6, 2], [13, 9, 4], [6, 4, 4]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 11, 6], [8, 8, 4], [8, 7, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 11, 2], [14, 5, 2], [7, 5, 5]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 12, 11], [13, 9, 2], [2, 8, 12]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 7, 1], [9, 7, 6], [4, 2, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 3, 9], [14, 8, 5], [6, 1, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 6, 7], [14, 5, 6], [8, 8, 5]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 8, 2], [9, 7, 3], [4, 8, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 2, 6], [4, 3, 2], [9, 8, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 10, 9], [11, 9, 3], [1, 3, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 5, 7], [5, 6, 2], [8, 2, 5]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[6, 8, 5], [10, 5, 3], [7, 6, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 7, 11], [13, 8, 6], [8, 6, 3]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 5, 3], [11, 7, 5], [9, 1, 7]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 7, 1], [7, 9, 1], [2, 1, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[3, 7, 9], [13, 4, 3], [1, 3, 11]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[5, 4, 9], [12, 4, 1], [4, 4, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[1, 4, 7], [9, 1, 3], [1, 8, 10]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[2, 11, 2], [11, 4, 4], [3, 5, 2]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[4, 2, 1], [14, 1, 3], [3, 4, 9]]) == False", "def check(magic_square_test):\n\tassert magic_square_test([[7, 4, 8], [8, 2, 3], [1, 7, 11]]) == False"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef magic_square_test(matrix: list[list[float]]) -> bool:\n    \"\"\"\n    Checks if the given matrix is a magic square.\n\n    Parameters:\n    matrix (list[list[float]]): A 2D list representing the matrix.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n\n    Raises:\n    ValueError: If the matrix is not square or contains non-numeric elements.\n    \"\"\"\n    # Check if the matrix is square\n    if not all(len(row) == len(matrix) for row in matrix):\n        raise ValueError(\"The matrix is not square.\")\n    \n    # Check if all elements are numeric\n    if not all(isinstance(item, (int, float)) for row in matrix for item in row):\n        raise ValueError(\"The matrix contains non-numeric elements.\")\n    \n    n = len(matrix)\n    \n    # Calculate the reference sum using the first row\n    reference_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != reference_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != reference_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != reference_sum:\n        return False\n    \n    return True\n", "passed": true, "pass": true, "pass_num": 10, "round": 387, "mutate_method": "add_1_sentence_at_end", "parent_index": 314}
