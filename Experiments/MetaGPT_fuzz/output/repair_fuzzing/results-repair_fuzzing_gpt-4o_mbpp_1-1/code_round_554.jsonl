{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 766, "prompt": "Write a function to return a list of all pairs of consecutive items in a given list.", "code": "def pair_wise(l1):\n    temp = []\n    for i in range(len(l1) - 1):\n        current_element, next_element = l1[i], l1[i + 1]\n        x = (current_element, next_element)\n        temp.append(x)\n    return temp", "test_imports": [], "test_list": ["assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]", "assert pair_wise([1,5,7,9,10])==[(1, 5), (5, 7), (7, 9), (9, 10)]", "assert pair_wise([1,2,3,4,5,6,7,8,9,10])==[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]", "assert pair_wise([1, 2, 5, 6, 5, 9, 9, 3]) == [(1, 2), (2, 5), (5, 6), (6, 5), (5, 9), (9, 9), (9, 3)]", "assert pair_wise([1, 3, 4, 3, 1, 7, 9, 7]) == [(1, 3), (3, 4), (4, 3), (3, 1), (1, 7), (7, 9), (9, 7)]", "assert pair_wise([6, 4, 4, 1, 3, 2, 2, 5]) == [(6, 4), (4, 4), (4, 1), (1, 3), (3, 2), (2, 2), (2, 5)]", "assert pair_wise([5, 1, 1, 1, 2, 5, 2, 8]) == [(5, 1), (1, 1), (1, 1), (1, 2), (2, 5), (5, 2), (2, 8)]", "assert pair_wise([5, 5, 1, 7, 1, 5, 4, 1]) == [(5, 5), (5, 1), (1, 7), (7, 1), (1, 5), (5, 4), (4, 1)]", "assert pair_wise([6, 4, 3, 3, 6, 8, 1, 3]) == [(6, 4), (4, 3), (3, 3), (3, 6), (6, 8), (8, 1), (1, 3)]", "assert pair_wise([5, 2, 1, 5, 2, 5, 6, 4]) == [(5, 2), (2, 1), (1, 5), (5, 2), (2, 5), (5, 6), (6, 4)]", "assert pair_wise([3, 5, 3, 4, 7, 4, 4, 7]) == [(3, 5), (5, 3), (3, 4), (4, 7), (7, 4), (4, 4), (4, 7)]", "assert pair_wise([6, 6, 1, 4, 3, 4, 3, 10]) == [(6, 6), (6, 1), (1, 4), (4, 3), (3, 4), (4, 3), (3, 10)]", "assert pair_wise([6, 3, 4, 6, 4, 9, 8, 10]) == [(6, 3), (3, 4), (4, 6), (6, 4), (4, 9), (9, 8), (8, 10)]", "assert pair_wise([6, 1, 4, 4, 2, 8, 2, 3]) == [(6, 1), (1, 4), (4, 4), (4, 2), (2, 8), (8, 2), (2, 3)]", "assert pair_wise([2, 3, 1, 3, 8, 2, 5, 10]) == [(2, 3), (3, 1), (1, 3), (3, 8), (8, 2), (2, 5), (5, 10)]", "assert pair_wise([3, 5, 7, 4, 5, 3, 7, 5]) == [(3, 5), (5, 7), (7, 4), (4, 5), (5, 3), (3, 7), (7, 5)]", "assert pair_wise([2, 6, 2, 7, 7, 5, 1, 10]) == [(2, 6), (6, 2), (2, 7), (7, 7), (7, 5), (5, 1), (1, 10)]", "assert pair_wise([1, 3, 7, 6, 5, 4, 8, 7]) == [(1, 3), (3, 7), (7, 6), (6, 5), (5, 4), (4, 8), (8, 7)]", "assert pair_wise([4, 6, 4, 7, 6, 4, 4, 8]) == [(4, 6), (6, 4), (4, 7), (7, 6), (6, 4), (4, 4), (4, 8)]", "assert pair_wise([2, 4, 2, 5, 5, 1, 6, 8]) == [(2, 4), (4, 2), (2, 5), (5, 5), (5, 1), (1, 6), (6, 8)]", "assert pair_wise([2, 4, 3, 7, 1, 1, 9, 4]) == [(2, 4), (4, 3), (3, 7), (7, 1), (1, 1), (1, 9), (9, 4)]", "assert pair_wise([3, 1, 2, 3, 1, 4, 6, 8]) == [(3, 1), (1, 2), (2, 3), (3, 1), (1, 4), (4, 6), (6, 8)]", "assert pair_wise([5, 6, 3, 2, 2, 4, 5, 8]) == [(5, 6), (6, 3), (3, 2), (2, 2), (2, 4), (4, 5), (5, 8)]", "assert pair_wise([3, 3, 1, 3, 1, 7, 8, 6]) == [(3, 3), (3, 1), (1, 3), (3, 1), (1, 7), (7, 8), (8, 6)]", "assert pair_wise([4, 4, 6, 5, 4, 1, 9, 10]) == [(4, 4), (4, 6), (6, 5), (5, 4), (4, 1), (1, 9), (9, 10)]", "assert pair_wise([6, 2, 2, 6, 8, 6, 1, 8]) == [(6, 2), (2, 2), (2, 6), (6, 8), (8, 6), (6, 1), (1, 8)]", "assert pair_wise([1, 5, 4, 6, 7, 2, 4, 6]) == [(1, 5), (5, 4), (4, 6), (6, 7), (7, 2), (2, 4), (4, 6)]", "assert pair_wise([5, 5, 1, 6, 8, 2, 1, 10]) == [(5, 5), (5, 1), (1, 6), (6, 8), (8, 2), (2, 1), (1, 10)]", "assert pair_wise([3, 2, 5, 1, 1, 5, 8, 7]) == [(3, 2), (2, 5), (5, 1), (1, 1), (1, 5), (5, 8), (8, 7)]", "assert pair_wise([6, 1, 7, 3, 8, 6, 6, 3]) == [(6, 1), (1, 7), (7, 3), (3, 8), (8, 6), (6, 6), (6, 3)]", "assert pair_wise([1, 5, 3, 6, 2, 5, 9, 6]) == [(1, 5), (5, 3), (3, 6), (6, 2), (2, 5), (5, 9), (9, 6)]", "assert pair_wise([4, 6, 6, 3, 5, 9, 2, 7]) == [(4, 6), (6, 6), (6, 3), (3, 5), (5, 9), (9, 2), (2, 7)]", "assert pair_wise([3, 1, 6, 7, 4, 1, 3, 10]) == [(3, 1), (1, 6), (6, 7), (7, 4), (4, 1), (1, 3), (3, 10)]", "assert pair_wise([4, 1, 1, 8, 1, 2, 6, 7]) == [(4, 1), (1, 1), (1, 8), (8, 1), (1, 2), (2, 6), (6, 7)]", "assert pair_wise([2, 4, 2, 8, 2, 8, 9, 5]) == [(2, 4), (4, 2), (2, 8), (8, 2), (2, 8), (8, 9), (9, 5)]", "assert pair_wise([6, 4, 6, 4, 1, 9, 2, 4]) == [(6, 4), (4, 6), (6, 4), (4, 1), (1, 9), (9, 2), (2, 4)]", "assert pair_wise([1, 2, 3, 7, 12]) == [(1, 2), (2, 3), (3, 7), (7, 12)]", "assert pair_wise([1, 5, 6, 14, 15]) == [(1, 5), (5, 6), (6, 14), (14, 15)]", "assert pair_wise([6, 9, 6, 14, 10]) == [(6, 9), (9, 6), (6, 14), (14, 10)]", "assert pair_wise([6, 4, 11, 8, 14]) == [(6, 4), (4, 11), (11, 8), (8, 14)]", "assert pair_wise([3, 8, 12, 5, 9]) == [(3, 8), (8, 12), (12, 5), (5, 9)]", "assert pair_wise([1, 6, 11, 10, 10]) == [(1, 6), (6, 11), (11, 10), (10, 10)]", "assert pair_wise([6, 9, 12, 4, 10]) == [(6, 9), (9, 12), (12, 4), (4, 10)]", "assert pair_wise([6, 1, 3, 14, 9]) == [(6, 1), (1, 3), (3, 14), (14, 9)]", "assert pair_wise([3, 5, 3, 8, 13]) == [(3, 5), (5, 3), (3, 8), (8, 13)]", "assert pair_wise([4, 3, 5, 6, 7]) == [(4, 3), (3, 5), (5, 6), (6, 7)]", "assert pair_wise([2, 4, 12, 6, 5]) == [(2, 4), (4, 12), (12, 6), (6, 5)]", "assert pair_wise([6, 5, 12, 14, 15]) == [(6, 5), (5, 12), (12, 14), (14, 15)]", "assert pair_wise([6, 8, 10, 4, 15]) == [(6, 8), (8, 10), (10, 4), (4, 15)]", "assert pair_wise([3, 1, 11, 9, 7]) == [(3, 1), (1, 11), (11, 9), (9, 7)]", "assert pair_wise([2, 7, 3, 8, 15]) == [(2, 7), (7, 3), (3, 8), (8, 15)]", "assert pair_wise([3, 3, 10, 8, 8]) == [(3, 3), (3, 10), (10, 8), (8, 8)]", "assert pair_wise([1, 7, 10, 7, 11]) == [(1, 7), (7, 10), (10, 7), (7, 11)]", "assert pair_wise([2, 8, 4, 6, 6]) == [(2, 8), (8, 4), (4, 6), (6, 6)]", "assert pair_wise([5, 8, 8, 13, 7]) == [(5, 8), (8, 8), (8, 13), (13, 7)]", "assert pair_wise([3, 9, 2, 13, 15]) == [(3, 9), (9, 2), (2, 13), (13, 15)]", "assert pair_wise([3, 2, 10, 13, 11]) == [(3, 2), (2, 10), (10, 13), (13, 11)]", "assert pair_wise([2, 7, 2, 7, 11]) == [(2, 7), (7, 2), (2, 7), (7, 11)]", "assert pair_wise([2, 2, 4, 4, 12]) == [(2, 2), (2, 4), (4, 4), (4, 12)]", "assert pair_wise([1, 3, 10, 13, 6]) == [(1, 3), (3, 10), (10, 13), (13, 6)]", "assert pair_wise([5, 3, 12, 12, 5]) == [(5, 3), (3, 12), (12, 12), (12, 5)]", "assert pair_wise([6, 10, 4, 14, 10]) == [(6, 10), (10, 4), (4, 14), (14, 10)]", "assert pair_wise([1, 9, 3, 10, 5]) == [(1, 9), (9, 3), (3, 10), (10, 5)]", "assert pair_wise([4, 2, 7, 10, 11]) == [(4, 2), (2, 7), (7, 10), (10, 11)]", "assert pair_wise([2, 1, 12, 12, 11]) == [(2, 1), (1, 12), (12, 12), (12, 11)]", "assert pair_wise([4, 4, 12, 14, 11]) == [(4, 4), (4, 12), (12, 14), (14, 11)]", "assert pair_wise([6, 8, 4, 9, 12]) == [(6, 8), (8, 4), (4, 9), (9, 12)]", "assert pair_wise([4, 3, 8, 8, 6]) == [(4, 3), (3, 8), (8, 8), (8, 6)]", "assert pair_wise([3, 9, 2, 7, 8]) == [(3, 9), (9, 2), (2, 7), (7, 8)]", "assert pair_wise([5, 3, 7, 5, 4, 3, 3, 4, 10, 12]) == [(5, 3), (3, 7), (7, 5), (5, 4), (4, 3), (3, 3), (3, 4), (4, 10), (10, 12)]", "assert pair_wise([4, 5, 1, 9, 2, 11, 7, 12, 11, 15]) == [(4, 5), (5, 1), (1, 9), (9, 2), (2, 11), (11, 7), (7, 12), (12, 11), (11, 15)]", "assert pair_wise([2, 4, 2, 9, 9, 4, 12, 7, 10, 15]) == [(2, 4), (4, 2), (2, 9), (9, 9), (9, 4), (4, 12), (12, 7), (7, 10), (10, 15)]", "assert pair_wise([3, 2, 8, 6, 7, 10, 6, 12, 9, 13]) == [(3, 2), (2, 8), (8, 6), (6, 7), (7, 10), (10, 6), (6, 12), (12, 9), (9, 13)]", "assert pair_wise([6, 5, 3, 4, 2, 7, 8, 6, 7, 14]) == [(6, 5), (5, 3), (3, 4), (4, 2), (2, 7), (7, 8), (8, 6), (6, 7), (7, 14)]", "assert pair_wise([2, 4, 3, 7, 4, 9, 11, 3, 10, 7]) == [(2, 4), (4, 3), (3, 7), (7, 4), (4, 9), (9, 11), (11, 3), (3, 10), (10, 7)]", "assert pair_wise([2, 4, 4, 6, 6, 7, 2, 12, 8, 12]) == [(2, 4), (4, 4), (4, 6), (6, 6), (6, 7), (7, 2), (2, 12), (12, 8), (8, 12)]", "assert pair_wise([3, 1, 2, 7, 2, 10, 7, 10, 12, 13]) == [(3, 1), (1, 2), (2, 7), (7, 2), (2, 10), (10, 7), (7, 10), (10, 12), (12, 13)]", "assert pair_wise([4, 1, 5, 1, 2, 7, 4, 12, 4, 9]) == [(4, 1), (1, 5), (5, 1), (1, 2), (2, 7), (7, 4), (4, 12), (12, 4), (4, 9)]", "assert pair_wise([5, 6, 8, 6, 2, 2, 5, 13, 13, 10]) == [(5, 6), (6, 8), (8, 6), (6, 2), (2, 2), (2, 5), (5, 13), (13, 13), (13, 10)]", "assert pair_wise([1, 2, 4, 9, 3, 5, 6, 6, 5, 9]) == [(1, 2), (2, 4), (4, 9), (9, 3), (3, 5), (5, 6), (6, 6), (6, 5), (5, 9)]", "assert pair_wise([1, 3, 2, 2, 5, 3, 10, 11, 12, 10]) == [(1, 3), (3, 2), (2, 2), (2, 5), (5, 3), (3, 10), (10, 11), (11, 12), (12, 10)]", "assert pair_wise([4, 2, 8, 5, 10, 10, 11, 7, 9, 15]) == [(4, 2), (2, 8), (8, 5), (5, 10), (10, 10), (10, 11), (11, 7), (7, 9), (9, 15)]", "assert pair_wise([6, 3, 2, 6, 9, 6, 2, 5, 7, 8]) == [(6, 3), (3, 2), (2, 6), (6, 9), (9, 6), (6, 2), (2, 5), (5, 7), (7, 8)]", "assert pair_wise([3, 3, 4, 2, 7, 10, 12, 10, 7, 11]) == [(3, 3), (3, 4), (4, 2), (2, 7), (7, 10), (10, 12), (12, 10), (10, 7), (7, 11)]", "assert pair_wise([3, 4, 4, 5, 9, 4, 12, 12, 4, 15]) == [(3, 4), (4, 4), (4, 5), (5, 9), (9, 4), (4, 12), (12, 12), (12, 4), (4, 15)]", "assert pair_wise([5, 7, 2, 5, 6, 2, 9, 11, 6, 9]) == [(5, 7), (7, 2), (2, 5), (5, 6), (6, 2), (2, 9), (9, 11), (11, 6), (6, 9)]", "assert pair_wise([3, 2, 3, 9, 10, 1, 10, 13, 14, 14]) == [(3, 2), (2, 3), (3, 9), (9, 10), (10, 1), (1, 10), (10, 13), (13, 14), (14, 14)]", "assert pair_wise([3, 1, 7, 3, 8, 4, 7, 8, 13, 13]) == [(3, 1), (1, 7), (7, 3), (3, 8), (8, 4), (4, 7), (7, 8), (8, 13), (13, 13)]", "assert pair_wise([6, 7, 2, 9, 7, 1, 6, 12, 10, 11]) == [(6, 7), (7, 2), (2, 9), (9, 7), (7, 1), (1, 6), (6, 12), (12, 10), (10, 11)]", "assert pair_wise([2, 5, 4, 8, 9, 5, 2, 12, 7, 10]) == [(2, 5), (5, 4), (4, 8), (8, 9), (9, 5), (5, 2), (2, 12), (12, 7), (7, 10)]", "assert pair_wise([5, 5, 3, 2, 4, 1, 11, 12, 5, 9]) == [(5, 5), (5, 3), (3, 2), (2, 4), (4, 1), (1, 11), (11, 12), (12, 5), (5, 9)]", "assert pair_wise([2, 3, 4, 4, 2, 7, 10, 10, 11, 6]) == [(2, 3), (3, 4), (4, 4), (4, 2), (2, 7), (7, 10), (10, 10), (10, 11), (11, 6)]", "assert pair_wise([4, 6, 7, 1, 5, 6, 6, 7, 10, 9]) == [(4, 6), (6, 7), (7, 1), (1, 5), (5, 6), (6, 6), (6, 7), (7, 10), (10, 9)]", "assert pair_wise([1, 5, 3, 2, 8, 5, 5, 3, 10, 15]) == [(1, 5), (5, 3), (3, 2), (2, 8), (8, 5), (5, 5), (5, 3), (3, 10), (10, 15)]", "assert pair_wise([5, 4, 6, 7, 7, 2, 4, 12, 7, 7]) == [(5, 4), (4, 6), (6, 7), (7, 7), (7, 2), (2, 4), (4, 12), (12, 7), (7, 7)]", "assert pair_wise([6, 4, 7, 3, 8, 2, 3, 11, 4, 9]) == [(6, 4), (4, 7), (7, 3), (3, 8), (8, 2), (2, 3), (3, 11), (11, 4), (4, 9)]", "assert pair_wise([1, 2, 1, 3, 9, 10, 11, 11, 6, 15]) == [(1, 2), (2, 1), (1, 3), (3, 9), (9, 10), (10, 11), (11, 11), (11, 6), (6, 15)]", "assert pair_wise([1, 1, 2, 5, 7, 7, 3, 4, 7, 12]) == [(1, 1), (1, 2), (2, 5), (5, 7), (7, 7), (7, 3), (3, 4), (4, 7), (7, 12)]", "assert pair_wise([4, 6, 7, 2, 1, 8, 5, 8, 11, 14]) == [(4, 6), (6, 7), (7, 2), (2, 1), (1, 8), (8, 5), (5, 8), (8, 11), (11, 14)]", "assert pair_wise([4, 3, 1, 5, 7, 6, 6, 13, 10, 13]) == [(4, 3), (3, 1), (1, 5), (5, 7), (7, 6), (6, 6), (6, 13), (13, 10), (10, 13)]", "assert pair_wise([3, 6, 6, 6, 7, 11, 5, 3, 13, 9]) == [(3, 6), (6, 6), (6, 6), (6, 7), (7, 11), (11, 5), (5, 3), (3, 13), (13, 9)]", "assert pair_wise([6, 2, 6, 5, 1, 11, 6, 13, 10, 13]) == [(6, 2), (2, 6), (6, 5), (5, 1), (1, 11), (11, 6), (6, 13), (13, 10), (10, 13)]"], "entry_point": "pair_wise", "repair_prompt": ["Write a function pair_wise to return a list of all pairs of consecutive items in a given list.\npair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n", "Write a function pair_wise to return a list. This list should contain all pairs of consecutive items in a given list.\npair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n", "Write a function pair_wise to return a list of all pairs of consecutive items in a given list.\npair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n"], "completions": ["from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    '''\n    Generate a list of pairs of consecutive items from the input list.\n    \n    Parameters:\n    input_list (list): A list of elements.\n    \n    Returns:\n    list: A list of tuples, each containing a pair of consecutive elements from the input list.\n    '''\n    # Initialize an empty list to store the pairs\n    pairs = []\n    \n    # Iterate over the list using an index from 0 to len(list) - 2\n    for i in range(len(input_list) - 1):\n        # Create a tuple with the current item and the next item\n        pair = (input_list[i], input_list[i + 1])\n        \n        # Append the tuple to the list of pairs\n        pairs.append(pair)\n    \n    # Return the list of pairs\n    return pairs\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"Generate a list of tuples, each containing a pair of consecutive elements from the input list.\n\n    This function takes a list of elements and returns a list of tuples, where each tuple contains\n    two consecutive elements from the input list. If the input list is empty or contains only one\n    element, the function returns an empty list.\n\n    Args:\n        input_list (list): A list of elements from which consecutive pairs are to be generated.\n\n    Returns:\n        list: A list of tuples, each containing a pair of consecutive elements.\n\n    Examples:\n        >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n\n        >>> pair_wise([])\n        []\n\n        >>> pair_wise([1])\n        []\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if len(input_list) < 2:\n        return []\n\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate through the list using an index to access each element and its consecutive element\n    for i in range(len(input_list) - 1):\n        # Create a tuple of consecutive elements and append it to the list of pairs\n        pairs.append((input_list[i], input_list[i + 1]))\n\n    # Return the list of pairs\n    return pairs\n", "from typing import List\n## main.py\n\ndef pair_wise(lst: list) -> list[tuple]:\n    \"\"\"\n    Generate a list of tuples, each containing a pair of consecutive elements from the input list.\n\n    Parameters:\n    lst (list): A list of elements (can be of any data type).\n\n    Returns:\n    list[tuple]: A list of tuples, each containing a pair of consecutive elements.\n    \"\"\"\n    # Check if the list has fewer than two elements, return an empty list if true\n    if len(lst) < 2:\n        return []\n\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate through the list using an index to access each element and its consecutive element\n    for i in range(len(lst) - 1):\n        # Create a tuple for each pair of consecutive elements and append it to the list of pairs\n        pairs.append((lst[i], lst[i + 1]))\n\n    # Return the list of pairs\n    return pairs\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"\n    Returns a list of tuples containing pairs of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): A list of elements.\n\n    Returns:\n    list: A list of tuples with consecutive pairs.\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if len(input_list) < 2:\n        return []\n\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate through the list using an index from 0 to the second-to-last element\n    for i in range(len(input_list) - 1):\n        # Create a tuple with the current element and the next element\n        pair = (input_list[i], input_list[i + 1])\n        # Append this tuple to the list of pairs\n        pairs.append(pair)\n\n    # Return the list of pairs\n    return pairs\n\n# Example usage:\n# result = pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n# print(result)  # Output: [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"\n    Generates a list of tuples, each containing pairs of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): A list of elements.\n\n    Returns:\n    list: A list of tuples with consecutive pairs.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate through the list using an index\n    for i in range(len(input_list) - 1):\n        # Create a tuple with the current element and the next element\n        pair = (input_list[i], input_list[i + 1])\n        # Append the tuple to the list of pairs\n        pairs.append(pair)\n\n    # Return the list of pairs\n    return pairs\n\n# Example usage\nif __name__ == \"__main__\":\n    example_list = [1, 1, 2, 3, 3, 4, 4, 5]\n    print(pair_wise(example_list))\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"\n    Generate pairs of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): A list of elements to generate pairs from.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive elements from the input list.\n    \"\"\"\n    # Initialize an empty list to store the pairs\n    pairs = []\n\n    # Iterate through the list, stopping at the second-to-last element\n    for i in range(len(input_list) - 1):\n        # Create a tuple with the current element and the next element\n        pair = (input_list[i], input_list[i + 1])\n        # Append the tuple to the list of pairs\n        pairs.append(pair)\n\n    # Return the list of pairs\n    return pairs\n\n# Example usage:\n# print(pair_wise([]))        # Output: []\n# print(pair_wise([1]))       # Output: []\n# print(pair_wise([1, 2]))    # Output: [(1, 2)]\n# print(pair_wise([1, 2, 3])) # Output: [(1, 2), (2, 3)]\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"\n    Generate a list of tuples, each containing a pair of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): A list of elements from which consecutive pairs are generated.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive elements.\n    \"\"\"\n    # Check if the list is empty or has only one element. If so, return an empty list.\n    if len(input_list) < 2:\n        return []\n\n    # Initialize an empty list to store the pairs.\n    pairs = []\n\n    # Iterate through the list using an index to access each element and its consecutive element.\n    for i in range(len(input_list) - 1):\n        # For each pair of consecutive elements, create a tuple and append it to the list of pairs.\n        pairs.append((input_list[i], input_list[i + 1]))\n\n    # Return the list of pairs.\n    return pairs\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"Takes a list of elements and returns a list of tuples, each containing a pair of consecutive elements.\n    \n    Parameters:\n    input_list (list): A list of elements to be paired.\n    \n    Returns:\n    list: A list of tuples, each containing a pair of consecutive elements from the input list.\n    \n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError('Input must be a list')\n    \n    # Initialize an empty list to store the pairs\n    pairs = []\n    \n    # Iterate through the list using an index to access each element and its consecutive element\n    for i in range(len(input_list) - 1):\n        # Create a tuple with the current element and the next element\n        pair = (input_list[i], input_list[i + 1])\n        # Append each tuple to the list of pairs\n        pairs.append(pair)\n    \n    # Return the list of pairs\n    return pairs\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list:\n    \"\"\"\n    Returns a list of tuples, each containing a pair of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): The list from which consecutive pairs are to be generated.\n\n    Returns:\n    list: A list of tuples, each tuple containing a pair of consecutive elements.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    # Check if the list has more than one element to form pairs\n    if len(input_list) > 1:\n        # Use list comprehension to generate pairs of consecutive elements\n        return [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]\n    else:\n        # Return an empty list if there are fewer than two elements\n        return []\n\n# Example usage\nif __name__ == \"__main__\":\n    example_list = [1, 1, 2, 3, 3, 4, 4, 5]\n    print(pair_wise(example_list))\n", "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list[tuple]:\n    \"\"\"\n    Generate a list of tuples, each containing a pair of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): The list from which to generate consecutive pairs.\n\n    Returns:\n    list[tuple]: A list of tuples, each containing a pair of consecutive elements.\n    \"\"\"\n    # Check if the list is empty or has only one element; if so, return an empty list.\n    if len(input_list) < 2:\n        return []\n\n    # Initialize an empty list to store the pairs.\n    pairs = []\n\n    # Iterate through the list using a loop that goes from the first element to the second-to-last element.\n    for i in range(len(input_list) - 1):\n        # For each element, create a tuple with the current element and the next element.\n        pair = (input_list[i], input_list[i + 1])\n        # Append the tuple to the list of pairs.\n        pairs.append(pair)\n\n    # Return the list of pairs.\n    return pairs\n"], "plans": ["requirement analysis:\nThe function should iterate over the list and create pairs of consecutive elements. It should handle edge cases such as empty lists or lists with a single element gracefully. The implementation should be efficient to handle large lists and should be compatible with different Python versions.\nrequirement pool:\n- Implement the pair_wise function to generate consecutive pairs\n- Ensure the function handles edge cases like empty or single-element lists\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Test compatibility across different Python versions\nWe will implement the pair_wise function using a simple loop to iterate over the list and create pairs of consecutive elements. This approach is efficient and straightforward, ensuring compatibility with different Python versions without the need for additional libraries. We will handle edge cases such as empty lists or lists with a single element by returning an empty list in those scenarios.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'consecutive items'\n    Explanation: In the requirement, it refers to items that are next to each other in the list. For example, in the list [1, 2, 3], the pairs of consecutive items are (1, 2) and (2, 3).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty list to store the pairs.\n    2. Iterate over the list using an index from 0 to len(list) - 2.\n    3. For each index, create a tuple with the current item and the next item.\n    4. Append the tuple to the list of pairs.\n    5. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no consecutive items, so the expected output is an empty list.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element has no consecutive items, so the expected output is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: The list has exactly two elements, which form a single pair of consecutive items.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating from 0 to len(list) - 2 naturally handles lists with fewer than two elements by not entering the loop.\n", "requirement analysis:\nThe function should efficiently generate pairs of consecutive elements from a list. It should handle edge cases such as empty lists or lists with a single element. The implementation should be straightforward and easy to understand, with clear documentation.\nrequirement pool:\n- Implement the pair_wise function to generate consecutive pairs\n- Ensure the function handles edge cases like empty or single-element lists\n- Provide comprehensive documentation and examples\n- Optimize the function for performance with large lists\n- Ensure compatibility with Python 3.x versions\nWe will implement a simple function using Python's built-in capabilities to generate pairs of consecutive elements from a list. The function will handle edge cases such as empty lists or lists with a single element by returning an empty list in these scenarios. The implementation will be straightforward, ensuring compatibility with Python 3.x versions and will include comprehensive documentation with examples.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This refers to creating tuples consisting of two elements that are next to each other in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the list is empty or has only one element. If so, return an empty list.\n    2. Initialize an empty list to store the pairs.\n    3. Iterate through the list using an index to access each element and its consecutive element.\n    4. For each pair of consecutive elements, create a tuple and append it to the list of pairs.\n    5. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no pairs to form.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the result is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: The list has exactly two elements, forming one pair.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for lists with fewer than two elements by returning an empty list.\n", "requirement analysis:\nThe function should iterate over the list and create pairs of consecutive elements. It should handle edge cases such as empty lists or lists with a single element gracefully. The implementation should be efficient to handle large lists.\nrequirement pool:\n- Implement the pair_wise function to generate consecutive pairs\n- Ensure the function handles edge cases like empty lists\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Test the function across different Python versions\nWe will implement a simple function using Python's built-in capabilities to iterate over the list and generate pairs of consecutive elements. This approach will ensure efficiency and simplicity, making it easy to integrate into existing codebases. We will handle edge cases such as empty lists or lists with a single element by returning an empty list in such scenarios. The function will be compatible with different Python versions, ensuring broad usability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This refers to creating tuples consisting of two elements that are next to each other in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the list is empty or has only one element. If so, return an empty list.\n    2. Initialize an empty list to store the pairs.\n    3. Iterate through the list using an index to access each element and its consecutive element.\n    4. For each pair of consecutive elements, create a tuple and append it to the list of pairs.\n    5. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no pairs to form.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the result is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: A list with two elements forms exactly one pair, which is the pair of the two elements themselves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already returns an empty list for lists with fewer than two elements.\n", "requirement analysis:\nThe function should iterate over the list and create pairs of consecutive elements. It should handle edge cases such as empty lists or lists with a single element by returning an empty list.\nrequirement pool:\n- Implement the pair_wise function to return pairs of consecutive elements\n- Ensure the function handles edge cases like empty or single-element lists\n- Optimize the function for performance with large lists\n- Document the function with examples and edge case handling\n- Test the function across different Python versions for compatibility\nWe will implement a simple function using Python's built-in capabilities to iterate over the list and create pairs of consecutive elements. The function will handle edge cases such as empty lists or lists with a single element by returning an empty list. We will ensure the function is efficient and compatible with different Python versions by using basic list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This means that for each element in the list, we need to create a tuple with the next element, effectively creating pairs of elements that are next to each other in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the list is empty or has only one element. If so, return an empty list as there are no consecutive pairs possible.\n    2. Initialize an empty list to store the pairs.\n    3. Iterate through the list using an index from 0 to the second-to-last element.\n    4. For each element, create a tuple with the current element and the next element.\n    5. Append this tuple to the list of pairs.\n    6. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no consecutive pairs to form.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the result is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: A list with two elements can form exactly one pair, which is (1, 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for lists that are empty or have a single element by returning an empty list in such cases.\n", "requirement analysis:\nThe function should efficiently generate pairs of consecutive elements from a list, ensuring it handles edge cases such as empty lists or lists with a single element. The output should be intuitive and easy to understand.\nrequirement pool:\n- The function should return pairs of consecutive elements.\n- The function should handle empty lists gracefully.\n- The function should be compatible with Python 3.x.\n- The function should include documentation and examples.\n- The function should be optimized for performance.\nWe will implement a simple function using native Python list operations to generate pairs of consecutive elements. This approach ensures compatibility with Python 3.x and handles edge cases efficiently. We will use list comprehensions for concise and readable code, avoiding the need for external libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This refers to creating tuples from each pair of adjacent elements in the list. For example, in the list [1, 2, 3], the pairs would be (1, 2) and (2, 3).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty list to store the pairs.\n    2. Iterate through the given list using an index.\n    3. For each index, create a tuple with the current element and the next element.\n    4. Append this tuple to the list of pairs.\n    5. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no pairs to form.\n    \n    pair_wise([1]) = []\n    Explanation: A single-element list cannot form any pairs since there is no consecutive element.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: A two-element list forms exactly one pair with its two elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic naturally handles lists with fewer than two elements by not entering the loop that generates pairs.\n", "requirement analysis:\nThe function should efficiently generate pairs of consecutive elements from a list, ensuring it handles edge cases such as empty lists or lists with a single element. It should be easy to integrate and understand, with clear documentation provided.\nrequirement pool:\n- The function should return pairs of consecutive elements.\n- The function should handle edge cases like empty lists.\n- The function should be compatible with different Python versions.\n- The function should be documented with examples.\n- The function should be efficient for large lists.\nWe will implement a simple function using Python's built-in capabilities to generate pairs of consecutive elements from a list. The function will handle edge cases such as empty lists or lists with a single element by returning an empty list. This approach ensures compatibility with different Python versions and maintains efficiency for large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This means that the function should return tuples containing two consecutive elements from the input list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize an empty list to store the pairs.\n    - Iterate through the given list using a loop that goes from the first element to the second-to-last element.\n    - For each element, create a tuple with the current element and the next element.\n    - Append this tuple to the list of pairs.\n    - Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no consecutive pairs to return.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the expected output is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: A list with two elements forms one pair, which is the only possible consecutive pair.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty lists and lists with a single element by returning an empty list.\n", "requirement analysis:\nThe function should efficiently generate pairs of consecutive elements from a list, ensuring it handles edge cases such as empty lists or lists with a single element. It should be easy to integrate and understand, with clear documentation provided.\nrequirement pool:\n- The function should return pairs of consecutive elements.\n- The function should handle edge cases like empty lists.\n- The function should be compatible with different Python versions.\n- The function should be optimized for performance.\n- The function should include clear documentation and examples.\nWe will implement a simple function using Python's built-in capabilities to generate pairs of consecutive elements from a list. The function will handle edge cases such as empty lists or lists with a single element by returning an empty list in these scenarios. This approach ensures compatibility with different Python versions and maintains efficiency without the need for additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This refers to creating tuples consisting of two elements that are next to each other in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the list is empty or has only one element. If so, return an empty list.\n    2. Initialize an empty list to store the pairs.\n    3. Iterate through the list using an index to access each element and its consecutive element.\n    4. For each pair of consecutive elements, create a tuple and append it to the list of pairs.\n    5. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no pairs to form.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the result is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: The list has exactly two elements, forming one pair.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for lists with fewer than two elements by returning an empty list.\n", "requirement analysis:\nThe function should iterate over the list and create pairs of consecutive elements. It should handle lists of varying lengths and types, ensuring that the output is consistent with the example provided.\nrequirement pool:\n- Implement the pair_wise function to create pairs of consecutive elements.\n- Optimize the function for performance with large lists.\n- Include error handling for non-list inputs.\n- Provide comprehensive documentation and usage examples.\n- Ensure compatibility with Python 3.x versions.\nWe will implement a simple function using Python's built-in capabilities to iterate over the list and create pairs of consecutive elements. The function will include error handling to ensure that the input is a list. This approach will be efficient for large lists and maintain compatibility with Python 3.x.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This refers to creating tuples consisting of two elements that are next to each other in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the input is a list.\n    2. Initialize an empty list to store the pairs.\n    3. Iterate through the list using an index to access each element and its consecutive element.\n    4. For each element, create a tuple with the current element and the next element.\n    5. Append each tuple to the list of pairs.\n    6. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no pairs to form.\n    \n    pair_wise([1]) = []\n    Explanation: A single-element list cannot form any pairs, so the result is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: A two-element list can form exactly one pair with its elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles lists with fewer than two elements by not entering the loop that forms pairs.\n", "requirement analysis:\nThe function should iterate over the list and create pairs of consecutive elements. It should handle edge cases such as empty lists or lists with a single element gracefully. The implementation should be efficient and easy to understand.\nrequirement pool:\n- Implement the pair_wise function to return consecutive pairs\n- Ensure the function handles edge cases like empty lists\n- Document the function with examples and edge cases\n- Optimize the function for large lists\n- Test the function across different Python versions\nWe will implement a simple function using a list comprehension to iterate over the input list and generate pairs of consecutive elements. This approach is efficient and easy to understand, making it suitable for large lists. We will also handle edge cases such as empty lists or lists with a single element by returning an empty list in such scenarios. The function will be compatible with different Python versions and will be well-documented with examples.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'consecutive items'\n    Explanation: In the requirement, 'consecutive items' refers to elements in the list that are adjacent to each other. The function should generate pairs of these adjacent elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize an empty list to store the pairs.\n    - Iterate over the input list using a loop that goes from the first element to the second-to-last element.\n    - For each element, create a tuple with the current element and the next element.\n    - Append the tuple to the list of pairs.\n    - Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no consecutive pairs to return.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the expected output is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: A list with two elements forms one pair, which is (1, 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating from the first element to the second-to-last element naturally handles lists with fewer than two elements by returning an empty list.\n", "requirement analysis:\nThe function should efficiently generate pairs of consecutive elements from a list. It should handle edge cases such as empty lists or lists with a single element. The implementation should be straightforward and not require additional libraries unless necessary.\nrequirement pool:\n- Implement the pair_wise function to generate consecutive pairs\n- Optimize the function for large lists\n- Document the function with examples and edge cases\n- Ensure compatibility with Python 3.x\n- Test the function with various input scenarios\nWe will implement the pair_wise function using Python's built-in capabilities to ensure efficiency and simplicity. The function will handle edge cases such as empty lists or lists with a single element by returning an empty list in these scenarios. We will avoid using additional libraries to maintain compatibility across different Python versions and to keep the function lightweight.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'pairs of consecutive items'\n    Explanation: This refers to creating tuples from adjacent elements in the list, where each tuple contains two consecutive elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Check if the list is empty or has only one element; if so, return an empty list.\n    2. Initialize an empty list to store the pairs.\n    3. Iterate through the list using a loop that goes from the first element to the second-to-last element.\n    4. For each element, create a tuple with the current element and the next element.\n    5. Append the tuple to the list of pairs.\n    6. Return the list of pairs.\n\n# [edge case] \n    pair_wise([]) = []\n    Explanation: An empty list has no elements, so there are no pairs to form, resulting in an empty list.\n    \n    pair_wise([1]) = []\n    Explanation: A list with a single element cannot form any pairs, so the result is an empty list.\n    \n    pair_wise([1, 2]) = [(1, 2)]\n    Explanation: The list has two elements, forming one pair of consecutive items.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already returns an empty list for lists with fewer than two elements.\n"], "test": ["def check(pair_wise):\n\tassert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]", "def check(pair_wise):\n\tassert pair_wise([1,5,7,9,10])==[(1, 5), (5, 7), (7, 9), (9, 10)]", "def check(pair_wise):\n\tassert pair_wise([1,2,3,4,5,6,7,8,9,10])==[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]", "def check(pair_wise):\n\tassert pair_wise([1, 2, 5, 6, 5, 9, 9, 3]) == [(1, 2), (2, 5), (5, 6), (6, 5), (5, 9), (9, 9), (9, 3)]", "def check(pair_wise):\n\tassert pair_wise([1, 3, 4, 3, 1, 7, 9, 7]) == [(1, 3), (3, 4), (4, 3), (3, 1), (1, 7), (7, 9), (9, 7)]", "def check(pair_wise):\n\tassert pair_wise([6, 4, 4, 1, 3, 2, 2, 5]) == [(6, 4), (4, 4), (4, 1), (1, 3), (3, 2), (2, 2), (2, 5)]", "def check(pair_wise):\n\tassert pair_wise([5, 1, 1, 1, 2, 5, 2, 8]) == [(5, 1), (1, 1), (1, 1), (1, 2), (2, 5), (5, 2), (2, 8)]", "def check(pair_wise):\n\tassert pair_wise([5, 5, 1, 7, 1, 5, 4, 1]) == [(5, 5), (5, 1), (1, 7), (7, 1), (1, 5), (5, 4), (4, 1)]", "def check(pair_wise):\n\tassert pair_wise([6, 4, 3, 3, 6, 8, 1, 3]) == [(6, 4), (4, 3), (3, 3), (3, 6), (6, 8), (8, 1), (1, 3)]", "def check(pair_wise):\n\tassert pair_wise([5, 2, 1, 5, 2, 5, 6, 4]) == [(5, 2), (2, 1), (1, 5), (5, 2), (2, 5), (5, 6), (6, 4)]", "def check(pair_wise):\n\tassert pair_wise([3, 5, 3, 4, 7, 4, 4, 7]) == [(3, 5), (5, 3), (3, 4), (4, 7), (7, 4), (4, 4), (4, 7)]", "def check(pair_wise):\n\tassert pair_wise([6, 6, 1, 4, 3, 4, 3, 10]) == [(6, 6), (6, 1), (1, 4), (4, 3), (3, 4), (4, 3), (3, 10)]", "def check(pair_wise):\n\tassert pair_wise([6, 3, 4, 6, 4, 9, 8, 10]) == [(6, 3), (3, 4), (4, 6), (6, 4), (4, 9), (9, 8), (8, 10)]", "def check(pair_wise):\n\tassert pair_wise([6, 1, 4, 4, 2, 8, 2, 3]) == [(6, 1), (1, 4), (4, 4), (4, 2), (2, 8), (8, 2), (2, 3)]", "def check(pair_wise):\n\tassert pair_wise([2, 3, 1, 3, 8, 2, 5, 10]) == [(2, 3), (3, 1), (1, 3), (3, 8), (8, 2), (2, 5), (5, 10)]", "def check(pair_wise):\n\tassert pair_wise([3, 5, 7, 4, 5, 3, 7, 5]) == [(3, 5), (5, 7), (7, 4), (4, 5), (5, 3), (3, 7), (7, 5)]", "def check(pair_wise):\n\tassert pair_wise([2, 6, 2, 7, 7, 5, 1, 10]) == [(2, 6), (6, 2), (2, 7), (7, 7), (7, 5), (5, 1), (1, 10)]", "def check(pair_wise):\n\tassert pair_wise([1, 3, 7, 6, 5, 4, 8, 7]) == [(1, 3), (3, 7), (7, 6), (6, 5), (5, 4), (4, 8), (8, 7)]", "def check(pair_wise):\n\tassert pair_wise([4, 6, 4, 7, 6, 4, 4, 8]) == [(4, 6), (6, 4), (4, 7), (7, 6), (6, 4), (4, 4), (4, 8)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 2, 5, 5, 1, 6, 8]) == [(2, 4), (4, 2), (2, 5), (5, 5), (5, 1), (1, 6), (6, 8)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 3, 7, 1, 1, 9, 4]) == [(2, 4), (4, 3), (3, 7), (7, 1), (1, 1), (1, 9), (9, 4)]", "def check(pair_wise):\n\tassert pair_wise([3, 1, 2, 3, 1, 4, 6, 8]) == [(3, 1), (1, 2), (2, 3), (3, 1), (1, 4), (4, 6), (6, 8)]", "def check(pair_wise):\n\tassert pair_wise([5, 6, 3, 2, 2, 4, 5, 8]) == [(5, 6), (6, 3), (3, 2), (2, 2), (2, 4), (4, 5), (5, 8)]", "def check(pair_wise):\n\tassert pair_wise([3, 3, 1, 3, 1, 7, 8, 6]) == [(3, 3), (3, 1), (1, 3), (3, 1), (1, 7), (7, 8), (8, 6)]", "def check(pair_wise):\n\tassert pair_wise([4, 4, 6, 5, 4, 1, 9, 10]) == [(4, 4), (4, 6), (6, 5), (5, 4), (4, 1), (1, 9), (9, 10)]", "def check(pair_wise):\n\tassert pair_wise([6, 2, 2, 6, 8, 6, 1, 8]) == [(6, 2), (2, 2), (2, 6), (6, 8), (8, 6), (6, 1), (1, 8)]", "def check(pair_wise):\n\tassert pair_wise([1, 5, 4, 6, 7, 2, 4, 6]) == [(1, 5), (5, 4), (4, 6), (6, 7), (7, 2), (2, 4), (4, 6)]", "def check(pair_wise):\n\tassert pair_wise([5, 5, 1, 6, 8, 2, 1, 10]) == [(5, 5), (5, 1), (1, 6), (6, 8), (8, 2), (2, 1), (1, 10)]", "def check(pair_wise):\n\tassert pair_wise([3, 2, 5, 1, 1, 5, 8, 7]) == [(3, 2), (2, 5), (5, 1), (1, 1), (1, 5), (5, 8), (8, 7)]", "def check(pair_wise):\n\tassert pair_wise([6, 1, 7, 3, 8, 6, 6, 3]) == [(6, 1), (1, 7), (7, 3), (3, 8), (8, 6), (6, 6), (6, 3)]", "def check(pair_wise):\n\tassert pair_wise([1, 5, 3, 6, 2, 5, 9, 6]) == [(1, 5), (5, 3), (3, 6), (6, 2), (2, 5), (5, 9), (9, 6)]", "def check(pair_wise):\n\tassert pair_wise([4, 6, 6, 3, 5, 9, 2, 7]) == [(4, 6), (6, 6), (6, 3), (3, 5), (5, 9), (9, 2), (2, 7)]", "def check(pair_wise):\n\tassert pair_wise([3, 1, 6, 7, 4, 1, 3, 10]) == [(3, 1), (1, 6), (6, 7), (7, 4), (4, 1), (1, 3), (3, 10)]", "def check(pair_wise):\n\tassert pair_wise([4, 1, 1, 8, 1, 2, 6, 7]) == [(4, 1), (1, 1), (1, 8), (8, 1), (1, 2), (2, 6), (6, 7)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 2, 8, 2, 8, 9, 5]) == [(2, 4), (4, 2), (2, 8), (8, 2), (2, 8), (8, 9), (9, 5)]", "def check(pair_wise):\n\tassert pair_wise([6, 4, 6, 4, 1, 9, 2, 4]) == [(6, 4), (4, 6), (6, 4), (4, 1), (1, 9), (9, 2), (2, 4)]", "def check(pair_wise):\n\tassert pair_wise([1, 2, 3, 7, 12]) == [(1, 2), (2, 3), (3, 7), (7, 12)]", "def check(pair_wise):\n\tassert pair_wise([1, 5, 6, 14, 15]) == [(1, 5), (5, 6), (6, 14), (14, 15)]", "def check(pair_wise):\n\tassert pair_wise([6, 9, 6, 14, 10]) == [(6, 9), (9, 6), (6, 14), (14, 10)]", "def check(pair_wise):\n\tassert pair_wise([6, 4, 11, 8, 14]) == [(6, 4), (4, 11), (11, 8), (8, 14)]", "def check(pair_wise):\n\tassert pair_wise([3, 8, 12, 5, 9]) == [(3, 8), (8, 12), (12, 5), (5, 9)]", "def check(pair_wise):\n\tassert pair_wise([1, 6, 11, 10, 10]) == [(1, 6), (6, 11), (11, 10), (10, 10)]", "def check(pair_wise):\n\tassert pair_wise([6, 9, 12, 4, 10]) == [(6, 9), (9, 12), (12, 4), (4, 10)]", "def check(pair_wise):\n\tassert pair_wise([6, 1, 3, 14, 9]) == [(6, 1), (1, 3), (3, 14), (14, 9)]", "def check(pair_wise):\n\tassert pair_wise([3, 5, 3, 8, 13]) == [(3, 5), (5, 3), (3, 8), (8, 13)]", "def check(pair_wise):\n\tassert pair_wise([4, 3, 5, 6, 7]) == [(4, 3), (3, 5), (5, 6), (6, 7)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 12, 6, 5]) == [(2, 4), (4, 12), (12, 6), (6, 5)]", "def check(pair_wise):\n\tassert pair_wise([6, 5, 12, 14, 15]) == [(6, 5), (5, 12), (12, 14), (14, 15)]", "def check(pair_wise):\n\tassert pair_wise([6, 8, 10, 4, 15]) == [(6, 8), (8, 10), (10, 4), (4, 15)]", "def check(pair_wise):\n\tassert pair_wise([3, 1, 11, 9, 7]) == [(3, 1), (1, 11), (11, 9), (9, 7)]", "def check(pair_wise):\n\tassert pair_wise([2, 7, 3, 8, 15]) == [(2, 7), (7, 3), (3, 8), (8, 15)]", "def check(pair_wise):\n\tassert pair_wise([3, 3, 10, 8, 8]) == [(3, 3), (3, 10), (10, 8), (8, 8)]", "def check(pair_wise):\n\tassert pair_wise([1, 7, 10, 7, 11]) == [(1, 7), (7, 10), (10, 7), (7, 11)]", "def check(pair_wise):\n\tassert pair_wise([2, 8, 4, 6, 6]) == [(2, 8), (8, 4), (4, 6), (6, 6)]", "def check(pair_wise):\n\tassert pair_wise([5, 8, 8, 13, 7]) == [(5, 8), (8, 8), (8, 13), (13, 7)]", "def check(pair_wise):\n\tassert pair_wise([3, 9, 2, 13, 15]) == [(3, 9), (9, 2), (2, 13), (13, 15)]", "def check(pair_wise):\n\tassert pair_wise([3, 2, 10, 13, 11]) == [(3, 2), (2, 10), (10, 13), (13, 11)]", "def check(pair_wise):\n\tassert pair_wise([2, 7, 2, 7, 11]) == [(2, 7), (7, 2), (2, 7), (7, 11)]", "def check(pair_wise):\n\tassert pair_wise([2, 2, 4, 4, 12]) == [(2, 2), (2, 4), (4, 4), (4, 12)]", "def check(pair_wise):\n\tassert pair_wise([1, 3, 10, 13, 6]) == [(1, 3), (3, 10), (10, 13), (13, 6)]", "def check(pair_wise):\n\tassert pair_wise([5, 3, 12, 12, 5]) == [(5, 3), (3, 12), (12, 12), (12, 5)]", "def check(pair_wise):\n\tassert pair_wise([6, 10, 4, 14, 10]) == [(6, 10), (10, 4), (4, 14), (14, 10)]", "def check(pair_wise):\n\tassert pair_wise([1, 9, 3, 10, 5]) == [(1, 9), (9, 3), (3, 10), (10, 5)]", "def check(pair_wise):\n\tassert pair_wise([4, 2, 7, 10, 11]) == [(4, 2), (2, 7), (7, 10), (10, 11)]", "def check(pair_wise):\n\tassert pair_wise([2, 1, 12, 12, 11]) == [(2, 1), (1, 12), (12, 12), (12, 11)]", "def check(pair_wise):\n\tassert pair_wise([4, 4, 12, 14, 11]) == [(4, 4), (4, 12), (12, 14), (14, 11)]", "def check(pair_wise):\n\tassert pair_wise([6, 8, 4, 9, 12]) == [(6, 8), (8, 4), (4, 9), (9, 12)]", "def check(pair_wise):\n\tassert pair_wise([4, 3, 8, 8, 6]) == [(4, 3), (3, 8), (8, 8), (8, 6)]", "def check(pair_wise):\n\tassert pair_wise([3, 9, 2, 7, 8]) == [(3, 9), (9, 2), (2, 7), (7, 8)]", "def check(pair_wise):\n\tassert pair_wise([5, 3, 7, 5, 4, 3, 3, 4, 10, 12]) == [(5, 3), (3, 7), (7, 5), (5, 4), (4, 3), (3, 3), (3, 4), (4, 10), (10, 12)]", "def check(pair_wise):\n\tassert pair_wise([4, 5, 1, 9, 2, 11, 7, 12, 11, 15]) == [(4, 5), (5, 1), (1, 9), (9, 2), (2, 11), (11, 7), (7, 12), (12, 11), (11, 15)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 2, 9, 9, 4, 12, 7, 10, 15]) == [(2, 4), (4, 2), (2, 9), (9, 9), (9, 4), (4, 12), (12, 7), (7, 10), (10, 15)]", "def check(pair_wise):\n\tassert pair_wise([3, 2, 8, 6, 7, 10, 6, 12, 9, 13]) == [(3, 2), (2, 8), (8, 6), (6, 7), (7, 10), (10, 6), (6, 12), (12, 9), (9, 13)]", "def check(pair_wise):\n\tassert pair_wise([6, 5, 3, 4, 2, 7, 8, 6, 7, 14]) == [(6, 5), (5, 3), (3, 4), (4, 2), (2, 7), (7, 8), (8, 6), (6, 7), (7, 14)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 3, 7, 4, 9, 11, 3, 10, 7]) == [(2, 4), (4, 3), (3, 7), (7, 4), (4, 9), (9, 11), (11, 3), (3, 10), (10, 7)]", "def check(pair_wise):\n\tassert pair_wise([2, 4, 4, 6, 6, 7, 2, 12, 8, 12]) == [(2, 4), (4, 4), (4, 6), (6, 6), (6, 7), (7, 2), (2, 12), (12, 8), (8, 12)]", "def check(pair_wise):\n\tassert pair_wise([3, 1, 2, 7, 2, 10, 7, 10, 12, 13]) == [(3, 1), (1, 2), (2, 7), (7, 2), (2, 10), (10, 7), (7, 10), (10, 12), (12, 13)]", "def check(pair_wise):\n\tassert pair_wise([4, 1, 5, 1, 2, 7, 4, 12, 4, 9]) == [(4, 1), (1, 5), (5, 1), (1, 2), (2, 7), (7, 4), (4, 12), (12, 4), (4, 9)]", "def check(pair_wise):\n\tassert pair_wise([5, 6, 8, 6, 2, 2, 5, 13, 13, 10]) == [(5, 6), (6, 8), (8, 6), (6, 2), (2, 2), (2, 5), (5, 13), (13, 13), (13, 10)]", "def check(pair_wise):\n\tassert pair_wise([1, 2, 4, 9, 3, 5, 6, 6, 5, 9]) == [(1, 2), (2, 4), (4, 9), (9, 3), (3, 5), (5, 6), (6, 6), (6, 5), (5, 9)]", "def check(pair_wise):\n\tassert pair_wise([1, 3, 2, 2, 5, 3, 10, 11, 12, 10]) == [(1, 3), (3, 2), (2, 2), (2, 5), (5, 3), (3, 10), (10, 11), (11, 12), (12, 10)]", "def check(pair_wise):\n\tassert pair_wise([4, 2, 8, 5, 10, 10, 11, 7, 9, 15]) == [(4, 2), (2, 8), (8, 5), (5, 10), (10, 10), (10, 11), (11, 7), (7, 9), (9, 15)]", "def check(pair_wise):\n\tassert pair_wise([6, 3, 2, 6, 9, 6, 2, 5, 7, 8]) == [(6, 3), (3, 2), (2, 6), (6, 9), (9, 6), (6, 2), (2, 5), (5, 7), (7, 8)]", "def check(pair_wise):\n\tassert pair_wise([3, 3, 4, 2, 7, 10, 12, 10, 7, 11]) == [(3, 3), (3, 4), (4, 2), (2, 7), (7, 10), (10, 12), (12, 10), (10, 7), (7, 11)]", "def check(pair_wise):\n\tassert pair_wise([3, 4, 4, 5, 9, 4, 12, 12, 4, 15]) == [(3, 4), (4, 4), (4, 5), (5, 9), (9, 4), (4, 12), (12, 12), (12, 4), (4, 15)]", "def check(pair_wise):\n\tassert pair_wise([5, 7, 2, 5, 6, 2, 9, 11, 6, 9]) == [(5, 7), (7, 2), (2, 5), (5, 6), (6, 2), (2, 9), (9, 11), (11, 6), (6, 9)]", "def check(pair_wise):\n\tassert pair_wise([3, 2, 3, 9, 10, 1, 10, 13, 14, 14]) == [(3, 2), (2, 3), (3, 9), (9, 10), (10, 1), (1, 10), (10, 13), (13, 14), (14, 14)]", "def check(pair_wise):\n\tassert pair_wise([3, 1, 7, 3, 8, 4, 7, 8, 13, 13]) == [(3, 1), (1, 7), (7, 3), (3, 8), (8, 4), (4, 7), (7, 8), (8, 13), (13, 13)]", "def check(pair_wise):\n\tassert pair_wise([6, 7, 2, 9, 7, 1, 6, 12, 10, 11]) == [(6, 7), (7, 2), (2, 9), (9, 7), (7, 1), (1, 6), (6, 12), (12, 10), (10, 11)]", "def check(pair_wise):\n\tassert pair_wise([2, 5, 4, 8, 9, 5, 2, 12, 7, 10]) == [(2, 5), (5, 4), (4, 8), (8, 9), (9, 5), (5, 2), (2, 12), (12, 7), (7, 10)]", "def check(pair_wise):\n\tassert pair_wise([5, 5, 3, 2, 4, 1, 11, 12, 5, 9]) == [(5, 5), (5, 3), (3, 2), (2, 4), (4, 1), (1, 11), (11, 12), (12, 5), (5, 9)]", "def check(pair_wise):\n\tassert pair_wise([2, 3, 4, 4, 2, 7, 10, 10, 11, 6]) == [(2, 3), (3, 4), (4, 4), (4, 2), (2, 7), (7, 10), (10, 10), (10, 11), (11, 6)]", "def check(pair_wise):\n\tassert pair_wise([4, 6, 7, 1, 5, 6, 6, 7, 10, 9]) == [(4, 6), (6, 7), (7, 1), (1, 5), (5, 6), (6, 6), (6, 7), (7, 10), (10, 9)]", "def check(pair_wise):\n\tassert pair_wise([1, 5, 3, 2, 8, 5, 5, 3, 10, 15]) == [(1, 5), (5, 3), (3, 2), (2, 8), (8, 5), (5, 5), (5, 3), (3, 10), (10, 15)]", "def check(pair_wise):\n\tassert pair_wise([5, 4, 6, 7, 7, 2, 4, 12, 7, 7]) == [(5, 4), (4, 6), (6, 7), (7, 7), (7, 2), (2, 4), (4, 12), (12, 7), (7, 7)]", "def check(pair_wise):\n\tassert pair_wise([6, 4, 7, 3, 8, 2, 3, 11, 4, 9]) == [(6, 4), (4, 7), (7, 3), (3, 8), (8, 2), (2, 3), (3, 11), (11, 4), (4, 9)]", "def check(pair_wise):\n\tassert pair_wise([1, 2, 1, 3, 9, 10, 11, 11, 6, 15]) == [(1, 2), (2, 1), (1, 3), (3, 9), (9, 10), (10, 11), (11, 11), (11, 6), (6, 15)]", "def check(pair_wise):\n\tassert pair_wise([1, 1, 2, 5, 7, 7, 3, 4, 7, 12]) == [(1, 1), (1, 2), (2, 5), (5, 7), (7, 7), (7, 3), (3, 4), (4, 7), (7, 12)]", "def check(pair_wise):\n\tassert pair_wise([4, 6, 7, 2, 1, 8, 5, 8, 11, 14]) == [(4, 6), (6, 7), (7, 2), (2, 1), (1, 8), (8, 5), (5, 8), (8, 11), (11, 14)]", "def check(pair_wise):\n\tassert pair_wise([4, 3, 1, 5, 7, 6, 6, 13, 10, 13]) == [(4, 3), (3, 1), (1, 5), (5, 7), (7, 6), (6, 6), (6, 13), (13, 10), (10, 13)]", "def check(pair_wise):\n\tassert pair_wise([3, 6, 6, 6, 7, 11, 5, 3, 13, 9]) == [(3, 6), (6, 6), (6, 6), (6, 7), (7, 11), (11, 5), (5, 3), (3, 13), (13, 9)]", "def check(pair_wise):\n\tassert pair_wise([6, 2, 6, 5, 1, 11, 6, 13, 10, 13]) == [(6, 2), (2, 6), (6, 5), (5, 1), (1, 11), (11, 6), (6, 13), (13, 10), (10, 13)]"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef pair_wise(input_list: list) -> list[tuple]:\n    \"\"\"\n    Generate a list of tuples, each containing a pair of consecutive elements from the input list.\n\n    Parameters:\n    input_list (list): The list from which to generate consecutive pairs.\n\n    Returns:\n    list[tuple]: A list of tuples, each containing a pair of consecutive elements.\n    \"\"\"\n    # Check if the list is empty or has only one element; if so, return an empty list.\n    if len(input_list) < 2:\n        return []\n\n    # Initialize an empty list to store the pairs.\n    pairs = []\n\n    # Iterate through the list using a loop that goes from the first element to the second-to-last element.\n    for i in range(len(input_list) - 1):\n        # For each element, create a tuple with the current element and the next element.\n        pair = (input_list[i], input_list[i + 1])\n        # Append the tuple to the list of pairs.\n        pairs.append(pair)\n\n    # Return the list of pairs.\n    return pairs\n", "passed": true, "pass": true, "pass_num": 10, "round": 554, "mutate_method": "condense_two2one", "parent_index": 246}
