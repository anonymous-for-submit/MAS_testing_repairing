{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 140, "prompt": "Write a function to flatten the list of lists into a single set of numbers.", "code": "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) ", "test_imports": [], "test_list": ["assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]", "assert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]", "assert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]", "assert extract_singly([(3, 7, 5), (7, 7, 9), (5, 2)]) == [3, 7, 5, 9, 2]", "assert extract_singly([(3, 9, 6), (1, 6, 6), (4, 3)]) == [3, 9, 6, 1, 4]", "assert extract_singly([(1, 7, 2), (5, 10, 5), (2, 6)]) == [1, 7, 2, 5, 10, 6]", "assert extract_singly([(6, 8, 9), (5, 8, 11), (4, 1)]) == [6, 8, 9, 5, 11, 4, 1]", "assert extract_singly([(6, 9, 4), (3, 9, 10), (3, 3)]) == [6, 9, 4, 3, 10]", "assert extract_singly([(2, 4, 9), (1, 3, 12), (2, 5)]) == [2, 4, 9, 1, 3, 12, 5]", "assert extract_singly([(8, 9, 4), (4, 6, 2), (2, 6)]) == [8, 9, 4, 6, 2]", "assert extract_singly([(6, 4, 2), (2, 5, 12), (5, 8)]) == [6, 4, 2, 5, 12, 8]", "assert extract_singly([(2, 6, 6), (3, 4, 2), (3, 4)]) == [2, 6, 3, 4]", "assert extract_singly([(4, 6, 5), (8, 3, 5), (6, 9)]) == [4, 6, 5, 8, 3, 9]", "assert extract_singly([(3, 9, 1), (4, 7, 7), (6, 4)]) == [3, 9, 1, 4, 7, 6]", "assert extract_singly([(4, 9, 2), (6, 8, 5), (5, 1)]) == [4, 9, 2, 6, 8, 5, 1]", "assert extract_singly([(6, 8, 10), (5, 5, 7), (4, 9)]) == [6, 8, 10, 5, 7, 4, 9]", "assert extract_singly([(8, 1, 5), (8, 9, 6), (2, 6)]) == [8, 1, 5, 9, 6, 2]", "assert extract_singly([(6, 1, 1), (9, 8, 6), (1, 7)]) == [6, 1, 9, 8, 7]", "assert extract_singly([(4, 5, 5), (8, 10, 2), (5, 6)]) == [4, 5, 8, 10, 2, 6]", "assert extract_singly([(6, 2, 8), (8, 5, 8), (6, 7)]) == [6, 2, 8, 5, 7]", "assert extract_singly([(5, 8, 9), (2, 3, 6), (5, 6)]) == [5, 8, 9, 2, 3, 6]", "assert extract_singly([(7, 4, 1), (6, 3, 11), (2, 1)]) == [7, 4, 1, 6, 3, 11, 2]", "assert extract_singly([(1, 4, 2), (8, 8, 3), (4, 6)]) == [1, 4, 2, 8, 3, 6]", "assert extract_singly([(3, 1, 2), (2, 3, 10), (5, 5)]) == [3, 1, 2, 10, 5]", "assert extract_singly([(6, 5, 10), (7, 3, 12), (4, 1)]) == [6, 5, 10, 7, 3, 12, 4, 1]", "assert extract_singly([(2, 6, 8), (9, 5, 4), (1, 5)]) == [2, 6, 8, 9, 5, 4, 1]", "assert extract_singly([(4, 5, 2), (1, 1, 11), (4, 1)]) == [4, 5, 2, 1, 11]", "assert extract_singly([(2, 4, 7), (7, 9, 4), (6, 3)]) == [2, 4, 7, 9, 6, 3]", "assert extract_singly([(4, 8, 7), (5, 10, 11), (3, 2)]) == [4, 8, 7, 5, 10, 11, 3, 2]", "assert extract_singly([(5, 4, 10), (7, 3, 11), (4, 4)]) == [5, 4, 10, 7, 3, 11]", "assert extract_singly([(6, 5, 2), (8, 10, 5), (1, 1)]) == [6, 5, 2, 8, 10, 1]", "assert extract_singly([(5, 5, 10), (5, 3, 11), (3, 9)]) == [5, 10, 3, 11, 9]", "assert extract_singly([(2, 5, 9), (7, 5, 6), (3, 6)]) == [2, 5, 9, 7, 6, 3]", "assert extract_singly([(2, 6, 5), (8, 2, 11), (6, 1)]) == [2, 6, 5, 8, 11, 1]", "assert extract_singly([(1, 2, 10), (4, 2, 5), (3, 2)]) == [1, 2, 10, 4, 5, 3]", "assert extract_singly([(8, 1, 10), (8, 3, 2), (1, 3)]) == [8, 1, 10, 3, 2]", "assert extract_singly([(3, 7, 4), (1, 1, 5), (5, 5)]) == [3, 7, 4, 1, 5]", "assert extract_singly([(6, 7, 1), (6, 5, 3), (11, 3)]) == [6, 7, 1, 5, 3, 11]", "assert extract_singly([(1, 7, 4), (2, 2, 7), (2, 7)]) == [1, 7, 4, 2]", "assert extract_singly([(4, 2, 3), (3, 7, 7), (2, 5)]) == [4, 2, 3, 7, 5]", "assert extract_singly([(5, 6, 1), (7, 4, 3), (6, 4)]) == [5, 6, 1, 7, 4, 3]", "assert extract_singly([(4, 1, 4), (8, 2, 5), (10, 12)]) == [4, 1, 8, 2, 5, 10, 12]", "assert extract_singly([(6, 1, 2), (8, 2, 5), (4, 9)]) == [6, 1, 2, 8, 5, 4, 9]", "assert extract_singly([(1, 5, 3), (9, 2, 6), (10, 4)]) == [1, 5, 3, 9, 2, 6, 10, 4]", "assert extract_singly([(4, 3, 8), (6, 1, 6), (12, 12)]) == [4, 3, 8, 6, 1, 12]", "assert extract_singly([(4, 7, 5), (9, 5, 3), (11, 11)]) == [4, 7, 5, 9, 3, 11]", "assert extract_singly([(5, 3, 6), (4, 6, 3), (2, 7)]) == [5, 3, 6, 4, 2, 7]", "assert extract_singly([(5, 1, 8), (1, 7, 8), (7, 9)]) == [5, 1, 8, 7, 9]", "assert extract_singly([(4, 7, 1), (3, 2, 1), (11, 3)]) == [4, 7, 1, 3, 2, 11]", "assert extract_singly([(6, 3, 6), (1, 2, 2), (8, 9)]) == [6, 3, 1, 2, 8, 9]", "assert extract_singly([(5, 1, 4), (5, 3, 1), (2, 9)]) == [5, 1, 4, 3, 2, 9]", "assert extract_singly([(2, 2, 2), (6, 5, 8), (12, 3)]) == [2, 6, 5, 8, 12, 3]", "assert extract_singly([(5, 4, 3), (1, 5, 2), (12, 5)]) == [5, 4, 3, 1, 2, 12]", "assert extract_singly([(4, 3, 4), (7, 2, 3), (8, 10)]) == [4, 3, 7, 2, 8, 10]", "assert extract_singly([(3, 3, 4), (4, 1, 4), (4, 9)]) == [3, 4, 1, 9]", "assert extract_singly([(5, 4, 3), (3, 5, 1), (3, 10)]) == [5, 4, 3, 1, 10]", "assert extract_singly([(3, 7, 1), (6, 4, 8), (8, 8)]) == [3, 7, 1, 6, 4, 8]", "assert extract_singly([(6, 3, 8), (3, 1, 1), (9, 13)]) == [6, 3, 8, 1, 9, 13]", "assert extract_singly([(6, 2, 1), (2, 3, 6), (4, 13)]) == [6, 2, 1, 3, 4, 13]", "assert extract_singly([(3, 7, 2), (8, 4, 1), (2, 10)]) == [3, 7, 2, 8, 4, 1, 10]", "assert extract_singly([(5, 7, 4), (4, 7, 1), (11, 5)]) == [5, 7, 4, 1, 11]", "assert extract_singly([(3, 3, 3), (4, 1, 7), (8, 12)]) == [3, 4, 1, 7, 8, 12]", "assert extract_singly([(3, 5, 7), (6, 1, 8), (4, 7)]) == [3, 5, 7, 6, 1, 8, 4]", "assert extract_singly([(2, 2, 2), (6, 4, 8), (12, 6)]) == [2, 6, 4, 8, 12]", "assert extract_singly([(1, 2, 3), (8, 2, 7), (6, 4)]) == [1, 2, 3, 8, 7, 6, 4]", "assert extract_singly([(5, 4, 1), (9, 6, 3), (6, 3)]) == [5, 4, 1, 9, 6, 3]", "assert extract_singly([(6, 3, 4), (3, 1, 4), (6, 6)]) == [6, 3, 4, 1]", "assert extract_singly([(1, 4, 1), (6, 3, 2), (10, 3)]) == [1, 4, 6, 3, 2, 10]", "assert extract_singly([(2, 5, 7), (3, 2, 8), (12, 7)]) == [2, 5, 7, 3, 8, 12]", "assert extract_singly([(6, 3, 8), (7, 9, 7), (10, 12)]) == [6, 3, 8, 7, 9, 10, 12]", "assert extract_singly([(7, 9, 7), (13, 11, 8), (14, 6)]) == [7, 9, 13, 11, 8, 14, 6]", "assert extract_singly([(3, 7, 11), (11, 14, 8), (11, 8)]) == [3, 7, 11, 14, 8]", "assert extract_singly([(12, 12, 5), (15, 14, 13), (15, 13)]) == [12, 5, 15, 14, 13]", "assert extract_singly([(6, 7, 13), (5, 12, 10), (14, 7)]) == [6, 7, 13, 5, 12, 10, 14]", "assert extract_singly([(10, 10, 4), (14, 6, 8), (9, 9)]) == [10, 4, 14, 6, 8, 9]", "assert extract_singly([(3, 11, 9), (12, 10, 12), (5, 16)]) == [3, 11, 9, 12, 10, 5, 16]", "assert extract_singly([(4, 11, 10), (8, 10, 12), (14, 8)]) == [4, 11, 10, 8, 12, 14]", "assert extract_singly([(5, 11, 9), (13, 15, 8), (9, 13)]) == [5, 11, 9, 13, 15, 8]", "assert extract_singly([(7, 8, 5), (8, 14, 12), (13, 9)]) == [7, 8, 5, 14, 12, 13, 9]", "assert extract_singly([(5, 13, 10), (7, 11, 13), (5, 7)]) == [5, 13, 10, 7, 11]", "assert extract_singly([(12, 4, 12), (7, 16, 8), (7, 12)]) == [12, 4, 7, 16, 8]", "assert extract_singly([(9, 10, 6), (7, 7, 8), (14, 16)]) == [9, 10, 6, 7, 8, 14, 16]", "assert extract_singly([(3, 3, 9), (6, 8, 13), (7, 14)]) == [3, 9, 6, 8, 13, 7, 14]", "assert extract_singly([(9, 7, 6), (9, 8, 9), (8, 6)]) == [9, 7, 6, 8]", "assert extract_singly([(9, 13, 4), (13, 6, 15), (11, 13)]) == [9, 13, 4, 6, 15, 11]", "assert extract_singly([(10, 4, 10), (7, 14, 9), (10, 15)]) == [10, 4, 7, 14, 9, 15]", "assert extract_singly([(7, 11, 9), (10, 9, 15), (8, 12)]) == [7, 11, 9, 10, 15, 8, 12]", "assert extract_singly([(8, 7, 10), (8, 10, 13), (6, 7)]) == [8, 7, 10, 13, 6]", "assert extract_singly([(6, 8, 9), (7, 15, 11), (5, 12)]) == [6, 8, 9, 7, 15, 11, 5, 12]", "assert extract_singly([(4, 7, 7), (8, 13, 17), (11, 13)]) == [4, 7, 8, 13, 17, 11]", "assert extract_singly([(8, 7, 14), (8, 14, 7), (15, 7)]) == [8, 7, 14, 15]", "assert extract_singly([(7, 7, 11), (13, 16, 9), (15, 7)]) == [7, 11, 13, 16, 9, 15]", "assert extract_singly([(5, 8, 13), (12, 16, 9), (10, 6)]) == [5, 8, 13, 12, 16, 9, 10, 6]", "assert extract_singly([(9, 3, 5), (11, 12, 8), (9, 8)]) == [9, 3, 5, 11, 12, 8]", "assert extract_singly([(11, 12, 10), (13, 9, 12), (5, 15)]) == [11, 12, 10, 13, 9, 5, 15]", "assert extract_singly([(4, 6, 14), (6, 8, 10), (11, 11)]) == [4, 6, 14, 8, 10, 11]", "assert extract_singly([(10, 6, 7), (8, 13, 16), (14, 13)]) == [10, 6, 7, 8, 13, 16, 14]", "assert extract_singly([(12, 12, 5), (6, 14, 15), (9, 16)]) == [12, 5, 6, 14, 15, 9, 16]", "assert extract_singly([(5, 5, 6), (14, 7, 7), (9, 13)]) == [5, 6, 14, 7, 9, 13]", "assert extract_singly([(11, 8, 8), (13, 12, 15), (12, 6)]) == [11, 8, 13, 12, 15, 6]", "assert extract_singly([(9, 3, 5), (12, 13, 15), (8, 14)]) == [9, 3, 5, 12, 13, 15, 8, 14]", "assert extract_singly([(7, 4, 5), (7, 14, 10), (14, 7)]) == [7, 4, 5, 14, 10]"], "entry_point": "extract_singly", "repair_prompt": ["Write a function extract_singly to flatten the list of lists into a single set of numbers.\nextract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]\n", "Write a function extract_singly to flatten the list of lists. Convert it into a single set of numbers.\nextract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]\n", "Write a function extract_singly to flatten the list of lists into a single set of numbers.\nextract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]\n"], "completions": ["from typing import List\n## main.py\n\ndef extract_singly(list_of_lists: list[list[int]]) -> list[int]:\n    \"\"\"\n    Flattens a list of lists into a single list of unique numbers.\n\n    Parameters:\n    list_of_lists (list[list[int]]): A list containing sublists of integers.\n\n    Returns:\n    list[int]: A list of unique integers.\n    \"\"\"\n    unique_numbers = set()\n    \n    for sublist in list_of_lists:\n        for item in sublist:\n            if isinstance(item, (int, float)):  # Check if the item is numeric\n                unique_numbers.add(item)\n    \n    return list(unique_numbers)\n\n# Example usage:\n# result = extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n# print(result)  # Output: [3, 4, 5, 7, 1]\n", "from typing import List\n## main.py\n\nfrom itertools import chain\nfrom typing import List, Tuple\n\ndef extract_singly(list_of_tuples: List[Tuple[int, ...]]) -> List[int]:\n    \"\"\"\n    Flattens a list of tuples into a unique set of numbers.\n\n    Parameters:\n    list_of_tuples (list of tuples): A list where each element is a tuple of integers.\n\n    Returns:\n    list: A list of unique integers sorted in ascending order.\n    \"\"\"\n    # Flatten the list of tuples and convert to a set to remove duplicates\n    unique_numbers = set(chain.from_iterable(list_of_tuples))\n    \n    # Convert the set to a sorted list\n    sorted_unique_numbers = sorted(unique_numbers)\n    \n    return sorted_unique_numbers\n\n# Example usage:\n# result = extract_singly([(1, 2), (2, 3), (3, 4)])\n# print(result)  # Output: [1, 2, 3, 4]\n", "from typing import List\n## main.py\n\nfrom itertools import chain\n\ndef extract_singly(nested_lists: list[tuple[int]]) -> list[int]:\n    \"\"\"\n    Flattens a list of tuples into a unique list of integers.\n\n    Parameters:\n    nested_lists (list[tuple[int]]): A list containing tuples of integers.\n\n    Returns:\n    list[int]: A list of unique integers.\n    \"\"\"\n    # Flatten the list of tuples using itertools.chain.from_iterable\n    flattened_iterable = chain.from_iterable(nested_lists)\n    \n    # Convert the flattened iterable into a set to remove duplicates\n    unique_numbers_set = set(flattened_iterable)\n    \n    # Convert the set back into a list to return the result\n    return list(unique_numbers_set)\n\n# Example usage:\n# result = extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n# print(result)  # Output: [3, 4, 5, 7, 1]\n", "from typing import List\n## main.py\n\ndef extract_singly(nested_list: list[tuple[int, ...]]) -> list[int]:\n    \"\"\"\n    Flattens a list of tuples into a single list of unique numbers.\n\n    Parameters:\n    nested_list (list of tuples): A list containing tuples of integers.\n\n    Returns:\n    list: A list of unique integers.\n\n    Example:\n    >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n    [1, 3, 4, 5, 7]\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n\n    # Iterate through each tuple in the list of tuples\n    for tuple_item in nested_list:\n        # For each tuple, iterate through each number and add it to the set\n        for number in tuple_item:\n            unique_numbers.add(number)\n\n    # Convert the set back to a list and sort it to return the result\n    return sorted(unique_numbers)\n\n# Example usage\nif __name__ == \"__main__\":\n    example_input = [(3, 4, 5), (4, 5, 7), (1, 4)]\n    print(extract_singly(example_input))  # Output: [1, 3, 4, 5, 7]\n", "from typing import List\n## main.py\n\ndef extract_singly(nested_list: list[tuple[int, ...]]) -> list[int]:\n    \"\"\"\n    Flattens a list of tuples into a single list of unique numbers.\n\n    Parameters:\n    nested_list (list of tuples): A list containing tuples of integers.\n\n    Returns:\n    list: A list of unique integers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n\n    # Iterate through each tuple in the list of tuples\n    for tuple_ in nested_list:\n        # For each tuple, iterate through its elements and add them to the set\n        for number in tuple_:\n            unique_numbers.add(number)\n\n    # Convert the set back to a list to get the final output\n    return list(unique_numbers)\n\n# Example usage:\n# print(extract_singly([(1, 2, 3), (3, 4), (5, 6, 7)]))  # Output: [1, 2, 3, 4, 5, 6, 7]\n# print(extract_singly([(1, 1, 1), (1, 1)]))  # Output: [1]\n# print(extract_singly([(2, 3), (3, 2), (2, 3)]))  # Output: [2, 3]\n# print(extract_singly([]))  # Output: []\n", "from typing import List\n## main.py\n\ndef extract_singly(nested_lists: list[tuple[int]]) -> list[int]:\n    \"\"\"\n    Flattens a list of tuples into a single list of unique integers, maintaining the order of first occurrence.\n    \n    Parameters:\n    nested_lists (list of tuple of int): A list containing tuples of integers.\n    \n    Returns:\n    list of int: A list of unique integers in the order of their first occurrence.\n    \"\"\"\n    unique_numbers_set = set()\n    unique_numbers_list = []\n\n    for sublist in nested_lists:\n        for number in sublist:\n            if number not in unique_numbers_set:\n                unique_numbers_set.add(number)\n                unique_numbers_list.append(number)\n\n    return unique_numbers_list\n\n# Example usage:\n# print(extract_singly([(1, 2), (2, 3), (3, 4)]))  # Output: [1, 2, 3, 4]\n# print(extract_singly([(1, 1, 1), (2, 2), (3)]))  # Output: [1, 2, 3]\n# print(extract_singly([]))  # Output: []\n", "from typing import List\n## main.py\n\nfrom itertools import chain\nfrom typing import List\n\ndef extract_singly(list_of_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Flattens a list of lists into a single list of unique numbers, maintaining the order of first appearance.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: A list of unique integers.\n    \"\"\"\n    # Flatten the list of lists into a single iterable\n    flattened_iterable = chain.from_iterable(list_of_lists)\n    \n    # Use a set to track seen elements and a list to maintain order\n    seen = set()\n    unique_list = []\n    \n    for number in flattened_iterable:\n        if number not in seen:\n            seen.add(number)\n            unique_list.append(number)\n    \n    return unique_list\n\n# Example usage:\n# result = extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n# print(result)  # Output: [3, 4, 5, 7, 1]\n", "from typing import List\n## main.py\n\ndef extract_singly(nested_lists: list[list[tuple]]) -> list[int]:\n    \"\"\"\n    Flattens a list of lists into a single list of unique numbers.\n\n    Parameters:\n    nested_lists (list[list[tuple]]): A list containing nested tuples of numbers.\n\n    Returns:\n    list[int]: A list of unique numbers.\n    \"\"\"\n    unique_numbers = set()\n    for sublist in nested_lists:\n        for item in sublist:\n            if isinstance(item, (int, float)):  # Check if item is numeric\n                unique_numbers.add(item)\n    return list(unique_numbers)\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_input = [(3, 4, 5), (4, 5, 7), (1, 4)]\n    result = extract_singly(example_input)\n    print(result)  # Output: [3, 4, 5, 7, 1]\n", "from typing import List\n## main.py\n\nfrom itertools import chain\nfrom typing import List, Tuple\n\ndef extract_singly(input_list: List[Tuple[int, ...]]) -> List[int]:\n    \"\"\"\n    Flattens a list of tuples into a single list of unique numbers.\n\n    Parameters:\n    input_list (list of tuples): A list where each element is a tuple of integers.\n\n    Returns:\n    list: A list of unique integers.\n    \"\"\"\n    # Flatten the list of tuples and convert to a set to remove duplicates\n    unique_numbers = set(chain.from_iterable(input_list))\n    \n    # Convert the set back to a list and return\n    return list(unique_numbers)\n\n# Example usage:\n# print(extract_singly([(1, 2, 3), (3, 2, 1)]))  # Output: [1, 2, 3]\n# print(extract_singly([(1,), (1,), (1,)]))      # Output: [1]\n# print(extract_singly([]))                      # Output: []\n", "from typing import List\n## main.py\nfrom itertools import chain\n\ndef extract_singly(list_of_lists: list[list[int]]) -> list[int]:\n    '''\n    Flattens a list of lists into a single list of unique numbers.\n    \n    Parameters:\n    list_of_lists (list[list[int]]): A list containing sublists of integers.\n    \n    Returns:\n    list[int]: A flattened list of unique integers.\n    '''\n    # Flatten the list of lists using itertools.chain\n    flattened_list = chain.from_iterable(list_of_lists)\n    \n    # Convert the flattened list to a set to ensure uniqueness\n    unique_numbers_set = set(flattened_list)\n    \n    # Convert the set to a sorted list to return the result\n    sorted_unique_numbers = sorted(unique_numbers_set)\n    \n    return sorted_unique_numbers\n\n# Example usage\nif __name__ == \"__main__\":\n    example_input = [(3, 4, 5), (4, 5, 7), (1, 4)]\n    result = extract_singly(example_input)\n    print(result)  # Output: [1, 3, 4, 5, 7]\n"], "plans": ["requirement analysis:\nThe function should efficiently flatten a list of lists into a single list of unique numbers, ensuring no duplicates and maintaining performance even with large datasets.\nrequirement pool:\n- Implement the function to flatten and deduplicate the list of lists.\n- Optimize the function for performance with large datasets.\n- Ensure the function is easy to use and integrate.\n- Provide clear documentation for the function.\n- Consider edge cases such as empty lists or non-numeric data.\nWe will use Python's built-in set operations to efficiently flatten and deduplicate the list of lists. This approach ensures simplicity and high performance, especially for large datasets. The function will handle numeric data and ignore non-numeric data, as clarification on handling non-numeric data is needed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten the list of lists'\n    Explanation: This means converting a list that contains other lists into a single list containing all the elements from the sublists.\n\n    'single set of numbers'\n    Explanation: This implies that the result should be a set, which inherently removes duplicates, and only contains unique numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to store unique numbers.\n    2. Iterate through each sublist in the list of lists.\n    3. For each sublist, iterate through each number and add it to the set.\n    4. Convert the set to a list to return the result in list format.\n    5. Return the list of unique numbers.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of lists should return an empty list as there are no numbers to extract.\n\n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The numbers are extracted and duplicates are removed, resulting in a list of unique numbers.\n\n    extract_singly([(1, 2), (2, 'a'), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: Non-numeric data ('a') is ignored, and only numeric data is included in the result.\n\n# [extra code for edge case]\n    We need extra code to handle non-numeric data.\n        def extract_singly(list_of_lists):\n            unique_numbers = set()\n            for sublist in list_of_lists:\n                for item in sublist:\n                    if isinstance(item, (int, float)):  # Check if the item is numeric\n                        unique_numbers.add(item)\n            return list(unique_numbers)\n", "requirement analysis:\nThe function should efficiently flatten a list of tuples into a unique set of numbers, ensuring no duplicates and maintaining performance with large datasets.\nrequirement pool:\n- Implement the main function to flatten lists\n- Optimize for performance with large datasets\n- Ensure the function handles edge cases\n- Provide comprehensive documentation\n- Maintain compatibility with Python 3.x\nWe will use Python's built-in itertools.chain to efficiently flatten the list of tuples into a single set of numbers. This approach is optimal as it provides high performance and usability, as indicated in the competitive analysis. We will also ensure that the function handles edge cases such as empty lists or lists with non-numeric values gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten'\n    Explanation: In the requirement, \"flatten\" means converting a list of lists (or tuples) into a single list containing all the elements without any nested structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Import the `itertools.chain` module to help flatten the list of tuples.\n    2. Use `itertools.chain.from_iterable()` to iterate over each tuple in the list and extract individual elements.\n    3. Convert the result into a set to remove duplicates and then back to a list to match the expected output format.\n    4. Return the final list.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list should return an empty list as there are no elements to flatten.\n    \n    extract_singly([(1, 2), (), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The function should handle empty tuples within the list and only return the numbers present in non-empty tuples.\n    \n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The function should remove duplicates and return a list with unique numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of `set` inherently handles duplicates, and `itertools.chain` handles empty tuples gracefully.\n", "requirement analysis:\nThe function should efficiently flatten a list of lists into a unique set of numbers, ensuring no duplicates and maintaining performance even with large inputs.\nrequirement pool:\n- The function must flatten nested lists into a single list\n- The output must be a set of unique numbers\n- The function should handle large datasets efficiently\n- The function should be easy to integrate into existing codebases\n- The function should have minimal dependencies\nWe will use Python's built-in set function combined with itertools.chain to efficiently flatten the list of lists into a unique set of numbers. This approach ensures simplicity and high performance, especially for large datasets, by leveraging the efficiency of set operations and the simplicity of itertools for flattening.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten'\n    Explanation: In the requirement, \"flatten\" means to convert a list of lists into a single list containing all the elements from the sublists.\n\n    'set of numbers'\n    Explanation: This refers to a collection of unique numbers, meaning no duplicates are allowed in the final output.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Import the `itertools.chain` module to help flatten the list of lists.\n    2. Use `itertools.chain.from_iterable` to iterate over each sublist and extract all elements.\n    3. Convert the resulting iterable into a set to ensure all numbers are unique.\n    4. Convert the set back into a list if a specific order is required or return it as is if order is not important.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of lists should return an empty list since there are no elements to flatten.\n\n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The numbers 1, 2, 3, and 4 appear in the sublists, and duplicates are removed in the final set.\n\n    extract_singly([(1,), (1,), (1,)]) = [1]\n    Explanation: Even though the number 1 appears multiple times in different sublists, it should only appear once in the final set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of a set inherently handles duplicates and empty inputs.\n", "requirement analysis:\nThe function should efficiently flatten a list of lists into a single set of unique numbers. It should handle various input sizes and types, ensuring that the output is a list of unique numbers in no particular order.\nrequirement pool:\n- The function must flatten nested lists into a single set of numbers.\n- The function should handle empty lists gracefully.\n- The function should maintain compatibility with Python 3.x.\n- The function should be optimized for performance with large datasets.\n- The function should include comprehensive documentation and examples.\nWe will implement a simple Python function named `extract_singly` that takes a list of tuples as input and returns a list of unique numbers. The function will utilize Python's set data structure to ensure uniqueness and will handle empty lists gracefully. The function will be compatible with Python 3.x and will be optimized for performance with large datasets by leveraging set operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten the list of lists'\n    Explanation: This means converting a nested list structure (list of tuples) into a single list containing all the elements without any nested structure.\n\n    'single set of numbers'\n    Explanation: This implies that the resulting list should contain unique numbers, with no duplicates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to store unique numbers.\n    2. Iterate through each tuple in the list of tuples.\n    3. For each tuple, iterate through each number and add it to the set.\n    4. Convert the set back to a list to return the result.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list should return an empty list as there are no numbers to extract.\n    \n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The numbers 1, 2, 3, and 4 are extracted and duplicates are removed.\n    \n    extract_singly([(1,), (1,), (1,)]) = [1]\n    Explanation: Even if the same number appears multiple times in different tuples, it should appear only once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of a set inherently handles duplicates and empty input cases.\n", "requirement analysis:\nThe function should efficiently flatten a list of lists into a single set of unique numbers. It should handle various input sizes and types, ensuring no duplicates in the output.\nrequirement pool:\n- The function must flatten nested lists into a single set\n- The function should handle empty lists gracefully\n- The function should be optimized for performance\n- The function should include error handling for non-iterable inputs\n- The function should be compatible with Python 3.x\nWe will implement a function named `extract_singly` that takes a list of tuples as input and returns a list of unique numbers. The function will flatten the list of tuples into a single set to ensure uniqueness and then convert it back to a list for the final output. This approach ensures that the function is efficient and handles large inputs by leveraging Python's set data structure for uniqueness. We will use Python's built-in capabilities to achieve this without any additional libraries, ensuring compatibility and simplicity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten'\n    Explanation: In the requirement, 'flatten' means converting a list of lists (or tuples) into a single list containing all elements from the sublists.\n\n    'unique'\n    Explanation: The requirement specifies that the final output should contain unique numbers, meaning no duplicates should be present in the result.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to store unique numbers.\n    2. Iterate through each tuple in the list of tuples.\n    3. For each tuple, iterate through its elements and add them to the set.\n    4. Convert the set back to a list to get the final output.\n    5. Return the list of unique numbers.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of tuples should return an empty list since there are no numbers to flatten or make unique.\n\n    extract_singly([(1, 1, 1), (1, 1)]) = [1]\n    Explanation: All numbers are the same, so the unique set will only contain one element, 1.\n\n    extract_singly([(2, 3), (3, 2), (2, 3)]) = [2, 3]\n    Explanation: Although numbers repeat across tuples, the final list should only contain unique numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of a set inherently handles uniqueness and empty input scenarios.\n", "requirement analysis:\nThe function needs to efficiently flatten a list of lists into a single set of unique numbers, ensuring that the output is ordered as per the first occurrence of each number.\nrequirement pool:\n- The function should flatten nested lists into a single list\n- The function should ensure all numbers are unique\n- The function should maintain the order of first occurrence\n- The function should handle large datasets efficiently\n- The function should be easy to integrate into existing projects\nWe will use Python's built-in set and list operations to efficiently flatten the list of lists into a single list of unique numbers, maintaining the order of their first occurrence. This approach leverages the efficiency of set operations for uniqueness and list operations for order preservation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten the list of lists'\n    Explanation: This means converting a nested list structure into a single, one-dimensional list.\n\n    'single set of numbers'\n    Explanation: This means that the resulting list should contain unique numbers, with no duplicates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to store unique numbers.\n    2. Initialize an empty list to maintain the order of first occurrence.\n    3. Iterate through each sublist in the list of lists.\n    4. For each number in the sublist, check if it is not already in the set.\n    5. If it is not in the set, add it to both the set and the list.\n    6. Return the list containing unique numbers in their first occurrence order.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of lists should return an empty list since there are no numbers to extract.\n    \n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: Although '2' and '3' appear in multiple sublists, they should only appear once in the result.\n\n    extract_singly([(1, 1, 1), (2, 2), (3)]) = [1, 2, 3]\n    Explanation: Even if a number appears multiple times within a sublist, it should only appear once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of using a set to track unique numbers inherently handles duplicates and ensures uniqueness.\n", "requirement analysis:\nThe function should efficiently flatten a list of lists into a single list of unique numbers, maintaining order of first appearance. It should handle large datasets without performance degradation and be easy to integrate into existing projects.\nrequirement pool:\n- Efficiently flatten list of lists\n- Return unique numbers maintaining order\n- Handle large datasets\n- Provide clear documentation\n- Ensure compatibility with existing systems\nWe will use Python's built-in set to ensure uniqueness and itertools.chain to efficiently flatten the list of lists. This approach is efficient and handles large datasets well. The function will maintain the order of first appearance by using a list to collect the unique elements after flattening.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten the list of lists'\n    Explanation: This means converting a nested list structure into a single list containing all the elements from the sublists.\n\n    'single set of numbers'\n    Explanation: This implies that the result should contain unique numbers, with no duplicates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Use itertools.chain to flatten the list of lists into a single iterable.\n    2. Convert the iterable into a set to remove duplicates.\n    3. Convert the set back into a list to maintain the order of first appearance.\n    4. Return the list of unique numbers.\n\n# [edge case] \n    extract_singly([(1, 2, 3), (3, 2, 1)]) = [1, 2, 3]\n    Explanation: The numbers 1, 2, and 3 appear in both sublists, but only their first appearances are kept in the result.\n    \n    extract_singly([(1,), (1,), (1,)]) = [1]\n    Explanation: Even though the number 1 appears multiple times across different sublists, it should only appear once in the result.\n\n    extract_singly([]) = []\n    Explanation: An empty input should result in an empty output since there are no numbers to flatten or deduplicate.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set naturally handles duplicates, and an empty input will naturally result in an empty output.\n", "requirement analysis:\nThe function should efficiently flatten nested lists and return a unique set of numbers. It should handle various data types and be easy to integrate into existing projects.\nrequirement pool:\n- The function must flatten nested lists into a single list\n- The function must return unique numbers\n- The function should handle different data types gracefully\n- The function should be efficient with large datasets\n- The function should be easy to integrate and use\nWe will use Python's built-in set function combined with list comprehension to efficiently flatten the list of lists and ensure uniqueness. This approach is simple, effective, and handles large datasets well. We will also ensure the function can handle different data types gracefully by filtering out non-numeric data.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten': means to convert a list of lists into a single list containing all elements from the sublists.\n    'set of numbers': means that the result should contain unique numbers only, without duplicates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to store unique numbers.\n    2. Iterate through each sublist in the list of lists.\n    3. For each sublist, iterate through its elements.\n    4. Add each element to the set to ensure uniqueness.\n    5. Convert the set back to a list and return it.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of lists should return an empty list as there are no numbers to flatten.\n    \n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The numbers are flattened and duplicates are removed, resulting in a list of unique numbers.\n    \n    extract_singly([(1, 'a'), (2, 3), ('b', 4)]) = [1, 2, 3, 4]\n    Explanation: Non-numeric data is filtered out, leaving only unique numeric values.\n\n# [extra code for edge case]\n    We need extra code to handle non-numeric data.\n        def extract_singly(list_of_lists):\n            unique_numbers = set()\n            for sublist in list_of_lists:\n                for item in sublist:\n                    if isinstance(item, (int, float)):  # Check if item is numeric\n                        unique_numbers.add(item)\n            return list(unique_numbers)\n", "requirement analysis:\nThe function should take a list of tuples and return a flattened list of unique numbers. It should efficiently handle large datasets and edge cases such as empty lists or lists with non-numeric values.\nrequirement pool:\n- Implement the main function to flatten and deduplicate the list of numbers.\n- Ensure the function handles edge cases like empty lists.\n- Optimize the function for performance with large inputs.\n- Provide comprehensive documentation and examples.\n- Include unit tests to verify functionality.\nWe will use Python's built-in set and itertools.chain to efficiently flatten and deduplicate the list of numbers. This approach is optimal as it combines the high efficiency of itertools.chain for flattening and the set data structure for deduplication, ensuring the function handles large inputs effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten the list of lists'\n    Explanation: This means converting a list that contains other lists (or tuples) into a single list containing all the elements from the sublists.\n\n    'single set of numbers'\n    Explanation: This means that the result should be a collection of unique numbers, with no duplicates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Use itertools.chain to iterate over each sublist in the list of lists.\n    2. Convert the chained result into a set to remove duplicates.\n    3. Convert the set back into a list to return the result in list format.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of lists should return an empty list since there are no numbers to flatten or deduplicate.\n\n    extract_singly([(1, 2, 3), (3, 2, 1)]) = [1, 2, 3]\n    Explanation: The numbers 1, 2, and 3 appear in both sublists, but the result should only contain unique numbers.\n\n    extract_singly([(1,), (1,), (1,)]) = [1]\n    Explanation: Even if the same number appears in multiple sublists, it should only appear once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of a set inherently handles deduplication, and converting an empty input will naturally result in an empty output.\n", "requirement analysis:\nThe function should efficiently flatten a list of lists into a single list of unique numbers, ensuring both speed and accuracy. It should be easy to use and integrate into various applications.\nrequirement pool:\n- The function must flatten lists efficiently.\n- The function must return unique numbers.\n- The function should handle large datasets.\n- The function should be easy to integrate.\n- The function should have minimal resource usage.\nWe will use Python's built-in set data structure to ensure uniqueness and itertools.chain to efficiently flatten the list of lists. This approach will handle large datasets efficiently and provide accurate results with minimal resource usage.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'flatten the list of lists'\n    Explanation: This means converting a list that contains other lists into a single list containing all the elements from the sublists.\n\n    'single set of numbers'\n    Explanation: This indicates that the result should be a set, which inherently contains unique elements, meaning any duplicates should be removed.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Use itertools.chain to iterate over each sublist in the list of lists.\n    2. Convert the chained result into a set to ensure all elements are unique.\n    3. Convert the set back to a list if a list output is required, or return the set directly if not specified.\n\n# [edge case] \n    extract_singly([]) = []\n    Explanation: An empty list of lists should return an empty list as there are no elements to flatten.\n\n    extract_singly([(1, 2), (2, 3), (3, 4)]) = [1, 2, 3, 4]\n    Explanation: The numbers 2 and 3 appear in multiple sublists but should only appear once in the result due to the set's uniqueness property.\n\n    extract_singly([(1,), (1,), (1,)]) = [1]\n    Explanation: Even if the same number appears in multiple sublists, it should only appear once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of a set inherently handles duplicates and empty inputs.\n"], "test": ["def check(extract_singly):\n\tassert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]", "def check(extract_singly):\n\tassert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]", "def check(extract_singly):\n\tassert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]", "def check(extract_singly):\n\tassert extract_singly([(3, 7, 5), (7, 7, 9), (5, 2)]) == [3, 7, 5, 9, 2]", "def check(extract_singly):\n\tassert extract_singly([(3, 9, 6), (1, 6, 6), (4, 3)]) == [3, 9, 6, 1, 4]", "def check(extract_singly):\n\tassert extract_singly([(1, 7, 2), (5, 10, 5), (2, 6)]) == [1, 7, 2, 5, 10, 6]", "def check(extract_singly):\n\tassert extract_singly([(6, 8, 9), (5, 8, 11), (4, 1)]) == [6, 8, 9, 5, 11, 4, 1]", "def check(extract_singly):\n\tassert extract_singly([(6, 9, 4), (3, 9, 10), (3, 3)]) == [6, 9, 4, 3, 10]", "def check(extract_singly):\n\tassert extract_singly([(2, 4, 9), (1, 3, 12), (2, 5)]) == [2, 4, 9, 1, 3, 12, 5]", "def check(extract_singly):\n\tassert extract_singly([(8, 9, 4), (4, 6, 2), (2, 6)]) == [8, 9, 4, 6, 2]", "def check(extract_singly):\n\tassert extract_singly([(6, 4, 2), (2, 5, 12), (5, 8)]) == [6, 4, 2, 5, 12, 8]", "def check(extract_singly):\n\tassert extract_singly([(2, 6, 6), (3, 4, 2), (3, 4)]) == [2, 6, 3, 4]", "def check(extract_singly):\n\tassert extract_singly([(4, 6, 5), (8, 3, 5), (6, 9)]) == [4, 6, 5, 8, 3, 9]", "def check(extract_singly):\n\tassert extract_singly([(3, 9, 1), (4, 7, 7), (6, 4)]) == [3, 9, 1, 4, 7, 6]", "def check(extract_singly):\n\tassert extract_singly([(4, 9, 2), (6, 8, 5), (5, 1)]) == [4, 9, 2, 6, 8, 5, 1]", "def check(extract_singly):\n\tassert extract_singly([(6, 8, 10), (5, 5, 7), (4, 9)]) == [6, 8, 10, 5, 7, 4, 9]", "def check(extract_singly):\n\tassert extract_singly([(8, 1, 5), (8, 9, 6), (2, 6)]) == [8, 1, 5, 9, 6, 2]", "def check(extract_singly):\n\tassert extract_singly([(6, 1, 1), (9, 8, 6), (1, 7)]) == [6, 1, 9, 8, 7]", "def check(extract_singly):\n\tassert extract_singly([(4, 5, 5), (8, 10, 2), (5, 6)]) == [4, 5, 8, 10, 2, 6]", "def check(extract_singly):\n\tassert extract_singly([(6, 2, 8), (8, 5, 8), (6, 7)]) == [6, 2, 8, 5, 7]", "def check(extract_singly):\n\tassert extract_singly([(5, 8, 9), (2, 3, 6), (5, 6)]) == [5, 8, 9, 2, 3, 6]", "def check(extract_singly):\n\tassert extract_singly([(7, 4, 1), (6, 3, 11), (2, 1)]) == [7, 4, 1, 6, 3, 11, 2]", "def check(extract_singly):\n\tassert extract_singly([(1, 4, 2), (8, 8, 3), (4, 6)]) == [1, 4, 2, 8, 3, 6]", "def check(extract_singly):\n\tassert extract_singly([(3, 1, 2), (2, 3, 10), (5, 5)]) == [3, 1, 2, 10, 5]", "def check(extract_singly):\n\tassert extract_singly([(6, 5, 10), (7, 3, 12), (4, 1)]) == [6, 5, 10, 7, 3, 12, 4, 1]", "def check(extract_singly):\n\tassert extract_singly([(2, 6, 8), (9, 5, 4), (1, 5)]) == [2, 6, 8, 9, 5, 4, 1]", "def check(extract_singly):\n\tassert extract_singly([(4, 5, 2), (1, 1, 11), (4, 1)]) == [4, 5, 2, 1, 11]", "def check(extract_singly):\n\tassert extract_singly([(2, 4, 7), (7, 9, 4), (6, 3)]) == [2, 4, 7, 9, 6, 3]", "def check(extract_singly):\n\tassert extract_singly([(4, 8, 7), (5, 10, 11), (3, 2)]) == [4, 8, 7, 5, 10, 11, 3, 2]", "def check(extract_singly):\n\tassert extract_singly([(5, 4, 10), (7, 3, 11), (4, 4)]) == [5, 4, 10, 7, 3, 11]", "def check(extract_singly):\n\tassert extract_singly([(6, 5, 2), (8, 10, 5), (1, 1)]) == [6, 5, 2, 8, 10, 1]", "def check(extract_singly):\n\tassert extract_singly([(5, 5, 10), (5, 3, 11), (3, 9)]) == [5, 10, 3, 11, 9]", "def check(extract_singly):\n\tassert extract_singly([(2, 5, 9), (7, 5, 6), (3, 6)]) == [2, 5, 9, 7, 6, 3]", "def check(extract_singly):\n\tassert extract_singly([(2, 6, 5), (8, 2, 11), (6, 1)]) == [2, 6, 5, 8, 11, 1]", "def check(extract_singly):\n\tassert extract_singly([(1, 2, 10), (4, 2, 5), (3, 2)]) == [1, 2, 10, 4, 5, 3]", "def check(extract_singly):\n\tassert extract_singly([(8, 1, 10), (8, 3, 2), (1, 3)]) == [8, 1, 10, 3, 2]", "def check(extract_singly):\n\tassert extract_singly([(3, 7, 4), (1, 1, 5), (5, 5)]) == [3, 7, 4, 1, 5]", "def check(extract_singly):\n\tassert extract_singly([(6, 7, 1), (6, 5, 3), (11, 3)]) == [6, 7, 1, 5, 3, 11]", "def check(extract_singly):\n\tassert extract_singly([(1, 7, 4), (2, 2, 7), (2, 7)]) == [1, 7, 4, 2]", "def check(extract_singly):\n\tassert extract_singly([(4, 2, 3), (3, 7, 7), (2, 5)]) == [4, 2, 3, 7, 5]", "def check(extract_singly):\n\tassert extract_singly([(5, 6, 1), (7, 4, 3), (6, 4)]) == [5, 6, 1, 7, 4, 3]", "def check(extract_singly):\n\tassert extract_singly([(4, 1, 4), (8, 2, 5), (10, 12)]) == [4, 1, 8, 2, 5, 10, 12]", "def check(extract_singly):\n\tassert extract_singly([(6, 1, 2), (8, 2, 5), (4, 9)]) == [6, 1, 2, 8, 5, 4, 9]", "def check(extract_singly):\n\tassert extract_singly([(1, 5, 3), (9, 2, 6), (10, 4)]) == [1, 5, 3, 9, 2, 6, 10, 4]", "def check(extract_singly):\n\tassert extract_singly([(4, 3, 8), (6, 1, 6), (12, 12)]) == [4, 3, 8, 6, 1, 12]", "def check(extract_singly):\n\tassert extract_singly([(4, 7, 5), (9, 5, 3), (11, 11)]) == [4, 7, 5, 9, 3, 11]", "def check(extract_singly):\n\tassert extract_singly([(5, 3, 6), (4, 6, 3), (2, 7)]) == [5, 3, 6, 4, 2, 7]", "def check(extract_singly):\n\tassert extract_singly([(5, 1, 8), (1, 7, 8), (7, 9)]) == [5, 1, 8, 7, 9]", "def check(extract_singly):\n\tassert extract_singly([(4, 7, 1), (3, 2, 1), (11, 3)]) == [4, 7, 1, 3, 2, 11]", "def check(extract_singly):\n\tassert extract_singly([(6, 3, 6), (1, 2, 2), (8, 9)]) == [6, 3, 1, 2, 8, 9]", "def check(extract_singly):\n\tassert extract_singly([(5, 1, 4), (5, 3, 1), (2, 9)]) == [5, 1, 4, 3, 2, 9]", "def check(extract_singly):\n\tassert extract_singly([(2, 2, 2), (6, 5, 8), (12, 3)]) == [2, 6, 5, 8, 12, 3]", "def check(extract_singly):\n\tassert extract_singly([(5, 4, 3), (1, 5, 2), (12, 5)]) == [5, 4, 3, 1, 2, 12]", "def check(extract_singly):\n\tassert extract_singly([(4, 3, 4), (7, 2, 3), (8, 10)]) == [4, 3, 7, 2, 8, 10]", "def check(extract_singly):\n\tassert extract_singly([(3, 3, 4), (4, 1, 4), (4, 9)]) == [3, 4, 1, 9]", "def check(extract_singly):\n\tassert extract_singly([(5, 4, 3), (3, 5, 1), (3, 10)]) == [5, 4, 3, 1, 10]", "def check(extract_singly):\n\tassert extract_singly([(3, 7, 1), (6, 4, 8), (8, 8)]) == [3, 7, 1, 6, 4, 8]", "def check(extract_singly):\n\tassert extract_singly([(6, 3, 8), (3, 1, 1), (9, 13)]) == [6, 3, 8, 1, 9, 13]", "def check(extract_singly):\n\tassert extract_singly([(6, 2, 1), (2, 3, 6), (4, 13)]) == [6, 2, 1, 3, 4, 13]", "def check(extract_singly):\n\tassert extract_singly([(3, 7, 2), (8, 4, 1), (2, 10)]) == [3, 7, 2, 8, 4, 1, 10]", "def check(extract_singly):\n\tassert extract_singly([(5, 7, 4), (4, 7, 1), (11, 5)]) == [5, 7, 4, 1, 11]", "def check(extract_singly):\n\tassert extract_singly([(3, 3, 3), (4, 1, 7), (8, 12)]) == [3, 4, 1, 7, 8, 12]", "def check(extract_singly):\n\tassert extract_singly([(3, 5, 7), (6, 1, 8), (4, 7)]) == [3, 5, 7, 6, 1, 8, 4]", "def check(extract_singly):\n\tassert extract_singly([(2, 2, 2), (6, 4, 8), (12, 6)]) == [2, 6, 4, 8, 12]", "def check(extract_singly):\n\tassert extract_singly([(1, 2, 3), (8, 2, 7), (6, 4)]) == [1, 2, 3, 8, 7, 6, 4]", "def check(extract_singly):\n\tassert extract_singly([(5, 4, 1), (9, 6, 3), (6, 3)]) == [5, 4, 1, 9, 6, 3]", "def check(extract_singly):\n\tassert extract_singly([(6, 3, 4), (3, 1, 4), (6, 6)]) == [6, 3, 4, 1]", "def check(extract_singly):\n\tassert extract_singly([(1, 4, 1), (6, 3, 2), (10, 3)]) == [1, 4, 6, 3, 2, 10]", "def check(extract_singly):\n\tassert extract_singly([(2, 5, 7), (3, 2, 8), (12, 7)]) == [2, 5, 7, 3, 8, 12]", "def check(extract_singly):\n\tassert extract_singly([(6, 3, 8), (7, 9, 7), (10, 12)]) == [6, 3, 8, 7, 9, 10, 12]", "def check(extract_singly):\n\tassert extract_singly([(7, 9, 7), (13, 11, 8), (14, 6)]) == [7, 9, 13, 11, 8, 14, 6]", "def check(extract_singly):\n\tassert extract_singly([(3, 7, 11), (11, 14, 8), (11, 8)]) == [3, 7, 11, 14, 8]", "def check(extract_singly):\n\tassert extract_singly([(12, 12, 5), (15, 14, 13), (15, 13)]) == [12, 5, 15, 14, 13]", "def check(extract_singly):\n\tassert extract_singly([(6, 7, 13), (5, 12, 10), (14, 7)]) == [6, 7, 13, 5, 12, 10, 14]", "def check(extract_singly):\n\tassert extract_singly([(10, 10, 4), (14, 6, 8), (9, 9)]) == [10, 4, 14, 6, 8, 9]", "def check(extract_singly):\n\tassert extract_singly([(3, 11, 9), (12, 10, 12), (5, 16)]) == [3, 11, 9, 12, 10, 5, 16]", "def check(extract_singly):\n\tassert extract_singly([(4, 11, 10), (8, 10, 12), (14, 8)]) == [4, 11, 10, 8, 12, 14]", "def check(extract_singly):\n\tassert extract_singly([(5, 11, 9), (13, 15, 8), (9, 13)]) == [5, 11, 9, 13, 15, 8]", "def check(extract_singly):\n\tassert extract_singly([(7, 8, 5), (8, 14, 12), (13, 9)]) == [7, 8, 5, 14, 12, 13, 9]", "def check(extract_singly):\n\tassert extract_singly([(5, 13, 10), (7, 11, 13), (5, 7)]) == [5, 13, 10, 7, 11]", "def check(extract_singly):\n\tassert extract_singly([(12, 4, 12), (7, 16, 8), (7, 12)]) == [12, 4, 7, 16, 8]", "def check(extract_singly):\n\tassert extract_singly([(9, 10, 6), (7, 7, 8), (14, 16)]) == [9, 10, 6, 7, 8, 14, 16]", "def check(extract_singly):\n\tassert extract_singly([(3, 3, 9), (6, 8, 13), (7, 14)]) == [3, 9, 6, 8, 13, 7, 14]", "def check(extract_singly):\n\tassert extract_singly([(9, 7, 6), (9, 8, 9), (8, 6)]) == [9, 7, 6, 8]", "def check(extract_singly):\n\tassert extract_singly([(9, 13, 4), (13, 6, 15), (11, 13)]) == [9, 13, 4, 6, 15, 11]", "def check(extract_singly):\n\tassert extract_singly([(10, 4, 10), (7, 14, 9), (10, 15)]) == [10, 4, 7, 14, 9, 15]", "def check(extract_singly):\n\tassert extract_singly([(7, 11, 9), (10, 9, 15), (8, 12)]) == [7, 11, 9, 10, 15, 8, 12]", "def check(extract_singly):\n\tassert extract_singly([(8, 7, 10), (8, 10, 13), (6, 7)]) == [8, 7, 10, 13, 6]", "def check(extract_singly):\n\tassert extract_singly([(6, 8, 9), (7, 15, 11), (5, 12)]) == [6, 8, 9, 7, 15, 11, 5, 12]", "def check(extract_singly):\n\tassert extract_singly([(4, 7, 7), (8, 13, 17), (11, 13)]) == [4, 7, 8, 13, 17, 11]", "def check(extract_singly):\n\tassert extract_singly([(8, 7, 14), (8, 14, 7), (15, 7)]) == [8, 7, 14, 15]", "def check(extract_singly):\n\tassert extract_singly([(7, 7, 11), (13, 16, 9), (15, 7)]) == [7, 11, 13, 16, 9, 15]", "def check(extract_singly):\n\tassert extract_singly([(5, 8, 13), (12, 16, 9), (10, 6)]) == [5, 8, 13, 12, 16, 9, 10, 6]", "def check(extract_singly):\n\tassert extract_singly([(9, 3, 5), (11, 12, 8), (9, 8)]) == [9, 3, 5, 11, 12, 8]", "def check(extract_singly):\n\tassert extract_singly([(11, 12, 10), (13, 9, 12), (5, 15)]) == [11, 12, 10, 13, 9, 5, 15]", "def check(extract_singly):\n\tassert extract_singly([(4, 6, 14), (6, 8, 10), (11, 11)]) == [4, 6, 14, 8, 10, 11]", "def check(extract_singly):\n\tassert extract_singly([(10, 6, 7), (8, 13, 16), (14, 13)]) == [10, 6, 7, 8, 13, 16, 14]", "def check(extract_singly):\n\tassert extract_singly([(12, 12, 5), (6, 14, 15), (9, 16)]) == [12, 5, 6, 14, 15, 9, 16]", "def check(extract_singly):\n\tassert extract_singly([(5, 5, 6), (14, 7, 7), (9, 13)]) == [5, 6, 14, 7, 9, 13]", "def check(extract_singly):\n\tassert extract_singly([(11, 8, 8), (13, 12, 15), (12, 6)]) == [11, 8, 13, 12, 15, 6]", "def check(extract_singly):\n\tassert extract_singly([(9, 3, 5), (12, 13, 15), (8, 14)]) == [9, 3, 5, 12, 13, 15, 8, 14]", "def check(extract_singly):\n\tassert extract_singly([(7, 4, 5), (7, 14, 10), (14, 7)]) == [7, 4, 5, 14, 10]"], "scores": [0.0196, 0.0196, 0.0196, 0.0196, 0.0196, 1.0, 1.0, 0.0196, 0.0196, 0.0196], "pass_results": [false, false, false, false, false, true, true, false, false, false], "pass_test_cases_num": [2, 2, 2, 2, 2, 102, 102, 2, 2, 2], "completion": "from typing import List\n## main.py\n\nfrom itertools import chain\nfrom typing import List\n\ndef extract_singly(list_of_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Flattens a list of lists into a single list of unique numbers, maintaining the order of first appearance.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: A list of unique integers.\n    \"\"\"\n    # Flatten the list of lists into a single iterable\n    flattened_iterable = chain.from_iterable(list_of_lists)\n    \n    # Use a set to track seen elements and a list to maintain order\n    seen = set()\n    unique_list = []\n    \n    for number in flattened_iterable:\n        if number not in seen:\n            seen.add(number)\n            unique_list.append(number)\n    \n    return unique_list\n\n# Example usage:\n# result = extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n# print(result)  # Output: [3, 4, 5, 7, 1]\n", "passed": true, "pass": true, "pass_num": 2, "round": 59, "mutate_method": "condense_two2one", "parent_index": 59}
