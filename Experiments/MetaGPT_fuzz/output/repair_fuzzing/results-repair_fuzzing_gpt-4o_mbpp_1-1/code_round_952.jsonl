{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 71, "prompt": "Write a function to sort a list of elements. Sorting a list involves arranging its elements in a specific order. This order can be either ascending. It can also be descending based on the requirements.", "code": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums", "test_imports": [], "test_list": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]", "assert comb_sort([7, 10, 39, 29, 78]) == [7, 10, 29, 39, 78]", "assert comb_sort([2, 19, 41, 28, 75]) == [2, 19, 28, 41, 75]", "assert comb_sort([9, 11, 37, 30, 83]) == [9, 11, 30, 37, 83]", "assert comb_sort([2, 10, 37, 27, 76]) == [2, 10, 27, 37, 76]", "assert comb_sort([1, 11, 37, 27, 75]) == [1, 11, 27, 37, 75]", "assert comb_sort([9, 12, 33, 24, 84]) == [9, 12, 24, 33, 84]", "assert comb_sort([10, 14, 41, 25, 82]) == [10, 14, 25, 41, 82]", "assert comb_sort([3, 20, 38, 27, 75]) == [3, 20, 27, 38, 75]", "assert comb_sort([7, 12, 40, 26, 76]) == [7, 12, 26, 40, 76]", "assert comb_sort([2, 19, 38, 24, 84]) == [2, 19, 24, 38, 84]", "assert comb_sort([3, 11, 34, 23, 77]) == [3, 11, 23, 34, 77]", "assert comb_sort([1, 12, 34, 20, 81]) == [1, 12, 20, 34, 81]", "assert comb_sort([6, 15, 38, 26, 77]) == [6, 15, 26, 38, 77]", "assert comb_sort([6, 10, 38, 22, 84]) == [6, 10, 22, 38, 84]", "assert comb_sort([7, 16, 38, 28, 75]) == [7, 16, 28, 38, 75]", "assert comb_sort([1, 14, 37, 26, 75]) == [1, 14, 26, 37, 75]", "assert comb_sort([8, 18, 36, 29, 80]) == [8, 18, 29, 36, 80]", "assert comb_sort([4, 16, 37, 28, 79]) == [4, 16, 28, 37, 79]", "assert comb_sort([8, 11, 37, 24, 84]) == [8, 11, 24, 37, 84]", "assert comb_sort([4, 10, 32, 25, 75]) == [4, 10, 25, 32, 75]", "assert comb_sort([2, 17, 38, 20, 78]) == [2, 17, 20, 38, 78]", "assert comb_sort([1, 16, 41, 30, 82]) == [1, 16, 30, 41, 82]", "assert comb_sort([5, 12, 32, 25, 83]) == [5, 12, 25, 32, 83]", "assert comb_sort([5, 13, 32, 28, 74]) == [5, 13, 28, 32, 74]", "assert comb_sort([6, 20, 40, 26, 79]) == [6, 20, 26, 40, 79]", "assert comb_sort([1, 10, 34, 22, 80]) == [1, 10, 22, 34, 80]", "assert comb_sort([7, 10, 39, 20, 83]) == [7, 10, 20, 39, 83]", "assert comb_sort([1, 20, 38, 24, 74]) == [1, 20, 24, 38, 74]", "assert comb_sort([3, 14, 42, 29, 80]) == [3, 14, 29, 42, 80]", "assert comb_sort([4, 13, 38, 28, 83]) == [4, 13, 28, 38, 83]", "assert comb_sort([2, 20, 33, 24, 80]) == [2, 20, 24, 33, 80]", "assert comb_sort([2, 13, 32, 25, 79]) == [2, 13, 25, 32, 79]", "assert comb_sort([7, 12, 33, 29, 76]) == [7, 12, 29, 33, 76]", "assert comb_sort([42, 36, 20, 21, 24]) == [20, 21, 24, 36, 42]", "assert comb_sort([37, 32, 20, 21, 18]) == [18, 20, 21, 32, 37]", "assert comb_sort([36, 27, 16, 24, 21]) == [16, 21, 24, 27, 36]", "assert comb_sort([42, 27, 11, 19, 25]) == [11, 19, 25, 27, 42]", "assert comb_sort([43, 31, 19, 24, 23]) == [19, 23, 24, 31, 43]", "assert comb_sort([37, 31, 13, 16, 25]) == [13, 16, 25, 31, 37]", "assert comb_sort([40, 34, 14, 17, 26]) == [14, 17, 26, 34, 40]", "assert comb_sort([36, 27, 17, 20, 20]) == [17, 20, 20, 27, 36]", "assert comb_sort([44, 37, 15, 19, 20]) == [15, 19, 20, 37, 44]", "assert comb_sort([44, 32, 11, 14, 23]) == [11, 14, 23, 32, 44]", "assert comb_sort([45, 27, 19, 14, 23]) == [14, 19, 23, 27, 45]", "assert comb_sort([46, 35, 18, 22, 21]) == [18, 21, 22, 35, 46]", "assert comb_sort([40, 31, 10, 20, 25]) == [10, 20, 25, 31, 40]", "assert comb_sort([45, 34, 11, 17, 21]) == [11, 17, 21, 34, 45]", "assert comb_sort([43, 28, 18, 21, 27]) == [18, 21, 27, 28, 43]", "assert comb_sort([40, 34, 14, 16, 22]) == [14, 16, 22, 34, 40]", "assert comb_sort([41, 31, 15, 22, 26]) == [15, 22, 26, 31, 41]", "assert comb_sort([43, 31, 17, 22, 27]) == [17, 22, 27, 31, 43]", "assert comb_sort([44, 29, 18, 22, 19]) == [18, 19, 22, 29, 44]", "assert comb_sort([42, 27, 11, 14, 26]) == [11, 14, 26, 27, 42]", "assert comb_sort([38, 32, 12, 14, 17]) == [12, 14, 17, 32, 38]", "assert comb_sort([46, 33, 18, 14, 18]) == [14, 18, 18, 33, 46]", "assert comb_sort([46, 34, 20, 17, 25]) == [17, 20, 25, 34, 46]", "assert comb_sort([43, 36, 10, 20, 26]) == [10, 20, 26, 36, 43]", "assert comb_sort([43, 28, 11, 20, 24]) == [11, 20, 24, 28, 43]", "assert comb_sort([42, 36, 12, 14, 26]) == [12, 14, 26, 36, 42]", "assert comb_sort([38, 29, 10, 23, 21]) == [10, 21, 23, 29, 38]", "assert comb_sort([41, 30, 19, 14, 18]) == [14, 18, 19, 30, 41]", "assert comb_sort([38, 37, 17, 19, 25]) == [17, 19, 25, 37, 38]", "assert comb_sort([44, 28, 16, 22, 18]) == [16, 18, 22, 28, 44]", "assert comb_sort([41, 31, 13, 14, 23]) == [13, 14, 23, 31, 41]", "assert comb_sort([45, 36, 20, 18, 21]) == [18, 20, 21, 36, 45]", "assert comb_sort([44, 31, 15, 24, 17]) == [15, 17, 24, 31, 44]", "assert comb_sort([97, 13, 17, 45]) == [13, 17, 45, 97]", "assert comb_sort([96, 10, 11, 48]) == [10, 11, 48, 96]", "assert comb_sort([97, 16, 12, 45]) == [12, 16, 45, 97]", "assert comb_sort([95, 13, 16, 51]) == [13, 16, 51, 95]", "assert comb_sort([104, 11, 18, 48]) == [11, 18, 48, 104]", "assert comb_sort([96, 10, 16, 48]) == [10, 16, 48, 96]", "assert comb_sort([95, 18, 8, 52]) == [8, 18, 52, 95]", "assert comb_sort([98, 15, 9, 43]) == [9, 15, 43, 98]", "assert comb_sort([94, 18, 8, 45]) == [8, 18, 45, 94]", "assert comb_sort([100, 11, 16, 47]) == [11, 16, 47, 100]", "assert comb_sort([103, 20, 10, 44]) == [10, 20, 44, 103]", "assert comb_sort([100, 10, 15, 48]) == [10, 15, 48, 100]", "assert comb_sort([100, 12, 15, 46]) == [12, 15, 46, 100]", "assert comb_sort([102, 16, 11, 42]) == [11, 16, 42, 102]", "assert comb_sort([99, 16, 15, 48]) == [15, 16, 48, 99]", "assert comb_sort([95, 14, 14, 42]) == [14, 14, 42, 95]", "assert comb_sort([98, 20, 12, 45]) == [12, 20, 45, 98]", "assert comb_sort([104, 19, 9, 42]) == [9, 19, 42, 104]", "assert comb_sort([100, 12, 16, 48]) == [12, 16, 48, 100]", "assert comb_sort([104, 16, 12, 42]) == [12, 16, 42, 104]", "assert comb_sort([94, 20, 17, 44]) == [17, 20, 44, 94]", "assert comb_sort([97, 16, 16, 43]) == [16, 16, 43, 97]", "assert comb_sort([100, 15, 9, 48]) == [9, 15, 48, 100]", "assert comb_sort([100, 14, 11, 51]) == [11, 14, 51, 100]", "assert comb_sort([98, 14, 9, 52]) == [9, 14, 52, 98]", "assert comb_sort([104, 10, 15, 51]) == [10, 15, 51, 104]", "assert comb_sort([99, 12, 13, 49]) == [12, 13, 49, 99]", "assert comb_sort([94, 14, 11, 49]) == [11, 14, 49, 94]", "assert comb_sort([102, 11, 15, 44]) == [11, 15, 44, 102]", "assert comb_sort([97, 11, 10, 42]) == [10, 11, 42, 97]", "assert comb_sort([102, 13, 17, 45]) == [13, 17, 45, 102]", "assert comb_sort([94, 12, 16, 46]) == [12, 16, 46, 94]", "assert comb_sort([97, 15, 12, 49]) == [12, 15, 49, 97]"], "entry_point": "comb_sort", "repair_prompt": ["Write a function comb_sort to sort a list of elements. Sorting a list involves arranging its elements in a specific order. This order can be either ascending. It can also be descending based on the requirements.\ncomb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n", "Write a function comb_sort to sort a list of elements. Sorting a list involves arranging its elements in a specific order. The specific order can be either ascending. The order can also be descending based on the requirements.\ncomb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n", "Write a function comb_sort to sort a list of elements. Sorting a list involves arranging its elements in a specific order, which can be either ascending or descending based on the requirements.\ncomb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n"], "completions": ["from typing import List\n## main.py\n\ndef comb_sort(arr: list, order: str = 'ascending') -> list:\n    \"\"\"\n    Sorts a list using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    order (str): The order of sorting, either 'ascending' or 'descending'. Default is 'ascending'.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def swap_elements(i: int, j: int):\n        \"\"\"Helper function to swap elements at indices i and j.\"\"\"\n        arr[i], arr[j] = arr[j], arr[i]\n\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        # Update the gap for the next pass\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True  # Assume sorted, will verify in the final pass\n\n        # Perform a single pass with the current gap\n        for i in range(len(arr) - gap):\n            if (order == 'ascending' and arr[i] > arr[i + gap]) or (order == 'descending' and arr[i] < arr[i + gap]):\n                swap_elements(i, i + gap)\n                sorted = False  # If a swap is made, the list is not sorted\n\n    return arr\n\n# Example usage:\n# sorted_list = comb_sort([64, 34, 25, 12, 22, 11, 90], 'ascending')\n# print(sorted_list)\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, order: str = 'ascending') -> list:\n    \"\"\"\n    Sorts a list using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    order (str): The order of sorting, either 'ascending' or 'descending'.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def swap_elements(i: int, j: int):\n        \"\"\"Helper function to swap elements at indices i and j.\"\"\"\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def should_swap(x, y) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the sorting order.\"\"\"\n        if order == 'ascending':\n            return x > y\n        elif order == 'descending':\n            return x < y\n        else:\n            raise ValueError(\"Order must be either 'ascending' or 'descending'.\")\n\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        # Update the gap for the next iteration\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True  # Assume sorted, will verify in the final pass\n\n        # Perform a single pass of comb sort\n        for i in range(len(arr) - gap):\n            if should_swap(arr[i], arr[i + gap]):\n                swap_elements(i, i + gap)\n                sorted = False  # If a swap is made, the list is not sorted\n\n    return arr\n\n# Example usage:\n# sorted_list = comb_sort([64, 34, 25, 12, 22, 11, 90], 'ascending')\n# print(sorted_list)\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, ascending: bool = True) -> list:\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    ascending (bool): If True, sort the list in ascending order; if False, sort in descending order.\n\n    Returns:\n    list: The sorted list of elements.\n    \"\"\"\n    def swap_elements(i: int, j: int):\n        \"\"\"Helper function to swap elements at indices i and j.\"\"\"\n        arr[i], arr[j] = arr[j], arr[i]\n\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while gap > 1 or not sorted:\n        # Calculate new gap\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n\n        sorted = True  # Assume the list is sorted\n        for i in range(len(arr) - gap):\n            # Compare and swap elements if needed\n            if (ascending and arr[i] > arr[i + gap]) or (not ascending and arr[i] < arr[i + gap]):\n                swap_elements(i, i + gap)\n                sorted = False  # If a swap is made, the list is not sorted\n\n    return arr\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_list = [64, 34, 25, 12, 22, 11, 90]\n    print(\"Original list:\", example_list)\n    sorted_list_asc = comb_sort(example_list, ascending=True)\n    print(\"Sorted list (ascending):\", sorted_list_asc)\n    sorted_list_desc = comb_sort(example_list, ascending=False)\n    print(\"Sorted list (descending):\", sorted_list_desc)\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, order: str = 'ascending') -> list:\n    \"\"\"\n    Sorts a list using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    order (str): The order of sorting, either 'ascending' or 'descending'.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def get_next_gap(gap: int) -> int:\n        \"\"\"Calculate the next gap size.\"\"\"\n        # Shrink factor is commonly 1.3\n        gap = int(gap / 1.3)\n        if gap < 1:\n            return 1\n        return gap\n\n    def should_swap(a, b, order: str) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the order.\"\"\"\n        if order == 'ascending':\n            return a > b\n        elif order == 'descending':\n            return a < b\n        else:\n            raise ValueError(\"Order must be either 'ascending' or 'descending'\")\n\n    n = len(arr)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n\n        for i in range(n - gap):\n            if should_swap(arr[i], arr[i + gap], order):\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr\n\n# Example usage:\n# sorted_list = comb_sort([64, 34, 25, 12, 22, 11, 90], 'ascending')\n# print(sorted_list)\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, ascending: bool = True) -> list:\n    '''\n    Sorts a list using the comb sort algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    ascending (bool): If True, sort in ascending order; if False, sort in descending order.\n    \n    Returns:\n    list: The sorted list.\n    '''\n    def swap_elements(i: int, j: int):\n        \"\"\"Helper function to swap elements at indices i and j.\"\"\"\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def should_swap(x, y) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the sorting order.\"\"\"\n        return (x > y) if ascending else (x < y)\n\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while gap > 1 or not sorted:\n        # Update the gap for the next pass\n        gap = max(1, int(gap / shrink_factor))\n        sorted = True  # Assume the list is sorted\n\n        for i in range(len(arr) - gap):\n            if should_swap(arr[i], arr[i + gap]):\n                swap_elements(i, i + gap)\n                sorted = False  # If a swap is made, the list is not sorted\n\n    return arr\n\n# Example usage:\nif __name__ == \"__main__\":\n    print(comb_sort([5, 3, 8, 4, 2], ascending=True))  # Output: [2, 3, 4, 5, 8]\n    print(comb_sort([5, 3, 8, 4, 2], ascending=False)) # Output: [8, 5, 4, 3, 2]\n    print(comb_sort([]))                               # Output: []\n    print(comb_sort([1]))                              # Output: [1]\n    print(comb_sort([2, 1], ascending=False))          # Output: [2, 1]\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, order: str = 'ascending') -> list:\n    '''\n    Sorts a list using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    order (str): The order of sorting, either 'ascending' or 'descending'. Default is 'ascending'.\n\n    Returns:\n    list: The sorted list.\n    '''\n    def swap_elements(i: int, j: int):\n        \"\"\"Swap elements at indices i and j in the list.\"\"\"\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def should_swap(x, y) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the sorting order.\"\"\"\n        if order == 'ascending':\n            return x > y\n        elif order == 'descending':\n            return x < y\n        else:\n            raise ValueError(\"Order must be either 'ascending' or 'descending'.\")\n\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while gap > 1 or not sorted:\n        # Update the gap for the next comb\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n\n        sorted = True  # Assume the list is sorted\n        for i in range(len(arr) - gap):\n            if should_swap(arr[i], arr[i + gap]):\n                swap_elements(i, i + gap)\n                sorted = False  # If a swap is made, the list is not sorted\n\n    return arr\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_list = [64, 34, 25, 12, 22, 11, 90]\n    print(\"Original list:\", example_list)\n    sorted_list = comb_sort(example_list, order='ascending')\n    print(\"Sorted list (ascending):\", sorted_list)\n    sorted_list_desc = comb_sort(example_list, order='descending')\n    print(\"Sorted list (descending):\", sorted_list_desc)\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, ascending: bool = True) -> list:\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    ascending (bool): If True, sorts the list in ascending order; if False, sorts in descending order.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def get_next_gap(gap: int) -> int:\n        \"\"\"Calculate the next gap size.\"\"\"\n        # Shrink factor is commonly 1.3\n        gap = int(gap / 1.3)\n        if gap < 1:\n            return 1\n        return gap\n\n    n = len(arr)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n\n        for i in range(n - gap):\n            if (ascending and arr[i] > arr[i + gap]) or (not ascending and arr[i] < arr[i + gap]):\n                # Swap elements if they are out of order\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_list = [5, 15, 37, 25, 79]\n    sorted_list = comb_sort(example_list, ascending=True)\n    print(sorted_list)  # Output: [5, 15, 25, 37, 79]\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list) -> list:\n    \"\"\"\n    Sorts a list of elements in ascending order using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: A new list with elements sorted in ascending order.\n    \"\"\"\n    # Initialize the gap as the length of the list\n    gap = len(arr)\n    # Set a shrink factor, typically 1.3, to reduce the gap\n    shrink_factor = 1.3\n    # Initialize a flag to check if any swaps were made\n    swapped = True\n\n    # Continue sorting while the gap is greater than 1 or swaps were made\n    while gap > 1 or swapped:\n        # Reduce the gap by dividing it by the shrink factor and rounding down\n        gap = max(1, int(gap // shrink_factor))\n        swapped = False\n\n        # Iterate through the list, comparing elements that are 'gap' positions apart\n        for i in range(len(arr) - gap):\n            # Swap elements if they are out of order\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_list = [5, 15, 37, 25, 79]\n    sorted_list = comb_sort(example_list)\n    print(sorted_list)  # Output: [5, 15, 25, 37, 79]\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, order: str = 'ascending') -> list:\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    order (str): The order of sorting, either 'ascending' or 'descending'. Default is 'ascending'.\n\n    Returns:\n    list: A new list with elements sorted in the specified order.\n    \"\"\"\n    def swap_elements(i: int, j: int):\n        \"\"\"Helper function to swap elements at indices i and j.\"\"\"\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def should_swap(a, b) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the sorting order.\"\"\"\n        if order == 'ascending':\n            return a > b\n        elif order == 'descending':\n            return a < b\n        else:\n            raise ValueError(\"Order must be either 'ascending' or 'descending'.\")\n\n    n = len(arr)\n    gap = n\n    shrink_factor = 1.3\n    sorted = False\n\n    while gap > 1 or not sorted:\n        gap = max(1, int(gap / shrink_factor))\n        sorted = True\n\n        for i in range(n - gap):\n            if should_swap(arr[i], arr[i + gap]):\n                swap_elements(i, i + gap)\n                sorted = False\n\n    return arr\n\n# Example usage:\n# sorted_list_asc = comb_sort([5, 15, 37, 25, 79], 'ascending')\n# sorted_list_desc = comb_sort([5, 15, 37, 25, 79], 'descending')\n", "from typing import List\n## main.py\n\ndef comb_sort(arr: list, ascending: bool = True) -> list:\n    \"\"\"\n    Sorts a list using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    ascending (bool): If True, sort in ascending order; if False, sort in descending order.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def get_next_gap(gap: int) -> int:\n        \"\"\"Calculate the next gap size.\"\"\"\n        # Shrink factor is commonly 1.3\n        gap = int(gap / 1.3)\n        if gap < 1:\n            return 1\n        return gap\n\n    def should_swap(x, y) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the sorting order.\"\"\"\n        if ascending:\n            return x > y\n        else:\n            return x < y\n\n    n = len(arr)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n\n        for i in range(n - gap):\n            if should_swap(arr[i], arr[i + gap]):\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr\n\n# Example usage:\n# sorted_list = comb_sort([64, 34, 25, 12, 22, 11, 90], ascending=True)\n# print(sorted_list)\n"], "plans": ["requirement analysis:\nThe requirement is to implement a comb sort function that can sort lists in both ascending and descending order. The function should be efficient and capable of handling large datasets. It should provide flexibility in sorting order based on user preference.\nrequirement pool:\n- Implement comb sort algorithm\n- Allow sorting in ascending and descending order\n- Optimize for large datasets\n- Ensure algorithm efficiency\n- Provide user-friendly interface for sorting options\nWe will implement the comb sort algorithm, which is an improvement over bubble sort. It uses a gap sequence to compare elements and gradually reduces the gap until it becomes 1, at which point it functions like a bubble sort. This approach is efficient for large datasets. We will provide an option to sort in either ascending or descending order based on user preference.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a sorting algorithm that improves on bubble sort by using a gap sequence to compare elements. It starts with a large gap and reduces it gradually until it becomes 1, at which point it functions like bubble sort.\n\n    'ascending/descending order'\n    Explanation: Sorting order refers to the arrangement of elements in either increasing (ascending) or decreasing (descending) order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define the comb_sort function with parameters for the list and sorting order.\n    2. Initialize the gap as the length of the list.\n    3. Set a shrink factor, typically 1.3, to reduce the gap.\n    4. Use a loop to continue sorting until the gap is reduced to 1.\n    5. Inside the loop, iterate through the list and compare elements separated by the current gap.\n    6. Swap elements if they are out of order based on the specified sorting order.\n    7. Reduce the gap using the shrink factor.\n    8. Once the gap is 1, perform a final pass similar to bubble sort to ensure the list is fully sorted.\n    9. Return the sorted list.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list has no elements to sort, so the expected output is an empty list.\n\n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n\n    comb_sort([5, 5, 5, 5]) = [5, 5, 5, 5]\n    Explanation: A list with identical elements is already sorted regardless of order, so the expected output is the same list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort inherently handles these cases by not performing unnecessary operations on lists that are already sorted or contain insufficient elements for sorting.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort a list of elements in either ascending or descending order. The function should be efficient and flexible to handle different sorting orders based on user input.\nrequirement pool:\n- Implement comb sort algorithm\n- Allow sorting in ascending and descending order\n- Optimize for large datasets\n- Ensure compatibility with Python lists\n- Provide clear documentation\nWe will implement the comb sort algorithm, which is an improvement over bubble sort. It works by comparing elements at a certain gap and reducing the gap over iterations until it becomes 1, at which point it functions like a bubble sort. We will use Python's native list operations to ensure compatibility and efficiency. The function will accept a parameter to specify the sorting order, either ascending or descending.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a sorting algorithm that improves on bubble sort by using a gap to compare elements, reducing the gap over iterations until it becomes 1, at which point it functions like a bubble sort.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending': means arranging elements from smallest to largest\n    'descending': means arranging elements from largest to smallest\n\n# [code logic]\n    1. Define the comb_sort function with parameters for the list and sorting order.\n    2. Initialize the gap as the length of the list.\n    3. Set a shrink factor (commonly 1.3) to reduce the gap.\n    4. Use a loop to continue sorting until the gap is reduced to 1.\n    5. Inside the loop, compare elements at the current gap and swap if necessary based on the sorting order.\n    6. Reduce the gap using the shrink factor.\n    7. Once the gap is 1, perform a final pass similar to bubble sort to ensure the list is sorted.\n    8. Return the sorted list.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list remains empty after sorting.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted.\n    \n    comb_sort([5, 5, 5, 5]) = [5, 5, 5, 5]\n    Explanation: A list with identical elements remains unchanged regardless of sorting order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort inherently handles these cases by its nature of comparison and swapping.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort lists in both ascending and descending order. The function should be efficient and easy to use, with clear documentation for integration into other projects.\nrequirement pool:\n- Implement comb sort algorithm for ascending order\n- Implement comb sort algorithm for descending order\n- Optimize comb sort for large datasets\n- Provide clear documentation and examples\n- Ensure compatibility with existing Python projects\nWe will implement the comb sort algorithm, which is an improvement over bubble sort. It uses a gap sequence to compare elements and gradually reduces the gap to 1, effectively turning into a bubble sort. This approach is efficient for large datasets. We will provide an option to sort in both ascending and descending order by using a parameter. The function will be simple to integrate into existing projects and will include clear documentation with examples.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a sorting algorithm that improves on bubble sort by using a gap sequence to compare elements. It starts with a large gap and reduces it over time, eventually turning into a bubble sort when the gap is 1.\n\n    'ascending order'\n    Explanation: Arranging elements from smallest to largest.\n\n    'descending order'\n    Explanation: Arranging elements from largest to smallest.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define the comb_sort function with parameters for the list and order (ascending or descending).\n    2. Initialize the gap as the length of the list.\n    3. Set a shrink factor, typically 1.3, to reduce the gap.\n    4. Use a loop to continue sorting while the gap is greater than 1.\n    5. Inside the loop, iterate through the list comparing elements at the current gap.\n    6. Swap elements if they are out of order based on the specified sorting order.\n    7. Reduce the gap using the shrink factor.\n    8. Once the gap is 1, perform a final pass similar to bubble sort to ensure the list is sorted.\n    9. Return the sorted list.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list should return an empty list as there are no elements to sort.\n\n    comb_sort([1]) = [1]\n    Explanation: A single-element list should return itself as it is already sorted.\n\n    comb_sort([5, 5, 5, 5]) = [5, 5, 5, 5]\n    Explanation: A list with all identical elements should return itself as all elements are equal and thus sorted.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort inherently handles these cases by its nature of comparison and swapping based on gaps.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort a list of elements in either ascending or descending order. The function should be efficient and easy to use, providing flexibility in sorting order.\nrequirement pool:\n- Implement comb sort algorithm\n- Allow sorting in ascending order\n- Allow sorting in descending order\n- Optimize for performance\n- Ensure code readability and simplicity\nWe will implement the comb sort algorithm, which is an improvement over bubble sort. It uses a gap sequence to compare elements and gradually reduces the gap until it becomes 1, at which point it functions like a bubble sort. This approach is efficient for sorting lists and can be easily adapted to sort in either ascending or descending order. We will use Python's built-in capabilities without any additional libraries to maintain simplicity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a sorting algorithm that improves on bubble sort by using a gap sequence to compare elements. It starts with a large gap and reduces it over time, eventually performing a bubble sort when the gap is 1.\n\n# [phrase showing quantity relationship]\n    'ascending': means arranging elements from smallest to largest.\n    'descending': means arranging elements from largest to smallest.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize the gap size to the length of the list.\n    2. Reduce the gap size using a shrink factor (commonly 1.3).\n    3. Compare elements that are 'gap' distance apart and swap them if they are in the wrong order.\n    4. Repeat the process until the gap size is 1, then perform a final pass similar to bubble sort.\n    5. Allow for sorting in either ascending or descending order based on an optional parameter.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n    \n    comb_sort([5, 5, 5, 5]) = [5, 5, 5, 5]\n    Explanation: A list with all identical elements is already sorted, so the expected output is the same list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort naturally handles these cases by not performing unnecessary swaps or operations on already sorted or trivial lists.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort a list of elements in either ascending or descending order. The function should be efficient and easy to use, providing flexibility in sorting order.\nrequirement pool:\n- Implement the comb_sort function to sort in ascending order.\n- Add functionality to sort in descending order.\n- Optimize the function for performance with large lists.\n- Ensure the function is easy to integrate into other projects.\n- Provide documentation and examples for usage.\nWe will implement the comb_sort function using a simple algorithm that improves upon bubble sort by using a gap sequence to reduce the number of swaps needed. The function will allow sorting in both ascending and descending order based on a parameter. We will ensure the function is efficient for moderate-sized lists and easy to integrate into existing projects without requiring additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb_sort'\n    Explanation: Comb sort is a comparison-based sorting algorithm that improves upon bubble sort by using a gap sequence to reduce the number of swaps needed. It starts with a large gap and reduces it over time, eventually performing a bubble sort when the gap is 1.\n\n    'ascending' and 'descending'\n    Explanation: These terms refer to the order in which the elements of the list should be arranged. Ascending order means sorting from smallest to largest, while descending order means sorting from largest to smallest.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `comb_sort` that takes a list and an optional parameter for order (ascending or descending).\n    2. Initialize the gap as the length of the list.\n    3. Set a shrink factor, typically 1.3, to reduce the gap.\n    4. Use a while loop to continue sorting until the gap is 1 and no swaps are needed.\n    5. Inside the loop, reduce the gap by dividing it by the shrink factor and ensure it is at least 1.\n    6. Use a for loop to iterate over the list, comparing elements that are `gap` positions apart.\n    7. Swap elements if they are out of order based on the desired sorting order.\n    8. Continue until no swaps are needed and the gap is 1.\n    9. Return the sorted list.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n\n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n\n    comb_sort([2, 1], order='descending') = [2, 1]\n    Explanation: The list is already in descending order, so no changes are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort inherently handles empty lists and single-element lists without any issues.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort a list of elements in either ascending or descending order. The function should be efficient and easy to use, providing flexibility in sorting order based on user needs.\nrequirement pool:\n- Implement the comb sort algorithm\n- Allow sorting in both ascending and descending order\n- Ensure the function is efficient for medium-sized lists\n- Provide clear documentation for integration\n- Optimize for performance in edge cases\nWe will implement the comb sort algorithm, which is a simple and efficient sorting algorithm for medium-sized lists. It improves upon bubble sort by using a gap sequence to eliminate turtles, or small values near the end of the list, early in the sorting process. We will provide an option to sort the list in either ascending or descending order based on user input. The implementation will be straightforward and easy to integrate into existing projects without requiring additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a sorting algorithm that improves upon bubble sort by using a gap sequence to eliminate small values near the end of the list early in the sorting process. It is efficient for medium-sized lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define the comb_sort function with parameters for the list and order (ascending or descending).\n    2. Initialize the gap size to the length of the list.\n    3. Set a shrink factor, typically 1.3, to reduce the gap size.\n    4. Use a loop to continue sorting while the gap is greater than 1 or swaps are still being made.\n    5. Inside the loop, reduce the gap size using the shrink factor.\n    6. Iterate through the list, comparing elements that are gap distance apart.\n    7. Swap elements if they are out of order based on the specified sorting order.\n    8. Continue until no swaps are needed and the gap is reduced to 1.\n    9. Return the sorted list.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n    \n    comb_sort([5, 5, 5, 5]) = [5, 5, 5, 5]\n    Explanation: A list with all identical elements is already sorted, so the expected output is the same list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort naturally handles these cases by not performing unnecessary swaps or operations on already sorted or trivial lists.\n", "requirement analysis:\nThe requirement is to implement a comb sort algorithm that efficiently sorts a list of elements. The function should handle both ascending and descending orders based on user input.\nrequirement pool:\n- Implement the comb sort algorithm\n- Ensure the function can sort in both ascending and descending order\n- Provide documentation for the function\n- Optimize the algorithm for performance\n- Maintain code readability\nWe will implement the comb sort algorithm, which is an improvement over bubble sort. It uses a gap sequence to compare elements and gradually reduces the gap until it becomes 1, at which point it functions like a bubble sort. This approach is efficient for medium-sized datasets and maintains simplicity. We will use Python's built-in capabilities without any external libraries to keep the implementation straightforward.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a sorting algorithm that improves on bubble sort by using a gap sequence to compare elements. It starts with a large gap and reduces it gradually until it becomes 1, at which point it functions like bubble sort.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize the gap size to the length of the list.\n    2. Reduce the gap size using a shrink factor (commonly 1.3) until it becomes 1.\n    3. For each gap size, iterate through the list and swap elements if they are out of order.\n    4. Continue this process until no swaps are needed and the gap is 1.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n    \n    comb_sort([2, 1]) = [1, 2]\n    Explanation: A two-element list needs sorting, and the expected output is the list in ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort naturally handles empty lists and lists with one or two elements without any additional modifications.\n", "requirement analysis:\nThe requirement is to implement a comb sort algorithm that efficiently sorts a list of elements. The function should be able to handle lists of varying sizes and provide sorted output in ascending order. The algorithm should be documented to ensure users understand its functionality and integration process.\nrequirement pool:\n- Implement the comb sort algorithm\n- Ensure the function sorts lists in ascending order\n- Document the algorithm for user understanding\n- Test the function with various list sizes\n- Optimize the algorithm for performance\nWe will implement the comb sort algorithm, which is an improvement over bubble sort. It uses a gap sequence to compare elements and gradually reduces the gap until it becomes 1, at which point it functions like a bubble sort. This approach helps eliminate turtles, or small values near the end of the list, which slow down bubble sort. The algorithm will be documented with comments to ensure clarity and understanding.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb sort'\n    Explanation: Comb sort is a comparison-based sorting algorithm that improves on bubble sort by using a gap sequence to compare elements. It starts with a large gap and reduces it over time, eventually performing a final pass with a gap of 1, similar to bubble sort.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize the gap as the length of the list.\n    2. Set a shrink factor, typically 1.3, to reduce the gap.\n    3. While the gap is greater than 1:\n        - Reduce the gap by dividing it by the shrink factor and rounding down.\n        - Iterate through the list, comparing elements that are 'gap' positions apart.\n        - Swap elements if they are out of order.\n    4. Perform a final pass with a gap of 1 to ensure the list is fully sorted.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n    \n    comb_sort([2, 1]) = [1, 2]\n    Explanation: A two-element list in descending order should be sorted to ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort naturally handles these cases due to its iterative comparison and swapping mechanism.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort a list of elements in ascending order. The function should be efficient and easy to understand, with the potential to extend functionality for descending order sorting.\nrequirement pool:\n- Implement the comb_sort function to sort lists in ascending order.\n- Ensure the function handles edge cases like empty lists or single-element lists.\n- Document the function with clear usage examples.\n- Extend the function to support descending order sorting.\n- Optimize the function for performance with large datasets.\nWe will implement the comb_sort function using a simple and efficient approach suitable for sorting lists in ascending order. The function will be designed to handle edge cases like empty lists or single-element lists. We will also extend the functionality to support descending order sorting. The implementation will focus on maintaining code readability and simplicity, while optimizing performance for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'comb_sort'\n    Explanation: Comb sort is a sorting algorithm that improves on bubble sort by using a gap sequence to compare elements. It starts with a large gap and reduces it over time, allowing for faster sorting by eliminating turtles (small values near the end of the list).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize the gap size to the length of the list.\n    2. Set a shrink factor, typically 1.3, to reduce the gap size.\n    3. While the gap is greater than 1:\n        - Reduce the gap size using the shrink factor.\n        - Compare elements at the current index and index + gap.\n        - Swap elements if they are out of order.\n        - Continue until no swaps are needed for the current gap size.\n    4. Perform a final pass with a gap of 1 to ensure the list is sorted.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n    \n    comb_sort([2, 1]) = [1, 2]\n    Explanation: A two-element list needs to be sorted by swapping if necessary, resulting in an ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort inherently handles empty lists and single-element lists without additional conditions.\n", "requirement analysis:\nThe requirement is to implement a comb sort function that can sort a list of elements in either ascending or descending order. The function should be efficient and easy to use, providing flexibility in sorting order.\nrequirement pool:\n- Implement the comb_sort function to sort in ascending order.\n- Add functionality to sort in descending order.\n- Optimize the function for performance with large datasets.\n- Ensure the function is easy to integrate into other projects.\n- Provide documentation and examples for usage.\nWe will implement the comb_sort function using a simple approach that allows sorting in both ascending and descending order. Comb Sort is an improvement over Bubble Sort and works by eliminating turtles, or small values near the end of the list, which slow down the sorting process. The function will use a gap sequence that starts with a large gap and reduces it over iterations, eventually performing a final pass with a gap of 1, similar to Bubble Sort. We will use Python's built-in capabilities to handle list operations efficiently.\nPlease read and understand the following inteperation before coding\n## Answer 3:\n\n# [core concept]\n    'comb sort'\n    Explanation: Comb Sort is a sorting algorithm that improves upon Bubble Sort by using a gap sequence to eliminate turtles (small values near the end of the list) and reduce the number of swaps needed. It starts with a large gap and reduces it over iterations, eventually performing a final pass with a gap of 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending': means arranging elements from smallest to largest\n    'descending': means arranging elements from largest to smallest\n\n# [code logic]\n    - Initialize the gap size to the length of the list.\n    - Reduce the gap size using a shrink factor (commonly 1.3).\n    - Perform a pass through the list, comparing elements that are 'gap' distance apart.\n    - Swap elements if they are in the wrong order based on the desired sorting order (ascending or descending).\n    - Repeat until the gap size is 1 and no swaps are needed.\n\n# [edge case] \n    comb_sort([]) = []\n    Explanation: An empty list is already sorted, so the expected output is an empty list.\n    \n    comb_sort([1]) = [1]\n    Explanation: A single-element list is already sorted, so the expected output is the same single-element list.\n    \n    comb_sort([5, 5, 5, 5]) = [5, 5, 5, 5]\n    Explanation: A list with all identical elements is already sorted, so the expected output is the same list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comb sort inherently handles these cases by not performing unnecessary swaps or operations on lists that are already sorted or contain identical elements.\n"], "test": ["def check(comb_sort):\n\tassert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "def check(comb_sort):\n\tassert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "def check(comb_sort):\n\tassert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]", "def check(comb_sort):\n\tassert comb_sort([7, 10, 39, 29, 78]) == [7, 10, 29, 39, 78]", "def check(comb_sort):\n\tassert comb_sort([2, 19, 41, 28, 75]) == [2, 19, 28, 41, 75]", "def check(comb_sort):\n\tassert comb_sort([9, 11, 37, 30, 83]) == [9, 11, 30, 37, 83]", "def check(comb_sort):\n\tassert comb_sort([2, 10, 37, 27, 76]) == [2, 10, 27, 37, 76]", "def check(comb_sort):\n\tassert comb_sort([1, 11, 37, 27, 75]) == [1, 11, 27, 37, 75]", "def check(comb_sort):\n\tassert comb_sort([9, 12, 33, 24, 84]) == [9, 12, 24, 33, 84]", "def check(comb_sort):\n\tassert comb_sort([10, 14, 41, 25, 82]) == [10, 14, 25, 41, 82]", "def check(comb_sort):\n\tassert comb_sort([3, 20, 38, 27, 75]) == [3, 20, 27, 38, 75]", "def check(comb_sort):\n\tassert comb_sort([7, 12, 40, 26, 76]) == [7, 12, 26, 40, 76]", "def check(comb_sort):\n\tassert comb_sort([2, 19, 38, 24, 84]) == [2, 19, 24, 38, 84]", "def check(comb_sort):\n\tassert comb_sort([3, 11, 34, 23, 77]) == [3, 11, 23, 34, 77]", "def check(comb_sort):\n\tassert comb_sort([1, 12, 34, 20, 81]) == [1, 12, 20, 34, 81]", "def check(comb_sort):\n\tassert comb_sort([6, 15, 38, 26, 77]) == [6, 15, 26, 38, 77]", "def check(comb_sort):\n\tassert comb_sort([6, 10, 38, 22, 84]) == [6, 10, 22, 38, 84]", "def check(comb_sort):\n\tassert comb_sort([7, 16, 38, 28, 75]) == [7, 16, 28, 38, 75]", "def check(comb_sort):\n\tassert comb_sort([1, 14, 37, 26, 75]) == [1, 14, 26, 37, 75]", "def check(comb_sort):\n\tassert comb_sort([8, 18, 36, 29, 80]) == [8, 18, 29, 36, 80]", "def check(comb_sort):\n\tassert comb_sort([4, 16, 37, 28, 79]) == [4, 16, 28, 37, 79]", "def check(comb_sort):\n\tassert comb_sort([8, 11, 37, 24, 84]) == [8, 11, 24, 37, 84]", "def check(comb_sort):\n\tassert comb_sort([4, 10, 32, 25, 75]) == [4, 10, 25, 32, 75]", "def check(comb_sort):\n\tassert comb_sort([2, 17, 38, 20, 78]) == [2, 17, 20, 38, 78]", "def check(comb_sort):\n\tassert comb_sort([1, 16, 41, 30, 82]) == [1, 16, 30, 41, 82]", "def check(comb_sort):\n\tassert comb_sort([5, 12, 32, 25, 83]) == [5, 12, 25, 32, 83]", "def check(comb_sort):\n\tassert comb_sort([5, 13, 32, 28, 74]) == [5, 13, 28, 32, 74]", "def check(comb_sort):\n\tassert comb_sort([6, 20, 40, 26, 79]) == [6, 20, 26, 40, 79]", "def check(comb_sort):\n\tassert comb_sort([1, 10, 34, 22, 80]) == [1, 10, 22, 34, 80]", "def check(comb_sort):\n\tassert comb_sort([7, 10, 39, 20, 83]) == [7, 10, 20, 39, 83]", "def check(comb_sort):\n\tassert comb_sort([1, 20, 38, 24, 74]) == [1, 20, 24, 38, 74]", "def check(comb_sort):\n\tassert comb_sort([3, 14, 42, 29, 80]) == [3, 14, 29, 42, 80]", "def check(comb_sort):\n\tassert comb_sort([4, 13, 38, 28, 83]) == [4, 13, 28, 38, 83]", "def check(comb_sort):\n\tassert comb_sort([2, 20, 33, 24, 80]) == [2, 20, 24, 33, 80]", "def check(comb_sort):\n\tassert comb_sort([2, 13, 32, 25, 79]) == [2, 13, 25, 32, 79]", "def check(comb_sort):\n\tassert comb_sort([7, 12, 33, 29, 76]) == [7, 12, 29, 33, 76]", "def check(comb_sort):\n\tassert comb_sort([42, 36, 20, 21, 24]) == [20, 21, 24, 36, 42]", "def check(comb_sort):\n\tassert comb_sort([37, 32, 20, 21, 18]) == [18, 20, 21, 32, 37]", "def check(comb_sort):\n\tassert comb_sort([36, 27, 16, 24, 21]) == [16, 21, 24, 27, 36]", "def check(comb_sort):\n\tassert comb_sort([42, 27, 11, 19, 25]) == [11, 19, 25, 27, 42]", "def check(comb_sort):\n\tassert comb_sort([43, 31, 19, 24, 23]) == [19, 23, 24, 31, 43]", "def check(comb_sort):\n\tassert comb_sort([37, 31, 13, 16, 25]) == [13, 16, 25, 31, 37]", "def check(comb_sort):\n\tassert comb_sort([40, 34, 14, 17, 26]) == [14, 17, 26, 34, 40]", "def check(comb_sort):\n\tassert comb_sort([36, 27, 17, 20, 20]) == [17, 20, 20, 27, 36]", "def check(comb_sort):\n\tassert comb_sort([44, 37, 15, 19, 20]) == [15, 19, 20, 37, 44]", "def check(comb_sort):\n\tassert comb_sort([44, 32, 11, 14, 23]) == [11, 14, 23, 32, 44]", "def check(comb_sort):\n\tassert comb_sort([45, 27, 19, 14, 23]) == [14, 19, 23, 27, 45]", "def check(comb_sort):\n\tassert comb_sort([46, 35, 18, 22, 21]) == [18, 21, 22, 35, 46]", "def check(comb_sort):\n\tassert comb_sort([40, 31, 10, 20, 25]) == [10, 20, 25, 31, 40]", "def check(comb_sort):\n\tassert comb_sort([45, 34, 11, 17, 21]) == [11, 17, 21, 34, 45]", "def check(comb_sort):\n\tassert comb_sort([43, 28, 18, 21, 27]) == [18, 21, 27, 28, 43]", "def check(comb_sort):\n\tassert comb_sort([40, 34, 14, 16, 22]) == [14, 16, 22, 34, 40]", "def check(comb_sort):\n\tassert comb_sort([41, 31, 15, 22, 26]) == [15, 22, 26, 31, 41]", "def check(comb_sort):\n\tassert comb_sort([43, 31, 17, 22, 27]) == [17, 22, 27, 31, 43]", "def check(comb_sort):\n\tassert comb_sort([44, 29, 18, 22, 19]) == [18, 19, 22, 29, 44]", "def check(comb_sort):\n\tassert comb_sort([42, 27, 11, 14, 26]) == [11, 14, 26, 27, 42]", "def check(comb_sort):\n\tassert comb_sort([38, 32, 12, 14, 17]) == [12, 14, 17, 32, 38]", "def check(comb_sort):\n\tassert comb_sort([46, 33, 18, 14, 18]) == [14, 18, 18, 33, 46]", "def check(comb_sort):\n\tassert comb_sort([46, 34, 20, 17, 25]) == [17, 20, 25, 34, 46]", "def check(comb_sort):\n\tassert comb_sort([43, 36, 10, 20, 26]) == [10, 20, 26, 36, 43]", "def check(comb_sort):\n\tassert comb_sort([43, 28, 11, 20, 24]) == [11, 20, 24, 28, 43]", "def check(comb_sort):\n\tassert comb_sort([42, 36, 12, 14, 26]) == [12, 14, 26, 36, 42]", "def check(comb_sort):\n\tassert comb_sort([38, 29, 10, 23, 21]) == [10, 21, 23, 29, 38]", "def check(comb_sort):\n\tassert comb_sort([41, 30, 19, 14, 18]) == [14, 18, 19, 30, 41]", "def check(comb_sort):\n\tassert comb_sort([38, 37, 17, 19, 25]) == [17, 19, 25, 37, 38]", "def check(comb_sort):\n\tassert comb_sort([44, 28, 16, 22, 18]) == [16, 18, 22, 28, 44]", "def check(comb_sort):\n\tassert comb_sort([41, 31, 13, 14, 23]) == [13, 14, 23, 31, 41]", "def check(comb_sort):\n\tassert comb_sort([45, 36, 20, 18, 21]) == [18, 20, 21, 36, 45]", "def check(comb_sort):\n\tassert comb_sort([44, 31, 15, 24, 17]) == [15, 17, 24, 31, 44]", "def check(comb_sort):\n\tassert comb_sort([97, 13, 17, 45]) == [13, 17, 45, 97]", "def check(comb_sort):\n\tassert comb_sort([96, 10, 11, 48]) == [10, 11, 48, 96]", "def check(comb_sort):\n\tassert comb_sort([97, 16, 12, 45]) == [12, 16, 45, 97]", "def check(comb_sort):\n\tassert comb_sort([95, 13, 16, 51]) == [13, 16, 51, 95]", "def check(comb_sort):\n\tassert comb_sort([104, 11, 18, 48]) == [11, 18, 48, 104]", "def check(comb_sort):\n\tassert comb_sort([96, 10, 16, 48]) == [10, 16, 48, 96]", "def check(comb_sort):\n\tassert comb_sort([95, 18, 8, 52]) == [8, 18, 52, 95]", "def check(comb_sort):\n\tassert comb_sort([98, 15, 9, 43]) == [9, 15, 43, 98]", "def check(comb_sort):\n\tassert comb_sort([94, 18, 8, 45]) == [8, 18, 45, 94]", "def check(comb_sort):\n\tassert comb_sort([100, 11, 16, 47]) == [11, 16, 47, 100]", "def check(comb_sort):\n\tassert comb_sort([103, 20, 10, 44]) == [10, 20, 44, 103]", "def check(comb_sort):\n\tassert comb_sort([100, 10, 15, 48]) == [10, 15, 48, 100]", "def check(comb_sort):\n\tassert comb_sort([100, 12, 15, 46]) == [12, 15, 46, 100]", "def check(comb_sort):\n\tassert comb_sort([102, 16, 11, 42]) == [11, 16, 42, 102]", "def check(comb_sort):\n\tassert comb_sort([99, 16, 15, 48]) == [15, 16, 48, 99]", "def check(comb_sort):\n\tassert comb_sort([95, 14, 14, 42]) == [14, 14, 42, 95]", "def check(comb_sort):\n\tassert comb_sort([98, 20, 12, 45]) == [12, 20, 45, 98]", "def check(comb_sort):\n\tassert comb_sort([104, 19, 9, 42]) == [9, 19, 42, 104]", "def check(comb_sort):\n\tassert comb_sort([100, 12, 16, 48]) == [12, 16, 48, 100]", "def check(comb_sort):\n\tassert comb_sort([104, 16, 12, 42]) == [12, 16, 42, 104]", "def check(comb_sort):\n\tassert comb_sort([94, 20, 17, 44]) == [17, 20, 44, 94]", "def check(comb_sort):\n\tassert comb_sort([97, 16, 16, 43]) == [16, 16, 43, 97]", "def check(comb_sort):\n\tassert comb_sort([100, 15, 9, 48]) == [9, 15, 48, 100]", "def check(comb_sort):\n\tassert comb_sort([100, 14, 11, 51]) == [11, 14, 51, 100]", "def check(comb_sort):\n\tassert comb_sort([98, 14, 9, 52]) == [9, 14, 52, 98]", "def check(comb_sort):\n\tassert comb_sort([104, 10, 15, 51]) == [10, 15, 51, 104]", "def check(comb_sort):\n\tassert comb_sort([99, 12, 13, 49]) == [12, 13, 49, 99]", "def check(comb_sort):\n\tassert comb_sort([94, 14, 11, 49]) == [11, 14, 49, 94]", "def check(comb_sort):\n\tassert comb_sort([102, 11, 15, 44]) == [11, 15, 44, 102]", "def check(comb_sort):\n\tassert comb_sort([97, 11, 10, 42]) == [10, 11, 42, 97]", "def check(comb_sort):\n\tassert comb_sort([102, 13, 17, 45]) == [13, 17, 45, 102]", "def check(comb_sort):\n\tassert comb_sort([94, 12, 16, 46]) == [12, 16, 46, 94]", "def check(comb_sort):\n\tassert comb_sort([97, 15, 12, 49]) == [12, 15, 49, 97]"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef comb_sort(arr: list, ascending: bool = True) -> list:\n    \"\"\"\n    Sorts a list using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n    ascending (bool): If True, sort in ascending order; if False, sort in descending order.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def get_next_gap(gap: int) -> int:\n        \"\"\"Calculate the next gap size.\"\"\"\n        # Shrink factor is commonly 1.3\n        gap = int(gap / 1.3)\n        if gap < 1:\n            return 1\n        return gap\n\n    def should_swap(x, y) -> bool:\n        \"\"\"Determine if two elements should be swapped based on the sorting order.\"\"\"\n        if ascending:\n            return x > y\n        else:\n            return x < y\n\n    n = len(arr)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n\n        for i in range(n - gap):\n            if should_swap(arr[i], arr[i + gap]):\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr\n\n# Example usage:\n# sorted_list = comb_sort([64, 34, 25, 12, 22, 11, 90], ascending=True)\n# print(sorted_list)\n", "passed": true, "pass": true, "pass_num": 10, "round": 952, "mutate_method": "expand_one2two", "parent_index": 450}
