{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 632, "prompt": "Write a python function to move all zeroes to the end of the list you are given. You need to ensure that the relative order of non-zero elements remains unchanged. The function should operate in-place without using extra space for another list. The objective is to maintain the order and shift all zeroes to the end.", "code": "def move_zero(num_list):\n    a = [0 for i in range(num_list.count(0))]\n    x = [i for i in num_list if i != 0]\n    return x + a", "test_imports": [], "test_list": ["assert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]", "assert move_zero([2,3,2,0,0,4,0,5,0]) == [2,3,2,4,5,0,0,0,0]", "assert move_zero([0,1,0,1,1]) == [1,1,1,0,0]", "assert move_zero([1, 2, 6, 1, 6, 8]) == [1, 2, 6, 1, 6, 8]", "assert move_zero([3, 3, 2, 3, 1, 3]) == [3, 3, 2, 3, 1, 3]", "assert move_zero([4, 2, 7, 2, 8, 1]) == [4, 2, 7, 2, 8, 1]", "assert move_zero([6, 5, 4, 1, 6, 2]) == [6, 5, 4, 1, 6, 2]", "assert move_zero([1, 4, 3, 3, 6, 8]) == [1, 4, 3, 3, 6, 8]", "assert move_zero([3, 1, 6, 4, 8, 5]) == [3, 1, 6, 4, 8, 5]", "assert move_zero([3, 3, 3, 4, 3, 8]) == [3, 3, 3, 4, 3, 8]", "assert move_zero([1, 5, 3, 2, 7, 2]) == [1, 5, 3, 2, 7, 2]", "assert move_zero([1, 3, 7, 1, 7, 5]) == [1, 3, 7, 1, 7, 5]", "assert move_zero([5, 1, 1, 5, 6, 4]) == [5, 1, 1, 5, 6, 4]", "assert move_zero([3, 3, 2, 2, 7, 4]) == [3, 3, 2, 2, 7, 4]", "assert move_zero([3, 5, 1, 3, 8, 3]) == [3, 5, 1, 3, 8, 3]", "assert move_zero([1, 3, 6, 3, 3, 9]) == [1, 3, 6, 3, 3, 9]", "assert move_zero([4, 1, 5, 1, 5, 1]) == [4, 1, 5, 1, 5, 1]", "assert move_zero([2, 1, 7, 3, 6, 7]) == [2, 1, 7, 3, 6, 7]", "assert move_zero([1, 2, 1, 1, 2, 5]) == [1, 2, 1, 1, 2, 5]", "assert move_zero([1, 2, 3, 4, 5, 2]) == [1, 2, 3, 4, 5, 2]", "assert move_zero([2, 2, 1, 5, 5, 2]) == [2, 2, 1, 5, 5, 2]", "assert move_zero([6, 1, 2, 1, 2, 9]) == [6, 1, 2, 1, 2, 9]", "assert move_zero([4, 5, 7, 1, 5, 5]) == [4, 5, 7, 1, 5, 5]", "assert move_zero([4, 4, 3, 4, 1, 6]) == [4, 4, 3, 4, 1, 6]", "assert move_zero([2, 5, 4, 4, 6, 3]) == [2, 5, 4, 4, 6, 3]", "assert move_zero([3, 4, 3, 3, 2, 2]) == [3, 4, 3, 3, 2, 2]", "assert move_zero([1, 3, 1, 5, 4, 5]) == [1, 3, 1, 5, 4, 5]", "assert move_zero([6, 1, 4, 1, 7, 9]) == [6, 1, 4, 1, 7, 9]", "assert move_zero([4, 2, 1, 2, 7, 7]) == [4, 2, 1, 2, 7, 7]", "assert move_zero([2, 2, 1, 3, 6, 7]) == [2, 2, 1, 3, 6, 7]", "assert move_zero([3, 4, 2, 1, 2, 8]) == [3, 4, 2, 1, 2, 8]", "assert move_zero([3, 1, 3, 2, 5, 7]) == [3, 1, 3, 2, 5, 7]", "assert move_zero([6, 5, 3, 3, 7, 8]) == [6, 5, 3, 3, 7, 8]", "assert move_zero([1, 5, 7, 1, 6, 8]) == [1, 5, 7, 1, 6, 8]", "assert move_zero([3, 4, 2, 2, 3, 7]) == [3, 4, 2, 2, 3, 7]", "assert move_zero([5, 3, 7, 3, 8, 1]) == [5, 3, 7, 3, 8, 1]", "assert move_zero([4, 5, 3, 2, 2, 8, 1, 9, 4]) == [4, 5, 3, 2, 2, 8, 1, 9, 4]", "assert move_zero([7, 6, 6, 1, 3, 3, 5, 8, 5]) == [7, 6, 6, 1, 3, 3, 5, 8, 5]", "assert move_zero([4, 3, 7, 5, 1, 8, 2, 6, 1]) == [4, 3, 7, 5, 1, 8, 2, 6, 1]", "assert move_zero([3, 1, 7, 5, 3, 1, 5, 3, 5]) == [3, 1, 7, 5, 3, 1, 5, 3, 5]", "assert move_zero([2, 3, 7, 1, 4, 1, 2, 9, 4]) == [2, 3, 7, 1, 4, 1, 2, 9, 4]", "assert move_zero([1, 7, 3, 1, 2, 1, 2, 8, 2]) == [1, 7, 3, 1, 2, 1, 2, 8, 2]", "assert move_zero([1, 7, 3, 2, 1, 6, 4, 3, 1]) == [1, 7, 3, 2, 1, 6, 4, 3, 1]", "assert move_zero([5, 7, 2, 4, 3, 8, 1, 1, 2]) == [5, 7, 2, 4, 3, 8, 1, 1, 2]", "assert move_zero([3, 3, 7, 4, 3, 2, 3, 9, 1]) == [3, 3, 7, 4, 3, 2, 3, 9, 1]", "assert move_zero([3, 2, 7, 5, 4, 4, 2, 10, 4]) == [3, 2, 7, 5, 4, 4, 2, 10, 4]", "assert move_zero([4, 2, 4, 2, 5, 5, 2, 2, 5]) == [4, 2, 4, 2, 5, 5, 2, 2, 5]", "assert move_zero([4, 8, 2, 5, 5, 1, 4, 4, 5]) == [4, 8, 2, 5, 5, 1, 4, 4, 5]", "assert move_zero([7, 3, 2, 1, 2, 7, 3, 8, 5]) == [7, 3, 2, 1, 2, 7, 3, 8, 5]", "assert move_zero([3, 4, 7, 5, 3, 4, 5, 6, 1]) == [3, 4, 7, 5, 3, 4, 5, 6, 1]", "assert move_zero([6, 1, 3, 2, 1, 3, 4, 8, 3]) == [6, 1, 3, 2, 1, 3, 4, 8, 3]", "assert move_zero([3, 1, 5, 1, 1, 9, 2, 1, 3]) == [3, 1, 5, 1, 1, 9, 2, 1, 3]", "assert move_zero([6, 8, 7, 5, 2, 5, 4, 7, 1]) == [6, 8, 7, 5, 2, 5, 4, 7, 1]", "assert move_zero([6, 3, 6, 4, 2, 8, 1, 10, 1]) == [6, 3, 6, 4, 2, 8, 1, 10, 1]", "assert move_zero([1, 7, 7, 1, 4, 1, 3, 6, 2]) == [1, 7, 7, 1, 4, 1, 3, 6, 2]", "assert move_zero([7, 7, 7, 1, 5, 2, 4, 3, 4]) == [7, 7, 7, 1, 5, 2, 4, 3, 4]", "assert move_zero([1, 2, 1, 4, 5, 2, 4, 6, 1]) == [1, 2, 1, 4, 5, 2, 4, 6, 1]", "assert move_zero([1, 5, 7, 3, 3, 7, 4, 2, 1]) == [1, 5, 7, 3, 3, 7, 4, 2, 1]", "assert move_zero([1, 7, 1, 4, 5, 1, 3, 7, 5]) == [1, 7, 1, 4, 5, 1, 3, 7, 5]", "assert move_zero([5, 8, 3, 5, 2, 1, 4, 8, 3]) == [5, 8, 3, 5, 2, 1, 4, 8, 3]", "assert move_zero([5, 6, 5, 5, 3, 1, 5, 10, 4]) == [5, 6, 5, 5, 3, 1, 5, 10, 4]", "assert move_zero([3, 6, 5, 3, 2, 1, 1, 8, 5]) == [3, 6, 5, 3, 2, 1, 1, 8, 5]", "assert move_zero([7, 7, 7, 4, 4, 7, 5, 4, 4]) == [7, 7, 7, 4, 4, 7, 5, 4, 4]", "assert move_zero([5, 2, 6, 1, 2, 9, 5, 8, 5]) == [5, 2, 6, 1, 2, 9, 5, 8, 5]", "assert move_zero([6, 6, 6, 4, 4, 6, 3, 1, 1]) == [6, 6, 6, 4, 4, 6, 3, 1, 1]", "assert move_zero([4, 3, 7, 1, 5, 6, 2, 6, 3]) == [4, 3, 7, 1, 5, 6, 2, 6, 3]", "assert move_zero([5, 7, 6, 3, 3, 9, 3, 8, 1]) == [5, 7, 6, 3, 3, 9, 3, 8, 1]", "assert move_zero([3, 6, 1, 2, 2, 1, 2, 1, 1]) == [3, 6, 1, 2, 2, 1, 2, 1, 1]", "assert move_zero([4, 7, 7, 4, 2, 4, 4, 4, 1]) == [4, 7, 7, 4, 2, 4, 4, 4, 1]", "assert move_zero([2, 1, 3, 2, 6]) == [2, 1, 3, 2, 6]", "assert move_zero([5, 6, 5, 3, 1]) == [5, 6, 5, 3, 1]", "assert move_zero([1, 4, 1, 4, 6]) == [1, 4, 1, 4, 6]", "assert move_zero([5, 3, 4, 6, 6]) == [5, 3, 4, 6, 6]", "assert move_zero([2, 2, 4, 6, 3]) == [2, 2, 4, 6, 3]", "assert move_zero([3, 1, 1, 3, 6]) == [3, 1, 1, 3, 6]", "assert move_zero([2, 2, 5, 3, 4]) == [2, 2, 5, 3, 4]", "assert move_zero([5, 4, 1, 1, 4]) == [5, 4, 1, 1, 4]", "assert move_zero([3, 6, 3, 5, 2]) == [3, 6, 3, 5, 2]", "assert move_zero([5, 4, 2, 5, 4]) == [5, 4, 2, 5, 4]", "assert move_zero([4, 2, 5, 2, 1]) == [4, 2, 5, 2, 1]", "assert move_zero([1, 2, 1, 5, 4]) == [1, 2, 1, 5, 4]", "assert move_zero([4, 2, 3, 1, 3]) == [4, 2, 3, 1, 3]", "assert move_zero([2, 2, 5, 5, 4]) == [2, 2, 5, 5, 4]", "assert move_zero([3, 4, 3, 5, 3]) == [3, 4, 3, 5, 3]", "assert move_zero([3, 3, 4, 1, 3]) == [3, 3, 4, 1, 3]", "assert move_zero([4, 1, 1, 4, 3]) == [4, 1, 1, 4, 3]", "assert move_zero([1, 2, 2, 6, 4]) == [1, 2, 2, 6, 4]", "assert move_zero([1, 6, 4, 1, 2]) == [1, 6, 4, 1, 2]", "assert move_zero([1, 5, 5, 5, 5]) == [1, 5, 5, 5, 5]", "assert move_zero([1, 2, 2, 5, 1]) == [1, 2, 2, 5, 1]", "assert move_zero([5, 5, 4, 5, 3]) == [5, 5, 4, 5, 3]", "assert move_zero([3, 1, 1, 4, 6]) == [3, 1, 1, 4, 6]", "assert move_zero([3, 1, 1, 6, 3]) == [3, 1, 1, 6, 3]", "assert move_zero([5, 6, 5, 5, 5]) == [5, 6, 5, 5, 5]", "assert move_zero([2, 1, 2, 5, 3]) == [2, 1, 2, 5, 3]", "assert move_zero([1, 3, 3, 5, 6]) == [1, 3, 3, 5, 6]", "assert move_zero([3, 4, 3, 2, 6]) == [3, 4, 3, 2, 6]", "assert move_zero([3, 1, 3, 4, 3]) == [3, 1, 3, 4, 3]", "assert move_zero([5, 2, 3, 2, 1]) == [5, 2, 3, 2, 1]", "assert move_zero([1, 4, 1, 4, 6]) == [1, 4, 1, 4, 6]", "assert move_zero([1, 3, 5, 1, 4]) == [1, 3, 5, 1, 4]", "assert move_zero([5, 6, 2, 2, 5]) == [5, 6, 2, 2, 5]"], "entry_point": "move_zero", "repair_prompt": ["Write a python function move_zero to move all zeroes to the end of the list you are given. You need to ensure that the relative order of non-zero elements remains unchanged. The function should operate in-place without using extra space for another list. The objective is to maintain the order and shift all zeroes to the end.\nmove_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n", "Write a python function move_zero to move all zeroes to the end of the list you are given. You need to ensure that the relative order of non-zero elements remains unchanged. The function must work directly on the list without creating a new one, maintaining the integrity of the operations in-place. You should avoid using extra space for another list. The objective is to maintain the order and shift all zeroes to the end.\nmove_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n", "Write a python function move_zero to move all zeroes to the end of the list you are given, ensuring that the relative order of non-zero elements remains unchanged. The function should operate in-place without using extra space for another list. The objective is to maintain the order and shift all zeroes to the end.\nmove_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n"], "completions": ["from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Modifies the input list in-place to move all zeroes to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums (list[int]): The list of integers to be modified.\n    \n    Returns:\n        None: The function modifies the list in-place and does not return anything.\n    \"\"\"\n    # Initialize the pointer for the last non-zero found position\n    last_non_zero_found_at = 0\n\n    # Iterate through the list with the current pointer\n    for current in range(len(nums)):\n        # If the current element is not zero, swap it with the element at last_non_zero_found_at\n        if nums[current] != 0:\n            # Swap the elements\n            nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]\n            # Increment the last_non_zero_found_at pointer\n            last_non_zero_found_at += 1\n\n# Example usage:\n# nums = [0, 1, 0, 2, 0, 3]\n# move_zero(nums)\n# print(nums)  # Output: [1, 2, 3, 0, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    Operates in-place and returns None.\n\n    Parameters:\n    nums (list[int]): The list of integers to be modified.\n    \"\"\"\n    # Initialize a pointer to track the position of the last non-zero element\n    last_non_zero_found_at = 0\n\n    # Iterate through the list with an index `current`\n    for current in range(len(nums)):\n        # If the current element is non-zero, swap it with the element at `last_non_zero_found_at`\n        if nums[current] != 0:\n            # Swap elements\n            nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]\n            # Increment the pointer after each swap\n            last_non_zero_found_at += 1\n\n# Example usage:\n# nums = [1, 0, 2, 0, 3, 4]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 2, 3, 4, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Modifies the input list in-place to move all zeroes to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums (list[int]): The list of integers to be modified.\n    \"\"\"\n    # Initialize a pointer to track the position to place the next non-zero element\n    non_zero_index = 0\n\n    # Iterate through the list with a pointer\n    for current_index in range(len(nums)):\n        # If the current element is not zero, swap it with the element at non_zero_index\n        if nums[current_index] != 0:\n            # Swap the elements\n            nums[non_zero_index], nums[current_index] = nums[current_index], nums[non_zero_index]\n            # Increment the non_zero_index to the next position\n            non_zero_index += 1\n\n# Example usage:\n# nums = [1, 0, 2, 0, 3, 4]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 2, 3, 4, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    This function modifies the list in-place and returns None.\n\n    Parameters:\n    nums (list[int]): The list of integers to be modified.\n    \"\"\"\n    last_non_zero_found_at = 0  # Initialize the pointer for the position of the next non-zero element\n\n    # Iterate through the list\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            # Swap the current element with the element at last_non_zero_found_at\n            nums[last_non_zero_found_at], nums[i] = nums[i], nums[last_non_zero_found_at]\n            # Increment the last_non_zero_found_at pointer\n            last_non_zero_found_at += 1\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 3, 12, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Modifies the list in-place to move all zeroes to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums (list[int]): The list of integers to be modified.\n    \"\"\"\n    # Initialize the pointer for the position of the next non-zero element\n    non_zero_position = 0\n\n    # Iterate through the list with the current index\n    for current_index in range(len(nums)):\n        # If the current element is non-zero, swap it with the element at the non-zero position\n        if nums[current_index] != 0:\n            # Swap the elements\n            nums[non_zero_position], nums[current_index] = nums[current_index], nums[non_zero_position]\n            # Move the non-zero position pointer forward\n            non_zero_position += 1\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 3, 12, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Modifies the input list in-place to move all zeroes to the end while preserving the order of non-zero elements.\n\n    Args:\n        nums (list[int]): A list of integers where zeroes need to be moved to the end.\n\n    Returns:\n        None: The function modifies the list in-place and does not return anything.\n    \"\"\"\n    # Initialize two pointers, i and j\n    i = 0  # Pointer to track the position to place the next non-zero element\n    j = 0  # Pointer to iterate through the list\n\n    # Iterate through the list with j\n    while j < len(nums):\n        # If the element at index j is non-zero, swap elements at indices i and j\n        if nums[j] != 0:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1  # Increment i to the next position for non-zero element\n        j += 1  # Increment j to continue iterating through the list\n\n# Example usage:\n# nums = [1, 0, 2, 0, 3, 4]\n# move_zero(nums)\n# print(nums)  # Output: [1, 2, 3, 4, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    This function modifies the list in-place and returns None.\n\n    Parameters:\n    nums (list[int]): The list of integers to be modified.\n    \"\"\"\n    last_non_zero_found_at = 0  # Initialize the pointer for the position of the last non-zero element\n\n    # Iterate through each element in the list\n    for current in range(len(nums)):\n        if nums[current] != 0:\n            # Swap the current element with the element at last_non_zero_found_at\n            nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]\n            # Increment the last_non_zero_found_at pointer\n            last_non_zero_found_at += 1\n\n# Example usage:\n# nums = [1, 0, 2, 0, 3, 4]\n# move_zero(nums)\n# print(nums)  # Output: [1, 2, 3, 4, 0, 0]\n\n# nums = [0, 0, 0, 1]\n# move_zero(nums)\n# print(nums)  # Output: [1, 0, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    Operates in-place and returns None.\n\n    Parameters:\n    nums (list[int]): The list of integers to be modified.\n    \"\"\"\n    # Initialize a pointer to track the position of the last non-zero element found\n    last_non_zero_found_at = 0\n\n    # Iterate through each element in the list\n    for current in range(len(nums)):\n        # If the current element is not zero, swap it with the element at last_non_zero_found_at\n        if nums[current] != 0:\n            # Swap the elements\n            nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]\n            # Increment the last_non_zero_found_at pointer\n            last_non_zero_found_at += 1\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 3, 12, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Modifies the input list in-place to move all zeroes to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums (list[int]): The list of integers to be modified.\n    \n    Returns:\n        None: The function modifies the list in-place and does not return anything.\n    \"\"\"\n    last_non_zero_found_at = 0  # Initialize the pointer for the last non-zero element found\n\n    # Iterate through the list with the current pointer\n    for current in range(len(nums)):\n        if nums[current] != 0:\n            # Swap the current element with the element at last_non_zero_found_at\n            nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at]\n            # Increment the last_non_zero_found_at pointer\n            last_non_zero_found_at += 1\n\n# Example usage:\n# nums = [1, 0, 2, 0, 3, 4]\n# move_zero(nums)\n# print(nums)  # Output: [1, 2, 3, 4, 0, 0]\n", "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    Operates in-place and returns None.\n\n    Args:\n        nums (list[int]): The list of integers to be processed.\n    \"\"\"\n    # Initialize the pointer for the position of the next non-zero element\n    non_zero_position = 0\n\n    # Iterate through the list with the second pointer\n    for current_position in range(len(nums)):\n        # Check if the current element is non-zero\n        if nums[current_position] != 0:\n            # Swap the current element with the element at the non-zero position\n            nums[non_zero_position], nums[current_position] = nums[current_position], nums[non_zero_position]\n            # Increment the non-zero position pointer\n            non_zero_position += 1\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 3, 12, 0, 0]\n"], "plans": ["requirement analysis:\nThe function must move all zeroes to the end of the list while maintaining the order of non-zero elements. It should operate in-place to avoid additional memory usage, making it suitable for large lists.\nrequirement pool:\n- Implement in-place zero movement algorithm\n- Ensure order of non-zero elements is preserved\n- Optimize for large list performance\n- Provide clear documentation and examples\n- Test across different list sizes and compositions\nWe will implement an in-place algorithm using a two-pointer technique to efficiently move all zeroes to the end of the list while maintaining the order of non-zero elements. This approach avoids additional memory usage and is optimal for large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize two pointers, `last_non_zero_found_at` and `current`.\n    2. Iterate through the list with the `current` pointer.\n    3. If the element at `current` is not zero, swap it with the element at `last_non_zero_found_at`.\n    4. Increment `last_non_zero_found_at` each time a non-zero element is found and swapped.\n    5. Continue until the end of the list is reached.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: The list contains only zeroes, so the output remains unchanged.\n    \n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: The list contains no zeroes, so the output remains unchanged.\n    \n    move_zero([0,1,0,2,0,3]) = [1,2,3,0,0,0]\n    Explanation: The non-zero elements are moved to the front in their original order, and all zeroes are moved to the end.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using two pointers will naturally handle these scenarios.\n", "requirement analysis:\nThe function must move all zeroes to the end of the list while preserving the order of non-zero elements. It should operate in-place, meaning it should not use additional space for another list. This requires careful manipulation of list indices and elements.\nrequirement pool:\n- Implement in-place zero movement\n- Preserve order of non-zero elements\n- Optimize for large lists\n- Ensure compatibility with different data types\n- Provide clear documentation\nWe will implement an in-place algorithm to move all zeroes to the end of the list while maintaining the order of non-zero elements. This will be achieved by iterating through the list and using two pointers to swap non-zero elements with zero elements. This approach ensures that the function operates efficiently without using additional space.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: The function should modify the list directly without creating a new list, meaning the operation should be done within the original list structure.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original sequence in the list after all zeroes are moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize a pointer `last_non_zero_found_at` to track the position of the last non-zero element.\n    - Iterate through the list with an index `current`.\n    - If the current element is non-zero, swap it with the element at `last_non_zero_found_at`.\n    - Increment `last_non_zero_found_at` after each swap.\n    - Continue until all elements have been processed.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: All elements are zeroes, so the list remains unchanged.\n    \n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: There are no zeroes to move, so the list remains unchanged.\n    \n    move_zero([]) = []\n    Explanation: The list is empty, so there are no elements to process.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles these cases naturally by iterating through the list and performing swaps only when necessary.\n", "requirement analysis:\nThe function must move all zeroes to the end of the list while maintaining the order of non-zero elements. It should operate in-place to avoid additional memory usage, which is crucial for handling large lists efficiently.\nrequirement pool:\n- Implement in-place zero movement without additional space.\n- Maintain relative order of non-zero elements.\n- Optimize for performance with large lists.\n- Ensure compatibility with different data types in the list.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through the list, maintaining two pointers: one for the current position and another for the position to place non-zero elements. This approach ensures in-place operation without additional space usage, efficiently handling large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a pointer `non_zero_index` to track the position to place the next non-zero element.\n    2. Iterate through the list with a pointer `current_index`.\n    3. If the element at `current_index` is not zero, swap it with the element at `non_zero_index`, and increment `non_zero_index`.\n    4. Continue this process until the end of the list is reached.\n    5. All zeroes will naturally be moved to the end of the list as non-zero elements are placed at the beginning.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: The list contains only zeroes, so the output remains unchanged.\n    \n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: The list contains no zeroes, so the output remains unchanged.\n    \n    move_zero([0,1,0,2,0,3]) = [1,2,3,0,0,0]\n    Explanation: The non-zero elements are moved to the front in their original order, and all zeroes are moved to the end.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of maintaining two pointers and swapping elements as needed will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently move zeroes to the end of the list while maintaining the order of non-zero elements. It must perform operations in-place without using additional space for another list, ensuring optimal performance for large datasets.\nrequirement pool:\n- Implement in-place zero movement\n- Maintain order of non-zero elements\n- Optimize for large lists\n- Avoid using extra space\n- Ensure compatibility with different data types\nWe will implement an in-place algorithm to move all zeroes to the end of the list while maintaining the order of non-zero elements. This can be achieved by iterating through the list and using a two-pointer technique to swap zeroes with non-zero elements. This approach ensures that we do not use any extra space and the operations are efficient for large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list. The operations should be performed on the original list itself.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a pointer `last_non_zero_found_at` to 0. This will track the position where the next non-zero element should be placed.\n    2. Iterate through the list with an index `i`.\n    3. If the current element is not zero, swap it with the element at `last_non_zero_found_at` and increment `last_non_zero_found_at`.\n    4. Continue this process until the end of the list is reached.\n    5. All zeroes will naturally be moved to the end of the list as non-zero elements are swapped forward.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: The list contains only zeroes, so the output remains unchanged.\n\n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: The list contains no zeroes, so the output remains unchanged.\n\n    move_zero([0,1,0,2,0,3]) = [1,2,3,0,0,0]\n    Explanation: The non-zero elements are moved to the front in their original order, and all zeroes are moved to the end.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of swapping non-zero elements forward and leaving zeroes behind naturally handles these cases.\n", "requirement analysis:\nThe function must efficiently move all zeroes to the end of the list while maintaining the order of non-zero elements. It should perform operations in-place without using additional space for another list, ensuring optimal performance for large datasets.\nrequirement pool:\n- Implement in-place zero movement without extra space.\n- Maintain the order of non-zero elements.\n- Optimize for performance with large lists.\n- Ensure compatibility with different data types in the list.\n- Provide clear documentation and examples.\nWe will implement an in-place solution using a two-pointer technique to efficiently move all zeroes to the end of the list while maintaining the order of non-zero elements. This approach avoids the use of additional space and is optimized for performance, especially with large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: The requirement specifies that the function should modify the list directly without creating a new list, meaning the operations should be performed on the original list itself.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize two pointers: one to track the position for non-zero elements and another to iterate through the list.\n    - Iterate through the list with the second pointer.\n    - When a non-zero element is found, swap it with the element at the first pointer's position and increment the first pointer.\n    - Continue this process until all elements have been checked.\n    - All zeroes will naturally be moved to the end as non-zero elements are swapped forward.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: The list contains only zeroes, so the output remains unchanged.\n    \n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: The list contains no zeroes, so the output remains unchanged.\n    \n    move_zero([]) = []\n    Explanation: The list is empty, so the output remains unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles these scenarios by iterating through the list and swapping non-zero elements forward.\n", "requirement analysis:\nThe function should efficiently move zeroes to the end of the list while preserving the order of non-zero elements. It must operate in-place without using additional space for another list, ensuring optimal performance for large datasets.\nrequirement pool:\n- Implement in-place zero movement\n- Preserve order of non-zero elements\n- Optimize for large lists\n- Avoid using extra space\n- Ensure compatibility with Python lists\nWe will implement an in-place algorithm using two pointers to efficiently move zeroes to the end of the list while preserving the order of non-zero elements. This approach avoids using extra space and is optimal for large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list. The operations should be performed within the existing list structure.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize two pointers, `i` and `j`. Set `i` to 0, which will track the position to place the next non-zero element, and `j` to 0, which will iterate through the list.\n    2. Iterate through the list with `j`.\n    3. If the element at index `j` is non-zero, swap elements at indices `i` and `j`, then increment `i`.\n    4. Continue this process until `j` has iterated through the entire list.\n    5. The zeroes will naturally be moved to the end of the list as `i` only increments when a non-zero is found.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: All elements are zeroes, so the list remains unchanged.\n\n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: There are no zeroes in the list, so the list remains unchanged.\n\n    move_zero([0,1,0,2,0,3]) = [1,2,3,0,0,0]\n    Explanation: The non-zero elements are moved to the front in their original order, and all zeroes are moved to the end.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using two pointers will naturally handle these scenarios.\n", "requirement analysis:\nThe function must move all zeroes to the end of the list while maintaining the order of non-zero elements. It should perform this operation in-place, meaning it cannot use additional space for another list. The solution should be efficient, especially for large lists.\nrequirement pool:\n- Implement in-place zero movement\n- Maintain order of non-zero elements\n- Optimize for large lists\n- Ensure compatibility with Python 3.x\n- Provide clear documentation and examples\nWe will implement an in-place algorithm to move all zeroes to the end of the list while maintaining the order of non-zero elements. This will be achieved by iterating through the list and swapping non-zero elements with zero elements as needed. This approach ensures that we do not use additional space, thus optimizing for space efficiency. The algorithm will be efficient for large lists as it will have a time complexity of O(n), where n is the number of elements in the list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list.\n\n    'relative order of non-zero elements'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a pointer `last_non_zero_found_at` to 0. This will track the position where the next non-zero element should be placed.\n    2. Iterate through each element in the list.\n    3. If the current element is not zero, swap it with the element at `last_non_zero_found_at` and increment `last_non_zero_found_at`.\n    4. Continue this process until all elements have been processed.\n    5. The zeroes will naturally be moved to the end of the list as non-zero elements are swapped forward.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: All elements are zero, so the list remains unchanged.\n\n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: There are no zeroes to move, so the list remains unchanged.\n\n    move_zero([]) = []\n    Explanation: The list is empty, so there are no elements to move.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles these scenarios by iterating through the list and only performing swaps when necessary.\n", "requirement analysis:\nThe function must efficiently move all zeroes to the end of the list while maintaining the order of non-zero elements. It should perform operations in-place to avoid additional memory usage, making it suitable for large datasets.\nrequirement pool:\n- Implement in-place zero movement without additional space.\n- Maintain the order of non-zero elements.\n- Optimize for performance with large lists.\n- Ensure compatibility with existing Python projects.\n- Provide clear documentation and examples.\nWe will implement a simple in-place algorithm to move all zeroes to the end of the list while maintaining the order of non-zero elements. This will be achieved by iterating through the list and swapping non-zero elements with the earliest zero found. This approach ensures that the function operates efficiently without using additional space, making it suitable for large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a pointer `last_non_zero_found_at` to 0. This will track the position to place the next non-zero element.\n    2. Iterate through each element in the list.\n    3. If the current element is not zero, swap it with the element at `last_non_zero_found_at` and increment `last_non_zero_found_at`.\n    4. Continue this process until all elements have been processed.\n    5. The zeroes will naturally be moved to the end of the list as non-zero elements are swapped forward.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: All elements are zero, so the list remains unchanged.\n\n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: There are no zeroes to move, so the list remains unchanged.\n\n    move_zero([]) = []\n    Explanation: The list is empty, so there are no elements to move.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles these scenarios by iterating through the list and only performing swaps when necessary.\n", "requirement analysis:\nThe function must efficiently move all zeroes to the end of the list while maintaining the order of non-zero elements. It should operate in-place to avoid additional memory usage, making it suitable for large datasets.\nrequirement pool:\n- Implement in-place zero movement\n- Maintain order of non-zero elements\n- Optimize for performance with large lists\n- Ensure compatibility with Python 3.x\n- Provide clear documentation and examples\nWe will implement a function that iterates through the list, using two pointers to efficiently move zeroes to the end while maintaining the order of non-zero elements. This approach ensures in-place operations without additional space usage, making it suitable for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: This means that the function should modify the input list directly without creating a new list.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original order in the list after all zeroes have been moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize two pointers, `last_non_zero_found_at` and `current`.\n    2. Iterate through the list with the `current` pointer.\n    3. If the element at `current` is not zero, swap it with the element at `last_non_zero_found_at`.\n    4. Increment `last_non_zero_found_at` each time a non-zero element is found.\n    5. Continue until the end of the list is reached.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: All elements are zeroes, so the list remains unchanged.\n    \n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: There are no zeroes to move, so the list remains unchanged.\n    \n    move_zero([0,1,0,2,0,3]) = [1,2,3,0,0,0]\n    Explanation: All zeroes are moved to the end while maintaining the order of non-zero elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using two pointers will naturally handle these scenarios.\n", "requirement analysis:\nThe function must efficiently move all zeroes to the end of the list while maintaining the order of non-zero elements. It should operate in-place to avoid additional memory usage, making it suitable for large datasets.\nrequirement pool:\n- Implement in-place zero movement\n- Maintain order of non-zero elements\n- Optimize for performance\n- Ensure compatibility with existing Python codebases\n- Provide clear documentation and examples\nWe will implement an in-place algorithm to move all zeroes to the end of the list while maintaining the relative order of non-zero elements. This will be done using a two-pointer technique, which is efficient and avoids the use of additional memory. The function will iterate through the list, swapping non-zero elements with zero elements as needed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'in-place'\n    Explanation: The operation should be performed directly on the input list without creating a new list or using additional memory.\n\n    'relative order'\n    Explanation: The non-zero elements should maintain their original sequence in the list after all zeroes are moved to the end.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize two pointers: one to track the position for non-zero elements and another to iterate through the list.\n    - Iterate through the list with the second pointer.\n    - When a non-zero element is found, swap it with the element at the first pointer's position and increment the first pointer.\n    - Continue this process until the entire list is traversed.\n\n# [edge case] \n    move_zero([0,0,0,0]) = [0,0,0,0]\n    Explanation: All elements are zeroes, so the list remains unchanged.\n    \n    move_zero([1,2,3,4]) = [1,2,3,4]\n    Explanation: There are no zeroes in the list, so the list remains unchanged.\n    \n    move_zero([]) = []\n    Explanation: The list is empty, so there are no elements to move.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using two pointers will naturally handle these scenarios without any additional conditions.\n"], "test": ["def check(move_zero):\n\tassert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]", "def check(move_zero):\n\tassert move_zero([2,3,2,0,0,4,0,5,0]) == [2,3,2,4,5,0,0,0,0]", "def check(move_zero):\n\tassert move_zero([0,1,0,1,1]) == [1,1,1,0,0]", "def check(move_zero):\n\tassert move_zero([1, 2, 6, 1, 6, 8]) == [1, 2, 6, 1, 6, 8]", "def check(move_zero):\n\tassert move_zero([3, 3, 2, 3, 1, 3]) == [3, 3, 2, 3, 1, 3]", "def check(move_zero):\n\tassert move_zero([4, 2, 7, 2, 8, 1]) == [4, 2, 7, 2, 8, 1]", "def check(move_zero):\n\tassert move_zero([6, 5, 4, 1, 6, 2]) == [6, 5, 4, 1, 6, 2]", "def check(move_zero):\n\tassert move_zero([1, 4, 3, 3, 6, 8]) == [1, 4, 3, 3, 6, 8]", "def check(move_zero):\n\tassert move_zero([3, 1, 6, 4, 8, 5]) == [3, 1, 6, 4, 8, 5]", "def check(move_zero):\n\tassert move_zero([3, 3, 3, 4, 3, 8]) == [3, 3, 3, 4, 3, 8]", "def check(move_zero):\n\tassert move_zero([1, 5, 3, 2, 7, 2]) == [1, 5, 3, 2, 7, 2]", "def check(move_zero):\n\tassert move_zero([1, 3, 7, 1, 7, 5]) == [1, 3, 7, 1, 7, 5]", "def check(move_zero):\n\tassert move_zero([5, 1, 1, 5, 6, 4]) == [5, 1, 1, 5, 6, 4]", "def check(move_zero):\n\tassert move_zero([3, 3, 2, 2, 7, 4]) == [3, 3, 2, 2, 7, 4]", "def check(move_zero):\n\tassert move_zero([3, 5, 1, 3, 8, 3]) == [3, 5, 1, 3, 8, 3]", "def check(move_zero):\n\tassert move_zero([1, 3, 6, 3, 3, 9]) == [1, 3, 6, 3, 3, 9]", "def check(move_zero):\n\tassert move_zero([4, 1, 5, 1, 5, 1]) == [4, 1, 5, 1, 5, 1]", "def check(move_zero):\n\tassert move_zero([2, 1, 7, 3, 6, 7]) == [2, 1, 7, 3, 6, 7]", "def check(move_zero):\n\tassert move_zero([1, 2, 1, 1, 2, 5]) == [1, 2, 1, 1, 2, 5]", "def check(move_zero):\n\tassert move_zero([1, 2, 3, 4, 5, 2]) == [1, 2, 3, 4, 5, 2]", "def check(move_zero):\n\tassert move_zero([2, 2, 1, 5, 5, 2]) == [2, 2, 1, 5, 5, 2]", "def check(move_zero):\n\tassert move_zero([6, 1, 2, 1, 2, 9]) == [6, 1, 2, 1, 2, 9]", "def check(move_zero):\n\tassert move_zero([4, 5, 7, 1, 5, 5]) == [4, 5, 7, 1, 5, 5]", "def check(move_zero):\n\tassert move_zero([4, 4, 3, 4, 1, 6]) == [4, 4, 3, 4, 1, 6]", "def check(move_zero):\n\tassert move_zero([2, 5, 4, 4, 6, 3]) == [2, 5, 4, 4, 6, 3]", "def check(move_zero):\n\tassert move_zero([3, 4, 3, 3, 2, 2]) == [3, 4, 3, 3, 2, 2]", "def check(move_zero):\n\tassert move_zero([1, 3, 1, 5, 4, 5]) == [1, 3, 1, 5, 4, 5]", "def check(move_zero):\n\tassert move_zero([6, 1, 4, 1, 7, 9]) == [6, 1, 4, 1, 7, 9]", "def check(move_zero):\n\tassert move_zero([4, 2, 1, 2, 7, 7]) == [4, 2, 1, 2, 7, 7]", "def check(move_zero):\n\tassert move_zero([2, 2, 1, 3, 6, 7]) == [2, 2, 1, 3, 6, 7]", "def check(move_zero):\n\tassert move_zero([3, 4, 2, 1, 2, 8]) == [3, 4, 2, 1, 2, 8]", "def check(move_zero):\n\tassert move_zero([3, 1, 3, 2, 5, 7]) == [3, 1, 3, 2, 5, 7]", "def check(move_zero):\n\tassert move_zero([6, 5, 3, 3, 7, 8]) == [6, 5, 3, 3, 7, 8]", "def check(move_zero):\n\tassert move_zero([1, 5, 7, 1, 6, 8]) == [1, 5, 7, 1, 6, 8]", "def check(move_zero):\n\tassert move_zero([3, 4, 2, 2, 3, 7]) == [3, 4, 2, 2, 3, 7]", "def check(move_zero):\n\tassert move_zero([5, 3, 7, 3, 8, 1]) == [5, 3, 7, 3, 8, 1]", "def check(move_zero):\n\tassert move_zero([4, 5, 3, 2, 2, 8, 1, 9, 4]) == [4, 5, 3, 2, 2, 8, 1, 9, 4]", "def check(move_zero):\n\tassert move_zero([7, 6, 6, 1, 3, 3, 5, 8, 5]) == [7, 6, 6, 1, 3, 3, 5, 8, 5]", "def check(move_zero):\n\tassert move_zero([4, 3, 7, 5, 1, 8, 2, 6, 1]) == [4, 3, 7, 5, 1, 8, 2, 6, 1]", "def check(move_zero):\n\tassert move_zero([3, 1, 7, 5, 3, 1, 5, 3, 5]) == [3, 1, 7, 5, 3, 1, 5, 3, 5]", "def check(move_zero):\n\tassert move_zero([2, 3, 7, 1, 4, 1, 2, 9, 4]) == [2, 3, 7, 1, 4, 1, 2, 9, 4]", "def check(move_zero):\n\tassert move_zero([1, 7, 3, 1, 2, 1, 2, 8, 2]) == [1, 7, 3, 1, 2, 1, 2, 8, 2]", "def check(move_zero):\n\tassert move_zero([1, 7, 3, 2, 1, 6, 4, 3, 1]) == [1, 7, 3, 2, 1, 6, 4, 3, 1]", "def check(move_zero):\n\tassert move_zero([5, 7, 2, 4, 3, 8, 1, 1, 2]) == [5, 7, 2, 4, 3, 8, 1, 1, 2]", "def check(move_zero):\n\tassert move_zero([3, 3, 7, 4, 3, 2, 3, 9, 1]) == [3, 3, 7, 4, 3, 2, 3, 9, 1]", "def check(move_zero):\n\tassert move_zero([3, 2, 7, 5, 4, 4, 2, 10, 4]) == [3, 2, 7, 5, 4, 4, 2, 10, 4]", "def check(move_zero):\n\tassert move_zero([4, 2, 4, 2, 5, 5, 2, 2, 5]) == [4, 2, 4, 2, 5, 5, 2, 2, 5]", "def check(move_zero):\n\tassert move_zero([4, 8, 2, 5, 5, 1, 4, 4, 5]) == [4, 8, 2, 5, 5, 1, 4, 4, 5]", "def check(move_zero):\n\tassert move_zero([7, 3, 2, 1, 2, 7, 3, 8, 5]) == [7, 3, 2, 1, 2, 7, 3, 8, 5]", "def check(move_zero):\n\tassert move_zero([3, 4, 7, 5, 3, 4, 5, 6, 1]) == [3, 4, 7, 5, 3, 4, 5, 6, 1]", "def check(move_zero):\n\tassert move_zero([6, 1, 3, 2, 1, 3, 4, 8, 3]) == [6, 1, 3, 2, 1, 3, 4, 8, 3]", "def check(move_zero):\n\tassert move_zero([3, 1, 5, 1, 1, 9, 2, 1, 3]) == [3, 1, 5, 1, 1, 9, 2, 1, 3]", "def check(move_zero):\n\tassert move_zero([6, 8, 7, 5, 2, 5, 4, 7, 1]) == [6, 8, 7, 5, 2, 5, 4, 7, 1]", "def check(move_zero):\n\tassert move_zero([6, 3, 6, 4, 2, 8, 1, 10, 1]) == [6, 3, 6, 4, 2, 8, 1, 10, 1]", "def check(move_zero):\n\tassert move_zero([1, 7, 7, 1, 4, 1, 3, 6, 2]) == [1, 7, 7, 1, 4, 1, 3, 6, 2]", "def check(move_zero):\n\tassert move_zero([7, 7, 7, 1, 5, 2, 4, 3, 4]) == [7, 7, 7, 1, 5, 2, 4, 3, 4]", "def check(move_zero):\n\tassert move_zero([1, 2, 1, 4, 5, 2, 4, 6, 1]) == [1, 2, 1, 4, 5, 2, 4, 6, 1]", "def check(move_zero):\n\tassert move_zero([1, 5, 7, 3, 3, 7, 4, 2, 1]) == [1, 5, 7, 3, 3, 7, 4, 2, 1]", "def check(move_zero):\n\tassert move_zero([1, 7, 1, 4, 5, 1, 3, 7, 5]) == [1, 7, 1, 4, 5, 1, 3, 7, 5]", "def check(move_zero):\n\tassert move_zero([5, 8, 3, 5, 2, 1, 4, 8, 3]) == [5, 8, 3, 5, 2, 1, 4, 8, 3]", "def check(move_zero):\n\tassert move_zero([5, 6, 5, 5, 3, 1, 5, 10, 4]) == [5, 6, 5, 5, 3, 1, 5, 10, 4]", "def check(move_zero):\n\tassert move_zero([3, 6, 5, 3, 2, 1, 1, 8, 5]) == [3, 6, 5, 3, 2, 1, 1, 8, 5]", "def check(move_zero):\n\tassert move_zero([7, 7, 7, 4, 4, 7, 5, 4, 4]) == [7, 7, 7, 4, 4, 7, 5, 4, 4]", "def check(move_zero):\n\tassert move_zero([5, 2, 6, 1, 2, 9, 5, 8, 5]) == [5, 2, 6, 1, 2, 9, 5, 8, 5]", "def check(move_zero):\n\tassert move_zero([6, 6, 6, 4, 4, 6, 3, 1, 1]) == [6, 6, 6, 4, 4, 6, 3, 1, 1]", "def check(move_zero):\n\tassert move_zero([4, 3, 7, 1, 5, 6, 2, 6, 3]) == [4, 3, 7, 1, 5, 6, 2, 6, 3]", "def check(move_zero):\n\tassert move_zero([5, 7, 6, 3, 3, 9, 3, 8, 1]) == [5, 7, 6, 3, 3, 9, 3, 8, 1]", "def check(move_zero):\n\tassert move_zero([3, 6, 1, 2, 2, 1, 2, 1, 1]) == [3, 6, 1, 2, 2, 1, 2, 1, 1]", "def check(move_zero):\n\tassert move_zero([4, 7, 7, 4, 2, 4, 4, 4, 1]) == [4, 7, 7, 4, 2, 4, 4, 4, 1]", "def check(move_zero):\n\tassert move_zero([2, 1, 3, 2, 6]) == [2, 1, 3, 2, 6]", "def check(move_zero):\n\tassert move_zero([5, 6, 5, 3, 1]) == [5, 6, 5, 3, 1]", "def check(move_zero):\n\tassert move_zero([1, 4, 1, 4, 6]) == [1, 4, 1, 4, 6]", "def check(move_zero):\n\tassert move_zero([5, 3, 4, 6, 6]) == [5, 3, 4, 6, 6]", "def check(move_zero):\n\tassert move_zero([2, 2, 4, 6, 3]) == [2, 2, 4, 6, 3]", "def check(move_zero):\n\tassert move_zero([3, 1, 1, 3, 6]) == [3, 1, 1, 3, 6]", "def check(move_zero):\n\tassert move_zero([2, 2, 5, 3, 4]) == [2, 2, 5, 3, 4]", "def check(move_zero):\n\tassert move_zero([5, 4, 1, 1, 4]) == [5, 4, 1, 1, 4]", "def check(move_zero):\n\tassert move_zero([3, 6, 3, 5, 2]) == [3, 6, 3, 5, 2]", "def check(move_zero):\n\tassert move_zero([5, 4, 2, 5, 4]) == [5, 4, 2, 5, 4]", "def check(move_zero):\n\tassert move_zero([4, 2, 5, 2, 1]) == [4, 2, 5, 2, 1]", "def check(move_zero):\n\tassert move_zero([1, 2, 1, 5, 4]) == [1, 2, 1, 5, 4]", "def check(move_zero):\n\tassert move_zero([4, 2, 3, 1, 3]) == [4, 2, 3, 1, 3]", "def check(move_zero):\n\tassert move_zero([2, 2, 5, 5, 4]) == [2, 2, 5, 5, 4]", "def check(move_zero):\n\tassert move_zero([3, 4, 3, 5, 3]) == [3, 4, 3, 5, 3]", "def check(move_zero):\n\tassert move_zero([3, 3, 4, 1, 3]) == [3, 3, 4, 1, 3]", "def check(move_zero):\n\tassert move_zero([4, 1, 1, 4, 3]) == [4, 1, 1, 4, 3]", "def check(move_zero):\n\tassert move_zero([1, 2, 2, 6, 4]) == [1, 2, 2, 6, 4]", "def check(move_zero):\n\tassert move_zero([1, 6, 4, 1, 2]) == [1, 6, 4, 1, 2]", "def check(move_zero):\n\tassert move_zero([1, 5, 5, 5, 5]) == [1, 5, 5, 5, 5]", "def check(move_zero):\n\tassert move_zero([1, 2, 2, 5, 1]) == [1, 2, 2, 5, 1]", "def check(move_zero):\n\tassert move_zero([5, 5, 4, 5, 3]) == [5, 5, 4, 5, 3]", "def check(move_zero):\n\tassert move_zero([3, 1, 1, 4, 6]) == [3, 1, 1, 4, 6]", "def check(move_zero):\n\tassert move_zero([3, 1, 1, 6, 3]) == [3, 1, 1, 6, 3]", "def check(move_zero):\n\tassert move_zero([5, 6, 5, 5, 5]) == [5, 6, 5, 5, 5]", "def check(move_zero):\n\tassert move_zero([2, 1, 2, 5, 3]) == [2, 1, 2, 5, 3]", "def check(move_zero):\n\tassert move_zero([1, 3, 3, 5, 6]) == [1, 3, 3, 5, 6]", "def check(move_zero):\n\tassert move_zero([3, 4, 3, 2, 6]) == [3, 4, 3, 2, 6]", "def check(move_zero):\n\tassert move_zero([3, 1, 3, 4, 3]) == [3, 1, 3, 4, 3]", "def check(move_zero):\n\tassert move_zero([5, 2, 3, 2, 1]) == [5, 2, 3, 2, 1]", "def check(move_zero):\n\tassert move_zero([1, 4, 1, 4, 6]) == [1, 4, 1, 4, 6]", "def check(move_zero):\n\tassert move_zero([1, 3, 5, 1, 4]) == [1, 3, 5, 1, 4]", "def check(move_zero):\n\tassert move_zero([5, 6, 2, 2, 5]) == [5, 6, 2, 2, 5]"], "scores": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "completion": "from typing import List\n## main.py\n\ndef move_zero(nums: list[int]) -> None:\n    \"\"\"Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    Operates in-place and returns None.\n\n    Args:\n        nums (list[int]): The list of integers to be processed.\n    \"\"\"\n    # Initialize the pointer for the position of the next non-zero element\n    non_zero_position = 0\n\n    # Iterate through the list with the second pointer\n    for current_position in range(len(nums)):\n        # Check if the current element is non-zero\n        if nums[current_position] != 0:\n            # Swap the current element with the element at the non-zero position\n            nums[non_zero_position], nums[current_position] = nums[current_position], nums[non_zero_position]\n            # Increment the non-zero position pointer\n            non_zero_position += 1\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# move_zero(nums)\n# print(nums)  # Output should be [1, 3, 12, 0, 0]\n", "passed": false, "pass": false, "pass_num": 0, "round": 821, "mutate_method": "expand_one2two", "parent_index": 205}
