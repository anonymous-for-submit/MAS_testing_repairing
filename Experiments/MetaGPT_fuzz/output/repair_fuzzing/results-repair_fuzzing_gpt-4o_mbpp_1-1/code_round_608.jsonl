{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 751, "prompt": "Create a function to determine whether the provided array is representative of a min heap. For example, [1, 3, 5, 7, 9, 11] is a min heap, but [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/", "code": "def check_min_heap_helper(arr, i):\n    if 2 * i + 2 > len(arr):\n        return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or (arr[i] <= arr[2 * i + 2] \n                                      and check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\n\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)", "test_imports": [], "test_list": ["assert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "assert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "assert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "assert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "assert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "assert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "assert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "assert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "assert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "assert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "assert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "assert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "assert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "assert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "assert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "assert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "assert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "assert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "assert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "assert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "assert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "assert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "assert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "assert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "assert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "assert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "assert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "assert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "assert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "assert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "assert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "assert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "assert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "assert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "assert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "assert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "assert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "assert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "assert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "assert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "assert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "assert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "assert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "assert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "assert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "assert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "assert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "assert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "assert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "assert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "assert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "assert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "assert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "assert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "assert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "assert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "assert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "assert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "assert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "assert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "assert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "assert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "assert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "assert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "assert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "assert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "assert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "assert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "assert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "assert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "assert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "assert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "assert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "assert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "assert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "assert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "assert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "assert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "assert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "assert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "assert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "assert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "assert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "assert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "assert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "assert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "assert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "assert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "assert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "assert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "assert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "assert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "assert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "assert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "assert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "assert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "assert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "assert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "assert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "assert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "assert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "assert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "entry_point": "check_min_heap", "repair_prompt": ["Create a function check_min_heap to determine whether the provided array is representative of a min heap. For example, [1, 3, 5, 7, 9, 11] is a min heap, but [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Create a function check_min_heap to determine whether the provided array is representative of a min heap. For example, [1, 3, 5, 7, 9, 11] is a min heap. However, [1, 3, 10, 7, 9, 11] is not a min heap structure. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Create a function check_min_heap to determine whether the provided array is representative of a min heap. For example, [1, 3, 5, 7, 9, 11] is a min heap, but [1, 3, 10, 7, 9, 11] is not, and find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n"], "completions": ["from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index for checking the min heap property. Default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each element up to the last parent node\n    for i in range(index, (n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the current element is less than or equal to its left child (if it exists)\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the current element is less than or equal to its right child (if it exists)\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Determines if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index for checking the heap property. Default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each parent node in the array\n    for i in range(index, n):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if left child exists and is greater than the parent\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if right child exists and is greater than the parent\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([1, 3, 10, 7, 9, 11]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each parent node in the array\n    for i in range(n):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and if the min heap property is violated\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Heap property violated at index {i}: parent {arr[i]} > left child {arr[left_child_index]}\")\n            return False\n        \n        # Check if the right child exists and if the min heap property is violated\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Heap property violated at index {i}: parent {arr[i]} > right child {arr[right_child_index]}\")\n            return False\n    \n    # If no violations are found, the array is a min heap\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Validate input\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Handle edge case for empty array\n    if len(arr) == 0:\n        return True\n    \n    # Iterate through the array\n    n = len(arr)\n    for i in range(n):\n        # Calculate indices of left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the current element is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the current element is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    # If all elements satisfy the min heap property, return True\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    index (int): The starting index for checking the heap property.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if not arr:\n        return True\n    if len(arr) == 1:\n        return True\n\n    # Iterate through the array to check the min heap property\n    n = len(arr)\n    for i in range(index, n):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if left child exists and violates the min heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if right child exists and violates the min heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the array is empty or has only one element, it is a min heap\n    if n == 0 or n == 1:\n        return True\n\n    # Calculate the indices of the left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n\n    # Check if the current node is greater than the left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n\n    # Check if the current node is greater than the right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n\n    # Recursively check the left and right subtrees\n    is_left_heap = True\n    is_right_heap = True\n\n    if left_child_index < n:\n        is_left_heap = check_min_heap(arr, left_child_index)\n\n    if right_child_index < n:\n        is_right_heap = check_min_heap(arr, right_child_index)\n\n    return is_left_heap and is_right_heap\n\n# Example usage:\n# print(check_min_heap([1, 2, 3]))  # Should return True\n# print(check_min_heap([2, 1, 3]))  # Should return False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, n: int) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    n (int): The number of elements in the array.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Iterate through each parent node in the array\n    for i in range((n - 2) // 2 + 1):\n        # Calculate the indices of the left and right children\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        # Check if the current node is greater than the left child\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the current node is greater than the right child\n        if right < n and arr[i] > arr[right]:\n            return False\n\n    # If all nodes satisfy the min heap property, return True\n    return True\n\n# Example usage:\n# print(check_min_heap([1], 1))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6], 6))  # Expected output: True\n# print(check_min_heap([10, 9, 8, 7, 6, 5], 6))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], n: int) -> bool:\n    \"\"\"\n    Determines if the given array represents a min heap.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    n (int): The size of the array.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Iterate through each parent node in the array\n    for i in range(n // 2):  # Only need to check up to the last parent node\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the current node is greater than its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the current node is greater than its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    # If all checks pass, the array is a min heap\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, n: int) -> bool:\n    \"\"\"Check if the given array represents a min heap.\n\n    Args:\n        arr (list): The array to be checked.\n        n (int): The size of the array.\n\n    Returns:\n        bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Iterate over each non-leaf node\n    for i in range((n - 2) // 2 + 1):\n        # Calculate indices of left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the current node is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the current node is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    # If all conditions are satisfied, return True\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    A min heap is a binary tree where the parent node is less than or equal to its child nodes.\n    This property must hold for all nodes in the tree.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the array is empty or has only one element, it is trivially a min heap.\n    if n == 0 or n == 1:\n        return True\n    \n    # Iterate through the array and check the min heap property\n    for i in range(n):\n        # Calculate indices of left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if left child exists and violates the min heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if right child exists and violates the min heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    # If no violations are found, the array is a min heap\n    return True\n\n# Example usage:\n# print(check_min_heap([]))  # Expected output: True\n# print(check_min_heap([1]))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([3, 2, 1]))  # Expected output: False\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that checks if a given array represents a min heap. The function should be efficient, handle edge cases, and be easy to use and integrate. The solution should be based on the principles outlined in the provided GeeksforGeeks article.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap property.\n- Ensure the function handles edge cases such as empty arrays or single-element arrays.\n- Provide comprehensive documentation and usage examples.\n- Optimize the function for performance with large datasets.\n- Include unit tests to validate the function's correctness.\nWe will implement the check_min_heap function using a simple loop to verify the min heap property. The function will iterate through the array and check if each parent node is less than or equal to its child nodes. This approach is efficient and straightforward, leveraging Python's native list operations without requiring additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element in the array up to the last parent node.\n    2. For each element at index `i`, calculate the indices of its left and right children.\n    3. Check if the current element is less than or equal to its left child (if it exists).\n    4. Check if the current element is less than or equal to its right child (if it exists).\n    5. If any of these conditions fail, return False.\n    6. If all conditions are satisfied, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: The array satisfies the min heap property as each parent node is less than or equal to its children.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' at index 2 is greater than its child '7' at index 3, violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent-child relationship inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. The solution should be optimized for performance and include comprehensive documentation.\nrequirement pool:\n- Implement the main function to check if an array is a min heap.\n- Optimize the function for performance with large arrays.\n- Provide detailed documentation and examples for users.\n- Include test cases to validate the function's accuracy.\n- Ensure compatibility with different Python versions.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop and index calculations to determine parent and child relationships. The function will be optimized for performance by minimizing unnecessary operations and will include comprehensive documentation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node's value should be less than or equal to the values of its child nodes in the array representation of the heap.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array using a loop.\n    2. For each element at index i, calculate the indices of its left and right children using the formulas: left_child_index = 2 * i + 1 and right_child_index = 2 * i + 2.\n    3. Check if the current element is less than or equal to its left and right children (if they exist).\n    4. If any parent node is greater than its child node, return False.\n    5. If all parent nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their child nodes, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element at index 2 (value 10) is greater than its child at index 5 (value 11), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent-child relationship inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array is a min heap by checking if each parent node is less than or equal to its child nodes. It should handle edge cases and provide informative feedback for invalid heaps.\nrequirement pool:\n- Implement efficient min heap validation algorithm\n- Optimize for large array performance\n- Provide detailed error messages for invalid heaps\n- Ensure compatibility with various data types\n- Include comprehensive documentation\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring the function is efficient and can handle large arrays. We will also include detailed error messages to explain why an array is not a min heap, if applicable.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a valid min heap, each parent node's value must be less than or equal to its child nodes' values. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to the values at its child indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array using a loop.\n    2. For each element at index `i`, calculate the indices of its left and right children.\n    3. Check if the element at index `i` is less than or equal to its children (if they exist).\n    4. If any parent node is greater than its child node, return False.\n    5. If all parent nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its child nodes, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' at index 2 is greater than its child '7' at index 3, violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array represents a min heap by checking if each parent node is less than or equal to its child nodes. It should handle edge cases such as empty arrays and provide feedback for invalid inputs.\nrequirement pool:\n- Implement the main function to check min heap property.\n- Optimize the function for performance with large datasets.\n- Include error handling for invalid inputs.\n- Provide documentation and examples for usage.\n- Test the function with various edge cases.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will ensure the array represents a min heap. We will handle edge cases such as empty arrays and provide feedback for invalid inputs. The function will be optimized for performance to handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is always less than or equal to its child nodes. This property must hold for the entire tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node in the heap must be less than or equal to its child nodes. In code, this can be implemented by iterating through the array and checking if each element is less than or equal to its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index (default 0) as arguments.\n    2. Iterate through the array from the given index.\n    3. For each element, calculate the indices of its left and right children.\n    4. Check if the current element is less than or equal to its left and right children.\n    5. If any element violates the min heap property, return False.\n    6. If all elements satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([]) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap since there are no children to compare with.\n\n    check_min_heap([2, 1]) = False\n    Explanation: The parent node (2) is greater than its child node (1), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent-child relationship inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. The solution should handle edge cases, such as empty arrays or single-element arrays, and provide clear error messages for invalid inputs.\nrequirement pool:\n- Implement the main function to check min heap property.\n- Optimize the function for performance with large datasets.\n- Include comprehensive documentation and usage examples.\n- Handle edge cases and provide error handling.\n- Create a user-friendly interface for testing the function.\nWe will implement a function named check_min_heap that verifies if a given array represents a min heap. The function will iterate through the array and ensure that each parent node is less than or equal to its child nodes. We will use Python's built-in capabilities to handle array operations efficiently. The function will also include error handling for edge cases such as empty arrays or non-integer inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to the values at its child indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an optional index (default to 0) as arguments.\n    2. Iterate through the array from the given index.\n    3. For each element at index `i`, calculate the indices of its left and right children.\n    4. Check if the element at index `i` is less than or equal to its children (if they exist).\n    5. If any parent node is greater than its child, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([]) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap since there are no children to compare with.\n    \n    check_min_heap([2, 1]) = False\n    Explanation: The parent node (2) is greater than its child (1), violating the min heap property.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not array:\n            return True\n        if len(array) == 1:\n            return True\n        (other code)\n", "requirement analysis:\nThe function should efficiently determine if an array is a min heap by checking if each parent node is less than or equal to its child nodes. It should handle edge cases like empty arrays and provide feedback for invalid structures.\nrequirement pool:\n- Implement the main function to check min heap structure.\n- Optimize the function for performance with large arrays.\n- Include error handling and feedback for invalid heaps.\n- Document the function usage and edge cases.\n- Test the function with various array inputs.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will ensure the array represents a min heap. We will use Python's built-in capabilities without additional libraries to keep the solution simple and efficient. The function will also handle edge cases like empty arrays and provide feedback for invalid structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This ensures that the smallest element is always at the root of the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node in the heap must be less than or equal to its child nodes. In code, this can be implemented by iterating through the array and checking if the value at each parent index is less than or equal to the values at its child indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array using an index.\n    2. For each index, calculate the indices of its left and right children.\n    3. Check if the current element is less than or equal to its children.\n    4. If any parent node is greater than its child nodes, return False.\n    5. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([], 0) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap since there are no child nodes to compare.\n\n    check_min_heap([2, 1], 0) = False\n    Explanation: The parent node (2) is greater than its child node (1), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent node against its children will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to create a function that checks if a given array represents a min heap. A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children. The function should be efficient and handle edge cases, such as empty arrays or arrays with a single element.\nrequirement pool:\n- Implement the check_min_heap function to validate min heap property.\n- Optimize the function for performance with large datasets.\n- Provide comprehensive documentation and usage examples.\n- Include test cases to cover various scenarios and edge cases.\n- Create a user-friendly interface for non-technical users.\nWe will implement a function named check_min_heap that verifies if a given array represents a min heap. The function will iterate through each parent node and check if it is less than or equal to its children. This approach ensures that the function is efficient and can handle large datasets. We will not strictly follow the solution from the provided link but will ensure our implementation meets the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its children. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its children nodes in the heap.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array up to the last parent node.\n    2. For each node, calculate the indices of its left and right children.\n    3. Check if the current node's value is less than or equal to its children's values.\n    4. If any parent node is greater than its child, return False.\n    5. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: The array satisfies the min heap property as each parent node is less than or equal to its children.\n    \n    check_min_heap([10, 9, 8, 7, 6, 5], 0) = False\n    Explanation: The array does not satisfy the min heap property as the first element (10) is greater than its children (9 and 8).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through each parent node and checking its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array is a min heap by checking if each parent node is less than or equal to its child nodes. The solution should be optimized for performance and include clear documentation.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap properties.\n- Optimize the function for large datasets.\n- Provide comprehensive documentation and examples.\n- Include edge case handling for empty arrays.\n- Ensure compatibility with different Python versions.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring the function is efficient and easy to understand. We will focus on integer arrays as the primary use case, given the context provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a valid min heap, each parent node's value must be less than or equal to its child nodes' values. In code, this can be implemented by checking if the value at the current index is less than or equal to the values at its child indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last element that has children.\n    2. For each element at index `i`, calculate the indices of its left and right children using the formulas `2*i + 1` and `2*i + 2`.\n    3. Check if the current element is less than or equal to its left child (if it exists).\n    4. Check if the current element is less than or equal to its right child (if it exists).\n    5. If any parent node is greater than its child node, return False.\n    6. If all checks pass, return True.\n\n# [edge case] \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap because there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6]) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11]) = False\n    Explanation: The element '10' at index 2 is greater than its child '7' at index 3, violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking parent-child relationships inherently handles these cases.\n", "requirement analysis:\nThe requirement is to create a function that checks if a given array represents a min heap. A min heap is a binary tree where the parent node is less than or equal to its child nodes. The function should be efficient and handle edge cases, such as empty arrays or arrays with a single element.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap property.\n- Optimize the function for performance with large arrays.\n- Provide comprehensive documentation and examples.\n- Include test cases for various scenarios, including edge cases.\n- Consider adding support for max heap verification in the future.\nWe will implement a function named check_min_heap that verifies if a given array represents a min heap. The function will iterate through each parent node and check if it is less than or equal to its child nodes. This approach ensures that the function is efficient and can handle large datasets. We will use Python's built-in capabilities without any additional libraries to keep the implementation simple and performant.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index (starting from 0).\n    2. Iterate through each node in the array up to the last parent node.\n    3. For each node, calculate the indices of its left and right children.\n    4. Check if the current node is less than or equal to its left child (if it exists).\n    5. Check if the current node is less than or equal to its right child (if it exists).\n    6. If any of these conditions fail, return False.\n    7. If all conditions are satisfied, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: The array satisfies the min heap property as each parent node is less than or equal to its children.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' is greater than its parent '3', violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent-child relationship inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle various input sizes and edge cases, such as empty arrays or single-element arrays.\nrequirement pool:\n- Implement the main function to check for min heap property.\n- Include comprehensive documentation and usage examples.\n- Optimize the function for performance with large arrays.\n- Ensure compatibility with different Python versions.\n- Add error handling for invalid inputs.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring efficiency. We will also include comprehensive documentation and examples to make the function easy to use and integrate. The function will handle edge cases such as empty arrays and single-element arrays gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array using a loop.\n    2. For each element at index i, check if it is less than or equal to its child nodes at indices 2*i + 1 and 2*i + 2.\n    3. If any parent node is greater than its child nodes, return False.\n    4. If the loop completes without finding any violations, return True.\n\n# [edge case] \n    check_min_heap([], 0) = True\n    Explanation: An empty array can be considered a min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap since there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their child nodes, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty arrays and single-element arrays.\n"], "test": ["def check(check_min_heap):\n\tassert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "scores": [0.9902, 0.9902, 0.2843, 0.2843, 0.9902, 1.0, 0.4216, 0.4216, 0.4216, 0.2843], "pass_results": [false, false, false, false, false, true, false, false, false, false], "pass_test_cases_num": [101, 101, 29, 29, 101, 102, 43, 43, 43, 29], "completion": "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the array is empty or has only one element, it is a min heap\n    if n == 0 or n == 1:\n        return True\n\n    # Calculate the indices of the left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n\n    # Check if the current node is greater than the left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n\n    # Check if the current node is greater than the right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n\n    # Recursively check the left and right subtrees\n    is_left_heap = True\n    is_right_heap = True\n\n    if left_child_index < n:\n        is_left_heap = check_min_heap(arr, left_child_index)\n\n    if right_child_index < n:\n        is_right_heap = check_min_heap(arr, right_child_index)\n\n    return is_left_heap and is_right_heap\n\n# Example usage:\n# print(check_min_heap([1, 2, 3]))  # Should return True\n# print(check_min_heap([2, 1, 3]))  # Should return False\n", "passed": true, "pass": true, "pass_num": 1, "round": 608, "mutate_method": "rephrase_one", "parent_index": 493}
