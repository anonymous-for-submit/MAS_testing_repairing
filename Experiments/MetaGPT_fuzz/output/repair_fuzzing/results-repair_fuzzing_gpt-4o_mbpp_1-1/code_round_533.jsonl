{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell and ends on bottom right cell by moving only right or down. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "repair_prompt": ["Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell and ends on bottom right cell by moving only right or down. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells. It starts from the top-left cell and ends on bottom right cell by moving only right or down. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell and ends on bottom right cell by moving only right or down, and we want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the path with the maximum average cost in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: A tuple containing the maximum average cost and the path as a list of coordinates.\n    \"\"\"\n    if n == 0 or not matrix or not matrix[0]:\n        return 0.0, []\n\n    # Initialize a matrix to store the maximum sum for each cell\n    max_sum = [[0] * n for _ in range(n)]\n    # Initialize a matrix to store the path for each cell\n    path = [[[] for _ in range(n)] for _ in range(n)]\n\n    # Start from the top-left cell\n    max_sum[0][0] = matrix[0][0]\n    path[0][0] = [(0, 0)]\n\n    # Fill the first row\n    for j in range(1, n):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n        path[0][j] = path[0][j-1] + [(0, j)]\n\n    # Fill the first column\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n        path[i][0] = path[i-1][0] + [(i, 0)]\n\n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if max_sum[i-1][j] > max_sum[i][j-1]:\n                max_sum[i][j] = max_sum[i-1][j] + matrix[i][j]\n                path[i][j] = path[i-1][j] + [(i, j)]\n            else:\n                max_sum[i][j] = max_sum[i][j-1] + matrix[i][j]\n                path[i][j] = path[i][j-1] + [(i, j)]\n\n    # Calculate the maximum average cost\n    total_cells = 2 * n - 1\n    max_average = max_sum[n-1][n-1] / total_cells\n\n    return max_average, path[n-1][n-1]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    '''\n    Calculate the maximum average path from top-left to bottom-right in a square matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of integers representing costs.\n    n (int): The size of the matrix (N*N).\n\n    Returns:\n    float: The maximum average cost of a path.\n    '''\n    # Initialize a matrix to store the maximum sum of costs for each cell\n    max_sum_matrix = np.zeros((n, n), dtype=int)\n    \n    # Set the initial cell value\n    max_sum_matrix[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, n):\n        max_sum_matrix[0][j] = max_sum_matrix[0][j-1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, n):\n        max_sum_matrix[i][0] = max_sum_matrix[i-1][0] + matrix[i][0]\n    \n    # Use dynamic programming to fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            max_sum_matrix[i][j] = max(max_sum_matrix[i-1][j], max_sum_matrix[i][j-1]) + matrix[i][j]\n    \n    # Calculate the average by dividing the maximum sum at the bottom-right cell by the number of cells in the path\n    total_cells = 2 * n - 1  # Total cells in the path from top-left to bottom-right\n    max_average = max_sum_matrix[n-1][n-1] / total_cells\n    \n    return max_average\n\n# Example usage\nif __name__ == \"__main__\":\n    matrix_example = [[1, 2], [3, 4]]\n    n_example = 2\n    print(maxAverageOfPath(matrix_example, n_example))  # Output: 2.5\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the maximum average path in a matrix using dynamic programming.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix of costs.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: The maximum average and the path taken as a list of coordinates.\n    \"\"\"\n    # Initialize 2D lists for maximum sums and path counts\n    max_sum = np.zeros((n, n), dtype=float)\n    path_count = np.zeros((n, n), dtype=int)\n    path_trace = [[[] for _ in range(n)] for _ in range(n)]\n\n    # Base case: starting point\n    max_sum[0][0] = matrix[0][0]\n    path_count[0][0] = 1\n    path_trace[0][0] = [(0, 0)]\n\n    # Fill the dynamic programming tables\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n\n            # Check from the top cell\n            if i > 0:\n                top_sum = max_sum[i-1][j] + matrix[i][j]\n                top_count = path_count[i-1][j] + 1\n                top_average = top_sum / top_count\n\n                if top_average > max_sum[i][j] / path_count[i][j] if path_count[i][j] != 0 else float('-inf'):\n                    max_sum[i][j] = top_sum\n                    path_count[i][j] = top_count\n                    path_trace[i][j] = path_trace[i-1][j] + [(i, j)]\n\n            # Check from the left cell\n            if j > 0:\n                left_sum = max_sum[i][j-1] + matrix[i][j]\n                left_count = path_count[i][j-1] + 1\n                left_average = left_sum / left_count\n\n                if left_average > max_sum[i][j] / path_count[i][j] if path_count[i][j] != 0 else float('-inf'):\n                    max_sum[i][j] = left_sum\n                    path_count[i][j] = left_count\n                    path_trace[i][j] = path_trace[i][j-1] + [(i, j)]\n\n    # Calculate the maximum average at the bottom-right cell\n    final_average = max_sum[n-1][n-1] / path_count[n-1][n-1]\n    final_path = path_trace[n-1][n-1]\n\n    return final_average, final_path\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average value of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize matrices to store the maximum sum and number of cells for each path\n    max_sum = np.zeros((n, n), dtype=float)\n    num_cells = np.zeros((n, n), dtype=int)\n\n    # Base case for the top-left cell\n    max_sum[0][0] = matrix[0][0]\n    num_cells[0][0] = 1\n\n    # Fill the first row (can only come from the left)\n    for j in range(1, n):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n        num_cells[0][j] = num_cells[0][j-1] + 1\n\n    # Fill the first column (can only come from above)\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n        num_cells[i][0] = num_cells[i-1][0] + 1\n\n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if max_sum[i-1][j] > max_sum[i][j-1]:\n                max_sum[i][j] = max_sum[i-1][j] + matrix[i][j]\n                num_cells[i][j] = num_cells[i-1][j] + 1\n            else:\n                max_sum[i][j] = max_sum[i][j-1] + matrix[i][j]\n                num_cells[i][j] = num_cells[i][j-1] + 1\n\n    # Calculate the maximum average\n    max_average = max_sum[n-1][n-1] / num_cells[n-1][n-1]\n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize dp and count arrays\n    dp = np.zeros((n, n), dtype=float)\n    count = np.zeros((n, n), dtype=int)\n\n    # Base case\n    dp[0][0] = matrix[0][0]\n    count[0][0] = 1\n\n    # Fill the dp and count arrays\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            if i > 0:\n                # Coming from above\n                if dp[i][j] < dp[i-1][j] + matrix[i][j]:\n                    dp[i][j] = dp[i-1][j] + matrix[i][j]\n                    count[i][j] = count[i-1][j] + 1\n            if j > 0:\n                # Coming from the left\n                if dp[i][j] < dp[i][j-1] + matrix[i][j]:\n                    dp[i][j] = dp[i][j-1] + matrix[i][j]\n                    count[i][j] = count[i][j-1] + 1\n\n    # Calculate the maximum average\n    max_average = dp[n-1][n-1] / count[n-1][n-1]\n    return max_average\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of integers representing the cost of each cell.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column of the DP table\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Fill the rest of the DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    # Calculate the maximum average\n    max_sum = dp[n-1][n-1]\n    num_cells = 2 * n - 1\n    max_average = max_sum / num_cells\n\n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix with costs.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    if n == 0 or not matrix or not matrix[0]:\n        return 0.0\n\n    # Initialize a 2D list `dp` to store the maximum sum of paths up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill in the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill in the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    # Calculate the maximum average path\n    max_sum = dp[n-1][n-1]\n    max_average = max_sum / (2 * n - 1)\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a square matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of integers representing costs.\n    n (int): The size of the matrix (N*N).\n\n    Returns:\n    float: The maximum average cost of a path.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize a DP table to store the maximum sum of costs for each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill the rest of the DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average path\n    total_cost = dp[n-1][n-1]\n    number_of_cells = 2 * n - 1  # Path length from top-left to bottom-right\n    max_average = total_cost / number_of_cells\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a matrix.\n    \n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the cost matrix.\n    n (int): The size of the matrix (n x n).\n    \n    Returns:\n    float: The maximum average cost of a path.\n    \"\"\"\n    if n == 0 or not matrix:\n        return 0.0\n\n    # Initialize a 2D list to store the maximum sum of costs up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_sum = dp[n-1][n-1]\n    max_average = max_sum / (2 * n - 1)\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the path with the maximum average cost in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: The maximum average cost and the path taken.\n    \"\"\"\n    if N == 0 or not matrix:\n        return 0.0, []\n\n    # Initialize a matrix to store the maximum sum of costs for each cell\n    max_sum = np.zeros((N, N), dtype=float)\n    path_count = np.zeros((N, N), dtype=int)\n\n    # Initialize the starting point\n    max_sum[0][0] = matrix[0][0]\n    path_count[0][0] = 1\n\n    # Fill the first row\n    for j in range(1, N):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n        path_count[0][j] = path_count[0][j-1] + 1\n\n    # Fill the first column\n    for i in range(1, N):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n        path_count[i][0] = path_count[i-1][0] + 1\n\n    # Fill the rest of the matrix\n    for i in range(1, N):\n        for j in range(1, N):\n            if max_sum[i-1][j] > max_sum[i][j-1]:\n                max_sum[i][j] = max_sum[i-1][j] + matrix[i][j]\n                path_count[i][j] = path_count[i-1][j] + 1\n            else:\n                max_sum[i][j] = max_sum[i][j-1] + matrix[i][j]\n                path_count[i][j] = path_count[i][j-1] + 1\n\n    # Calculate the maximum average\n    max_average = max_sum[N-1][N-1] / path_count[N-1][N-1]\n\n    # Backtrack to find the path\n    path = []\n    i, j = N-1, N-1\n    while i > 0 or j > 0:\n        path.append((i, j))\n        if i == 0:\n            j -= 1\n        elif j == 0:\n            i -= 1\n        elif max_sum[i-1][j] > max_sum[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    path.append((0, 0))\n    path.reverse()\n\n    return max_average, path\n"], "plans": ["requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle large matrices and provide clear output of the path and average cost.\nrequirement pool:\n- Implement the algorithm to find the path with maximum average cost.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output includes the path taken and the average cost.\n- Develop a user-friendly interface for input and output.\n- Include error handling for invalid matrix inputs.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. This approach will efficiently handle large matrices by storing intermediate results to avoid redundant calculations. We will use Python's built-in capabilities and libraries like NumPy for efficient matrix operations if needed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    'maximum': We need to find the path with the highest average cost among all possible paths.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum average cost for each cell.\n    2. Start from the top-left cell and iterate through the matrix.\n    3. For each cell, calculate the maximum average cost by considering the cost from the top or left cell.\n    4. Use dynamic programming to store intermediate results and avoid redundant calculations.\n    5. Return the maximum average cost from the bottom-right cell.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value of the cell itself.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All cells have a cost of zero, so any path will have an average of zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these scenarios by considering all possible paths and calculating averages accordingly.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a square matrix by only moving right or down. The solution should be efficient and handle large matrices. The average is calculated as the total cost divided by the number of cells in the path.\nrequirement pool:\n- Implement the algorithm to find the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the code is well-documented and easy to understand.\n- Create test cases for various matrix sizes and values.\n- Provide a user-friendly interface for input and output.\nWe will implement a dynamic programming solution to efficiently compute the maximum average path in the matrix. This approach will allow us to handle large matrices by storing intermediate results and avoiding redundant calculations. We will use NumPy for efficient matrix operations and ensure the code is well-documented for easy understanding and maintenance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for each cell.\n    2. Use dynamic programming to fill this matrix by iterating through each cell and calculating the maximum sum of costs from the top-left to that cell.\n    3. For each cell, consider the cost from the cell above and the cell to the left, choosing the path with the higher sum.\n    4. Calculate the average by dividing the maximum sum at the bottom-right cell by the number of cells in the path.\n    5. Return the maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these scenarios by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to compute the maximum average path in a matrix by moving only right or down. The solution should efficiently handle large matrices and provide clear output of the path taken.\nrequirement pool:\n- Efficient computation of maximum average path\n- Clear output of path taken\n- Optimization for large matrix sizes\n- User-friendly interface\n- Detailed documentation\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. This approach will involve creating a 2D list to store the maximum sum of costs up to each cell, and another 2D list to store the number of cells in the path up to each cell. We will then iterate over the matrix, updating these lists based on the possible moves (right or down) and calculate the average for each path. The final result will be the maximum average found at the bottom-right cell. We will use the numpy library for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path'\n    Explanation: A path is a sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n\n    'average'\n    Explanation: The average is calculated as the total cost of the path divided by the number of cells visited in the path.\n\n# [phrase showing quantity relationship]\n    'maximum average'\n    Explanation: We need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right cell.\n\n# [degree adverb]\n    'maximum'\n    Explanation: We are looking for the path that yields the highest average cost.\n\n# [code logic]\n    1. Initialize two 2D lists: one for storing the maximum sum of costs up to each cell and another for storing the number of cells in the path up to each cell.\n    2. Iterate over each cell in the matrix.\n    3. For each cell, update the maximum sum and number of cells based on possible moves (right or down).\n    4. Calculate the average for each path using the stored sums and counts.\n    5. At the bottom-right cell, determine the maximum average from all paths.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: With only one cell, the path is just that cell, so the average is the value of that cell itself.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both yielding an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these scenarios by considering all possible paths and calculating averages accordingly.\n", "requirement analysis:\nThe requirement is to find a path in a matrix that maximizes the average cost per cell. The path can only move right or down, starting from the top-left and ending at the bottom-right. The solution should efficiently handle the calculation of the average for potentially large matrices.\nrequirement pool:\n- Implement the algorithm to find the maximum average path.\n- Design a user-friendly interface for inputting matrices.\n- Optimize the algorithm for performance with large matrices.\n- Provide detailed documentation on how the path is calculated.\n- Include examples and test cases for user reference.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, calculating the maximum sum and the number of cells for each path. The average will be computed as the sum divided by the number of cells. We will use the NumPy library to handle matrix operations efficiently, especially for large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path'\n    Explanation: A path is a sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n\n    'maximum average'\n    Explanation: The goal is to find the path with the highest average cost, calculated as the total cost divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum': means we need to find the path with the highest average cost.\n\n# [degree adverb] \n    'maximum': indicates that we are looking for the path with the greatest average cost among all possible paths.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum and number of cells for each path.\n    2. Traverse the matrix using dynamic programming, updating the maximum sum and number of cells for each cell.\n    3. Calculate the average for each path as the sum divided by the number of cells.\n    4. Use NumPy for efficient matrix operations.\n    5. Return the maximum average found.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value of the cell itself.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all cell values are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide a clear output of the maximum average path value.\nrequirement pool:\n- Implement the main algorithm to compute maximum average path\n- Optimize the solution for larger matrices\n- Ensure the output is user-friendly and easy to interpret\n- Include error handling for invalid inputs\n- Provide documentation for the function usage\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in a matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, calculating the maximum sum of costs for each cell while keeping track of the number of cells visited. The average will be computed by dividing the total cost by the number of cells in the path. This approach ensures scalability for larger matrices. We will use the NumPy library to handle matrix operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path'\n    Explanation: A path is a sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n\n    'maximum average'\n    Explanation: The goal is to find the path with the highest average cost, calculated as the total cost of the path divided by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right of the matrix.\n\n# [code logic]\n1. Initialize a 2D array `dp` to store the maximum sum of costs for each cell.\n2. Initialize another 2D array `count` to store the number of cells visited for each path.\n3. Set `dp[0][0]` to `matrix[0][0]` and `count[0][0]` to 1.\n4. Iterate over each cell in the matrix:\n   - For each cell, calculate the maximum sum of costs if coming from the left or from above.\n   - Update the `dp` and `count` arrays accordingly.\n5. Calculate the average for each path by dividing the total cost by the number of cells.\n6. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 3.0\n    Explanation: The path with maximum average is [1, 3, 4] with an average of (1+3+4)/3 = 2.67, but since we can only move right or down, we consider [1, 4] with an average of (1+4)/2 = 2.5.\n\n    maxAverageOfPath([[5, 1], [1, 5]], 2) = 5.0\n    Explanation: The path with maximum average is [5, 5] with an average of (5+5)/2 = 5.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should handle these cases correctly by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to calculate maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and easy to interpret.\n- Include error handling for invalid matrix inputs.\n- Provide documentation for the function usage.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. This approach will efficiently handle large matrices by storing intermediate results to avoid redundant calculations. We will use Python's built-in capabilities and libraries like NumPy for efficient matrix operations if needed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maxAverageOfPath'\n    Explanation: This refers to finding a path in the matrix that has the highest average cost. The average is calculated by dividing the total cost of the path by the number of cells in the path.\n\n    'path'\n    Explanation: A sequence of cells starting from the top-left cell to the bottom-right cell, moving only right or down.\n\n# [phrase showing quantity relationship]\n    'maximum average'\n    Explanation: This means we need to find the path with the highest possible average cost. In code, this involves calculating the average for each path and comparing them to find the maximum.\n\n# [degree adverb]\n    'maximum'\n    Explanation: Indicates that we are looking for the highest average value among all possible paths.\n\n# [code logic]\n1. Initialize a 2D list `dp` where `dp[i][j]` will store the maximum sum of costs from the top-left to cell (i, j).\n2. Set `dp[0][0]` to `matrix[0][0]` as the starting point.\n3. Fill in the first row and first column of `dp` since they can only be reached from one direction.\n4. For each cell (i, j) in the matrix, calculate `dp[i][j]` as `matrix[i][j] + max(dp[i-1][j], dp[i][j-1])`.\n5. The number of cells in any path from top-left to bottom-right is always `2N-1`.\n6. Calculate the maximum average as `dp[N-1][N-1] / (2N-1)`.\n7. Return this maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: With only one cell, the path is just that cell, so the average is the value of that cell itself.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have a total cost of 0, so the average is also 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all possible scenarios by calculating the maximum sum and dividing by the fixed number of cells in any path (2N-1).\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide a clear output of the maximum average.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and concise.\n- Develop a user-friendly interface for input and output.\n- Test the solution with various matrix sizes and configurations.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. This approach will ensure that we handle large matrices effectively by storing intermediate results and avoiding redundant calculations. We will use the NumPy library for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maxAverageOfPath'\n    Explanation: This refers to finding a path in the matrix from the top-left to the bottom-right corner that has the highest average value of the cells included in the path.\n\n    'path'\n    Explanation: A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    'maximum': This indicates that we need to find the path with the highest average value among all possible paths from the top-left to the bottom-right of the matrix.\n\n# [code logic]\n1. Initialize a 2D list `dp` of the same size as the matrix to store the maximum sum of paths up to each cell.\n2. Set `dp[0][0]` to `matrix[0][0]` as it is the starting point.\n3. Fill in the first row and first column of `dp` by accumulating sums from the start.\n4. For each cell `(i, j)`, calculate `dp[i][j]` as `matrix[i][j] + max(dp[i-1][j], dp[i][j-1])`, which represents the maximum sum path to that cell.\n5. The maximum average path can be calculated as `dp[N-1][N-1] / (2N - 1)`, where `N` is the size of the matrix.\n6. Return this maximum average.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is the value itself.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all cells are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of using dynamic programming to calculate maximum sums and then dividing by the number of steps in the path will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a square matrix by only moving right or down. The challenge lies in efficiently computing this for potentially large matrices while ensuring accuracy.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Provide detailed documentation and examples for users.\n- Include edge case handling for small matrices.\n- Develop a user-friendly interface for input and output.\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. This approach will leverage memoization to store intermediate results and avoid redundant calculations, optimizing performance for large matrices. We will use NumPy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths from top-left to bottom-right.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for each cell.\n    2. Use dynamic programming to fill this matrix by iterating over each cell and calculating the maximum sum of costs that can be achieved by reaching that cell.\n    3. For each cell, consider the maximum sum of costs from the cell above or the cell to the left, adding the current cell's cost.\n    4. Once the matrix is filled, calculate the average for the path ending at the bottom-right cell by dividing the total cost by the number of cells in the path.\n    5. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both having an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size and values, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe function should efficiently compute the maximum average path in a matrix by considering all possible paths from the top-left to the bottom-right corner, moving only right or down. The solution should be optimized for performance, especially for larger matrices, and provide clear output.\nrequirement pool:\n- Efficient computation of maximum average path\n- Handle large matrix sizes\n- Provide clear and concise output\n- Optimize for performance\n- User-friendly interface\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. This approach will involve creating a 2D list to store the maximum sum of costs up to each cell, and then using this to calculate the maximum average path. We will use the numpy library for efficient matrix operations, which is well-suited for handling large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right cell.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize a 2D list to store the maximum sum of costs up to each cell.\n    2. Use dynamic programming to fill this list by iterating through each cell and updating the maximum sum based on the possible moves (right or down).\n    3. Calculate the average for each path by dividing the total cost by the number of cells visited.\n    4. Keep track of the maximum average encountered during the iteration.\n    5. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: With only one cell, the path is just that cell, and its average is its own value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both having an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these scenarios by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The challenge lies in efficiently calculating the average while ensuring the path is optimal.\nrequirement pool:\n- Implement the algorithm to find the maximum average path\n- Optimize the algorithm for large matrices\n- Provide detailed path output\n- Ensure user-friendly input and output\n- Include visualization of the path\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, calculating the maximum sum of costs for each cell while keeping track of the number of cells visited. The average will be computed by dividing the total cost by the number of cells in the path. We will use NumPy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'maximum average': The highest average cost of all possible paths, calculated as the total cost divided by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    'maximum': Refers to finding the path with the highest average cost among all possible paths.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for each cell.\n    2. Traverse the matrix from the top-left to the bottom-right.\n    3. For each cell, calculate the maximum sum of costs by considering the cost from the top or left cell.\n    4. Keep track of the number of cells visited for each path.\n    5. Calculate the average for each path by dividing the total cost by the number of cells.\n    6. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value of that cell itself.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of (1+2+4)/3 = 2.5 or (1+3+4)/3 = 2.67, but since we need to consider all paths, we take the maximum.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have a total cost of 0, so the average is also 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating maximum sum and dividing by number of cells will handle these cases correctly.\n"], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0], "pass_results": [false, true, false, true, true, true, true, true, true, false], "pass_test_cases_num": [0, 102, 0, 102, 102, 102, 102, 102, 102, 0], "completion": "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a matrix.\n    \n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the cost matrix.\n    n (int): The size of the matrix (n x n).\n    \n    Returns:\n    float: The maximum average cost of a path.\n    \"\"\"\n    if n == 0 or not matrix:\n        return 0.0\n\n    # Initialize a 2D list to store the maximum sum of costs up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_sum = dp[n-1][n-1]\n    max_average = max_sum / (2 * n - 1)\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "passed": true, "pass": true, "pass_num": 7, "round": 533, "mutate_method": "condense_two2one", "parent_index": 213}
