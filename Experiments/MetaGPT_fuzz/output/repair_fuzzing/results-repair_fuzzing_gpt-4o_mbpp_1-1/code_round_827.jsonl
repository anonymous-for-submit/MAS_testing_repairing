{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell. The path can move only right or down and ends on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "repair_prompt": ["Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell. The path can move only right or down and ends on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell. The path can move only right or down. It ends on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell and moves only right or down to end on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize a 2D array `dp` where `dp[i][j]` will store the maximum total cost to reach cell `(i, j)`.\n    dp = np.zeros((n, n), dtype=float)\n    \n    # Set `dp[0][0]` to `matrix[0][0]` as it is the starting point.\n    dp[0][0] = matrix[0][0]\n\n    # Fill in the first row and first column of `dp` since they can only be reached from one direction.\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Iterate over the matrix to fill the `dp` table.\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    # Calculate the maximum average.\n    max_average = dp[n-1][n-1] / (2 * n - 1)\n\n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a square matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N containing integer costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if N == 0:\n        return 0.0\n\n    # Initialize a matrix to store the maximum sum of costs for paths ending at each cell\n    max_sum = np.zeros((N, N), dtype=float)\n    max_sum[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, N):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, N):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n\n    # Use dynamic programming to fill the rest of the matrix\n    for i in range(1, N):\n        for j in range(1, N):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    total_cells = 2 * N - 1  # Total cells in the path from top-left to bottom-right\n    max_average = max_sum[N-1][N-1] / total_cells\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\n## main.py\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> tuple[float, list[tuple[int, int]]]:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (list[list[int]]): A 2D list representing the matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    tuple[float, list[tuple[int, int]]]: A tuple containing the maximum average and the path as a list of coordinates.\n    \"\"\"\n    if n == 0 or not matrix or not matrix[0]:\n        return 0.0, []\n\n    # Initialize dp_sum and dp_count matrices\n    dp_sum = [[0] * n for _ in range(n)]\n    dp_count = [[0] * n for _ in range(n)]\n    path = [[None] * n for _ in range(n)]\n\n    # Base case for the top-left cell\n    dp_sum[0][0] = matrix[0][0]\n    dp_count[0][0] = 1\n    path[0][0] = [(0, 0)]\n\n    # Fill the dp_sum and dp_count matrices\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n\n            # Calculate the maximum sum and count of cells for each cell\n            if i > 0:\n                if dp_sum[i][j] < dp_sum[i-1][j] + matrix[i][j]:\n                    dp_sum[i][j] = dp_sum[i-1][j] + matrix[i][j]\n                    dp_count[i][j] = dp_count[i-1][j] + 1\n                    path[i][j] = path[i-1][j] + [(i, j)]\n\n            if j > 0:\n                if dp_sum[i][j] < dp_sum[i][j-1] + matrix[i][j]:\n                    dp_sum[i][j] = dp_sum[i][j-1] + matrix[i][j]\n                    dp_count[i][j] = dp_count[i][j-1] + 1\n                    path[i][j] = path[i][j-1] + [(i, j)]\n\n    # Calculate the maximum average at the bottom-right cell\n    max_average = dp_sum[n-1][n-1] / dp_count[n-1][n-1]\n    max_path = path[n-1][n-1]\n\n    return max_average, max_path\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    '''\n    Calculate the maximum average path in a given N*N matrix.\n    \n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n    \n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    '''\n    # Initialize a 2D array `dp` where each element `dp[i][j]` will store a tuple (sum, count)\n    dp = [[(0, 0) for _ in range(n)] for _ in range(n)]\n    \n    # Set `dp[0][0]` to (matrix[0][0], 1) since the path starts at the top-left corner\n    dp[0][0] = (matrix[0][0], 1)\n    \n    # Iterate over each cell in the matrix\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue  # Skip the top-left corner as it's already initialized\n            \n            # Initialize current cell with negative infinity for comparison\n            current_sum, current_count = float('-inf'), 0\n            \n            # Check the cell above (i-1, j) if within bounds\n            if i > 0:\n                above_sum, above_count = dp[i-1][j]\n                if (above_sum + matrix[i][j]) / (above_count + 1) > current_sum / current_count:\n                    current_sum = above_sum + matrix[i][j]\n                    current_count = above_count + 1\n            \n            # Check the cell to the left (i, j-1) if within bounds\n            if j > 0:\n                left_sum, left_count = dp[i][j-1]\n                if (left_sum + matrix[i][j]) / (left_count + 1) > current_sum / current_count:\n                    current_sum = left_sum + matrix[i][j]\n                    current_count = left_count + 1\n            \n            # Update dp[i][j] with the best path sum and count\n            dp[i][j] = (current_sum, current_count)\n    \n    # Calculate the maximum average from the bottom-right corner\n    final_sum, final_count = dp[n-1][n-1]\n    max_average = final_sum / final_count\n    \n    return max_average\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (list[list[int]]): A 2D list representing the matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize dp_sum and dp_count matrices\n    dp_sum = np.zeros((n, n), dtype=float)\n    dp_count = np.zeros((n, n), dtype=int)\n\n    # Set the starting point (top-left cell)\n    dp_sum[0][0] = matrix[0][0]\n    dp_count[0][0] = 1\n\n    # Fill the dp_sum and dp_count matrices\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n\n            # Calculate possible path sums and counts from the top and left cells\n            from_top_sum = dp_sum[i-1][j] if i > 0 else float('-inf')\n            from_left_sum = dp_sum[i][j-1] if j > 0 else float('-inf')\n\n            from_top_count = dp_count[i-1][j] if i > 0 else 0\n            from_left_count = dp_count[i][j-1] if j > 0 else 0\n\n            # Choose the path with the maximum sum\n            if from_top_sum > from_left_sum:\n                dp_sum[i][j] = from_top_sum + matrix[i][j]\n                dp_count[i][j] = from_top_count + 1\n            else:\n                dp_sum[i][j] = from_left_sum + matrix[i][j]\n                dp_count[i][j] = from_left_count + 1\n\n    # Calculate the maximum average for paths ending at the bottom-right cell\n    max_average = dp_sum[n-1][n-1] / dp_count[n-1][n-1]\n\n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a square matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of integers representing costs.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    float: The maximum average of any path from top-left to bottom-right.\n    \"\"\"\n    # Initialize a 2D list to store the maximum sum of paths to each cell\n    max_sum = np.zeros((n, n), dtype=int)\n    max_sum[0][0] = matrix[0][0]\n\n    # Fill the first row and first column\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n        max_sum[0][i] = max_sum[0][i-1] + matrix[0][i]\n\n    # Fill the rest of the max_sum matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_average = max_sum[n-1][n-1] / (2 * n - 1)\n\n    # Visualize the path\n    path = reconstruct_path(max_sum, n)\n    visualize_path(matrix, path)\n\n    return max_average\n\ndef reconstruct_path(max_sum: np.ndarray, n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Reconstruct the path from the max_sum matrix.\n\n    Parameters:\n    max_sum (np.ndarray): The matrix storing maximum sums.\n    n (int): The size of the matrix.\n\n    Returns:\n    List[Tuple[int, int]]: The path from top-left to bottom-right.\n    \"\"\"\n    path = []\n    i, j = n - 1, n - 1\n    while i > 0 or j > 0:\n        path.append((i, j))\n        if i == 0:\n            j -= 1\n        elif j == 0:\n            i -= 1\n        elif max_sum[i-1][j] > max_sum[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    path.append((0, 0))\n    path.reverse()\n    return path\n\ndef visualize_path(matrix: List[List[int]], path: List[Tuple[int, int]]) -> None:\n    \"\"\"\n    Visualize the path on the matrix using Matplotlib.\n\n    Parameters:\n    matrix (List[List[int]]): The matrix to visualize.\n    path (List[Tuple[int, int]]): The path to highlight.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.matshow(matrix, cmap=plt.cm.Blues)\n\n    for (i, j) in path:\n        ax.text(j, i, str(matrix[i][j]), va='center', ha='center', color='red')\n\n    plt.show()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the path with the maximum average cost in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: The maximum average cost and the path taken as a list of coordinates.\n    \"\"\"\n    # Initialize the dynamic programming table\n    dp = np.zeros((N, N), dtype=float)\n    path = [[None for _ in range(N)] for _ in range(N)]\n\n    # Base case: starting point\n    dp[0][0] = matrix[0][0]\n    path[0][0] = [(0, 0)]\n\n    # Fill the first row and first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        path[i][0] = path[i-1][0] + [(i, 0)]\n        \n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n        path[0][j] = path[0][j-1] + [(0, j)]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            if dp[i-1][j] > dp[i][j-1]:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n                path[i][j] = path[i-1][j] + [(i, j)]\n            else:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n                path[i][j] = path[i][j-1] + [(i, j)]\n\n    # Calculate the maximum average\n    total_cost = dp[N-1][N-1]\n    num_cells = len(path[N-1][N-1])\n    max_average = total_cost / num_cells\n\n    return max_average, path[N-1][N-1]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize a 2D list to store the maximum sum of costs up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Compute maximum path sums for the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    total_cells = 2 * n - 1  # Total cells in the path from top-left to bottom-right\n    max_average = dp[n-1][n-1] / total_cells\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the path with the maximum average cost in a square matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of integers representing costs.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: A tuple containing the maximum average and the path as a list of coordinates.\n    \"\"\"\n    # Validate input matrix\n    if not matrix or len(matrix) != n or any(len(row) != n for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size n x n.\")\n\n    # Initialize a 2D list to store the maximum sum up to each cell\n    max_sum = [[0] * n for _ in range(n)]\n    path = [[None] * n for _ in range(n)]\n\n    # Base case: start from the top-left corner\n    max_sum[0][0] = matrix[0][0]\n    path[0][0] = [(0, 0)]\n\n    # Fill the first row\n    for j in range(1, n):\n        max_sum[0][j] = max_sum[0][j - 1] + matrix[0][j]\n        path[0][j] = path[0][j - 1] + [(0, j)]\n\n    # Fill the first column\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i - 1][0] + matrix[i][0]\n        path[i][0] = path[i - 1][0] + [(i, 0)]\n\n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if max_sum[i - 1][j] > max_sum[i][j - 1]:\n                max_sum[i][j] = max_sum[i - 1][j] + matrix[i][j]\n                path[i][j] = path[i - 1][j] + [(i, j)]\n            else:\n                max_sum[i][j] = max_sum[i][j - 1] + matrix[i][j]\n                path[i][j] = path[i][j - 1] + [(i, j)]\n\n    # Calculate the maximum average\n    total_cells = 2 * n - 1  # Number of cells in the path from (0,0) to (n-1,n-1)\n    max_average = max_sum[n - 1][n - 1] / total_cells\n\n    return max_average, path[n - 1][n - 1]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a matrix.\n    \n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N containing integer costs.\n    n (int): The size of the matrix.\n    \n    Returns:\n    float: The maximum average cost of a path.\n    \"\"\"\n    # Initialize a memoization table to store the maximum sum of costs for paths ending at each cell\n    dp = np.zeros((n, n), dtype=float)\n    \n    # Base case: the starting point\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row (can only come from the left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum sum of costs for the current cell can come from either the left or above\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # The number of cells in the path from top-left to bottom-right is 2n-1\n    path_length = 2 * n - 1\n    \n    # Calculate the maximum average by dividing the maximum sum by the number of cells in the path\n    max_average = dp[n-1][n-1] / path_length\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n"], "plans": ["requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle large matrices and provide clear output.\nrequirement pool:\n- Implement the main algorithm to calculate the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and understandable.\n- Test the solution with various matrix sizes.\n- Provide documentation for users to understand the functionality.\nWe will implement a dynamic programming approach to calculate the maximum average path in the matrix. This approach will efficiently handle large matrices by storing intermediate results to avoid redundant calculations. We will use the NumPy library for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maxAverageOfPath'\n    Explanation: This refers to finding a path in the matrix that has the highest average cost per cell. The path starts at the top-left corner and ends at the bottom-right corner, moving only right or down.\n\n    'path'\n    Explanation: A sequence of cells in the matrix that starts from the top-left cell and ends at the bottom-right cell, moving only right or down.\n\n# [phrase showing quantity relationship]\n    'maximum average'\n    Explanation: This means we need to find the path with the highest average cost, calculated as the total cost of the path divided by the number of cells in the path. In code, this can be implemented by keeping track of the total cost and number of cells for each path and comparing their averages.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This indicates that we are looking for the path with the highest possible average cost. In code, this involves comparing averages of different paths and selecting the highest one.\n\n# [code logic]\n1. Initialize a 2D array `dp` where `dp[i][j]` will store the maximum total cost to reach cell `(i, j)`.\n2. Set `dp[0][0]` to `matrix[0][0]` as it is the starting point.\n3. Fill in the first row and first column of `dp` since they can only be reached from one direction.\n4. For each cell `(i, j)`, calculate `dp[i][j]` as `matrix[i][j] + max(dp[i-1][j], dp[i][j-1])`.\n5. The maximum average is then `dp[N-1][N-1] / (2N - 1)`, where `2N - 1` is the number of cells in any path from top-left to bottom-right.\n6. Return this maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both having an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all cells are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles matrices of any size, including single-cell matrices and matrices with all zero values.\n", "requirement analysis:\nThe requirement is to develop a function that calculates the maximum average path in a square matrix, moving only right or down. The function should be efficient and handle edge cases such as varying matrix sizes.\nrequirement pool:\n- Develop the main function to calculate the maximum average path.\n- Optimize the function for performance with large matrices.\n- Write comprehensive documentation for the function.\n- Create test cases to validate the function's correctness.\n- Ensure the function handles edge cases gracefully.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. This approach will utilize memoization to store intermediate results and avoid redundant calculations. We will use the NumPy library for efficient matrix operations, which is well-suited for handling large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for paths ending at each cell.\n    2. Use dynamic programming to fill this matrix by iterating over each cell and calculating the maximum sum of costs for paths ending at that cell.\n    3. For each cell, consider the maximum sum of costs from the cell above and the cell to the left, adding the current cell's cost.\n    4. Calculate the average for each path by dividing the total cost by the number of cells visited.\n    5. Keep track of the maximum average encountered during the iteration.\n    6. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is [1, 2, 4] with an average of (1+2+4)/3 = 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe requirement is to compute the maximum average path in a matrix, focusing on efficiency and clarity. The solution should handle large matrices and provide insights into the path taken.\nrequirement pool:\n- Efficient computation of maximum average path\n- Clear output of path and average\n- Optimization for large matrices\n- User-friendly interface\n- Detailed path visualization\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. This approach will allow us to handle large matrices by storing intermediate results and avoiding redundant calculations. We will use a 2D list to store the maximum sum of paths up to each cell, and another 2D list to store the number of cells in the path to compute the average. The solution will also track the path taken to achieve this maximum average.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize two 2D lists: one for storing the maximum sum of paths up to each cell and another for storing the number of cells in the path.\n    2. Start from the top-left cell and iterate through the matrix, updating the maximum sum and cell count for each cell based on possible moves (right or down).\n    3. For each cell, calculate the average by dividing the maximum sum by the number of cells.\n    4. Track the path taken to achieve this maximum average.\n    5. Return the maximum average found at the bottom-right cell.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All cells have a cost of zero, so any path will have an average of zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size and values, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe function should efficiently compute the maximum average path in a matrix, considering only right and down movements. It should handle edge cases like small and large matrices and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to calculate the maximum average path\n- Optimize the algorithm for performance in large matrices\n- Provide clear documentation and examples\n- Ensure compatibility with different Python versions\n- Include error handling for invalid inputs\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. The algorithm will traverse the matrix using only right and down movements, storing the maximum sum and count of cells for each path in a 2D array. This approach ensures that we can handle large matrices efficiently. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path'\n    Explanation: In this context, a path is a sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n\n    'maximum average'\n    Explanation: The goal is to find the path where the average cost (total cost divided by the number of cells in the path) is the highest among all possible paths.\n\n# [phrase showing quantity relationship]\n    'maximum': This indicates that we need to find the path with the highest average cost.\n\n# [degree adverb] \n    'maximum': This refers to finding the path with the greatest average cost.\n\n# [code logic]\n1. Initialize a 2D array `dp` where each element `dp[i][j]` will store a tuple (sum, count) representing the maximum sum and the number of cells in the path to reach cell (i, j).\n2. Set `dp[0][0]` to (matrix[0][0], 1) since the path starts at the top-left corner.\n3. Iterate over each cell in the matrix:\n   - For each cell (i, j), update `dp[i][j]` by considering paths from the left (i, j-1) and above (i-1, j).\n   - Calculate the new sum and count for each possible path and update `dp[i][j]` if it results in a higher average.\n4. The result will be in `dp[N-1][N-1]`, where N is the size of the matrix. Calculate the average as sum/count.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value of that cell itself.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of 2.5.\n\n    maxAverageOfPath([[5, 1], [1, 5]], 2) = 3.0\n    Explanation: The path with maximum average is [5, 5], giving an average of 3.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using dynamic programming will naturally handle these cases by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to find a path in a matrix that maximizes the average cost. The path can only move right or down, starting from the top-left and ending at the bottom-right. The challenge is to efficiently compute this for potentially large matrices.\nrequirement pool:\n- Implement the algorithm to find the maximum average path\n- Optimize the algorithm for performance on large matrices\n- Document the algorithm and its usage\n- Create test cases for various matrix sizes\n- Develop a user interface for input and output\nWe will implement a dynamic programming approach to solve the problem of finding the maximum average path in a matrix. The algorithm will use a 2D list to store the maximum sum of costs up to each cell, and another 2D list to store the number of cells in the path up to each cell. This will allow us to compute the average cost efficiently. We will use the numpy library to handle matrix operations efficiently, especially for large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'maximum average': The highest average cost of all possible paths, calculated as the total cost divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum': Refers to finding the path with the highest average cost among all possible paths.\n\n# [degree adverb]\n    'maximum': Indicates that we need to find the path with the greatest average cost.\n\n# [code logic]\n1. Initialize two 2D lists (or arrays) to store:\n   - The maximum sum of costs up to each cell.\n   - The number of cells in the path up to each cell.\n2. Set the starting point (top-left cell) with its cost and count as 1.\n3. Iterate through the matrix:\n   - For each cell, calculate the possible path sums and counts from the top and left cells.\n   - Update the current cell's maximum sum and count based on the best path (highest sum).\n4. Calculate the average for each path ending at the bottom-right cell.\n5. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 3.0\n    Explanation: The path [1 -> 3 -> 4] gives a total cost of 8 over 3 cells, resulting in an average of 8/3 = 2.67, which is less than [1 -> 2 -> 4] with an average of 7/3 = 2.33. The correct path is [1 -> 2 -> 4] with an average of 7/3 = 2.33.\n\n    maxAverageOfPath([[5, 1], [1, 5]], 2) = 5.0\n    Explanation: Both paths [5 -> 1 -> 5] and [5 -> 5] have a total cost of 11 over 3 cells, resulting in an average of 11/3 = 3.67.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should handle these cases correctly by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to develop an algorithm that efficiently calculates the maximum average path in a matrix, considering only right and down movements. The solution should handle large matrices and provide a user-friendly interface for input and output.\nrequirement pool:\n- Develop the core algorithm to calculate the maximum average path\n- Create a user interface for matrix input and result display\n- Implement visualization of the path with the maximum average\n- Optimize the algorithm for performance with large matrices\n- Provide comprehensive documentation and examples\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in a square matrix. The algorithm will utilize a 2D list to store the maximum sum of paths to each cell, allowing us to compute the maximum average by dividing the maximum sum by the number of cells in the path. We will use the NumPy library for efficient matrix operations and Matplotlib for visualizing the path.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths.\n\n# [degree adverb]\n    'maximum': Refers to the highest possible average cost of a path.\n\n# [code logic]\n    1. Initialize a 2D list to store the maximum sum of paths to each cell.\n    2. Start from the top-left cell and iterate through the matrix.\n    3. For each cell, calculate the maximum sum of paths by considering the sum from the top or left cell.\n    4. Store the maximum sum in the 2D list.\n    5. At the bottom-right cell, calculate the maximum average by dividing the maximum sum by the number of cells in the path.\n    6. Return the maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is [1, 2, 4] with an average of (1+2+4)/3 = 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of zero since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will correctly compute the maximum average for any given matrix size and values.\n", "requirement analysis:\nThe function should efficiently compute the maximum average path in a matrix, considering only right and down movements. It should handle large matrices and provide clear output of the average and path taken.\nrequirement pool:\n- Efficient computation of maximum average path\n- Handle large matrices without performance degradation\n- Provide detailed path output\n- Optimize memory usage\n- User-friendly interface for input and output\nWe will use dynamic programming to efficiently compute the maximum average path in the matrix. This approach will allow us to handle large matrices without performance degradation. We will utilize NumPy for efficient matrix operations and storage. The function will return both the maximum average and the path taken.\nPlease read and understand the following inteperation before coding\n## Prompt 3:\n\n[requirement]\nGiven a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell and moves only right or down to end on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n[plan]\nWe will use dynamic programming to efficiently compute the maximum average path in the matrix. This approach will allow us to handle large matrices without performance degradation. We will utilize NumPy for efficient matrix operations and storage. The function will return both the maximum average and the path taken.\n\n## Answer 3:\n\n# [core concept]\n    'path': A sequence of cells starting from the top-left and moving only right or down to reach the bottom-right cell.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost per cell.\n\n# [degree adverb] \n    'maximum': Indicates that we are looking for the path with the highest possible average cost.\n\n# [code logic]\n    - Initialize a dynamic programming table to store maximum sums for each cell.\n    - Start from the top-left corner and iterate through each cell.\n    - For each cell, calculate the maximum sum by considering paths from the top or left.\n    - Compute the average by dividing the sum by the number of cells in the path.\n    - Track the path taken to achieve this maximum average.\n    - Return both the maximum average and the path.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The possible paths are [1, 2, 4] and [1, 3, 4]. Both have an average of (1+2+4)/3 = 2.33 and (1+3+4)/3 = 2.67 respectively. The maximum average is 2.67.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of zero since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these cases by considering all possible paths and calculating averages accordingly.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The challenge lies in efficiently computing this for larger matrices while ensuring accuracy.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path\n- Optimize the algorithm for scalability\n- Ensure the output is user-friendly\n- Test the solution with various matrix sizes\n- Document the solution process\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. The algorithm will use a 2D list to store the maximum sum of costs up to each cell, and then calculate the average by dividing the sum by the number of cells in the path. This approach ensures scalability for larger matrices. We will use the NumPy library to handle matrix operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left and moving only right or down to the bottom-right.\n    'average': The total cost divided by the number of cells visited in the path.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    'maximum': We need to find the path with the highest average cost among all possible paths.\n\n# [code logic]\n    1. Initialize a 2D list to store the maximum sum of costs up to each cell.\n    2. Start from the top-left cell and iterate through the matrix.\n    3. For each cell, calculate the maximum sum of costs by considering the sum from the cell above and the cell to the left.\n    4. Once the bottom-right cell is reached, calculate the average by dividing the sum by the number of cells in the path.\n    5. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle matrices of any size, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, which involves calculating the sum of costs and dividing by the number of cells. The solution should handle matrices of varying sizes efficiently and provide clear outputs.\nrequirement pool:\n- Implement the main algorithm to calculate maximum average path\n- Optimize the algorithm for performance with large matrices\n- Develop error handling for invalid matrix inputs\n- Create a user-friendly interface for input and output\n- Document the code for maintainability and clarity\nWe will implement a dynamic programming approach to calculate the maximum average path in the matrix. This approach will efficiently compute the maximum sum path from the top-left to the bottom-right corner by storing intermediate results, thus optimizing performance for larger matrices. We will also include input validation to ensure the matrix is square and contains valid numerical values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path'\n    Explanation: A path is a sequence of cells starting from the top-left cell and moving only right or down to reach the bottom-right cell.\n\n    'maximum average'\n    Explanation: The goal is to find the path with the highest average cost, calculated as the total cost of the path divided by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': means we need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right cell.\n\n# [code logic]\n    1. Validate that the input matrix is square and contains valid numerical values.\n    2. Use dynamic programming to calculate the maximum sum path from the top-left to the bottom-right corner.\n    3. Initialize a 2D list to store the maximum sum up to each cell.\n    4. Iterate over each cell, updating the maximum sum by considering the maximum sum from the top or left cell.\n    5. Calculate the average by dividing the maximum sum at the bottom-right cell by the number of cells in the path.\n    6. Return the maximum average.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix contains only one cell, so the path is just that cell, and its average is its value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is [1, 2, 4] with a total cost of 7 over 3 cells, giving an average of 2.33.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have a total cost of 0, so the average is also 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using dynamic programming will naturally handle these cases by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle large matrices and provide accurate results.\nrequirement pool:\n- Implement the algorithm to find the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Provide comprehensive documentation and code comments.\n- Include test cases for various matrix sizes.\n- Ensure the solution is user-friendly and easy to integrate.\nWe will implement a dynamic programming solution to efficiently compute the maximum average path in the matrix. The algorithm will utilize memoization to store intermediate results and avoid redundant calculations, ensuring optimal performance even for large matrices. We will use NumPy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell and ending at the bottom-right cell, moving only right or down.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    'maximum': We need to find the path with the highest average cost among all possible paths.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for paths ending at each cell.\n    2. Use dynamic programming to fill this matrix, starting from the top-left cell.\n    3. For each cell, calculate the maximum sum of costs by considering paths from the left and above.\n    4. Divide the maximum sum by the number of cells in the path to get the average.\n    5. Keep track of the maximum average found during the process.\n    6. Return the maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value itself.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is [1, 2, 4] with an average of (1+2+4)/3 = 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of zero since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size, including single-cell matrices and matrices with zero values.\n"], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [1.0, 1.0, 0.0, 0.2647, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0], "pass_results": [true, true, false, false, true, false, false, true, false, true], "pass_test_cases_num": [102, 102, 0, 27, 102, 0, 0, 102, 0, 102], "completion": "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path from top-left to bottom-right in a matrix.\n    \n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N containing integer costs.\n    n (int): The size of the matrix.\n    \n    Returns:\n    float: The maximum average cost of a path.\n    \"\"\"\n    # Initialize a memoization table to store the maximum sum of costs for paths ending at each cell\n    dp = np.zeros((n, n), dtype=float)\n    \n    # Base case: the starting point\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row (can only come from the left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum sum of costs for the current cell can come from either the left or above\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # The number of cells in the path from top-left to bottom-right is 2n-1\n    path_length = 2 * n - 1\n    \n    # Calculate the maximum average by dividing the maximum sum by the number of cells in the path\n    max_average = dp[n-1][n-1] / path_length\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "passed": true, "pass": true, "pass_num": 5, "round": 827, "mutate_method": "expand_one2two", "parent_index": 213}
