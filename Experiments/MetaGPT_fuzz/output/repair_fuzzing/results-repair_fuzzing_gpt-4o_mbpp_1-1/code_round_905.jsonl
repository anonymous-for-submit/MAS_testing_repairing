{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 751, "prompt": "Write a function to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap, while [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/", "code": "def check_min_heap_helper(arr, i):\n    if 2 * i + 2 > len(arr):\n        return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or (arr[i] <= arr[2 * i + 2] \n                                      and check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\n\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)", "test_imports": [], "test_list": ["assert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "assert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "assert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "assert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "assert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "assert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "assert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "assert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "assert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "assert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "assert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "assert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "assert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "assert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "assert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "assert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "assert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "assert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "assert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "assert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "assert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "assert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "assert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "assert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "assert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "assert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "assert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "assert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "assert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "assert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "assert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "assert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "assert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "assert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "assert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "assert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "assert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "assert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "assert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "assert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "assert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "assert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "assert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "assert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "assert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "assert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "assert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "assert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "assert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "assert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "assert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "assert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "assert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "assert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "assert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "assert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "assert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "assert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "assert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "assert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "assert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "assert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "assert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "assert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "assert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "assert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "assert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "assert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "assert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "assert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "assert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "assert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "assert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "assert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "assert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "assert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "assert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "assert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "assert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "assert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "assert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "assert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "assert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "assert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "assert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "assert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "assert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "assert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "assert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "assert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "assert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "assert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "assert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "assert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "assert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "assert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "assert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "assert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "assert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "assert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "assert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "assert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "entry_point": "check_min_heap", "repair_prompt": ["Write a function check_min_heap to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap, while [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Write a function check_min_heap to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap. In contrast, the array [1, 3, 10, 7, 9, 11] is not a min heap. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Write a function check_min_heap to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap, while [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n"], "completions": ["from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to check.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through all non-leaf nodes\n    for i in range((n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the current node is greater than its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the current node is greater than its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3]))  # Expected output: True\n# print(check_min_heap([3, 2, 1]))  # Expected output: False\n# print(check_min_heap([1]))        # Expected output: True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # An empty array or a single-element array is a valid min heap\n    if n == 0 or n == 1:\n        return True\n\n    # Iterate through each parent node in the array\n    for i in range((n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the left child exists and violates the min heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the right child exists and violates the min heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Should return True\n# print(check_min_heap([1, 3, 2, 7, 6, 5]))  # Should return True\n# print(check_min_heap([10, 15, 14, 25, 30]))  # Should return False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, n: int) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    n (int): The number of elements in the array.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Iterate through each parent node in the array\n    for i in range(n // 2):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the current node is less than or equal to its left child (if it exists)\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the current node is less than or equal to its right child (if it exists)\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    # If all nodes satisfy the min heap property, return True\n    return True\n\n# Example usage:\n# print(check_min_heap([1], 1))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6], 6))  # Expected output: True\n# print(check_min_heap([1, 3, 10, 7, 9, 11], 6))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, n: int) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    n (int): The size of the array.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Iterate over each parent node in the array\n    for i in range(n // 2):\n        # Calculate the indices of the left and right children\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        # Check if the current node is less than or equal to its left child\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the current node is less than or equal to its right child\n        if right < n and arr[i] > arr[right]:\n            return False\n\n    # If all nodes satisfy the min heap property, return True\n    return True\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test cases\n    print(check_min_heap([1], 1))  # Expected output: True\n    print(check_min_heap([1, 2, 3, 4, 5, 6], 6))  # Expected output: True\n    print(check_min_heap([1, 3, 10, 7, 9, 11], 6))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, n: int) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    n (int): The number of elements in the array.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    for i in range(n):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the left child exists and is greater than the parent\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the right child exists and is greater than the parent\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    return True\n\n# Example usage:\n# print(check_min_heap([1], 1))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6], 6))  # Expected output: True\n# print(check_min_heap([10, 9, 8, 7, 6, 5], 6))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    index (int): The starting index for checking the min heap property.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the array is empty or has one element, it is a min heap\n    if n <= 1:\n        return True\n\n    # Iterate through the array and check the min heap property\n    for i in range(n):\n        # Calculate the indices of the left and right children\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        # Check if the left child exists and violates the min heap property\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the right child exists and violates the min heap property\n        if right < n and arr[i] > arr[right]:\n            return False\n\n    # If no violations are found, the array is a min heap\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    A min heap is a binary tree where the parent node is less than or equal to its child nodes.\n    This property must hold for all nodes in the tree.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index in the array, default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the array is empty or has one element, it is a min heap\n    if n == 0 or n == 1:\n        return True\n\n    # Iterate through each parent node\n    for i in range((n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the parent node is greater than the left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the parent node is greater than the right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> (bool, str):\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    (bool, str): A tuple where the first element is True if the array is a min heap, False otherwise.\n                 The second element is an error message if the array is not a min heap, or an empty string if it is.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] > arr[left]:\n            return False, f\"Heap property violated at index {i}: parent {arr[i]} > left child {arr[left]}\"\n        \n        if right < n and arr[i] > arr[right]:\n            return False, f\"Heap property violated at index {i}: parent {arr[i]} > right child {arr[right]}\"\n\n    return True, \"\"\n\n# Example usage:\n# result, message = check_min_heap([1, 2, 3])\n# print(result, message)  # Output: True, \"\"\n# result, message = check_min_heap([3, 1, 2])\n# print(result, message)  # Output: False, \"Heap property violated at index 0: parent 3 > left child 1\"\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index for heap validation. Default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through all non-leaf nodes\n    for i in range((n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and violates the min heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Min heap property violated at index {i}: {arr[i]} > {arr[left_child_index]}\")\n            return False\n        \n        # Check if the right child exists and violates the min heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Min heap property violated at index {i}: {arr[i]} > {arr[right_child_index]}\")\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected: True\n# print(check_min_heap([1, 3, 10, 7, 9, 11]))  # Expected: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    index (int): The starting index to check the heap property. Defaults to 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each parent node in the array\n    for i in range(index, (n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the parent node is greater than the left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the parent node is greater than the right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1], 0))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6], 0))  # Expected output: True\n# print(check_min_heap([1, 3, 10, 7, 9, 11], 0))  # Expected output: False\n"], "plans": ["requirement analysis:\nThe function should efficiently determine if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. The solution should handle arrays of varying sizes and edge cases, such as empty arrays or single-element arrays.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap property\n- Optimize the function for large datasets\n- Provide comprehensive documentation and examples\n- Include error handling for invalid inputs\n- Test the function with edge cases\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring the function is efficient and can handle large datasets. We will not use any external libraries as the task is straightforward and can be efficiently handled with basic Python constructs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a valid min heap, each parent node's value must be less than or equal to its child nodes' values. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last non-leaf node.\n    2. For each node, calculate the indices of its left and right children.\n    3. Check if the current node's value is less than or equal to its children's values.\n    4. If any node violates the min heap property, return False.\n    5. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3], 0) = True\n    Explanation: The root node (1) is less than both its children (2 and 3), satisfying the min heap property.\n    \n    check_min_heap([3, 2, 1], 0) = False\n    Explanation: The root node (3) is greater than its left child (2), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases like empty arrays and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap\n- Optimize for large array inputs\n- Provide detailed error messages\n- Include edge case handling\n- Document usage examples\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will ensure the array represents a min heap. We will handle edge cases such as empty arrays and provide detailed error messages for invalid heaps. The function will be optimized for large datasets by using a simple loop structure without additional overhead.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to the values at its child indices (2*i + 1 and 2*i + 2).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap(arr, n)` where `arr` is the array and `n` is the index of the current node.\n    2. Iterate through each node in the array up to the last parent node.\n    3. For each node, calculate the indices of its left and right children.\n    4. Check if the current node's value is less than or equal to its children's values.\n    5. If any node violates the min heap property, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([], 0) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap since there are no children to compare with.\n\n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty arrays and single-element arrays as valid min heaps.\n", "requirement analysis:\nThe function should efficiently determine if an array satisfies the min heap property, where each parent node is less than or equal to its child nodes. The solution should handle edge cases, such as empty arrays and single-element arrays, and be optimized for performance with large datasets.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Include comprehensive test cases\n- Provide detailed documentation and examples\n- Ensure compatibility with Python 3.x\nWe will implement a function named `check_min_heap` that checks if a given array represents a min heap. The function will iterate through each parent node and verify that it is less than or equal to its child nodes. This approach ensures that the function is efficient and can handle large arrays. We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by iterating through the array and checking if each parent node satisfies this condition with its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index (starting from 0).\n    2. Iterate through each node in the array up to the last parent node.\n    3. For each node, calculate the indices of its left and right children.\n    4. Check if the current node is less than or equal to its left child (if it exists).\n    5. Check if the current node is less than or equal to its right child (if it exists).\n    6. If any of these conditions fail, return False.\n    7. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: The array satisfies the min heap property as each parent node is less than or equal to its children.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' is greater than its parent '3', violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship inherently handles these cases.\n", "requirement analysis:\nThe requirement is to create a function that checks if a given array represents a min heap. A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children. The function should efficiently handle arrays of varying sizes and provide accurate results.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap properties.\n- Optimize the function for performance with large datasets.\n- Include detailed documentation and examples for user guidance.\n- Create test cases to validate the function's accuracy.\n- Ensure compatibility with different Python versions.\nWe will implement a function named check_min_heap that verifies if a given array represents a min heap. A min heap is a binary tree where each parent node is less than or equal to its child nodes. The function will iterate through the array and check the heap property for each node. We will use Python's built-in capabilities to handle the array efficiently, ensuring the function performs well even with large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where each parent node is less than or equal to its child nodes. This property must be maintained throughout the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index (default to 0) as input.\n    2. Calculate the length of the array.\n    3. For each node at index `i`, calculate the indices of its left and right children.\n    4. Check if the current node is less than or equal to its left and right children (if they exist).\n    5. If any node violates the min heap property, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: The array satisfies the min heap property as each parent node is less than or equal to its children.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' at index 2 is greater than its parent '3', violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should iterate through the array and ensure that each parent node is less than or equal to its child nodes, adhering to the min heap property. The function should be efficient, ideally with a time complexity of O(n).\nrequirement pool:\n- Implement the check_min_heap function to verify min heap properties.\n- Optimize the function for performance with large arrays.\n- Provide comprehensive documentation and examples.\n- Include error handling for invalid inputs.\n- Create test cases to validate the function's accuracy.\nWe will implement a function named check_min_heap that iterates through the given array and checks if each parent node is less than or equal to its child nodes, which is the property of a min heap. The function will be optimized for performance with a time complexity of O(n). We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is always less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node in the heap, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by iterating through the array and checking if each element is less than or equal to its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index as input.\n    2. Iterate through the array from the given index.\n    3. For each element at index `i`, calculate the indices of its left and right children.\n    4. Check if the current element is less than or equal to its left and right children (if they exist).\n    5. If any parent node is greater than its child, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([10, 9, 8, 7, 6, 5], 0) = False\n    Explanation: The first element (10) is greater than its children (9 and 8), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently determine if a given array satisfies the min heap property, where each parent node is less than or equal to its child nodes. The solution should handle edge cases, such as empty arrays and arrays with a single element, and should be optimized for performance with large datasets.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Include comprehensive test cases\n- Provide detailed documentation and examples\n- Ensure compatibility with different Python versions\nWe will implement a function named check_min_heap that verifies if a given array satisfies the min heap property. The function will iterate through the array and check if each parent node is less than or equal to its child nodes. We will use Python's built-in capabilities to handle edge cases such as empty arrays and arrays with a single element. The function will be optimized for performance with large datasets by minimizing unnecessary computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must be satisfied for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array.\n    2. For each element at index i, check if it satisfies the min heap property with its children at indices 2*i + 1 and 2*i + 2.\n    3. If any parent node is greater than its child nodes, return False.\n    4. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([], 0) = True\n    Explanation: An empty array can be considered a min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap as there are no child nodes to compare.\n\n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their child nodes, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers empty arrays and single-element arrays as valid min heaps.\n", "requirement analysis:\nThe requirement is to create a function that checks if a given array represents a min heap. The function should be efficient, handle edge cases, and be easy to integrate. The solution should be based on the properties of a min heap, where each parent node is less than or equal to its child nodes.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap property.\n- Optimize the function for large datasets.\n- Include comprehensive documentation and examples.\n- Ensure compatibility with Python 2 and 3.\n- Handle edge cases such as empty arrays or single-element arrays.\nWe will implement a function named check_min_heap that verifies if a given array represents a min heap. The function will iterate through each parent node and check if it is less than or equal to its child nodes. This approach ensures efficiency and handles large datasets effectively. We will also handle edge cases such as empty arrays and single-element arrays. The function will be compatible with both Python 2 and 3, and we will use standard Python libraries to maintain simplicity and ease of integration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node in the heap must be less than or equal to its child nodes. In code, this can be implemented by iterating through the array and checking if each parent node satisfies this condition with its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last parent node.\n    2. For each parent node at index i, calculate the indices of its left and right children.\n    3. Check if the parent node is less than or equal to its left child (if it exists).\n    4. Check if the parent node is less than or equal to its right child (if it exists).\n    5. If any parent node fails these checks, return False.\n    6. If all checks pass, return True.\n\n# [edge case] \n    check_min_heap([]) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6]) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty arrays and single-element arrays by iterating only when there are elements to check.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide meaningful feedback when the array does not meet heap properties.\nrequirement pool:\n- Implement the main heap validation logic.\n- Optimize the function for large array inputs.\n- Provide detailed error messages for invalid heaps.\n- Ensure compatibility with different Python versions.\n- Include comprehensive documentation and examples.\nWe will implement a function named `check_min_heap` that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will ensure the array satisfies the min heap property. We will optimize the function to handle large arrays efficiently by using a simple loop without recursion. Additionally, we will provide detailed error messages indicating the first occurrence where the heap property is violated.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must be satisfied for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a min heap, each parent node's value should be less than or equal to its child nodes' values. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to the values at its child indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last element that has children.\n    2. For each element at index `i`, calculate the indices of its left and right children: `left = 2*i + 1` and `right = 2*i + 2`.\n    3. Check if the element at index `i` is less than or equal to the elements at indices `left` and `right`.\n    4. If any parent node is greater than its child node, return False.\n    5. If all parent nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3], 0) = True\n    Explanation: The root node (1) is less than both of its children (2 and 3), satisfying the min heap property.\n    \n    check_min_heap([3, 1, 2], 0) = False\n    Explanation: The root node (3) is greater than its left child (1), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide feedback for invalid heaps.\nrequirement pool:\n- Implement the min heap validation logic.\n- Optimize the function for large arrays.\n- Provide detailed error messages for invalid heaps.\n- Ensure compatibility with various Python versions.\n- Include comprehensive test cases.\nWe will implement a function to check if a given array represents a min heap by ensuring each parent node is less than or equal to its child nodes. We will use a simple loop to iterate through the array and check the heap property for each node. The function will provide detailed error messages indicating which node violates the min heap property.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to'\n    Explanation: This indicates that for each parent node in the heap, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last non-leaf node.\n    2. For each node, calculate the indices of its left and right children.\n    3. Check if the current node is less than or equal to its left child (if it exists).\n    4. Check if the current node is less than or equal to its right child (if it exists).\n    5. If any node violates the min heap property, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than their child nodes, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' is greater than its parent '3', violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. The solution should be optimized for performance, especially with large arrays, and include comprehensive documentation.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap properties.\n- Optimize the function for performance with large datasets.\n- Provide detailed documentation and examples for users.\n- Include error handling for invalid inputs.\n- Create test cases to validate the function's accuracy.\nWe will implement a function named check_min_heap that verifies if a given array represents a min heap. The function will iterate through the array and ensure that each parent node is less than or equal to its child nodes. We will use Python's built-in capabilities to handle array operations efficiently. The function will be optimized for performance, especially with large datasets, and will include comprehensive documentation and examples for users.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a valid min heap, each parent node must be less than or equal to its child nodes. In code, this can be implemented by checking if the value at the parent index is less than or equal to the values at the child indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element in the array up to the last parent node.\n    2. For each parent node, calculate the indices of its left and right children.\n    3. Check if the parent node is less than or equal to its children.\n    4. If any parent node is greater than its children, return False.\n    5. If all parent nodes satisfy the condition, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' is greater than its child '7', violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship inherently handles these cases.\n"], "test": ["def check(check_min_heap):\n\tassert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "scores": [0.2843, 0.2843, 0.4216, 0.4216, 0.4216, 0.2843, 0.2843, 0.0, 0.2843, 0.9902], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [29, 29, 43, 43, 43, 29, 29, 0, 29, 101], "completion": "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    index (int): The starting index to check the heap property. Defaults to 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each parent node in the array\n    for i in range(index, (n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the parent node is greater than the left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the parent node is greater than the right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1], 0))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6], 0))  # Expected output: True\n# print(check_min_heap([1, 3, 10, 7, 9, 11], 0))  # Expected output: False\n", "passed": false, "pass": false, "pass_num": 0, "round": 905, "mutate_method": "condense_two2one", "parent_index": 493}
