{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 751, "prompt": "Write a function to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap, but [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/", "code": "def check_min_heap_helper(arr, i):\n    if 2 * i + 2 > len(arr):\n        return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or (arr[i] <= arr[2 * i + 2] \n                                      and check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\n\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)", "test_imports": [], "test_list": ["assert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "assert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "assert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "assert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "assert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "assert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "assert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "assert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "assert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "assert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "assert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "assert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "assert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "assert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "assert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "assert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "assert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "assert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "assert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "assert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "assert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "assert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "assert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "assert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "assert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "assert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "assert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "assert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "assert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "assert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "assert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "assert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "assert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "assert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "assert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "assert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "assert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "assert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "assert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "assert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "assert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "assert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "assert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "assert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "assert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "assert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "assert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "assert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "assert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "assert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "assert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "assert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "assert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "assert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "assert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "assert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "assert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "assert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "assert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "assert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "assert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "assert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "assert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "assert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "assert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "assert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "assert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "assert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "assert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "assert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "assert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "assert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "assert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "assert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "assert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "assert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "assert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "assert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "assert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "assert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "assert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "assert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "assert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "assert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "assert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "assert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "assert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "assert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "assert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "assert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "assert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "assert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "assert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "assert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "assert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "assert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "assert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "assert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "assert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "assert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "assert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "assert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "entry_point": "check_min_heap", "repair_prompt": ["Write a function check_min_heap to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap, but [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Write a function check_min_heap to check if the given array represents min heap or not. As an example, [1, 3, 5, 7, 9, 11] is a min heap. However, [1, 3, 10, 7, 9, 11] is not a min heap. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Write a function check_min_heap to check if the given array represents min heap or not. For example, [1, 3, 5, 7, 9, 11] is a min heap, while [1, 3, 10, 7, 9, 11] is not. Find the solution at: https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n"], "completions": ["from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each element up to the last parent node\n    for i in range(n // 2):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the current element is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the current element is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1]))  # Expected output: True\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([1, 3, 10, 7, 9, 11]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index in the array to check.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through all parent nodes\n    for i in range((n - 2) // 2 + 1):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        # Check if the current node is greater than the left child\n        if left < n and arr[i] > arr[left]:\n            print(f\"Node at index {i} with value {arr[i]} is greater than its left child at index {left} with value {arr[left]}.\")\n            return False\n        \n        # Check if the current node is greater than the right child\n        if right < n and arr[i] > arr[right]:\n            print(f\"Node at index {i} with value {arr[i]} is greater than its right child at index {right} with value {arr[right]}.\")\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([10, 5, 6, 2, 3, 4]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each element up to the last parent node\n    for i in range(n // 2):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the current element is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Error: Parent node {arr[i]} at index {i} is greater than left child {arr[left_child_index]} at index {left_child_index}.\")\n            return False\n        \n        # Check if the current element is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Error: Parent node {arr[i]} at index {i} is greater than right child {arr[right_child_index]} at index {right_child_index}.\")\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([10, 9, 8, 7, 6, 5]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check. Default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each element up to the last parent node\n    for i in range(n // 2):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the parent node is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the parent node is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 2, 3, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([10, 9, 8, 7, 6, 5]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> tuple:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index for checking, default is 0.\n\n    Returns:\n    tuple: (bool, str) where bool indicates if the array is a min heap,\n           and str provides an error message if it is not.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return (False, f\"Heap property violated at index {i}: parent {arr[i]} > left child {arr[left_child_index]}\")\n\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return (False, f\"Heap property violated at index {i}: parent {arr[i]} > right child {arr[right_child_index]}\")\n\n    return (True, '')\n\n# Example usage:\n# result = check_min_heap([1, 2, 3, 4, 5, 6])\n# print(result)  # Output: (True, '')\n# result = check_min_heap([1, 3, 10, 7, 9, 11])\n# print(result)  # Output: (False, 'Heap property violated at index 2: parent 10 > left child 9')\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through the array\n    for i in range(n):\n        # Calculate indices of left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if left child exists and violates min heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Error: Parent node {arr[i]} at index {i} is greater than left child {arr[left_child_index]} at index {left_child_index}.\")\n            return False\n        \n        # Check if right child exists and violates min heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Error: Parent node {arr[i]} at index {i} is greater than right child {arr[right_child_index]} at index {right_child_index}.\")\n            return False\n    \n    # If all checks pass, the array is a min heap\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each parent node in the array\n    for i in range(n // 2):  # Only need to check up to the last parent node\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the parent node is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Min heap property violated at index {i}: parent {arr[i]} > left child {arr[left_child_index]}\")\n            return False\n        \n        # Check if the parent node is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Min heap property violated at index {i}: parent {arr[i]} > right child {arr[right_child_index]}\")\n            return False\n    \n    # If all conditions are satisfied, the array is a min heap\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index to check the heap property. Defaults to 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each node in the array\n    for i in range(index, n):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and if the parent node is greater than the left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the right child exists and if the parent node is greater than the right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    # If all nodes satisfy the min heap property, return True\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, n: int) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    n (int): The number of elements in the array.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    # Iterate through each parent node in the array\n    for i in range((n - 2) // 2 + 1):\n        # Calculate the indices of the left and right children\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        # Check if the left child exists and is greater than the parent\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the right child exists and is greater than the parent\n        if right < n and arr[i] > arr[right]:\n            return False\n\n    # If all parent nodes satisfy the min heap property, return True\n    return True\n\n# Example usage:\n# print(check_min_heap([1], 1))  # True\n# print(check_min_heap([1, 2, 3, 4, 5, 6], 6))  # True\n# print(check_min_heap([1, 3, 10, 7, 9, 11], 6))  # False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the index is beyond the last element, return True\n    if index >= n:\n        return True\n\n    # Calculate the indices of the left and right children\n    left = 2 * index + 1\n    right = 2 * index + 2\n\n    # Check if the current node is greater than the left child\n    if left < n and arr[index] > arr[left]:\n        print(f\"Min heap property violated at index {index}: {arr[index]} > {arr[left]}\")\n        return False\n\n    # Check if the current node is greater than the right child\n    if right < n and arr[index] > arr[right]:\n        print(f\"Min heap property violated at index {index}: {arr[index]} > {arr[right]}\")\n        return False\n\n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left) and check_min_heap(arr, right)\n\n# Example usage:\n# print(check_min_heap([1, 2, 3]))  # Should return True\n# print(check_min_heap([3, 1, 2]))  # Should return False\n"], "plans": ["requirement analysis:\nThe function should efficiently check if the given array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases like empty arrays and provide informative feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap\n- Optimize for large array inputs\n- Provide detailed error messages\n- Include unit tests for various scenarios\n- Document the function usage and edge cases\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring O(n) time complexity, which is efficient for large arrays. We will also include error messages to indicate why an array is not a min heap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by iterating through the array and checking if each element is less than or equal to its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element of the array up to the last parent node.\n    2. For each element at index `i`, calculate the indices of its left and right children.\n    3. Check if the current element is less than or equal to its left child (if it exists).\n    4. Check if the current element is less than or equal to its right child (if it exists).\n    5. If any of these conditions fail, return False.\n    6. If all conditions are satisfied, return True.\n\n# [edge case] \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap because there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6]) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11]) = False\n    Explanation: The element '10' is greater than its parent '3', violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide informative feedback for invalid heaps.\nrequirement pool:\n- Implement the min heap validation logic\n- Optimize for large array inputs\n- Provide detailed error messages\n- Ensure compatibility with various Python versions\n- Include comprehensive test cases\nWe will implement a function to check if a given array represents a min heap by ensuring each parent node is less than or equal to its child nodes. We will use Python's native capabilities to handle array operations efficiently. The function will iterate through the array and verify the heap property for each node. For large arrays, the function will be optimized to minimize time complexity. Detailed error messages will be provided to explain why an array is not a min heap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a valid min heap, each parent node's value must be less than or equal to its child nodes' values. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last element that has children.\n    2. For each element at index `i`, calculate the indices of its left and right children: `left = 2*i + 1` and `right = 2*i + 2`.\n    3. Check if the element at index `i` is less than or equal to its left child (if it exists).\n    4. Check if the element at index `i` is less than or equal to its right child (if it exists).\n    5. If any parent node is greater than its child, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([10, 5, 6, 2, 3, 4], 0) = False\n    Explanation: The root node (10) is greater than its left child (5), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each node's children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide meaningful feedback when the array does not meet the min heap criteria.\nrequirement pool:\n- Implement the min heap validation logic.\n- Optimize the function for large arrays.\n- Include detailed error messages for invalid heaps.\n- Ensure compatibility with various Python versions.\n- Provide documentation and examples for usage.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring the function is efficient for large arrays. We will also include detailed error messages to indicate which part of the array violates the min heap property.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented using the `<=` operator.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element in the array up to the last parent node.\n    2. For each element at index `i`, calculate the indices of its left and right children.\n    3. Check if the current element is less than or equal to its left child (if it exists).\n    4. Check if the current element is less than or equal to its right child (if it exists).\n    5. If any of these conditions are violated, return False.\n    6. If all conditions are satisfied, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([10, 9, 8, 7, 6, 5], 0) = False\n    Explanation: The first element (10) is greater than its children (9 and 8), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent node against its children inherently handles these cases.\n", "requirement analysis:\nThe function should iterate through the array and ensure that each parent node is less than or equal to its child nodes, adhering to the min heap property. The function should be efficient, handling large arrays without significant performance degradation.\nrequirement pool:\n- Implement the main function to check min heap properties.\n- Optimize the function for performance with large datasets.\n- Write comprehensive documentation and examples.\n- Create unit tests to validate the function's correctness.\n- Ensure compatibility with different Python versions.\nWe will implement a function that iterates through the given array and checks if each parent node is less than or equal to its child nodes, adhering to the min heap property. We will use Python's native capabilities without additional libraries, as the task is straightforward and does not require complex data structures or algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This ensures that the smallest element is always at the root of the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes in the array representation of the heap.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element in the array up to the last parent node.\n    2. For each parent node at index `i`, calculate the indices of its left and right children.\n    3. Check if the parent node is less than or equal to its left child (if it exists).\n    4. Check if the parent node is less than or equal to its right child (if it exists).\n    5. If any parent node is greater than its child, return False.\n    6. If all parent nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([10, 9, 8, 7, 6, 5], 0) = False\n    Explanation: The root node (10) is greater than its children (9 and 8), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently checks all necessary conditions for a min heap.\n", "requirement analysis:\nThe function should efficiently check if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide informative feedback for invalid heaps.\nrequirement pool:\n- Implement the main heap validation logic.\n- Optimize for large array inputs.\n- Provide detailed error messages for invalid heaps.\n- Ensure compatibility with various Python versions.\n- Include comprehensive test cases.\nWe will implement a function to check if a given array represents a min heap by ensuring each parent node is less than or equal to its child nodes. We will use a simple loop to iterate through the array and check the heap property for each node. The function will handle large arrays efficiently by using a linear time complexity approach. Additionally, we will provide detailed error messages for invalid heaps by identifying the first instance where the heap property is violated.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array using a loop.\n    2. For each node at index i, check if it satisfies the min heap property:\n        - The left child is at index 2*i + 1.\n        - The right child is at index 2*i + 2.\n    3. Ensure that the value at index i is less than or equal to the values at its child indices.\n    4. If any node violates the min heap property, return False.\n    5. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its child nodes, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element at index 2 (value 10) is greater than its child at index 5 (value 9), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Include error handling and messaging\n- Document the function usage and edge cases\n- Test the function with various datasets\nWe will implement a function named `check_min_heap` that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will ensure the array satisfies the min heap property. We will use Python's built-in capabilities without any additional libraries to keep the solution simple and efficient. The function will also provide detailed error messages if the array does not represent a min heap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must be maintained throughout the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array using an index.\n    2. For each element at index `i`, calculate the indices of its left and right children using the formulas `2*i + 1` and `2*i + 2`.\n    3. Check if the current element is less than or equal to its children (if they exist).\n    4. If any parent node is greater than its child node, return False.\n    5. If all parent nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its child nodes, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' at index 2 is greater than its child '7' at index 3, violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main heap validation logic.\n- Optimize for large array inputs.\n- Provide detailed error messages for invalid heaps.\n- Ensure compatibility with various Python versions.\n- Include comprehensive documentation.\nWe will implement a function named `check_min_heap` that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done using a simple loop, ensuring O(n) time complexity for efficiency. We will also include detailed error messages to indicate which part of the array violates the min heap property.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented by checking if `array[parent] <= array[child]` for each parent-child relationship.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element of the array up to the last parent node.\n    2. For each parent node at index `i`, calculate the indices of its left and right children.\n    3. Check if the parent node is less than or equal to its left child (if it exists).\n    4. Check if the parent node is less than or equal to its right child (if it exists).\n    5. If any of these conditions are violated, return False.\n    6. If all conditions are satisfied, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap because there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' at index 2 is greater than its child '7' at index 3, violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array satisfies the min heap property, where each parent node is less than or equal to its child nodes. The solution should handle edge cases such as empty arrays and single-element arrays.\nrequirement pool:\n- Implement the check_min_heap function to verify min heap properties.\n- Optimize the function for performance with large datasets.\n- Include comprehensive test cases to cover various scenarios.\n- Provide detailed documentation and usage examples.\n- Ensure compatibility with different Python versions.\nWe will implement a function named check_min_heap that verifies if a given array satisfies the min heap property. The function will iterate through the array and check if each parent node is less than or equal to its child nodes. We will use Python's built-in capabilities without any external libraries to keep the implementation simple and efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its child nodes. This property must be satisfied for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its child nodes. In code, this can be implemented using the `<=` operator.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index (default to 0) as input.\n    2. Calculate the length of the array.\n    3. Iterate through each node in the array:\n       - For each node at index `i`, calculate the indices of its left and right children.\n       - Check if the left child exists and if the parent node is greater than the left child. If so, return False.\n       - Check if the right child exists and if the parent node is greater than the right child. If so, return False.\n    4. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: Each parent node is less than or equal to its children, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element at index 2 (value 10) is greater than its child at index 5 (value 11), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent-child relationship in the array will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently determine if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. The solution should be optimized for performance, especially for large arrays, and include comprehensive documentation and examples.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large datasets\n- Provide detailed documentation and examples\n- Include error handling for invalid inputs\n- Create test cases for various scenarios\nWe will implement a function named `check_min_heap` that verifies if a given array represents a min heap. The function will iterate through each parent node and check if it is less than or equal to its child nodes. This approach ensures that the function runs in O(n) time complexity, making it efficient for large datasets. We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each element in the array up to the last parent node.\n    2. For each parent node at index `i`, check its left child at index `2*i + 1` and right child at index `2*i + 2`.\n    3. Ensure the parent node is less than or equal to both child nodes.\n    4. If any parent node is greater than its child nodes, return False.\n    5. If all parent nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than their child nodes, satisfying the min heap property.\n    \n    check_min_heap([1, 3, 10, 7, 9, 11], 0) = False\n    Explanation: The element '10' at index 2 is greater than its child '7' at index 3, violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent node against its children inherently handles all edge cases.\n", "requirement analysis:\nThe function should efficiently check if an array is a min heap by ensuring each parent node is less than or equal to its child nodes. It should handle edge cases like empty arrays and provide informative feedback when the array does not meet heap properties.\nrequirement pool:\n- Implement the main heap validation logic.\n- Optimize the function for large arrays.\n- Include detailed error messages for invalid heaps.\n- Ensure compatibility with different data types.\n- Provide documentation and examples for users.\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its child nodes. This will be done by comparing each element with its left and right children, if they exist. The function will also provide detailed error messages indicating which element violates the min heap property. We will use Python's built-in capabilities without additional libraries to ensure optimal performance for large arrays.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its child nodes. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array.\n    2. For each element at index i, calculate the indices of its left and right children: left = 2*i + 1, right = 2*i + 2.\n    3. Check if the element at index i is less than or equal to its left child (if it exists).\n    4. Check if the element at index i is less than or equal to its right child (if it exists).\n    5. If any parent node is greater than its child node, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no child nodes to compare.\n    \n    check_min_heap([1, 2, 3], 0) = True\n    Explanation: The parent node (1) is less than both child nodes (2 and 3), satisfying the min heap property.\n    \n    check_min_heap([3, 1, 2], 0) = False\n    Explanation: The parent node (3) is greater than its left child (1), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each parent node against its children will naturally handle these cases.\n"], "test": ["def check(check_min_heap):\n\tassert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "scores": [0.2843, 0.2843, 0.2843, 0.2843, 0.0, 0.2843, 0.2843, 0.9902, 0.4216, 1.0], "pass_results": [false, false, false, false, false, false, false, false, false, true], "pass_test_cases_num": [29, 29, 29, 29, 0, 29, 29, 101, 43, 102], "completion": "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the index is beyond the last element, return True\n    if index >= n:\n        return True\n\n    # Calculate the indices of the left and right children\n    left = 2 * index + 1\n    right = 2 * index + 2\n\n    # Check if the current node is greater than the left child\n    if left < n and arr[index] > arr[left]:\n        print(f\"Min heap property violated at index {index}: {arr[index]} > {arr[left]}\")\n        return False\n\n    # Check if the current node is greater than the right child\n    if right < n and arr[index] > arr[right]:\n        print(f\"Min heap property violated at index {index}: {arr[index]} > {arr[right]}\")\n        return False\n\n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left) and check_min_heap(arr, right)\n\n# Example usage:\n# print(check_min_heap([1, 2, 3]))  # Should return True\n# print(check_min_heap([3, 1, 2]))  # Should return False\n", "passed": true, "pass": true, "pass_num": 1, "round": 550, "mutate_method": "condense_two2one", "parent_index": 237}
