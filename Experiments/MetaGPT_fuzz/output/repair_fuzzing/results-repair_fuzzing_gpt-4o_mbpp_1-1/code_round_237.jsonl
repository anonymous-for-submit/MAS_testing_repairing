{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 751, "prompt": "Write a function to check if the given array represents min heap or not. Ensure to validate the heap property for all nodes and their children.", "code": "def check_min_heap_helper(arr, i):\n    if 2 * i + 2 > len(arr):\n        return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or (arr[i] <= arr[2 * i + 2] \n                                      and check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\n\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)", "test_imports": [], "test_list": ["assert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "assert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "assert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "assert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "assert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "assert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "assert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "assert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "assert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "assert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "assert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "assert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "assert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "assert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "assert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "assert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "assert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "assert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "assert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "assert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "assert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "assert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "assert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "assert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "assert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "assert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "assert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "assert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "assert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "assert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "assert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "assert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "assert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "assert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "assert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "assert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "assert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "assert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "assert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "assert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "assert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "assert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "assert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "assert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "assert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "assert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "assert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "assert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "assert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "assert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "assert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "assert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "assert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "assert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "assert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "assert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "assert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "assert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "assert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "assert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "assert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "assert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "assert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "assert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "assert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "assert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "assert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "assert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "assert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "assert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "assert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "assert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "assert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "assert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "assert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "assert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "assert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "assert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "assert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "assert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "assert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "assert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "assert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "assert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "assert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "assert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "assert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "assert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "assert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "assert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "assert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "assert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "assert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "assert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "assert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "assert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "assert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "assert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "assert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "assert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "assert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "assert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "entry_point": "check_min_heap", "repair_prompt": ["Write a function check_min_heap to check if the given array represents min heap or not. Ensure to validate the heap property for all nodes and their children.\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Write a function check_min_heap to check if the given array represents min heap or not. Ensure to validate the heap property for all nodes. Verify that the nodes maintain the required order with their children.\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n", "Write a function check_min_heap to check if the given array represents min heap or not. Validate the heap property for all nodes and their children.\ncheck_min_heap([1, 2, 3, 4, 5, 6], 0) == True\n"], "completions": ["from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index for checking the heap property. Default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    # Handle edge case for empty array\n    if not arr:\n        return True\n\n    # Iterate through each node in the array\n    for i in range(index, len(arr)):\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        # Check if the current node is less than or equal to its left child\n        if left < len(arr) and arr[i] > arr[left]:\n            return False\n\n        # Check if the current node is less than or equal to its right child\n        if right < len(arr) and arr[i] > arr[right]:\n            return False\n\n    # If all nodes satisfy the min heap property, return True\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min-heap starting from the given index.\n\n    Parameters:\n    arr (list[int]): The array to check.\n    index (int): The starting index for heap validation.\n\n    Returns:\n    bool: True if the array is a min-heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each node in the array up to the last parent node\n    for i in range(index, (n - 2) // 2 + 1):\n        # Calculate the indices of the left and right children\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        # Check if the current node is less than or equal to its left child (if it exists)\n        if left < n and arr[i] > arr[left]:\n            return False\n        \n        # Check if the current node is less than or equal to its right child (if it exists)\n        if right < n and arr[i] > arr[right]:\n            return False\n    \n    # If all nodes satisfy the min-heap property, return True\n    return True\n\n# Example usage:\n# print(check_min_heap([1], 0))  # Expected: True\n# print(check_min_heap([2, 1], 0))  # Expected: False\n# print(check_min_heap([1, 3, 2, 4, 5, 6], 0))  # Expected: True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min-heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index to check from, default is 0.\n\n    Returns:\n    bool: True if the array is a min-heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through all parent nodes\n    for i in range((n - 2) // 2 + 1):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and violates the min-heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Min-heap property violated at index {i}: {arr[i]} > {arr[left_child_index]}\")\n            return False\n        \n        # Check if the right child exists and violates the min-heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Min-heap property violated at index {i}: {arr[i]} > {arr[right_child_index]}\")\n            return False\n    \n    return True\n\n# Example usage:\n# print(check_min_heap([1, 3, 2, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([2, 1]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Checks if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the array is empty or has one element, it is a valid min heap.\n    if n == 0 or n == 1:\n        return True\n    \n    # Calculate indices of left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n    \n    # Check if left child exists and if the parent node is greater than the left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n    \n    # Check if right child exists and if the parent node is greater than the right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n    \n    # Recursively check the left and right subtrees\n    left_is_heap = left_child_index >= n or check_min_heap(arr, left_child_index)\n    right_is_heap = right_child_index >= n or check_min_heap(arr, right_child_index)\n    \n    return left_is_heap and right_is_heap\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the index is a leaf node, return True\n    if index >= n:\n        return True\n\n    # Calculate the indices of the left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n\n    # Check if the current node is less than or equal to its left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n\n    # Check if the current node is less than or equal to its right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n\n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left_child_index) and check_min_heap(arr, right_child_index)\n\n# Example usage:\n# print(check_min_heap([1, 3, 2, 4, 5, 6]))  # Should return True\n# print(check_min_heap([2, 1]))  # Should return False\n# print(check_min_heap([1]))  # Should return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list[int], index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min-heap starting from the given index.\n\n    Parameters:\n    arr (list[int]): The array to be checked.\n    index (int): The starting index to check the heap property. Defaults to 0.\n\n    Returns:\n    bool: True if the array represents a min-heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: An empty array or a single-element array is trivially a min-heap\n    if n == 0 or n == 1:\n        return True\n    \n    # Iterate through each node in the array\n    for i in range(index, n):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and violates the min-heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the right child exists and violates the min-heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    # If all nodes satisfy the min-heap property, return True\n    return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate through each node up to the last parent node\n    for i in range(n // 2):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the current node is less than or equal to its left child\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            print(f\"Error: Parent node {arr[i]} at index {i} is greater than left child {arr[left_child_index]} at index {left_child_index}.\")\n            return False\n        \n        # Check if the current node is less than or equal to its right child\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            print(f\"Error: Parent node {arr[i]} at index {i} is greater than right child {arr[right_child_index]} at index {right_child_index}.\")\n            return False\n    \n    # If all nodes satisfy the min heap property, return True\n    return True\n\n# Example usage:\n# print(check_min_heap([1, 3, 2, 4, 5, 6]))  # Expected output: True\n# print(check_min_heap([2, 1]))  # Expected output: False\n# print(check_min_heap([1]))  # Expected output: True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the index is beyond the last element, return True\n    if index >= n:\n        return True\n\n    # Calculate the indices of the left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n\n    # Check if the current node is greater than the left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n\n    # Check if the current node is greater than the right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n\n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left_child_index) and check_min_heap(arr, right_child_index)\n\n# Example usage:\n# print(check_min_heap([1, 2, 3]))  # Should return True\n# print(check_min_heap([2, 1, 3]))  # Should return False\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the index is beyond the last element, return True\n    if index >= n:\n        return True\n\n    # Calculate the indices of the left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n\n    # Check if the current node is less than or equal to its left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n\n    # Check if the current node is less than or equal to its right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n\n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left_child_index) and check_min_heap(arr, right_child_index)\n\n# Example usage:\n# print(check_min_heap([1, 3, 2, 4, 5, 6], 0))  # Should return True\n# print(check_min_heap([2, 1], 0))  # Should return False\n# print(check_min_heap([1], 0))  # Should return True\n", "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the array represents a min heap starting from the given index.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The starting index for the heap check. Default is 0.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: An empty array or a single-element array is a valid min heap\n    if n == 0 or n == 1:\n        return True\n\n    # Iterate through each node in the array\n    for i in range(n):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n\n        # Check if the current node is less than or equal to its left child (if it exists)\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n\n        # Check if the current node is less than or equal to its right child (if it exists)\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n\n    # If all nodes satisfy the min heap property, return True\n    return True\n"], "plans": ["requirement analysis:\nThe function should efficiently check if an array represents a min heap by ensuring each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Include detailed error messages for invalid heaps\n- Ensure compatibility with different Python versions\n- Provide comprehensive documentation\nWe will implement a function to check if an array represents a min heap by ensuring each parent node is less than or equal to its children. We will use a simple loop to iterate through the array and check the heap property for each node. The function will handle edge cases like empty arrays and provide detailed error messages for invalid heaps. We will optimize the function for large arrays by minimizing unnecessary operations and using efficient indexing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its children. This property must be validated for all nodes in the array representation of the heap.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Iterate through each node in the array.\n    - For each node, calculate the indices of its left and right children.\n    - Check if the current node is less than or equal to its children.\n    - If any node violates the min heap property, return False.\n    - If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([]) = True\n    Explanation: An empty array can be considered a valid min heap as there are no nodes to violate the heap property.\n    \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap as there are no children to compare against.\n    \n    check_min_heap([2, 1]) = False\n    Explanation: The first element (2) is greater than its child (1), violating the min heap property.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not array:\n            return True\n        for i in range(len(array)):\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < len(array) and array[i] > array[left]:\n                return False\n            if right < len(array) and array[i] > array[right]:\n                return False\n        return True\n", "requirement analysis:\nThe function should efficiently check if the array maintains the min-heap property, where each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min-heap property\n- Optimize for large datasets\n- Provide detailed error messages\n- Include unit tests for various scenarios\n- Document the function usage and edge cases\nWe will implement a function to check if an array represents a min-heap by iterating through each node and verifying that it is less than or equal to its children. We will use Python's built-in capabilities for efficient array handling and provide detailed error messages for invalid heaps.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each node in the heap, its value should be less than or equal to the values of its children. In code, this can be implemented by iterating through the array and checking if each parent node satisfies this condition with its children.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array up to the last parent node.\n    2. For each node, calculate the indices of its left and right children.\n    3. Check if the current node is less than or equal to its left child (if it exists).\n    4. Check if the current node is less than or equal to its right child (if it exists).\n    5. If any node violates the min-heap property, return False.\n    6. If all nodes satisfy the min-heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min-heap as there are no children to compare.\n    \n    check_min_heap([2, 1], 0) = False\n    Explanation: The root node (2) is greater than its child (1), violating the min-heap property.\n    \n    check_min_heap([1, 3, 2, 4, 5, 6], 0) = True\n    Explanation: All nodes satisfy the min-heap property where each parent is less than or equal to its children.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through each node and checking its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if the array maintains the min-heap property, where each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min-heap property\n- Optimize for large datasets\n- Provide detailed error messages\n- Handle edge cases like empty arrays\n- Ensure compatibility with different data types\nWe will implement a function named check_min_heap that iterates through the given array and checks if each parent node is less than or equal to its children, ensuring the min-heap property is maintained. We will use Python's built-in capabilities to handle large datasets efficiently. Additionally, we will provide detailed error messages to help users understand why an array does not represent a min-heap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its children. This property must be maintained throughout the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for a valid min heap, each parent node's value must be less than or equal to its children's values. In code, this can be implemented by iterating through the array and checking if the value at each index is less than or equal to its children indices.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through the array from the first element to the last parent node.\n    2. For each parent node at index `i`, calculate the indices of its left and right children.\n    3. Check if the value at index `i` is less than or equal to the values at its children's indices.\n    4. If any parent node violates the min-heap property, return False.\n    5. If all nodes satisfy the min-heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array trivially satisfies the min-heap property as there are no children to compare.\n    \n    check_min_heap([2, 1], 0) = False\n    Explanation: The parent node (2) is greater than its child (1), violating the min-heap property.\n    \n    check_min_heap([1, 3, 2, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their children, satisfying the min-heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each node's children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if the array maintains the min heap property, where each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide feedback on why an array fails the check.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Provide detailed error messages for invalid heaps\n- Include unit tests for various scenarios\n- Document the function usage and edge cases\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its children. We will use Python's built-in capabilities for efficient iteration and comparison. The function will also provide detailed error messages if the array does not satisfy the min heap property. We will handle edge cases such as empty arrays and arrays with duplicate values, considering them valid min heaps if they maintain the heap property.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its children. This property must be maintained throughout the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node's value should be less than or equal to its children's values in the heap.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array.\n    2. For each node at index `i`, calculate the indices of its left child (`2*i + 1`) and right child (`2*i + 2`).\n    3. Check if the left child exists and if the parent node is greater than the left child. If so, return False.\n    4. Check if the right child exists and if the parent node is greater than the right child. If so, return False.\n    5. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([], 0) = True\n    Explanation: An empty array is considered a valid min heap as there are no nodes to violate the heap property.\n    \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is a valid min heap as there are no children to compare with.\n\n    check_min_heap([1, 1, 1], 0) = True\n    Explanation: Duplicate values are allowed in a min heap as long as the parent node is not greater than its children.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking for the existence of children before comparing values.\n", "requirement analysis:\nThe function should efficiently check if the given array maintains the min heap property, where each parent node is less than or equal to its children. It should handle edge cases such as empty arrays and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Include error handling and messaging\n- Document the function usage and edge cases\n- Test the function with various datasets\nWe will implement a function named check_min_heap that iterates through the given array and checks if each parent node is less than or equal to its children. This will ensure the min heap property is maintained. We will use Python's built-in capabilities to handle large datasets efficiently. Additionally, we will include error handling to provide meaningful feedback if the array does not represent a min heap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its children. This ensures that the smallest element is always at the root of the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node's value should be less than or equal to its children's values in the array representation of the heap.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array.\n    2. For each node, calculate the indices of its left and right children.\n    3. Check if the current node is less than or equal to its children.\n    4. If any node violates the min heap property, return False.\n    5. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array trivially satisfies the min heap property as there are no children to compare.\n    \n    check_min_heap([2, 1], 0) = False\n    Explanation: The first element (2) is greater than its child (1), violating the min heap property.\n    \n    check_min_heap([1, 3, 2, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their children, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through each node and checking its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array represents a min-heap by ensuring each parent node is less than or equal to its children. It should handle edge cases such as empty arrays and single-element arrays. The function should be well-documented to aid user understanding.\nrequirement pool:\n- The function must correctly identify min-heap structures\n- The function should handle edge cases gracefully\n- Provide clear documentation and examples\n- Ensure compatibility with Python 3.x versions\n- Optimize for performance with large datasets\nWe will implement a function named check_min_heap that iterates through the given array and checks if each parent node is less than or equal to its children, ensuring the min-heap property. The function will handle edge cases such as empty arrays and single-element arrays. We will use native Python capabilities to ensure compatibility across Python 3.x versions and optimize for performance with large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is always less than or equal to its children. This property must be maintained throughout the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node should be less than or equal to its children in the heap structure.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array.\n    2. For each node, check if it has children.\n    3. If it has a left child, ensure the parent node is less than or equal to the left child.\n    4. If it has a right child, ensure the parent node is less than or equal to the right child.\n    5. If any node violates the min-heap property, return False.\n    6. If all nodes satisfy the min-heap property, return True.\n\n# [edge case] \n    check_min_heap([]) = True\n    Explanation: An empty array can be considered a valid min heap as there are no nodes to violate the heap property.\n    \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap since there are no children to compare with.\n\n    check_min_heap([2, 1]) = False\n    Explanation: The parent node (2) is greater than its child (1), violating the min-heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles empty arrays and single-element arrays correctly.\n", "requirement analysis:\nThe function should efficiently check if the array satisfies the min heap property, where each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide meaningful feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for large arrays\n- Provide detailed error messages for invalid heaps\n- Ensure compatibility with different Python versions\n- Include unit tests for various scenarios\nWe will implement a function named check_min_heap that iterates through the array and checks if each parent node is less than or equal to its children. This will be done using a simple loop, ensuring the function is efficient for large datasets. We will also include detailed error messages to indicate which part of the array violates the min heap property.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a complete binary tree where the value of each parent node is less than or equal to the values of its children. This property must hold for all nodes in the heap.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its children. In code, this can be implemented by checking if `array[parent] <= array[child]` for each parent-child relationship.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array up to the last parent node.\n    2. For each node, calculate the indices of its left and right children.\n    3. Check if the current node is less than or equal to its left child (if it exists).\n    4. Check if the current node is less than or equal to its right child (if it exists).\n    5. If any of these conditions fail, return False.\n    6. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([2, 1], 0) = False\n    Explanation: The parent node (2) is greater than its child (1), violating the min heap property.\n    \n    check_min_heap([1, 3, 2, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their children, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the array and checking each parent-child relationship will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if an array is a min heap by ensuring each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide informative feedback for invalid heaps.\nrequirement pool:\n- Implement the main heap validation logic\n- Optimize for large array inputs\n- Provide detailed error messages\n- Ensure compatibility with different Python versions\n- Include comprehensive test cases\nWe will implement a function to check if an array represents a min heap by ensuring each parent node is less than or equal to its children. We will use Python's built-in capabilities for efficient array handling and provide detailed error messages for invalid heaps. The function will be optimized for large datasets by minimizing unnecessary computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its children. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Iterate through each node in the array.\n    2. For each node, check if it satisfies the min heap property by comparing it with its children.\n    3. If any node violates the min heap property, return False.\n    4. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single element array is trivially a min heap as there are no children to compare.\n    \n    check_min_heap([2, 1], 0) = False\n    Explanation: The first element (2) is greater than its child (1), violating the min heap property.\n    \n    check_min_heap([], 0) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles these scenarios by iterating through the array and checking the heap property for each node.\n", "requirement analysis:\nThe function should efficiently check if an array satisfies the min heap property, ensuring that each parent node is less than or equal to its children. It should handle edge cases and provide feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize the function for performance with large arrays\n- Include detailed error messages for invalid heaps\n- Ensure compatibility with different data types\n- Provide documentation and examples for usage\nWe will implement a function named check_min_heap that iterates through the given array and checks if each parent node is less than or equal to its children. The function will provide detailed error messages if the heap property is violated. We will use Python's built-in capabilities to ensure efficient performance, especially for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the value of each parent node is less than or equal to the values of its children. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that for each parent node, its value should be less than or equal to the values of its children. In code, this can be implemented using the `<=` operator.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index as input.\n    2. Iterate through the array, treating it as a binary tree.\n    3. For each node at index `i`, calculate the indices of its left and right children.\n    4. Check if the current node is less than or equal to its left and right children (if they exist).\n    5. If any node violates the min heap property, return `False`.\n    6. If all nodes satisfy the min heap property, return `True`.\n\n# [edge case] \n    check_min_heap([1], 0) = True\n    Explanation: A single-element array is trivially a min heap since there are no children to compare.\n    \n    check_min_heap([2, 1], 0) = False\n    Explanation: The parent node (2) is greater than its child (1), violating the min heap property.\n    \n    check_min_heap([1, 3, 2, 4, 5, 6], 0) = True\n    Explanation: All parent nodes are less than or equal to their children, satisfying the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each node against its children will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check if the array satisfies the min heap property, where each parent node is less than or equal to its children. It should handle edge cases like empty arrays and provide feedback for invalid heaps.\nrequirement pool:\n- Implement the main function to check min heap property\n- Optimize for large datasets\n- Provide detailed error messages\n- Handle edge cases like empty arrays\n- Ensure compatibility with different data types\nWe will implement a function to check if an array represents a min heap by ensuring each parent node is less than or equal to its children. We will use Python's built-in capabilities for array manipulation and ensure the function is optimized for large datasets. Additionally, we will provide detailed error messages for invalid heaps and handle edge cases like empty arrays.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'min heap'\n    Explanation: A min heap is a binary tree where the parent node is less than or equal to its children. This property must hold for all nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'less than or equal to': This indicates that each parent node's value should be less than or equal to the values of its children in the heap.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `check_min_heap` that takes an array and an index (starting from 0).\n    2. Iterate through each node in the array.\n    3. For each node, calculate the indices of its left and right children.\n    4. Check if the current node is less than or equal to its left child (if it exists).\n    5. Check if the current node is less than or equal to its right child (if it exists).\n    6. If any of these conditions fail, return False.\n    7. If all nodes satisfy the min heap property, return True.\n\n# [edge case] \n    check_min_heap([]) = True\n    Explanation: An empty array can be considered a valid min heap as there are no elements to violate the heap property.\n    \n    check_min_heap([1]) = True\n    Explanation: A single-element array is trivially a min heap since there are no children to compare with.\n    \n    check_min_heap([2, 1]) = False\n    Explanation: The parent node (2) is greater than its child (1), violating the min heap property.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking each node's children and returning True for empty arrays or single-element arrays.\n"], "test": ["def check(check_min_heap):\n\tassert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 3, 5, 3, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 3, 5, 2, 5], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 8, 3, 1, 3], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 1, 1, 3, 8, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 1, 9, 6, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 5, 3, 7, 10, 8], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 8, 6, 10, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 7, 4, 2, 4, 9], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 3, 2, 9, 2], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 7, 6, 2, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 1, 4, 4, 4, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 7, 9, 7, 6], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 4, 2, 8, 6], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 6, 7, 2, 3], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 5, 1, 7, 7, 8], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 1, 6, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 8, 8, 5, 4], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([3, 3, 6, 8, 6, 2], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 2, 8, 7, 9], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 4, 8, 10, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 3, 8, 3, 7], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 4, 5, 1, 11], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 2, 5, 6, 8, 9], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 6, 6, 4, 1, 1], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 6, 6, 9, 6], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 1, 8, 7, 5, 1], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 2, 8, 1, 4], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 1, 8, 4, 6, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 6, 7, 1, 5, 7], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 3, 2, 2, 8, 3], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 6, 6, 2, 7, 9], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 7, 9, 4, 5], 2) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 4, 7, 5, 10, 5], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 7, 7, 12, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 9, 3, 6, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 8, 6, 3, 6, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 9, 6, 15, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 6, 3, 9, 10, 19], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 4, 8, 8, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 1, 5, 8, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 7, 10, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 2, 1, 3, 7, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 7, 5, 10, 7, 12], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 2, 9, 9, 9, 19], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 9, 7, 11, 19], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 4, 7, 7, 13, 18], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 9, 6, 6, 12], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 4, 1, 2, 9, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 2, 9, 2, 15, 14], 1) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 1, 1, 2, 8, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 5, 4, 5, 15, 14], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 5, 9, 3, 13, 10], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 4, 1, 6, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 8, 7, 3, 13, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 8, 6, 5, 8, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 2, 4, 5, 15, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 6, 2, 15, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 8, 9, 1, 10, 18], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 9, 10, 12], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 3, 10, 15, 13], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 1, 6, 7, 9, 10], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 5, 5, 10, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 4, 7, 6, 7, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 4, 9, 13, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 3, 9, 2, 9, 18], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 5, 3, 8, 6, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 11, 2, 9, 5, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 8, 4, 10, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 3, 4, 5, 13], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([5, 10, 2, 3, 2, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 3, 3, 1, 16], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 7, 3, 8, 7, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 10, 8, 6, 8, 16], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 13, 5, 5, 4, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 13, 4, 2, 3, 17], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 8, 10, 5, 10], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 7, 1, 6, 7, 12], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 7, 1, 10, 3, 20], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([4, 13, 3, 10, 7, 14], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 8, 8, 6, 13], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 14, 3, 1, 4, 15], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 9, 10, 8, 16], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 10, 5, 1, 1, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 8, 1, 9, 3, 11], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([6, 13, 1, 1, 6, 19], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 6, 2, 1, 4, 16], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 7, 4, 3, 3, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 12, 8, 8, 8, 16], 1) == False", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 8, 5, 6, 10], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 5, 1, 3, 8, 17], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 9, 4, 5, 7, 18], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([2, 15, 3, 6, 6, 11], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([4, 10, 8, 6, 4, 20], 5) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 15, 1, 6, 2, 11], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 11, 7, 7, 7, 14], 3) == True", "def check(check_min_heap):\n\tassert check_min_heap([5, 15, 2, 9, 2, 13], 4) == True", "def check(check_min_heap):\n\tassert check_min_heap([1, 13, 8, 6, 7, 14], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([3, 15, 6, 2, 7, 20], 2) == True", "def check(check_min_heap):\n\tassert check_min_heap([7, 7, 4, 8, 8, 18], 1) == True"], "scores": [0.9902, 0.9902, 0.2843, 1.0, 1.0, 0.9902, 0.2843, 1.0, 1.0, 0.2843], "pass_results": [false, false, false, true, true, false, false, true, true, false], "pass_test_cases_num": [101, 101, 29, 102, 102, 101, 29, 102, 102, 29], "completion": "from typing import List\n## main.py\n\ndef check_min_heap(arr: list, index: int = 0) -> bool:\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The array to be checked.\n    index (int): The current index to check, default is 0.\n\n    Returns:\n    bool: True if the array is a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Base case: If the index is beyond the last element, return True\n    if index >= n:\n        return True\n\n    # Calculate the indices of the left and right children\n    left_child_index = 2 * index + 1\n    right_child_index = 2 * index + 2\n\n    # Check if the current node is less than or equal to its left child\n    if left_child_index < n and arr[index] > arr[left_child_index]:\n        return False\n\n    # Check if the current node is less than or equal to its right child\n    if right_child_index < n and arr[index] > arr[right_child_index]:\n        return False\n\n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left_child_index) and check_min_heap(arr, right_child_index)\n\n# Example usage:\n# print(check_min_heap([1, 3, 2, 4, 5, 6], 0))  # Should return True\n# print(check_min_heap([2, 1], 0))  # Should return False\n# print(check_min_heap([1], 0))  # Should return True\n", "passed": true, "pass": true, "pass_num": 4, "round": 237, "mutate_method": "condense_two2one", "parent_index": 237}
