{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell, moves only right or down, and ends on the bottom-right cell. We want to find a path with the maximum average over all existing paths, where average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "repair_prompt": ["Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell, moves only right or down, and ends on the bottom-right cell. We want to find a path with the maximum average over all existing paths, where average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell. It moves only right or down, and ends on the bottom-right cell. We want to find a path with the maximum average over all existing paths, where average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell, moves only right or down, and ends on the bottom-right cell, and we want to find a path with the maximum average over all existing paths, where average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the maximum average path in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: The maximum average and the path taken as a list of coordinates.\n    \"\"\"\n    if n == 0 or not matrix:\n        return 0.0, []\n\n    # Initialize a matrix to store the maximum sum path up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    path = [[[] for _ in range(n)] for _ in range(n)]\n\n    # Base case for the top-left cell\n    dp[0][0] = matrix[0][0]\n    path[0][0] = [(0, 0)]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n        path[0][j] = path[0][j-1] + [(0, j)]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        path[i][0] = path[i-1][0] + [(i, 0)]\n\n    # Fill the rest of the dp matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if dp[i-1][j] > dp[i][j-1]:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n                path[i][j] = path[i-1][j] + [(i, j)]\n            else:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n                path[i][j] = path[i][j-1] + [(i, j)]\n\n    # Calculate the maximum average\n    max_sum = dp[n-1][n-1]\n    num_cells = 2 * n - 1  # Number of cells in the path from (0,0) to (n-1,n-1)\n    max_average = max_sum / num_cells\n\n    return max_average, path[n-1][n-1]\n", "from typing import List\n## main.py\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N containing integer costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    # Initialize a memoization table to store the maximum sum of costs for paths ending at each cell\n    dp = np.zeros((N, N), dtype=float)\n    \n    # Base case: starting point\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row and first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    \n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the maximum average path\n    max_sum = dp[N-1][N-1]\n    num_cells = 2 * N - 1  # Total number of cells in the path from top-left to bottom-right\n    max_average = max_sum / num_cells\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\n## main.py\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    '''\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of integers representing the cost of each cell.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    '''\n    # Initialize matrices to store maximum sum and number of cells for each cell\n    max_sum = np.zeros((n, n), dtype=int)\n    num_cells = np.zeros((n, n), dtype=int)\n\n    # Base case: starting point\n    max_sum[0][0] = matrix[0][0]\n    num_cells[0][0] = 1\n\n    # Fill the matrices using dynamic programming\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue  # Skip the starting point as it's already initialized\n\n            # Calculate maximum sum and number of cells from the left and above\n            if i > 0:\n                sum_from_above = max_sum[i-1][j] + matrix[i][j]\n                cells_from_above = num_cells[i-1][j] + 1\n            else:\n                sum_from_above = float('-inf')\n                cells_from_above = 0\n\n            if j > 0:\n                sum_from_left = max_sum[i][j-1] + matrix[i][j]\n                cells_from_left = num_cells[i][j-1] + 1\n            else:\n                sum_from_left = float('-inf')\n                cells_from_left = 0\n\n            # Choose the path with the maximum sum\n            if sum_from_above > sum_from_left:\n                max_sum[i][j] = sum_from_above\n                num_cells[i][j] = cells_from_above\n            else:\n                max_sum[i][j] = sum_from_left\n                num_cells[i][j] = cells_from_left\n\n    # Calculate the maximum average\n    total_sum = max_sum[n-1][n-1]\n    total_cells = num_cells[n-1][n-1]\n    max_average = total_sum / total_cells\n\n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N where each cell has a specific cost.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from the top-left to the bottom-right.\n    \"\"\"\n    if n == 0 or not matrix or not matrix[0]:\n        return 0.0\n\n    # Initialize a DP table to store the maximum sum of costs for paths ending at each cell\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the maximum average by dividing the maximum sum by the number of cells in the path\n    max_sum = dp[n - 1][n - 1]\n    num_cells = 2 * n - 1  # Number of cells in the path from top-left to bottom-right\n    max_average = max_sum / num_cells\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "from typing import List\n## main.py\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix using dynamic programming.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    # Initialize a matrix to store maximum average values for each cell\n    max_avg_matrix = np.zeros((n, n), dtype=float)\n    \n    # Start from the top-left cell\n    max_avg_matrix[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, n):\n        max_avg_matrix[0][j] = (max_avg_matrix[0][j-1] * j + matrix[0][j]) / (j + 1)\n    \n    # Fill the first column\n    for i in range(1, n):\n        max_avg_matrix[i][0] = (max_avg_matrix[i-1][0] * i + matrix[i][0]) / (i + 1)\n    \n    # Iterate through the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            # Calculate the potential average if moving right or down\n            avg_from_top = (max_avg_matrix[i-1][j] * (i + j) + matrix[i][j]) / (i + j + 1)\n            avg_from_left = (max_avg_matrix[i][j-1] * (i + j) + matrix[i][j]) / (i + j + 1)\n            \n            # Update the matrix with the maximum average for each cell\n            max_avg_matrix[i][j] = max(avg_from_top, avg_from_left)\n    \n    # Return the maximum average value from the bottom-right cell\n    return max_avg_matrix[n-1][n-1]\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix using dynamic programming and memoization.\n\n    Parameters:\n    matrix (list[list[int]]): A 2D list representing the matrix.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average value of a path from top-left to bottom-right.\n    \"\"\"\n    # Initialize matrices to store maximum sum and number of cells for each path\n    max_sum = np.zeros((n, n), dtype=int)\n    num_cells = np.zeros((n, n), dtype=int)\n\n    # Base case: starting point\n    max_sum[0][0] = matrix[0][0]\n    num_cells[0][0] = 1\n\n    # Fill the matrices using dynamic programming\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue  # Skip the starting point as it's already initialized\n\n            # Calculate maximum sum and number of cells from the left and above\n            if i > 0:\n                sum_from_above = max_sum[i-1][j] + matrix[i][j]\n                cells_from_above = num_cells[i-1][j] + 1\n            else:\n                sum_from_above = float('-inf')\n                cells_from_above = 0\n\n            if j > 0:\n                sum_from_left = max_sum[i][j-1] + matrix[i][j]\n                cells_from_left = num_cells[i][j-1] + 1\n            else:\n                sum_from_left = float('-inf')\n                cells_from_left = 0\n\n            # Choose the path with the maximum sum\n            if sum_from_above > sum_from_left:\n                max_sum[i][j] = sum_from_above\n                num_cells[i][j] = cells_from_above\n            else:\n                max_sum[i][j] = sum_from_left\n                num_cells[i][j] = cells_from_left\n\n    # Calculate the maximum average for the path ending at the bottom-right cell\n    final_sum = max_sum[n-1][n-1]\n    final_cells = num_cells[n-1][n-1]\n    max_average = final_sum / final_cells if final_cells > 0 else 0.0\n\n    return max_average\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n    \n    Parameters:\n    matrix (list[list[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n    \n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize a 2D list `dp` where `dp[i][j]` will store a tuple containing\n    # the maximum sum of costs to reach cell (i, j) and the number of steps taken to reach there.\n    dp = [[(0, 0) for _ in range(n)] for _ in range(n)]\n    \n    # Set `dp[0][0]` to (matrix[0][0], 1) since the starting point is the first cell with its own cost and one step.\n    dp[0][0] = (matrix[0][0], 1)\n    \n    # Fill the dp table\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            max_sum, steps = 0, 0\n            # Check from top\n            if i > 0:\n                top_sum, top_steps = dp[i-1][j]\n                if top_sum + matrix[i][j] > max_sum:\n                    max_sum = top_sum + matrix[i][j]\n                    steps = top_steps + 1\n            # Check from left\n            if j > 0:\n                left_sum, left_steps = dp[i][j-1]\n                if left_sum + matrix[i][j] > max_sum:\n                    max_sum = left_sum + matrix[i][j]\n                    steps = left_steps + 1\n            dp[i][j] = (max_sum, steps)\n    \n    # Calculate the average for the bottom-right cell using its stored sum and steps.\n    final_sum, final_steps = dp[n-1][n-1]\n    if final_steps == 0:\n        return 0.0\n    return final_sum / final_steps\n", "from typing import List\n## main.py\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a square matrix.\n\n    Parameters:\n    matrix (list[list[int]]): A square matrix of integers representing costs.\n    n (int): The size of the matrix (number of rows/columns).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Initialize a 2D list `dp` to store the maximum sum of costs up to each cell.\n    dp = [[0] * n for _ in range(n)]\n    \n    # Set `dp[0][0]` to `matrix[0][0]` as the starting point.\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row (can only come from the left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Iterate over each cell in the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            # Update `dp[i][j]` as the maximum of `dp[i-1][j]` and `dp[i][j-1]` plus `matrix[i][j]`\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the average for the path ending at `(N-1, N-1)`\n    max_sum = dp[n - 1][n - 1]\n    num_cells_in_path = 2 * n - 1\n    max_average = max_sum / num_cells_in_path\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# n = 2\n# print(maxAverageOfPath(matrix, n))  # Output: 2.5\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path cost in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average path cost.\n    \"\"\"\n    if N == 0:\n        return 0.0\n\n    # Initialize a DP table to store the maximum sum of costs up to each cell\n    dp = np.zeros((N, N), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column of the DP table\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Fill the rest of the DP table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average path cost\n    max_sum = dp[N-1][N-1]\n    path_length = 2 * N - 1  # Path length from top-left to bottom-right\n    max_average = max_sum / path_length\n\n    return max_average\n", "from typing import List\n## main.py\n\ndef maxAverageOfPath(matrix: list[list[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (list of list of int): The N*N matrix with costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    if N == 0:\n        return 0.0\n\n    # Initialize a 2D list to store the maximum sum of costs up to each cell\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the maximum average path\n    max_sum = dp[N - 1][N - 1]\n    max_average = max_sum / (2 * N - 1)\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n"], "plans": ["requirement analysis:\nThe requirement is to compute the maximum average path in a matrix, focusing on efficiency and clarity. The solution should handle large matrices and provide detailed path information.\nrequirement pool:\n- Efficient computation of maximum average path\n- Clear output of path details\n- Optimization for large matrices\n- User-friendly interface\n- Support for various matrix sizes\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. This approach will involve calculating the maximum sum path and then dividing by the number of cells in the path to get the average. We will use numpy for efficient matrix operations, which is well-suited for handling large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'average': The total cost of the path divided by the number of cells visited in the path.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost, which is calculated as the total cost divided by the number of cells.\n\n# [degree adverb]\n    'maximum': Refers to finding the path with the highest average cost among all possible paths.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum path up to each cell.\n    2. Use dynamic programming to fill this matrix by considering only right and down moves.\n    3. Calculate the maximum sum path to the bottom-right cell.\n    4. Divide this sum by the number of cells in the path to get the average.\n    5. Return the maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size and values, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe requirement is to develop a function that calculates the maximum average path in a matrix, moving only right or down. The function should be efficient and handle large matrices. The average is defined as the total cost divided by the number of cells in the path.\nrequirement pool:\n- Develop the main algorithm to compute the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Provide detailed documentation for the algorithm.\n- Create test cases for various matrix sizes and values.\n- Implement error handling for invalid inputs.\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. This approach will leverage memoization to store intermediate results and avoid redundant calculations, ensuring optimal performance even for large matrices. We will use NumPy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost per cell.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for paths ending at each cell.\n    2. Use dynamic programming to fill this matrix by considering paths from the top-left to each cell, moving only right or down.\n    3. Calculate the average cost for each path by dividing the total cost by the number of cells visited.\n    4. Keep track of the maximum average found during the computation.\n    5. Return the maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size and values, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The challenge lies in efficiently computing this for large matrices while ensuring accuracy.\nrequirement pool:\n- Implement efficient path calculation algorithm.\n- Ensure accurate average computation for paths.\n- Optimize algorithm for large matrix sizes.\n- Provide clear user instructions for matrix input.\n- Develop a user-friendly interface for input and output.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. This approach will ensure that we compute the maximum path sum while keeping track of the number of cells visited, allowing us to calculate the average. We will use numpy for efficient matrix operations, which is well-suited for handling large matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'maximum average': The highest average cost of all possible paths, calculated as the total cost divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum': Refers to finding the path with the highest average cost among all possible paths.\n\n# [degree adverb]\n    'maximum': Indicates that we need to find the path with the greatest average cost.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum and number of cells for each cell in the matrix.\n    2. Use dynamic programming to fill this matrix by iterating through each cell and calculating the maximum sum and number of cells for paths ending at that cell.\n    3. For each cell, consider paths coming from the left and above, and update the matrix with the maximum sum and number of cells.\n    4. Calculate the average for each path by dividing the total cost by the number of cells.\n    5. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value of that cell itself.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 3.0\n    Explanation: The path with maximum average is [1, 3, 4] with an average of (1+3+4)/3 = 2.67, but [1, 2, 4] gives a higher average of (1+2+4)/3 = 2.33.\n    \n    maxAverageOfPath([[5, 1], [1, 5]], 2) = 5.0\n    Explanation: The path with maximum average is [5, 5] with an average of (5+5)/2 = 5.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles all possible paths and calculates their averages correctly.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide a clear output of the maximum average path cost.\nrequirement pool:\n- Implement the main algorithm to calculate the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and easy to understand.\n- Provide documentation for the solution.\n- Include error handling for invalid inputs.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. This approach will ensure that we handle large matrices efficiently by storing intermediate results and avoiding redundant calculations. We will use Python's built-in capabilities and libraries like NumPy for efficient matrix operations if needed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right cell.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the highest average cost.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum of costs for paths ending at each cell.\n    2. Start from the top-left cell and iterate through each cell in the matrix.\n    3. For each cell, calculate the maximum sum of costs by considering paths coming from the left and above.\n    4. Store the maximum sum in the matrix.\n    5. Once the bottom-right cell is reached, calculate the average by dividing the maximum sum by the number of cells in the path.\n    6. Return the maximum average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle these cases correctly by considering all possible paths and calculating their averages.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle the calculation and be optimized for performance, especially for larger matrices.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path\n- Optimize the algorithm for performance\n- Provide clear documentation and examples\n- Create a user-friendly interface for input and output\n- Ensure compatibility with larger matrices\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, maintaining a running total of the path cost and the number of cells visited. At each cell, we will decide whether to move right or down based on which option provides a higher average cost. This approach ensures that we consider all possible paths and select the one with the maximum average. We will use the NumPy library to handle matrix operations efficiently, especially for larger matrices.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path'\n    Explanation: A path is a sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n\n    'average'\n    Explanation: The average is calculated as the total cost of the path divided by the number of cells visited in the path.\n\n# [phrase showing quantity relationship]\n    'maximum average'\n    Explanation: We need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right cell.\n    Implementation: Compare averages of all possible paths and select the maximum.\n\n# [degree adverb]\n    'maximum'\n    Explanation: We are looking for the path with the highest average cost.\n    Implementation: Use dynamic programming to keep track of maximum averages at each step.\n\n# [code logic]\n    1. Initialize a matrix to store maximum average values for each cell.\n    2. Start from the top-left cell and iterate through the matrix.\n    3. For each cell, calculate the potential average if moving right or down.\n    4. Update the matrix with the maximum average for each cell.\n    5. Continue until reaching the bottom-right cell.\n    6. Return the maximum average value from the bottom-right cell.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is [1, 2, 4] with an average of (1+2+4)/3 = 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All cells have zero cost, so any path will have an average of zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these cases by considering all possible paths and calculating averages accordingly.\n", "requirement analysis:\nThe requirement is to find a path in a matrix that maximizes the average cost per cell. The path can only move right or down, starting from the top-left and ending at the bottom-right. The challenge is to efficiently compute this path, especially for larger matrices.\nrequirement pool:\n- Implement the algorithm to find the maximum average path.\n- Optimize the algorithm for performance.\n- Provide detailed documentation and examples.\n- Create a user-friendly interface for input and output.\n- Include error handling for invalid inputs.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, calculating the maximum sum and the number of cells for each path. We will use memoization to store intermediate results and avoid redundant calculations. The final result will be the maximum average calculated from the top-left to the bottom-right cell. The numpy library will be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'average': The total cost of the path divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum average': We need to find the path with the highest average cost among all possible paths from the top-left to the bottom-right cell.\n\n# [degree adverb]\n    'maximum': Refers to the highest possible average cost of a path.\n\n# [code logic]\n    1. Initialize a matrix to store the maximum sum and number of cells for each path.\n    2. Use dynamic programming to traverse the matrix from the top-left to the bottom-right.\n    3. For each cell, calculate the maximum sum and number of cells by considering paths from the left and above.\n    4. Use memoization to store intermediate results and avoid redundant calculations.\n    5. Calculate the maximum average by dividing the maximum sum by the number of cells for the path ending at the bottom-right cell.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both have an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles matrices of any size and values, including single-cell matrices and matrices with zero values.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to calculate the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and easy to understand.\n- Provide documentation for the solution.\n- Test the solution with various matrix sizes.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. This approach will efficiently compute the maximum average by maintaining a table that stores the maximum sum of costs for each cell, and then dividing by the number of steps to get the average. We will use the numpy library for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maxAverageOfPath'\n    Explanation: This refers to finding a path in a matrix that has the highest average cost, where the average is calculated as the total cost of the path divided by the number of cells in the path.\n\n    'path'\n    Explanation: A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n\n# [phrase showing quantity relationship]\n    'maximum average'\n    Explanation: This means we need to find the path with the highest possible average cost. In code, this involves calculating the sum of costs for each path and dividing by the number of cells in that path, then comparing these averages to find the maximum.\n\n# [degree adverb]\n    'maximum'\n    Explanation: Indicates that we are looking for the highest possible average among all paths. In code, this involves keeping track of the highest average found during the computation.\n\n# [code logic]\n1. Initialize a 2D list `dp` where `dp[i][j]` will store a tuple containing the maximum sum of costs to reach cell (i, j) and the number of steps taken to reach there.\n2. Set `dp[0][0]` to (matrix[0][0], 1) since the starting point is the first cell with its own cost and one step.\n3. Iterate over each cell in the matrix:\n   - For each cell (i, j), update `dp[i][j]` by considering paths from the top (i-1, j) and left (i, j-1).\n   - Calculate the new sum and steps for each possible path and update `dp[i][j]` if a higher sum is found.\n4. After filling `dp`, calculate the average for the bottom-right cell using its stored sum and steps.\n5. Return the maximum average found.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell itself with an average equal to its value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have a total cost of 0, so the maximum average is also 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of dynamic programming will naturally handle matrices of any size, including single-cell matrices and matrices with all zero values.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The challenge lies in efficiently computing this for larger matrices while ensuring the result is easily interpretable.\nrequirement pool:\n- Implement the algorithm to find the maximum average path\n- Optimize the algorithm for performance with large matrices\n- Ensure the output is clear and understandable\n- Add support for non-square matrices in future iterations\n- Provide a visual representation of the path in the matrix\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in a square matrix. The algorithm will utilize a 2D list to store the maximum sum of costs up to each cell, and then calculate the average by dividing the maximum sum by the number of cells in the path. This approach ensures that we only traverse the matrix once, optimizing for performance. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'maximum average': The highest possible average cost of a path, calculated as the total cost divided by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    'maximum': Refers to finding the path with the highest average cost.\n\n# [degree adverb]\n    'maximum': Indicates that we are looking for the path with the greatest average cost among all possible paths.\n\n# [code logic]\n1. Initialize a 2D list `dp` to store the maximum sum of costs up to each cell.\n2. Set `dp[0][0]` to `matrix[0][0]` as the starting point.\n3. Iterate over each cell in the matrix:\n   - For each cell `(i, j)`, update `dp[i][j]` as the maximum of `dp[i-1][j]` and `dp[i][j-1]` plus `matrix[i][j]`, if those indices are valid.\n4. Calculate the average for the path ending at `(N-1, N-1)` by dividing `dp[N-1][N-1]` by `2N-1` (the number of cells in the path).\n5. Return the calculated average.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and the average is the value of that cell itself.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both giving an average of (1+2+4)/3 = 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All cells have zero cost, so any path will have an average of zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles matrices of any size and values correctly.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide a clear output of the maximum average path cost.\nrequirement pool:\n- Implement the main algorithm to calculate the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and easy to understand.\n- Test the solution with various matrix sizes.\n- Document the solution for user understanding.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. This approach will ensure optimal performance even for large matrices. We will use NumPy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maxAverageOfPath'\n    Explanation: This refers to finding a path in a matrix that has the highest average cost per cell, where the path starts at the top-left corner and ends at the bottom-right corner, moving only right or down.\n\n# [phrase showing quantity relationship]\n    'maximum average': This means we need to find the path with the highest possible average cost per cell.\n    Implementation: Calculate the total cost of each path and divide by the number of cells in the path, then compare to find the maximum.\n\n# [degree adverb]\n    'maximum': This indicates that we are looking for the path with the highest average cost.\n    Implementation: Use a comparison to keep track of the highest average found during the path exploration.\n\n# [code logic]\n1. Initialize a matrix to store the maximum sum of costs up to each cell.\n2. Start from the top-left cell and iterate through each cell in the matrix.\n3. For each cell, calculate the maximum sum of costs from either the cell above or the cell to the left.\n4. Calculate the average cost for each path by dividing the total cost by the number of cells in the path.\n5. Keep track of the maximum average found.\n6. Return the maximum average when reaching the bottom-right cell.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its own value.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both having an average of 2.5.\n\n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all cells have a cost of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of calculating maximum sum and then dividing by path length will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to develop a function that calculates the maximum average path in a matrix, moving only right or down. The function should be efficient and handle matrices of varying sizes, including edge cases like small or large matrices.\nrequirement pool:\n- Develop the main function to calculate the maximum average path.\n- Optimize the function for performance with large matrices.\n- Ensure the function handles edge cases gracefully.\n- Provide comprehensive documentation and examples.\n- Implement unit tests to validate the function's correctness.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in the matrix. This approach will involve creating a 2D list to store the maximum sum of costs up to each cell, and then using this to compute the maximum average path. The algorithm will be optimized to handle large matrices by ensuring that each cell is computed in constant time, resulting in an overall time complexity of O(N^2). We will use Python's built-in capabilities and avoid any unnecessary third-party libraries to keep the implementation simple and efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'path': A sequence of cells starting from the top-left cell, moving only right or down, and ending at the bottom-right cell.\n    'maximum average': The highest average cost of a path, calculated as the total cost divided by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    'maximum': Refers to finding the path with the highest average cost.\n    Implementation: Use a dynamic programming approach to calculate and compare averages of all possible paths.\n\n# [degree adverb]\n    'maximum': Indicates the need to find the path with the highest average cost.\n    Implementation: Compare averages of all paths and select the highest one.\n\n# [code logic]\n    1. Initialize a 2D list to store the maximum sum of costs up to each cell.\n    2. Start from the top-left cell and iterate through the matrix, updating the sum for each cell based on the maximum sum from either the cell above or the cell to the left.\n    3. Calculate the average for each path by dividing the total cost by the number of cells visited.\n    4. Keep track of the maximum average encountered during iteration.\n    5. Return the maximum average as the result.\n\n# [edge case]\n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: The matrix has only one cell, so the path is just that cell, and its average is its value.\n    \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with maximum average is either [1, 2, 4] or [1, 3, 4], both having an average of 2.5.\n    \n    maxAverageOfPath([[0, 0], [0, 0]], 2) = 0.0\n    Explanation: All paths have an average of 0 since all costs are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will correctly compute the maximum average for any matrix size and values.\n"], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [false, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [0, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef maxAverageOfPath(matrix: list[list[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (list of list of int): The N*N matrix with costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    if N == 0:\n        return 0.0\n\n    # Initialize a 2D list to store the maximum sum of costs up to each cell\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the maximum average path\n    max_sum = dp[N - 1][N - 1]\n    max_average = max_sum / (2 * N - 1)\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "passed": true, "pass": true, "pass_num": 9, "round": 213, "mutate_method": "condense_two2one", "parent_index": 213}
