{"name": "1613_E. Crazy Robot", "description": "There is a grid, consisting of n rows and m columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "tags": ["dfs and similar", "graphs"], "difficulty": 11, "id": 1613, "sample_io": [{"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n"]}], "test_list": [{"input": "1\n3 31\n############################..#\n.............................L.\n############################..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n3 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n############################..#\n", "output": ["#++############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n#..######################\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n#..######################\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n#++######################\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "1\n3 25\n##..#####################\n.......................L.\n#..######################\n", "output": ["##..#####################\n....+++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 31\n#############################..\n...........L...................\n############################..#\n", "output": ["#############################..\n+++++++++++L++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n#++######################\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#..###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#..############################\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n#++############################\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n############################..#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n######################..#\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n######################..#\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n#..######$####\"#$########\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n3 31\n..#############################\n.L.............................\n############################..#\n", "output": ["++#############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n##########\"######\"##########./#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n############################..#\n", "output": ["#############################..\n+++++++++++++++++++L++++++++...\n############################..#\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#.##.##########################\n", "output": ["#++############################\n+L++...........................\n#+##.##########################\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"#################..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"########..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.......................L.\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n.......................L+\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n################.############.#\n", "output": ["#++############################\n+L++++++++++++++...............\n################.############.#\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n..#..\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n..#..\n.....\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#..############################\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 25\n##.#####.################\n.L.......................\n#..######$####\"#$########\n", "output": ["##.#####.################\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#.##.##########################\n", "output": ["#..############################\n.....++++++++++++++++++++++++L+\n#.##.##########################\n"]}, {"input": "1\n2 25\n######################..#\n......................L..\n#..###$##################\n", "output": ["######################++#\n++++++++++++++++++++++L++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n++++L++#.\n"]}, {"input": "1\n2 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n"]}, {"input": "1\n2 25\n########.#############.##\n.L.......................\n#..###$###########$######\n", "output": ["########.#############.##\n+L++++++.................\n"]}, {"input": "1\n2 25\n###########.##########.##\n.L.......................\n####\"#################..#\n", "output": ["###########.##########.##\n+L+++++++++..............\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n################.############.#\n", "output": ["#..############################\n.................++++++++++++L+\n################.############+#\n"]}, {"input": "1\n2 25\n##########.############.#\n......................L..\n#..###$##################\n", "output": ["##########.############.#\n...........+++++++++++L..\n"]}, {"input": "1\n2 31\n#..############################\n...............L...............\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++L+++++++++++++++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\nL.##.\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#....\nL.##.\n...#.\n.....\nL\n++++L++#.\n"]}, {"input": "1\n2 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n2 25\n#..######################\n....................L....\n#..######################\n", "output": ["#..######################\n...+++++++++++++++++L++++\n"]}, {"input": "1\n2 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n"]}, {"input": "1\n2 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n######################..#\n", "output": ["##..#####################\n+L.......................\n######################..#\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n#..############################\n", "output": ["#############################..\n...++++++++++++++++L+++++++++..\n#..############################\n"]}, {"input": "1\n2 25\n######.###############.##\n.......................L.\n#..###$##################\n", "output": ["######.###############.##\n.......................L+\n"]}, {"input": "1\n3 31\n############################..#\n.............................L.\n#..############################\n", "output": ["############################++#\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 31\n#..############################\n.L.............................\n#################\"##########-.#\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"##########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$##################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$###########$######\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$###########$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"##############$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"####\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##########\"###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$####$###\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$##$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#.#############.#########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$##################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############\"######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########$##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#######\"######$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n##################$###..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##################$###..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########./#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#$########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##############\"#######..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$#####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##$##$###########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############!######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$$#..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$#####$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n####\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n$#######$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###################$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#############\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"##########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########-.#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$########$##$######\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##$#\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n##########\"######\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"\"###\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######!###############..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$##################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-##########\"#################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######$##$########$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"##$######$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#########$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"###\"###$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#########\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n######\"######\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#####\"###\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$#####..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$######\"####$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#######\"#########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.#############.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########%##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#..##########\"######\"##########\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$$\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n##############\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#/.###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###################$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#./######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####$########\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n###$####$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########-.#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$##\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"..##$#########\"####\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"############\"####..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##%#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"##\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######\"#######\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$#####$##\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#$#######$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###\"\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"####$######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#########\"####$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$##\"..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$#$..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..$\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n.#################$####.#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n########$#\"####$######..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n\"###\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$######$###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"######\"##########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-######\"#####################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"###\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"#############$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#######$#########\"###\"\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########!##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.############$.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######$##%########$###..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$#$###..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$\"#\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$###$########\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"#$#\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n$..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$###\"\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}], "task_id": "codecontest/117", "prompt": "There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed. One of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "repair_prompt": ["There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed. One of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed. One of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction. The direction differs from the one in command. Also, the cell in that direction should not be blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed and one of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples containing grid dimensions and the grid itself.\n\n    Returns:\n        A list of modified grids for each test case.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Perform BFS to find all reachable free cells from the lab.\n\n        Args:\n            n: Number of rows in the grid.\n            m: Number of columns in the grid.\n            grid: The grid representation.\n\n        Returns:\n            The modified grid with reachable free cells marked.\n        \"\"\"\n        # Directions for BFS traversal: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Initialize BFS structures\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Perform BFS\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited:\n                    # Mark the cell as reachable\n                    grid[nx][ny] = '+'\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        \n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    # Process each test case\n    result = []\n    for n, m, grid in test_cases:\n        modified_grid = bfs(n, m, grid)\n        result.append(modified_grid)\n    \n    return result\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Call the function\n    result = find_reachable_cells(t, test_cases)\n    \n    # Output interface\n    for grid in result:\n        for row in grid:\n            print(row)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab using BFS.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable free cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS structures\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # Perform BFS from the lab\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    # Check if the cell can be forced to reach the lab\n                    free_neighbors = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_neighbors += 1\n                    if free_neighbors <= 1:\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Mark reachable cells with '+'\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if (i, j) in visited and grid[i][j] == '.':\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n        \n        results.append(modified_grid)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = find_reachable_cells(t, test_cases)\nfor result in results:\n    for row in result:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of rows, number of columns, and the grid itself.\n\n    Returns:\n        A list of grids with free cells marked as '+' if the robot can be forced to reach the lab from there.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable free cells from the lab\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_directions += 1\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab using BFS.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable free cells marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS structures\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # Perform BFS from the lab\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    # Check if the cell is reachable\n                    free_neighbors = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_neighbors += 1\n                    if free_neighbors <= 1:\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Modify the grid based on reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if (i, j) in visited and grid[i][j] == '.':\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n        \n        results.append(modified_grid)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = find_reachable_cells(t, test_cases)\nfor result in results:\n    for row in result:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Find free cells that can force the robot to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str], lab_pos: Tuple[int, int]) -> List[str]:\n        \"\"\"Perform BFS to find reachable cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): The grid representation.\n            lab_pos (Tuple[int, int]): Position of the lab in the grid.\n\n        Returns:\n            List[str]: Modified grid with reachable cells marked.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque([lab_pos])\n        visited = set([lab_pos])\n        result_grid = [list(row) for row in grid]\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    # Check if the cell can be forced to reach the lab\n                    free_directions = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_directions += 1\n                    if free_directions <= 1:\n                        result_grid[nx][ny] = '+'\n                        queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        return [''.join(row) for row in result_grid]\n\n    results = []\n    for n, m, grid in test_cases:\n        lab_pos = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_pos = (i, j)\n                    break\n            if lab_pos:\n                break\n        modified_grid = bfs(n, m, grid, lab_pos)\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: List of modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n\n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to mark reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_directions += 1\n\n                        # If only one free direction, it can be forced to reach the lab\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS structures\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # Perform BFS from the lab\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n\n        # Modify the grid based on reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if (i, j) in visited and grid[i][j] == '.':\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom collections import deque\nfrom typing import List\n\ndef process_grid(n: int, m: int, grid: List[str]) -> List[str]:\n    \"\"\"Processes the grid to determine which free cells can be forced to reach the lab.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        List[str]: The modified grid with reachable free cells marked with '+'.\n    \"\"\"\n    # Convert grid to a list of lists for mutability\n    grid = [list(row) for row in grid]\n\n    # Find the position of the lab\n    lab_position = None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                lab_position = (i, j)\n                break\n        if lab_position:\n            break\n\n    # Directions for moving in the grid: right, down, left, up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    # BFS to explore from the lab\n    queue = deque([lab_position])\n    visited = set([lab_position])\n\n    while queue:\n        x, y = queue.popleft()\n\n        # Check all four possible directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            # Check if the new position is within bounds and is a free cell\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.':\n                # Count the number of free neighboring cells\n                free_neighbors = 0\n                for ddx, ddy in directions:\n                    nnx, nny = nx + ddx, ny + ddy\n                    if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                        free_neighbors += 1\n\n                # If there is only one free neighbor, mark it as reachable\n                if free_neighbors <= 1:\n                    grid[nx][ny] = '+'\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n    # Convert grid back to list of strings\n    return [''.join(row) for row in grid]\n\n# Input interface\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    result = process_grid(n, m, grid)\n    results.append(result)\n\n# Output interface\nfor result in results:\n    for line in result:\n        print(line)\n", "from typing import List\n## main.py\nfrom collections import deque\nfrom typing import List\n\ndef process_grid(n: int, m: int, grid: List[str]) -> List[str]:\n    \"\"\"Process the grid to determine which free cells can force the robot to reach the lab.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): The grid representation as a list of strings.\n\n    Returns:\n        List[str]: The modified grid with '+' marking the free cells that can force the robot to reach the lab.\n    \"\"\"\n    # Directions for moving in the grid: right, down, left, up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Find the position of the lab\n    lab_position = None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                lab_position = (i, j)\n                break\n        if lab_position:\n            break\n    \n    # Initialize BFS structures\n    queue = deque([lab_position])\n    visited = set([lab_position])\n    \n    # BFS to explore all reachable free cells from the lab\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited:\n                # Check if the cell can be forced to reach the lab\n                free_neighbors = 0\n                for ddx, ddy in directions:\n                    nnx, nny = nx + ddx, ny + ddy\n                    if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                        free_neighbors += 1\n                # If the cell has only one free neighbor, it can be forced to reach the lab\n                if free_neighbors <= 1:\n                    queue.append((nx, ny))\n                    visited.add((nx, ny))\n    \n    # Modify the grid based on the visited cells\n    modified_grid = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if (i, j) in visited and grid[i][j] == '.':\n                row.append('+')\n            else:\n                row.append(grid[i][j])\n        modified_grid.append(''.join(row))\n    \n    return modified_grid\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        result = process_grid(n, m, grid)\n        results.append(result)\n    \n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds free cells that can be forced to reach the lab in each test case grid.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the grid dimensions and the grid itself.\n\n    Returns:\n        A list of grids with reachable free cells marked with '+'.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Performs BFS to mark reachable free cells from the lab.\n\n        Args:\n            n: Number of rows in the grid.\n            m: Number of columns in the grid.\n            grid: The grid representation as a list of strings.\n\n        Returns:\n            The modified grid with reachable free cells marked.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque()\n        visited = set()\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Initialize BFS from the lab position\n        queue.append(lab_position)\n        visited.add(lab_position)\n        \n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    result = []\n    for n, m, grid in test_cases:\n        result.append(bfs(n, m, grid))\n    \n    return result\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n"], "plans": ["requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Validate the output format against the requirements\n- Document the solution for maintainability\nWe will use a graph traversal algorithm, specifically Breadth-First Search (BFS), to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all free cells, marking those that can be reached regardless of the robot's erratic behavior.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, each of which can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab. The task is to determine which free cells can lead the robot to the lab, given its erratic behavior.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb]\n    No degree adverbs are present in the requirement.\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use Breadth-First Search (BFS) starting from the lab to explore all reachable free cells:\n   - Initialize a queue with the lab's position.\n   - Use a set to track visited cells.\n   - For each cell, check all four possible directions (up, down, left, right).\n   - If moving in a direction leads to a free cell that hasn't been visited, mark it as reachable and add it to the queue.\n5. For each free cell that can be reached from the lab, mark it with a '+'.\n6. Output the modified grid for each test case.\n\n# [edge case]\n    1. A grid with only one cell which is a lab:\n       Input: 1 1 L\n       Output: L\n       Explanation: The grid contains only the lab, so no free cells can be marked.\n\n    2. A grid where all cells are blocked except for the lab:\n       Input: 3 3 ### #L# ###\n       Output: ### #L# ###\n       Explanation: No free cells are available to reach the lab.\n\n    3. A grid where all cells are free and the lab is in a corner:\n       Input: 3 3 L.. ... ...\n       Output: L++ +++ +++\n       Explanation: All free cells can be marked as reachable since they can all lead to the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking only those cells that can be reached from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab, considering the robot's unpredictable movement. The solution must efficiently handle large grids and provide clear output for each test case.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Optimize the solution for large grid sizes\n- Ensure the output format matches the requirements\n- Handle edge cases effectively\n- Provide documentation for maintainability\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other free cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all directions, marking cells that can be reached by the robot.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab. The task is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be reached by the robot using BFS.\n    5. Mark reachable free cells with a '+'.\n    6. Print the modified grid for each test case.\n\n# [edge case] \n    Test case with only one cell being a lab:\n    Input: \n    1\n    1 1\n    L\n    Output:\n    L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except the lab:\n    Input:\n    1\n    3 3\n    ###\n    #L#\n    ###\n    Output:\n    ###\n    #L#\n    ###\n    Explanation: All cells are blocked except the lab, so no free cells can be marked.\n\n    Test case with multiple paths leading to the lab:\n    Input:\n    1\n    3 3\n    ...\n    .L.\n    ...\n    Output:\n    ...\n    .L.\n    ...\n    Explanation: No free cells can be forced to reach the lab due to multiple paths.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by marking only reachable free cells from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input size within constraints.\n- Optimize the algorithm for speed and memory usage.\n- Provide clear documentation and comments in the code.\n- Include comprehensive test cases for edge scenarios.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other free cells, ensuring we find all reachable cells. We will utilize a queue to manage the exploration process and a set to track visited cells. The algorithm will start from the lab and explore all directions, marking cells that can reach the lab.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid'\n    Explanation: A grid is a two-dimensional array of cells, where each cell can be free, obstructed, or contain a lab.\n\n    'lab'\n    Explanation: The lab is a specific cell in the grid that the robot needs to reach.\n\n    'crazy robot'\n    Explanation: A robot that does not follow direct commands but instead moves in a different direction if possible.\n\n# [phrase showing quantity relationship]\n    'one of the free cells'\n    Explanation: There is exactly one lab in the grid, and the robot starts from one of the free cells.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n5. For each free cell, check if it can be forced to reach the lab by sending commands.\n6. Mark such cells with a '+'.\n7. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid is already at the lab, so no free cells to mark.\n\n    Test case with all cells blocked except for the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 ... .L. ...\n    Output: +++ +L+ +++\n    Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by exploring all possible paths from the lab and marking reachable cells.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct and clear.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize the algorithm for computational efficiency.\n- Provide clear and correct output format.\n- Test the solution against a variety of test cases.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other free cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all directions, marking cells that can be reached by the robot.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab. The task is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use BFS starting from the lab to explore all reachable free cells ('.') that can lead the robot to the lab.\n    4. For each free cell, check if it can be reached by the robot using BFS.\n    5. Mark reachable free cells with a '+'.\n    6. Print the modified grid for each test case.\n\n# [edge case] \n    Test case with only one cell being the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: All cells are blocked except the lab, so no free cells can reach the lab.\n\n    Test case with a single row:\n    Input: 1 5 ....L\n    Output: ++++L\n    Explanation: All free cells can reach the lab directly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by starting from the lab and exploring reachable cells.\n", "requirement analysis:\nThe requirements focus on determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is consistent with the given examples.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles large grid sizes efficiently\n- Optimize the algorithm for performance across multiple test cases\n- Verify the output format matches the requirements\n- Test the solution with various grid configurations\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it explores all possible paths from the lab to free cells, ensuring that we can find all reachable cells efficiently. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all free cells, marking those that can be forced to reach the lab.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A matrix-like structure consisting of rows and columns where each cell can be free, obstructed, or contain a lab.\n    'free cell': A cell in the grid that is not obstructed and can be moved into.\n    'lab': A specific free cell in the grid that the robot needs to reach.\n    'crazy robot': A robot that does not follow direct commands but moves in a different direction than commanded.\n\n# [phrase showing quantity relationship]\n    'one of the following commands': Indicates that there are four possible commands to move the robot.\n    'exactly one lab': There is only one lab in the grid, which is crucial for determining the target location.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n5. For each free cell, determine if it can be forced to reach the lab by checking if all possible moves lead towards the lab.\n6. Mark such cells with a '+'.\n7. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid is already at the lab, so no changes are needed.\n\n    Test case with all cells blocked except for the lab:\n    Input: 3 3\n           ###\n           #L#\n           ###\n    Output: ###\n            #L#\n            ###\n    Explanation: No free cells exist, so no changes are needed.\n\n    Test case with a free path directly to the lab:\n    Input: 3 3\n           ...\n           .L.\n           ...\n    Output: ...\n            .L.\n            ...\n    Explanation: No free cell can be forced to reach the lab due to multiple possible escape routes.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The BFS approach inherently handles grids of varying configurations, including those with no free cells or direct paths to the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct for each scenario.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize the algorithm for better performance.\n- Provide clear documentation and comments in the code.\n- Include additional test cases for thorough testing.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other free cells, ensuring that we can mark all reachable cells. The BFS will start from the lab and propagate through all free cells, marking them as reachable if they can be forced to reach the lab.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, each of which can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab. The task is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Implement a Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by ensuring that there is always a path to the lab regardless of the robot's choice.\n    5. Mark all reachable free cells with a '+'.\n    6. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 L.. ...\n    Output: L++ +++\n    Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking reachable cells starting from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct and clear.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for computational efficiency.\n- Provide clear and correct output format for each test case.\n- Include comprehensive test coverage for various scenarios.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. The BFS will start from the lab and explore all reachable free cells, marking them as reachable. This approach ensures that we efficiently handle large grids and multiple test cases. We will use a queue to manage the BFS exploration and a set to track visited cells.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and needs to be guided to the lab. The task is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n    4. Mark cells as reachable if they can lead the robot to the lab.\n    5. Replace reachable free cells with '+' in the grid.\n    6. Print the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to be marked.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 .L. ...\n    Output: +L+\n            +++\n    Explanation: All free cells can lead directly to the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking reachable cells starting from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic movement behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for better performance.\n- Provide detailed comments and documentation for the code.\n- Create additional test cases for thorough testing.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can mark all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all possible paths, marking cells that can reach the lab.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid'\n    Explanation: A grid is a two-dimensional array of cells, where each cell can be free, obstructed, or contain a lab.\n\n    'free cell'\n    Explanation: A cell in the grid that is not obstructed and can be moved into by the robot.\n\n    'obstructed cell'\n    Explanation: A cell in the grid that cannot be moved into by the robot.\n\n    'lab'\n    Explanation: A specific free cell in the grid that the robot needs to reach.\n\n    'crazy robot'\n    Explanation: A robot that does not follow direct commands but instead moves in a different direction if possible.\n\n# [phrase showing quantity relationship]\n    'one of the free cells'\n    Explanation: There is exactly one lab in the grid, and it is located in one of the free cells.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the dimensions of the grid and the grid itself.\n3. Identify the position of the lab in the grid.\n4. Use a Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n5. For each free cell, check if it can be forced to reach the lab by considering all possible moves and ensuring that at least one move leads towards the lab.\n6. Mark all such cells with a '+'.\n7. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only a lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells to mark.\n\n    Test case with all cells blocked except for the lab:\n    Input: 3 3\n           ###\n           #L#\n           ###\n    Output: ###\n            #L#\n            ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a straight path to the lab:\n    Input: 1 5\n           ....L\n    Output: ++++L\n    Explanation: All free cells can be forced to reach the lab by moving towards it.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The BFS approach inherently handles grids of varying configurations, including those with minimal or no free cells.\n", "requirement analysis:\nThe task requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and provide accurate results for each test case.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Optimize for performance with large grid sizes\n- Ensure output format matches requirements\n- Handle edge cases such as single cell grids\n- Provide detailed documentation for the solution\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it explores all possible paths from the lab to free cells, ensuring that we can mark all reachable cells efficiently. Given the constraints, we will use a queue to manage the BFS process and a set to track visited cells. This approach will handle large grids efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and needs to be guided to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use BFS starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by ensuring that all possible moves lead towards the lab.\n    5. Mark the free cells that can force the robot to reach the lab with '+'.\n    6. Print the modified grid for each test case.\n\n# [edge case] \n    Edge Case 1: A grid with only one cell which is a lab.\n    Input: 1 1 L\n    Expected Output: L\n    Explanation: The grid contains only the lab, no free cells to mark.\n\n    Edge Case 2: A grid where all cells are blocked except for the lab.\n    Input: 3 3 ### #L# ###\n    Expected Output: ### #L# ###\n    Explanation: No free cells exist, so no cells can be marked.\n\n    Edge Case 3: A grid where all free cells are directly adjacent to the lab.\n    Input: 3 3 .L. ...\n    Expected Output: +L+ +++\n    Explanation: All free cells can be forced to reach the lab as they are directly adjacent.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by marking reachable cells from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic movement behavior. The solution must efficiently handle large grids and provide a clear output format. The challenge lies in ensuring the robot can be guided to the lab from any free cell, considering the robot's tendency to move in any direction except the commanded one.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Optimize the solution for large grid sizes.\n- Ensure the output format is clear and correct.\n- Test the solution against edge cases.\n- Document the solution and its approach.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can mark all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted according to the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab. The robot's movement is unpredictable, as it will move in any direction except the one commanded, provided the cell in that direction is not blocked.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. Maintain a queue for BFS and a set to track visited cells.\n    5. For each free cell, check if it can be reached from the lab by considering all possible movements.\n    6. Mark reachable free cells with '+'.\n    7. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    1 1\n    L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except the lab:\n    3 3\n    ###\n    #L#\n    ###\n    Output:\n    ###\n    #L#\n    ###\n    Explanation: All cells are blocked except the lab, so no free cells can be marked.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    3 3\n    L..\n    ...\n    ...\n    Output:\n    L++\n    +++\n    +++\n    Explanation: All free cells can be reached from the lab, so they are marked with '+'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by exploring all possible paths from the lab and marking reachable free cells.\n"], "scores": [], "pass_results": [true, false, false, true, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 308, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "mutate_method": "rephrase_one", "parent_index": 39}
