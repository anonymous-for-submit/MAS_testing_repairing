{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds. Throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon. This toxic effect inflicts 1 damage in each of the ensuing k seconds. The poisonous effect commences along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds. Throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon. This toxic effect inflicts 1 damage in each of the ensuing k seconds. The poisonous effect commences along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds. Throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon. This toxic effect inflicts 1 damage in each of the ensuing k seconds. The poisonous effect starts along with the exact second that the dragon is pierced by the dagger. It begins exactly when the animal gets hit by the dagger weapon. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds, and throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle, and the dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon. This toxic effect inflicts 1 damage in each of the ensuing k seconds, commencing along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one). For instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13, and in aggregate, the dragon sustains 10 damage. Monocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # Initial bounds for k\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                right = mid  # Try a smaller k\n            else:\n                left = mid + 1  # Increase k\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of the poison effect (k) for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        left, right = 1, h\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attack_times = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, 10**18\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, 10**18\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        # Append the minimum k found for this test case\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to inflict at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # k cannot be more than h because h damage is needed\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\ndef minimum_poison_duration(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (list): List of attack times.\n\n    Returns:\n        list: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, max(attacks) + 1\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Interface using input() and print()\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\"\"\"\n    results = []\n    \n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # Set initial bounds for k\n        while low < high:\n            mid = (low + high) // 2\n            if can_inflict_damage(n, h, attack_times, mid):\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    \n    return results\n\ndef can_inflict_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if the poison duration k can inflict at least h damage.\"\"\"\n    total_damage = 0\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        if total_damage >= h:\n            return True\n    return total_damage >= h\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    \n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp inflicts at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # Set high to h as the maximum possible k\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # Set initial bounds for k\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust bounds based on whether the calculated damage meets or exceeds h\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe game requires efficient handling of large numbers and strategic timing of attacks to ensure the dragon is defeated. The player must be able to understand the impact of their actions and adjust their strategy accordingly. The game should provide clear feedback and run smoothly even with complex calculations.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure intuitive game mechanics for player engagement\n- Optimize performance for handling large numbers\n- Provide clear feedback on player's progress\n- Design a replay feature for strategy improvement\nWe will implement a binary search algorithm to efficiently determine the minimum value of k that causes at least h damage to the dragon. This approach is optimal for handling large numbers and ensures the game mechanics are intuitive and engaging.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger's attack doesn't cause direct damage but initiates a poison effect that deals 1 damage per second for k seconds. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Accumulate damage over time and check if it meets or exceeds h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the attack times.\n3. Implement a binary search for k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - Calculate the total damage for a mid value of k.\n   - If the damage is at least h, try a smaller k; otherwise, increase k.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Case 2: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n    Case 3: n = 100, h = 100, a = [1, 2, ..., 100] => k = 1\n    Explanation: With consecutive attacks and needing only 100 damage, k can be minimal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the accumulated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large input values, ensuring accurate and timely results.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large input values efficiently.\n- Optimize the algorithm to reduce execution time.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for the code.\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. This approach is chosen because it allows us to handle large input values and multiple test cases efficiently. We will iterate over each test case, calculate the damage for different values of k using binary search, and find the minimum k that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect starts when the dragon is attacked and lasts for k seconds, dealing 1 damage per second. If another attack occurs during this period, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb] \n    'smallest possible value'\n    Explanation: We need to find the minimum k that satisfies the condition. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. For each test case, initialize the binary search range for k.\n2. Calculate the total damage for a given k by iterating over attack times and summing up the damage.\n3. Use binary search to adjust k until the minimum k that results in at least h damage is found.\n4. Output the minimum k for each test case.\n\n# [edge case] \n    Test case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 to inflict at least 1 damage.\n\n    Test case 2: n = 100, h = 10000, a = [1, 2, ..., 100]\n    Expected output: 100\n    Explanation: With consecutive attacks, each attack refreshes the poison. The minimum k is equal to n to inflict at least h damage.\n\n    Test case 3: n = 2, h = 10^18, a = [1, 10^9]\n    Expected output: 10^18\n    Explanation: With large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k until the condition is met.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of poison effect needed to inflict at least h damage to the dragon, given the attack timings. The solution must efficiently handle large input sizes and constraints.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Optimize the solution for large input constraints\n- Ensure the solution is tested against multiple test cases\n- Provide clear documentation for the implemented solution\n- Consider edge cases and validate the solution\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) needed to inflict at least h damage to the dragon. The binary search will be applied on the possible values of k, ranging from 1 to the maximum possible time difference between consecutive attacks. This approach ensures that we handle large input sizes and constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect starts when the dragon is attacked and lasts for k seconds, dealing 1 damage per second. If another attack occurs during this period, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a condition to check if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. For each test case, initialize the binary search range for k from 1 to a large number (e.g., 10^18).\n2. Calculate the total damage for a given k by iterating through the attack times and summing up the damage.\n3. If the total damage is at least h, adjust the binary search range to find a smaller k.\n4. If not, increase k.\n5. Continue until the smallest k is found.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1.\n\n    Test case 2: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n    Test case 3: n = 100, h = 100, a = [1, 2, ..., 100] => k = 1\n    Explanation: With consecutive attacks and h equal to n, k can be minimal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k based on the damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large input sizes, ensuring that the algorithm is both time and space efficient.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Optimize the algorithm for large input sizes\n- Ensure the solution is robust and handles edge cases\n- Provide clear documentation and comments in the code\n- Develop a user-friendly interface for input and output\nWe will use a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. This approach is suitable given the constraints, as it allows us to handle large input sizes effectively. We will iterate over each test case, calculate the damage for different values of k, and use binary search to find the minimum k that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poisonous impact refers to the damage inflicted on the dragon over a period of k seconds after each attack. If a new attack occurs before the previous poison effect ends, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: This is the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a loop or binary search to find the smallest k such that the total damage is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. For each test case, initialize low and high values for binary search. Low can start at 1, and high can be a large number (e.g., h).\n2. Perform binary search:\n   - Calculate mid as (low + high) // 2.\n   - Calculate total damage for k = mid.\n   - If total damage >= h, update high = mid.\n   - Otherwise, update low = mid + 1.\n3. The result for each test case is the value of low after the binary search completes.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 to inflict at least 1 damage.\n\n    Test case 2: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n    Test case 3: n = 100, h = 100, a = [1, 2, ..., 100] => k = 1\n    Explanation: With consecutive attacks and small h, k can be minimal to achieve the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe main requirement is to calculate the minimum poison duration (k) needed to inflict at least h damage to the dragon. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate damage calculation based on attack timings.\nrequirement pool:\n- Implement the algorithm to calculate minimum poison duration k\n- Optimize the solution for performance with large input sizes\n- Provide detailed feedback on damage calculation\n- Ensure the solution handles edge cases effectively\n- Design a user-friendly interface for input and output\nWe will implement a binary search algorithm to efficiently determine the minimum poison duration k. The binary search will be used to find the smallest k such that the total damage inflicted is at least h. This approach is chosen because it allows us to handle large input sizes and high values of h efficiently. We will iterate over each test case, calculate the damage for a given k, and adjust k using binary search until the minimum valid k is found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poisonous impact refers to the damage inflicted on the dragon over a period of k seconds after each attack. If a new attack occurs before the previous poison effect ends, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a condition to check if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. For each test case, initialize low and high values for binary search. Low can start at 1, and high can be a large number, such as 10^18.\n2. Perform binary search:\n   - Calculate mid as (low + high) // 2.\n   - Calculate total damage for this mid value of k.\n   - If total damage >= h, update high to mid.\n   - Otherwise, update low to mid + 1.\n3. Once binary search completes, low will be the minimum k that satisfies the condition.\n4. Output the result for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n    \n    Test case: 2 1000000000000000000\n    Explanation: With two attacks far apart and needing a very large amount of damage, k will need to be very large.\n    \n    Test case: 3 3\n    Explanation: With three attacks and needing only 3 damage, k = 1 is sufficient if attacks are close enough.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe game requires a mechanism to calculate the minimum poison duration needed to defeat the dragon based on attack timings and dragon's health. The solution should efficiently handle large numbers and multiple test cases, ensuring performance optimization.\nrequirement pool:\n- Implement the algorithm to calculate minimum poison duration (k) for each test case.\n- Develop a user interface that visually represents the poison effect timeline.\n- Optimize the game for handling large-scale computations efficiently.\n- Include real-time updates on the dragon's health during the battle.\n- Allow players to replay battles to test different strategies.\nWe will implement a function to calculate the minimum poison duration (k) required to inflict at least h damage to the dragon. The approach involves iterating over the attack times and calculating the damage inflicted by each attack, considering the poison refresh mechanism. We will use binary search to efficiently find the minimum k for each test case, ensuring the solution handles large numbers and multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poisonous impact refers to the damage inflicted on the dragon over a duration of k seconds after each attack. If a new attack occurs while the poison is still active, the poison duration is refreshed.\n\n    'refreshes the poisonous impact'\n    Explanation: This means that if the dragon is already under the influence of poison, a new attack will reset the poison duration to start from that attack time.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest possible value of k'\n    Explanation: We need to find the minimum duration k such that the total damage inflicted is at least h. This can be implemented using binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n (number of attacks) and h (required damage).\n    3. Read the attack times into a list.\n    4. Use binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - For each mid value in binary search, calculate total damage:\n            - Iterate through attack times and calculate damage considering poison refresh.\n            - If total damage >= h, adjust high bound; otherwise, adjust low bound.\n    5. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: \n    Input: 1 1\n           1\n    Expected Output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Case 2:\n    Input: 2 2\n           1 2\n    Expected Output: 1\n    Explanation: Two attacks at consecutive seconds mean k=1 is enough to inflict 2 damage.\n\n    Case 3:\n    Input: 3 3\n           1 2 3\n    Expected Output: 1\n    Explanation: Three attacks at consecutive seconds mean k=1 is enough to inflict 3 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by checking if the total damage meets or exceeds h for each candidate k value.\n", "requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) needed to inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The attacks are given in increasing order of time, and the solution must account for overlapping poison effects.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize the algorithm to minimize execution time.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for the code.\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) needed to inflict at least h damage to the dragon. The binary search will be applied on the possible values of k, ranging from 1 to the maximum possible time difference between consecutive attacks plus one. This approach ensures that we efficiently handle large input sizes and high damage requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect starts when the dragon is attacked and lasts for k seconds, dealing 1 damage per second. If another attack occurs during this period, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb] \n    'smallest possible value'\n    Explanation: We need to find the minimum k that satisfies the condition. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Initialize binary search bounds for k: low = 1, high = maximum possible time difference between consecutive attacks plus one.\n4. Perform binary search:\n   - Calculate mid = (low + high) // 2.\n   - Simulate the damage with k = mid:\n     - Initialize total_damage = 0.\n     - For each attack time, calculate the damage period and accumulate damage.\n     - If total_damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n5. After binary search, low will be the minimum k that satisfies the condition.\n6. Output the result for each test case.\n\n# [edge case] \n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to inflict any damage.\n\n    Test case 2: (2, 2, [1, 1000000000]) = 1\n    Explanation: With two attacks far apart and h = 2, k = 1 is sufficient as each attack contributes exactly 1 damage.\n\n    Test case 3: (3, 10^18, [1, 2, 3]) = 10^18\n    Explanation: With a very high h and closely spaced attacks, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) needed to inflict at least h damage on the dragon. The solution must efficiently handle up to 1000 test cases with large input sizes, ensuring performance and accuracy.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize the algorithm for performance.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for the code.\nWe will implement a binary search algorithm to efficiently determine the minimum duration of poison effect (k) needed to inflict at least h damage on the dragon. The binary search will be applied over the possible values of k, leveraging the sorted nature of attack times to calculate the cumulative damage efficiently. This approach ensures that we handle up to 1000 test cases with large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger initiates a poisonous effect that lasts for k seconds, inflicting 1 damage per second. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage inflicted must be greater than or equal to h.\n    Implementation: Ensure the cumulative damage calculation meets or exceeds h.\n\n# [degree adverb]\n    'smallest': means we need to find the minimum possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the attack times.\n    3. Implement a binary search for k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate damage for a mid-point k.\n        - Adjust bounds based on whether the damage meets or exceeds h.\n    4. Return the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum n and h:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient.\n\n    Test case with maximum n and minimum h:\n    100 1\n    1 2 3 ... 100\n    Expected output: 1\n    Explanation: Any k >= 1 will suffice since each attack inflicts at least 1 damage.\n\n    Test case with large h:\n    2 10^18\n    1 10^9\n    Expected output: Large value of k\n    Explanation: Requires a large k to accumulate enough damage over sparse attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying values of n and h efficiently.\n", "requirement analysis:\nThe requirements focus on determining the minimum value of k that ensures Monocarp inflicts at least h damage to the dragon. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate and clear output.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure output format matches expected results\n- Optimize for large values of h and n\n- Handle edge cases effectively\n- Provide detailed comments and documentation\nWe will implement a binary search algorithm to efficiently determine the minimum value of k that ensures Monocarp inflicts at least h damage to the dragon. The binary search will be used to find the smallest k such that the total damage is at least h. This approach is chosen because it allows us to efficiently handle large input sizes and multiple test cases, ensuring the solution is both scalable and optimized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger's attack initiates a poison effect that lasts for k seconds, dealing 1 damage per second. If another attack occurs during this period, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k for which the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'smallest possible value of k'\n    Explanation: We need to find the minimum k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., low = 1, high = maximum possible k).\n   - While low < high:\n     - Calculate mid as the average of low and high.\n     - Calculate total damage for this mid value of k.\n     - If total damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n4. Output the value of low as the minimum k for each test case.\n\n# [edge case] \n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to inflict the required damage.\n\n    Test case 2: (2, 2, [1, 1000000000]) = 1\n    Explanation: The attacks are far apart, so each attack must independently inflict at least 1 damage.\n\n    Test case 3: (3, 10, [1, 2, 3]) = 4\n    Explanation: The attacks are close together, so a smaller k can accumulate enough damage over overlapping periods.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage inflicted is at least h. The solution must efficiently handle up to 1000 test cases with large constraints on n and h. The attacks are given in increasing order, which can be leveraged to optimize the solution.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k.\n- Optimize the solution for large input sizes.\n- Ensure the solution is tested against edge cases.\n- Provide detailed comments and documentation.\n- Consider additional features like visualizing the attack timeline.\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage inflicted by the poison can be calculated by considering the intervals between attacks and the duration of the poison effect. By leveraging the sorted nature of attack times, we can optimize the calculation of total damage for a given k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poisonous impact refers to the damage inflicted on the dragon over a period of k seconds after each attack. If a new attack occurs while the poison is still active, the poison duration is reset.\n\n    'minimum value of k'\n    Explanation: The smallest duration for which the poison effect remains active and is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all intervals is >= h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search for k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate total damage for a given k by iterating through attack times and summing up the damage intervals.\n        - Adjust bounds based on whether the calculated damage meets or exceeds h.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to inflict 1 damage.\n\n    Case 2: n = 2, h = 10, a = [1, 1000000000]\n    Expected output: 10\n    Explanation: The attacks are far apart, so k must be at least 10 to accumulate enough damage.\n\n    Case 3: n = 100, h = 10000, a = [1, 2, ..., 100]\n    Expected output: 100\n    Explanation: Continuous attacks mean k must be large enough to cover all intervals without overlap.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on calculated damage.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 717, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 310}
