{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n. Let's define the eversion operation; let x = a_n, then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x), and the right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n. Let's define the eversion operation; let x = a_n, then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x), and the right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n. Let's define the eversion operation; let x = a_n, then array a is partitioned into two parts: left and right. In this operation, the left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n. Then array a is partitioned into two parts: left and right, where the left part contains the elements of a that are not greater than x (\u2264 x), and the right part contains the elements of a that are strictly greater than x (> x). For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Get results\n    results = min_eversions(t, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        if n == 0:\n            results.append(0)\n            continue\n        \n        # Initialize the number of eversions\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            # If the array does not change, break the loop\n            if new_array == current_array:\n                break\n            \n            # Update the current array and increment the eversion count\n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        max_so_far = float('-inf')\n        eversion_count = 0\n        \n        # Traverse the array from the end to the start\n        for num in reversed(case):\n            if num > max_so_far:\n                max_so_far = num\n                eversion_count += 1\n        \n        # The number of eversions is one less than the number of new maximums encountered\n        results.append(eversion_count - 1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        current_array = case[:]\n        eversion_count = 0\n        \n        while True:\n            x = current_array[-1]\n            left = [num for num in current_array if num <= x]\n            right = [num for num in current_array if num > x]\n            new_array = left + right\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        max_value = max(case)\n        eversion_count = 0\n        current_max = float('-inf')\n        \n        # Iterate from the end to the start of the array\n        for i in range(n - 1, -1, -1):\n            if case[i] > current_max:\n                current_max = case[i]\n            if current_max == max_value:\n                break\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    until the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            max_value = max(current_array)\n            left_part = [x for x in current_array if x <= max_value]\n            right_part = [x for x in current_array if x > max_value]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        max_element = max(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            # Partition the array based on the maximum element\n            left_part = [x for x in current_array if x <= max_element]\n            right_part = [x for x in current_array if x > max_element]\n            new_array = left_part + right_part\n            \n            # Check if the array has changed\n            if new_array == current_array:\n                break\n            \n            # Update the current array and increment the eversion count\n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case\n    until the array stabilizes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum number of eversions needed for an array to stop changing. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring that the partitioning and concatenation operations are performed correctly and quickly.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation within the code.\n- Include edge case handling for arrays with identical elements.\nWe will implement the eversion operation by iterating over the array from the end to the start, partitioning the array based on the last element, and counting the number of eversions until the array stops changing. We will use Python's built-in list operations to efficiently partition and concatenate the array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements greater than x. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': This means elements in the left part should be less than or equal to x.\n    'strictly greater than (>)': This means elements in the right part should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array changes:\n   - Set x as the last element of the array.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. Stop when the array no longer changes and output k.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array does not change.\n\n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition point, so no eversion is needed.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no eversion is needed by checking if the array changes after an eversion operation.\n", "requirement analysis:\nThe requirements focus on efficiently partitioning the array based on the eversion operation and determining the minimum number of eversions needed for the array to stabilize. The solution must handle multiple test cases and large input sizes while ensuring accurate and optimized performance.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the function handles multiple test cases\n- Optimize the algorithm for large input sizes\n- Provide clear output format as specified\n- Minimize execution time\nWe will implement the eversion operation by iterating over the array and partitioning it into two parts based on the last element. We will use a loop to perform eversions until the array stops changing. The approach will efficiently handle large input sizes by minimizing unnecessary operations and using stable partitioning.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements greater than x. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': This means elements in the left part are less than or equal to x.\n    'strictly greater than (>)': This means elements in the right part are greater than x.\n\n# [degree adverb] \n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. Perform the eversion operation:\n   - Identify x as the last element of the array.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n4. Increment k after each eversion.\n5. Repeat the eversion until the array stops changing.\n6. Output k for each test case.\n\n# [edge case] \n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition point, so no eversion is needed.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after an eversion. If it doesn't change, the loop terminates naturally.\n", "requirement analysis:\nThe requirements focus on efficiently partitioning an array based on a defined operation until the array stabilizes. The solution must handle multiple test cases and large input sizes, ensuring performance optimization and accurate results.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles large input sizes\n- Optimize the algorithm for performance\n- Provide clear output for each test case\n- Handle edge cases gracefully\nWe will implement the eversion operation using a simple loop to partition the array based on the last element. The algorithm will repeatedly perform eversions until the array stabilizes. We will use Python's built-in list operations to efficiently handle the partitioning and concatenation. The solution will be optimized to handle large input sizes by minimizing unnecessary operations and using efficient list manipulations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to x.\n    'strictly greater than': means elements in the right part are greater than x.\n\n# [degree adverb]\n    'minimum number': means the smallest number of eversions needed for the array to stop changing.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n       - Identify the last element, x.\n       - Partition the array into left and right parts based on x.\n       - Concatenate the left and right parts to form a new array.\n    4. Check if the new array is the same as the previous one. If it is, stop; otherwise, repeat.\n    5. Return the number of eversions performed.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Input: [1, 2, 3, 4, 5] = 1\n    Explanation: Only one eversion is needed as the array is already sorted in increasing order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after each eversion.\n", "requirement analysis:\nThe requirement involves implementing an eversion operation on an array, which partitions the array based on the last element and rearranges it. The goal is to determine the minimum number of eversions required for the array to stop changing. The challenge lies in efficiently handling large input sizes and ensuring the algorithm performs optimally.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles large input sizes efficiently\n- Optimize the code for performance\n- Provide accurate output for each test case\n- Document the code for clarity and maintainability\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered so far. The number of eversions required is equal to the number of times we encounter a new maximum element when traversing the array from the end. This approach ensures that we efficiently determine the minimum number of eversions required for the array to stop changing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element of the array. Elements less than or equal to the last element form the left part, and elements greater form the right part. The array is then reformed by concatenating the left and right parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': Elements that are less than or equal to the last element of the array.\n    'strictly greater than (>)': Elements that are greater than the last element of the array.\n\n# [degree adverb] \n    'minimum number': The smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Traverse the array from the end to the start.\n    3. Keep track of the maximum element encountered so far.\n    4. Each time a new maximum is encountered, increment the eversion counter.\n    5. The counter will represent the minimum number of eversions required.\n\n# [edge case] \n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Case 2: [5, 4, 3, 2, 1] = 4\n    Explanation: Each element is a new maximum when traversing from end to start, requiring an eversion for each.\n    \n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting new maximums encountered from end to start inherently handles these cases.\n", "requirement analysis:\nThe requirements focus on efficiently partitioning an array based on the eversion operation until it stabilizes. The solution must handle multiple test cases and large input sizes, ensuring optimal performance and correct output.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the function handles multiple test cases\n- Optimize the algorithm for large input sizes\n- Provide clear documentation for integration\n- Test the function with edge cases\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. We will use a simple loop to count the number of eversions required for stabilization. The function will handle multiple test cases efficiently by iterating through each test case and applying the eversion logic. Given the constraints, the solution will be optimized to handle large input sizes by ensuring the partitioning and concatenation operations are performed in linear time.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements greater than x. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': This means elements in the left part are less than or equal to x.\n    'strictly greater than (>)': This means elements in the right part are greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for the number of eversions.\n3. Perform the eversion operation:\n   - Identify the last element, x.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate the left and right parts to form a new array.\n4. Check if the array has changed after the eversion. If not, stop; otherwise, increment the counter and repeat.\n5. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will sort the array in ascending order, and no further eversions will change it.\n    \n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in ascending order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array changes after each eversion inherently handles these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of eversions needed for an array to stabilize. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring that the partitioning and concatenation operations are performed correctly and quickly.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the solution handles the maximum input size efficiently\n- Provide detailed comments and documentation for the code\n- Optimize the code for readability and maintainability\n- Include edge case handling and testing\nWe will implement a function to perform the eversion operation on the array as described. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. We will repeat this process until the array stops changing. The solution will efficiently handle multiple test cases by processing each test case independently and using a loop to determine the number of eversions required for stabilization.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, where the left part contains elements not greater than the last element, and the right part contains elements strictly greater than the last element. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to the last element.\n    'strictly greater than': means elements in the right part are greater than the last element.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for eversions.\n    3. Perform the eversion operation:\n        - Identify the last element of the array.\n        - Partition the array into two parts: left (elements \u2264 last element) and right (elements > last element).\n        - Concatenate the left and right parts to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it is different, increment the counter and repeat; otherwise, stop.\n    6. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so the expected output is 0.\n\n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 1\n    Explanation: After one eversion, the array becomes stable as all elements are less than or equal to the last element.\n\n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = n-1\n    Explanation: Each eversion moves one element to the right part until only one element remains in the left part.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles them by checking if the array changes after each eversion.\n", "requirement analysis:\nThe task requires determining the minimum number of eversions needed for an array to stabilize. The solution must efficiently handle multiple test cases and large input sizes, ensuring that the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to calculate the number of eversions.\n- Ensure the solution handles the maximum constraints efficiently.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear documentation and comments within the code.\n- Include additional test cases to verify edge cases.\nWe will implement a function that iteratively performs eversions on the array until it stabilizes. The partition point x will be the maximum value in the current array during each eversion. We will use a loop to track the number of eversions needed for stabilization. The solution will efficiently handle multiple test cases and large input sizes by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion'\n    Explanation: In the context of this problem, an eversion refers to the process of partitioning the array into two parts based on a pivot value x, where elements less than or equal to x are moved to the left and elements greater than x are moved to the right. The array is then reassembled in this order.\n\n    'stabilizes'\n    Explanation: The array stabilizes when further eversions do not change the order of elements in the array.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': This means elements that are less than or equal to x should be in the left part of the partition.\n    'strictly greater than (> x)': This means elements that are greater than x should be in the right part of the partition.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for the number of eversions.\n3. While the array is not stabilized:\n   - Find the maximum value in the current array, which will be used as the partition point x.\n   - Partition the array into two parts: elements \u2264 x and elements > x.\n   - Reassemble the array with elements \u2264 x followed by elements > x.\n   - Increment the eversion counter.\n4. Once the array stabilizes, record the number of eversions.\n5. Output the number of eversions for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will sort the array into [1, 2, 3, 4, 5], which is stable.\n\n    Test case: [1] = 0\n    Explanation: A single-element array is already stable.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of iterating until stabilization inherently handles these scenarios.\n", "requirement analysis:\nThe task requires partitioning an array based on a pivot value and counting the number of times this operation needs to be performed until the array stabilizes. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the main algorithm to partition the array and count eversions.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear and concise output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that iteratively partitions the array based on a pivot value, which is the maximum element of the current array. The function will count the number of eversions needed until the array stops changing. This approach ensures that the array is partitioned efficiently, and the number of eversions is minimized. We will use a simple loop to perform the partitioning and check for stability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion'\n    Explanation: In the context of the requirement, eversion refers to the process of partitioning the array into two parts based on a pivot value and rearranging the elements accordingly. The goal is to determine the number of eversions required until the array stops changing.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': means elements in the left part are less than or equal to x.\n    'strictly greater than (> x)': means elements in the right part are greater than x.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, initialize a counter for eversions.\n    2. Set the pivot value as the maximum element of the current array.\n    3. Partition the array into two parts: elements not greater than the pivot and elements strictly greater than the pivot.\n    4. Rearrange the array by concatenating the left and right parts.\n    5. Check if the array has changed; if not, stop and return the counter value.\n    6. Repeat steps 2-5 until the array stops changing.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion is needed as the array is already stable.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: Similar to the previous case, all elements are equal, so no eversion is needed.\n    \n    Input: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array has changed after each eversion. If no change occurs, it returns the current count of eversions.\n", "requirement analysis:\nThe task requires partitioning an array based on a pivot value and determining the number of iterations needed for the array to stabilize. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring performance and correctness.\nrequirement pool:\n- Implement the partitioning logic to separate elements based on the pivot value.\n- Ensure the solution handles multiple test cases efficiently.\n- Optimize the algorithm for performance with large datasets.\n- Provide clear and concise output for each test case.\n- Document the code for maintainability and readability.\nWe will implement a function that partitions the array based on a pivot value x, which is the maximum element in the current array. The function will iterate until the array stops changing, counting the number of eversions required. We will use Python's built-in list operations for efficient partitioning and comparison.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'partitioned'\n    Explanation: The array is divided into two parts based on a pivot value x, where elements less than or equal to x are in the left part, and elements greater than x are in the right part.\n\n    'eversion'\n    Explanation: The process of rearranging the array into two parts based on the pivot value x, and then combining them back into a single array.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': means elements in the left part are less than or equal to x.\n    'strictly greater than (> x)': means elements in the right part are greater than x.\n\n# [degree adverb] \n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. For each test case, find the maximum element in the array as the pivot value x.\n    3. Partition the array into two parts based on x.\n    4. Combine the two parts back into a single array.\n    5. Check if the array has changed; if not, stop and return the counter value.\n    6. Repeat until the array stops changing.\n\n# [edge case] \n    Input: 1\n           1\n           1\n    Output: 0\n    Explanation: The array contains only one element, so no eversion is needed.\n\n    Input: 2\n           2\n           1 2\n           2\n           2 1\n    Output: 0\n            1\n    Explanation: In the first test case, no eversion is needed as the array is already partitioned correctly. In the second test case, one eversion is needed to partition the array correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array has changed after each eversion will naturally handle these cases.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform the eversion operation on an array until it stabilizes. The key challenge is to efficiently determine the number of eversions needed for the array to stop changing. The solution must handle multiple test cases and large input sizes within the given constraints.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Output the correct number of eversions for each test case.\n- Optimize the algorithm to handle the maximum input size within time limits.\n- Maintain code readability and simplicity for future maintenance.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The key is to efficiently partition the array into two parts based on the last element and count the number of eversions needed for the array to stop changing. We will use a simple loop to perform the eversions and check for stability. The solution will handle multiple test cases and large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements greater than x. The array is then replaced with the concatenation of these two parts.\n\n    'stabilizes'\n    Explanation: The array is said to stabilize when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': Elements in the left part of the partition are less than or equal to x.\n    'strictly greater than (> x)': Elements in the right part of the partition are greater than x.\n\n# [degree adverb]\n    'minimum number': We need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array is not stable:\n   - Set x as the last element of the array.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. Check if the new array is the same as the previous one. If so, break the loop.\n5. Output k for each test case.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will sort the array in ascending order, and it will stabilize immediately.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in ascending order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if further eversions change the array.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 482, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "condense_two2one", "parent_index": 18}
