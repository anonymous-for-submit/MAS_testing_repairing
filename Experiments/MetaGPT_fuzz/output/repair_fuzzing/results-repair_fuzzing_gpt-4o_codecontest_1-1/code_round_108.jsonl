{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A of size n by m. There are n rows and m columns of blocks. Every block in the rectangle is either an obsidian block or it is empty. CQXYM is able to convert an obsidian block into an empty block or an empty block into an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5. Additionally, it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to find out the smallest number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A of size n by m. There are n rows and m columns of blocks. Every block in the rectangle is either an obsidian block or it is empty. CQXYM is able to convert an obsidian block into an empty block or an empty block into an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5. Additionally, it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to find out the smallest number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A of size n by m. There are n rows and m columns of blocks. Every block in the rectangle is either an obsidian block or it is empty. CQXYM is able to convert an obsidian block into an empty block. Alternatively, CQXYM can convert an empty block into an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5. Additionally, it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to find out the smallest number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A of size n by m. There are n rows and m columns of blocks. Every block in the rectangle is either an obsidian block or it is empty. CQXYM is able to convert an obsidian block into an empty block or an empty block into an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, necessitating that the number of rows is at least 5 and the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to find out the smallest number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing the dimensions and grid for each test case.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The grid matrix.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure the outer rows and columns meet the obsidian block criteria\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] != 1:\n            operations += 1\n        if matrix[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] != 1:\n            operations += 1\n        if matrix[end_row, y] != 1:\n            operations += 1\n\n    # Ensure the inner blocks are empty\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of n, m and the grid\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Find the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        test_cases: A list of tuples, each containing the dimensions of the rectangle and the grid.\n\n    Returns:\n        A list of integers representing the minimum operations needed for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed to meet the portal criteria\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix: The numpy array representing the grid.\n        start_row: The starting row index of the sub-rectangle.\n        start_col: The starting column index of the sub-rectangle.\n        end_row: The ending row index of the sub-rectangle.\n        end_col: The ending column index of the sub-rectangle.\n\n    Returns:\n        The number of operations needed to transform the sub-rectangle into a portal.\n    \"\"\"\n    operations = 0\n\n    # Ensure the first and last rows have obsidian blocks at specified positions\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            operations += 1\n        if matrix[end_row, col] != 1:\n            operations += 1\n\n    # Ensure the first and last columns have obsidian blocks at specified positions\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            operations += 1\n        if matrix[row, end_col] != 1:\n            operations += 1\n\n    # Ensure all inner blocks are empty\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n\n    # Initialize list to store test cases\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = find_min_operations(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and block configuration.\n\n    Returns:\n        list[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed to convert the sub-rectangle into a portal\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Ensure the border blocks meet the obsidian criteria\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Ensure the inner blocks are empty\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to form a portal for each test case.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid).\n        \n    Returns:\n        list: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[start_row:start_row + a, start_col:start_col + b]\n                        \n                        # Calculate the number of operations needed to convert this sub-rectangle into a portal\n                        operations = calculate_operations_to_portal(sub_rect, a, b)\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to convert a sub-rectangle into a portal.\n    \n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be converted.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n        \n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n    \n    # Check the border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n    \n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal number of operations required to transform a given rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and grid configuration.\n\n    Returns:\n        list: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to convert sub-rectangle into a portal\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The grid matrix.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure border blocks meet the obsidian criteria\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] == 0:\n            operations += 1\n        if matrix[row, end_col] == 0:\n            operations += 1\n\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] == 0:\n            operations += 1\n        if matrix[end_row, col] == 0:\n            operations += 1\n\n    # Ensure inner blocks are empty\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of n, m and the grid\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_min_operations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to form a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid) where grid is a list of strings.\n\n    Returns:\n        list: List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list[list[str]]) -> list[int]:\n    \"\"\"Find the minimum number of operations needed to transform a rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[list[str]]): List of matrices representing each test case.\n\n    Returns:\n        list[int]: List of integers representing the minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        grid = np.array([list(map(int, row)) for row in case])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for start_row in range(n - a + 1):\n                    for start_col in range(m - b + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = 0\n                        for i in range(start_row, start_row + a):\n                            for j in range(start_col, start_col + b):\n                                if (i == start_row or i == start_row + a - 1) and (j > start_col and j < start_col + b - 1):\n                                    # Top and bottom borders (except corners)\n                                    if grid[i][j] != 1:\n                                        changes += 1\n                                elif (j == start_col or j == start_col + b - 1) and (i > start_row and i < start_row + a - 1):\n                                    # Left and right borders (except corners)\n                                    if grid[i][j] != 1:\n                                        changes += 1\n                                elif (i > start_row and i < start_row + a - 1) and (j > start_col and j < start_col + b - 1):\n                                    # Interior\n                                    if grid[i][j] != 0:\n                                        changes += 1\n\n                        # Update the minimum number of changes\n                        min_operations = min(min_operations, changes)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m followed by n lines of m characters\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append(matrix)\n\n# Call the function and print results\nresults = find_min_operations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check borders\n    for x in range(start_row + 1, end_row):\n        if grid[x][start_col] != '1':\n            operations += 1\n        if grid[x][end_col] != '1':\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row][y] != '1':\n            operations += 1\n        if grid[end_row][y] != '1':\n            operations += 1\n\n    # Check inner blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x][y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: 2D numpy array representing the grid\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Check the edges and interior of the sub-rectangle\n    for i in range(a):\n        for j in range(b):\n            current_value = grid[start_row + i, start_col + j]\n            \n            if i == 0 or i == a - 1:  # Top and bottom rows\n                if 1 < j < b - 1 and current_value != 1:\n                    operations += 1\n            elif j == 0 or j == b - 1:  # Left and right columns\n                if 1 < i < a - 1 and current_value != 1:\n                    operations += 1\n            else:  # Interior\n                if current_value != 0:\n                    operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n\n                        # Calculate operations needed for current sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                if (1 < x < a - 1 and (y == 0 or y == b - 1)) or (1 < y < b - 1 and (x == 0 or x == a - 1)):\n                                    # These should be obsidian blocks\n                                    if grid[i + x][j + y] == '0':\n                                        operations += 1\n                                elif 1 < x < a - 1 and 1 < y < b - 1:\n                                    # These should be empty blocks\n                                    if grid[i + x][j + y] == '1':\n                                        operations += 1\n\n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, especially given the maximum possible size of the input. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria, ensuring that the solution is optimized for performance.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear and concise output for each test case.\n- Include comprehensive test cases to validate the solution.\nWe will implement a function to find the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to meet the portal criteria. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n by m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where 'n' is the number of rows and 'm' is the number of columns.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the rectangle. An obsidian block is represented by '1', and an empty block is represented by '0'.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria, including size and block type arrangement.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle (portal) must have at least 5 rows and 4 columns. In code, this means checking sub-rectangles with dimensions starting from 5x4.\n\n    '1 < x < a' and '1 < y < b'\n    Explanation: These conditions specify the range of indices for which certain blocks must be obsidian or empty. In code, this involves iterating over these index ranges to check or modify block types.\n\n# [degree adverb]\n    'smallest number of operations'\n    Explanation: The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of operations for different sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the outer rows and columns meet the obsidian block criteria.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations across all sub-rectangles.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Explanation: If a sub-rectangle already meets all portal criteria, no operations are needed, so the output should be 0.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Explanation: Transforming such a rectangle into a portal will require changing all inner blocks to empty, which could be a large number of operations.\n\n    Case 3: A rectangle with all blocks as empty.\n    Explanation: Transforming such a rectangle into a portal will require changing all required outer blocks to obsidian, which could also be a large number of operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating operations will naturally handle these cases by finding the minimum operations required.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size of the portal and the types of blocks at specific positions are crucial for determining the solution. The challenge lies in efficiently finding the sub-rectangle that can be transformed with the least operations, especially given the large possible input sizes.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations needed\n- Ensure the solution handles multiple test cases efficiently\n- Optimize the algorithm for large input sizes\n- Provide clear and concise output for each test case\n- Develop a user-friendly interface for input and output\nWe will implement a function to find the minimum number of operations needed to transform a sub-rectangle into a portal. The approach will involve iterating over possible sub-rectangles of size at least 5x4 and calculating the number of changes required to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with n rows and m columns.\n    'obsidian block': A block represented by '1' in the matrix.\n    'empty block': A block represented by '0' in the matrix.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'smallest number of operations': The minimum number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'smallest': Refers to the least number of operations required to achieve the transformation.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the first and last rows have obsidian blocks at specified positions.\n   - Ensure the first and last columns have obsidian blocks at specified positions.\n   - Ensure all inner blocks are empty.\n4. Track the minimum number of changes required across all sub-rectangles for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Test case with a rectangle having all obsidian blocks:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: Transforming all inner blocks to empty requires 12 operations.\n\n    Test case with a rectangle having all empty blocks:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: Transforming boundary blocks to obsidian requires 12 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must be efficient to handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed.\nrequirement pool:\n- Develop an efficient algorithm to identify the optimal sub-rectangle.\n- Implement a function to calculate the minimum operations required.\n- Ensure the solution handles edge cases and maximum constraints.\n- Optimize the code for performance and readability.\n- Provide detailed comments and documentation for the code.\nWe will implement a function to find the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to convert each into a portal. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'smallest number of operations': The minimum number of changes needed to convert a sub-rectangle into a portal.\n\n# [degree adverb]\n    'smallest': Refers to the least number of operations required to achieve the transformation.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases, dimensions of each rectangle, and the block configuration.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the border blocks meet the obsidian criteria.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations across all sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Test case with maximum dimensions:\n    Input:\n    1\n    400 400\n    (All blocks are empty)\n    Expected Output: Large number (depends on specific configuration)\n    Explanation: Transforming a large empty rectangle into a portal requires many operations.\n\n    Test case with minimum dimensions:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Depends on specific configuration\n    Explanation: Transforming a small empty rectangle into a portal requires specific operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle of a given grid into a portal. The constraints ensure that the solution must be efficient, especially given the maximum grid size of 400x400. The solution should iterate over possible sub-rectangles and calculate the cost of transformation, ensuring that the output is correctly formatted for each test case.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Ensure the solution handles edge cases and maximum constraints efficiently.\n- Optimize the algorithm for performance improvements.\n- Provide detailed comments and documentation for the code.\n- Implement additional test cases to ensure robustness.\nWe will implement a function to find the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the cost to convert each into a portal. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle configuration within the larger rectangle that meets certain criteria.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'smallest number of operations': The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations required to achieve the desired transformation.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4 within the given rectangle.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the border blocks meet the obsidian criteria.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations across all sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already configured as a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as it already meets the portal criteria.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: Convert inner blocks to empty, requiring 8 operations.\n\n    Case 3: A rectangle with all blocks as empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: Convert border blocks to obsidian, requiring 12 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size of the rectangle and the number of test cases ensure that the solution must be efficient and scalable. The output format must be strictly followed to ensure compatibility with test cases.\nrequirement pool:\n- Implement efficient algorithm to find the minimal operations for portal transformation.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Provide clear and concise output format.\n- Optimize the algorithm for speed and performance.\n- Include detailed comments and documentation for maintainability.\nWe will implement a function to find the minimal number of operations required to transform a given rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations needed to convert it into a portal. We will use numpy for efficient matrix manipulation and calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': For rows between the first and last, specific blocks must be obsidian.\n    '1 < x < b': For columns between the first and last, specific blocks must be obsidian.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations needed to convert a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configuration.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the border blocks meet the obsidian criteria.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations across all sub-rectangles for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected output: 0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Test case with minimal dimensions:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: 12\n    Explanation: All border blocks need conversion to obsidian, requiring 12 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires determining the minimum number of operations to transform a sub-rectangle of a given grid into a portal. The constraints ensure that the solution must efficiently handle grids up to 400x400 in size. The solution should iterate over possible sub-rectangles, calculate the cost of transformation, and return the minimum cost for each test case.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the output format is clear and adheres to the requirements.\n- Include comprehensive test cases to validate the solution.\n- Document the code for better understanding and maintenance.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle of a given grid into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4, calculating the cost to transform each into a portal, and returning the minimum cost. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'smallest number of operations': The minimum number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'smallest': Refers to the least number of operations required to achieve the transformation.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the grid dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border blocks meet the obsidian criteria.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations across all sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with a grid already in portal form:\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected output: 0\n    Explanation: The grid is already a portal, so no operations are needed.\n\n    Test case with maximum grid size:\n    Input:\n    1\n    400 400\n    (grid with alternating '0' and '1')\n    Expected output: (calculated based on specific grid pattern)\n    Explanation: The complexity increases with grid size, requiring careful calculation.\n\n    Test case with minimum grid size:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: (calculated based on transformation needs)\n    Explanation: All blocks need transformation to meet portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating transformation costs will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size of the portal and the types of blocks at specific positions are critical. The solution must efficiently handle multiple test cases and large input sizes, ensuring scalability and performance.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal.\n- Optimize the solution for performance and scalability.\n- Ensure the solution handles edge cases effectively.\n- Provide clear input and output instructions.\n- Develop a user-friendly interface for inputting test cases.\nWe will implement a function to find the minimum number of operations needed to transform a given rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes required to meet the portal criteria. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n by m'\n    Explanation: This refers to the initial grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid, represented by 1 (obsidian) and 0 (empty) respectively.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle (portal) must have at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'smallest number of operations'\n    Explanation: The goal is to find the minimum number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes for each potential sub-rectangle.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and then the grid itself.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior is empty blocks.\n5. Track the minimum number of changes across all sub-rectangles.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: The entire grid is obsidian, so converting the interior to empty blocks requires changing 8 blocks.\n\n    Case 2:\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: 16\n    Explanation: The entire grid is empty, so converting the borders to obsidian requires changing 16 blocks.\n\n    Case 3:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: 12\n    Explanation: Alternating pattern requires significant changes to meet portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must efficiently handle the maximum grid size. The algorithm should focus on identifying potential portal positions and calculating the necessary transformations.\nrequirement pool:\n- Develop the main algorithm to find the minimum operations for portal transformation.\n- Optimize the algorithm for large grid sizes.\n- Ensure the solution is robust against edge cases.\n- Provide detailed comments and documentation for the code.\n- Implement additional test cases to validate the solution.\nWe will develop an algorithm that iterates over all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The algorithm will keep track of the minimum number of operations required across all sub-rectangles. Given the constraints, this approach will efficiently handle the maximum grid size using nested loops and condition checks.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for block arrangement.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure the sub-rectangle dimensions are checked against these minimum values.\n    'smallest number of operations': Find the minimum operations needed to transform a sub-rectangle into a portal.\n    Implementation: Track the minimum operations across all possible sub-rectangles.\n\n# [degree adverb]\n    'smallest': Refers to the least number of operations required.\n    Implementation: Use a variable to store the minimum operations and update it when a smaller value is found.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the grid dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the borders meet the obsidian block criteria.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Test case with minimum size grid:\n    Input: 1\n           5 4\n           1111\n           1001\n           1001\n           1001\n           1111\n    Expected output: 0\n    Explanation: The grid already forms a portal, so no operations are needed.\n\n    Test case with all blocks as obsidian:\n    Input: 1\n           5 4\n           1111\n           1111\n           1111\n           1111\n           1111\n    Expected output: 8\n    Explanation: Transform inner blocks to empty blocks, requiring 8 operations.\n\n    Test case with all blocks as empty:\n    Input: 1\n           5 4\n           0000\n           0000\n           0000\n           0000\n           0000\n    Expected output: 12\n    Explanation: Transform border blocks to obsidian blocks, requiring 12 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires transforming a given grid into a specific pattern with minimal operations. The constraints on grid size and the number of test cases necessitate an efficient algorithm. The solution must handle edge cases where the grid is already close to the desired pattern or requires significant transformation.\nrequirement pool:\n- Develop an algorithm to identify the optimal sub-rectangle for transformation.\n- Implement a function to calculate the minimum operations required for transformation.\n- Optimize the algorithm for large grid sizes.\n- Ensure the solution can handle multiple test cases efficiently.\n- Provide detailed output for each test case.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. The function will keep track of the minimum number of operations needed across all sub-rectangles. This approach ensures that we efficiently find the optimal sub-rectangle for transformation. We will use numpy for efficient grid manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n by m'\n    Explanation: This refers to the grid of blocks with n rows and m columns, where each block can be either an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: The action of converting an obsidian block into an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'at least 5': The number of rows in the portal must be 5 or more.\n    \n    'at least 4': The number of columns in the portal must be 4 or more.\n\n# [degree adverb]\n    'smallest': Refers to finding the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n4. Keep track of the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the correct configuration for a portal.\n    Explanation: The expected output is 0 because no operations are needed.\n\n    Case 2: A grid where no sub-rectangle can be transformed into a portal without changing every block.\n    Explanation: The expected output is the total number of blocks in the smallest possible portal (5x4 = 20).\n\n    Case 3: A grid with exactly one row or column that needs to be changed to form a portal.\n    Explanation: The expected output is the number of blocks in that row or column that need to be changed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Check if any sub-rectangle is already a portal and return 0 immediately if found.\n    - Implement logic to efficiently calculate the number of operations needed for each potential portal configuration.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The key challenge is ensuring the algorithm can quickly identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an algorithm to identify the optimal sub-rectangle for transformation.\n- Ensure the solution is efficient for maximum input sizes.\n- Optimize the algorithm to reduce computational complexity.\n- Implement comprehensive test cases to validate the solution.\n- Provide detailed documentation for the algorithm.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations needed to convert each into a portal. We will use a brute-force method due to the manageable constraints, ensuring that the solution is efficient for the maximum input sizes. The function will handle multiple test cases and output the result for each.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n by m'\n    Explanation: This refers to the grid of blocks with n rows and m columns, where each block can be either an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these minimum dimensions.\n\n    '1 < x < a', '1 < x < b'\n    Explanation: These conditions specify the range of indices for which certain blocks must be obsidian. In code, this involves checking and potentially converting blocks within these index ranges.\n\n# [degree adverb]\n    'smallest number of operations'\n    Explanation: The goal is to minimize the number of conversions needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of operations for each potential sub-rectangle.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the outer edges (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations across all sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already in portal form\n    Explanation: If a sub-rectangle is already a portal, the expected output is 0 operations.\n\n    Case 2: A rectangle with all blocks as obsidian\n    Explanation: The expected output would be the number of operations needed to convert the inner blocks to empty while maintaining the portal structure.\n\n    Case 3: A rectangle with all blocks as empty\n    Explanation: The expected output would be the number of operations needed to convert the necessary blocks to obsidian to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the required operations will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 108, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 94}
