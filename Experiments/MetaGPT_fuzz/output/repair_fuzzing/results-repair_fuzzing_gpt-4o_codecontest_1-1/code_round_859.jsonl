{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to assist his distant relative Indiana Jones in discovering a hidden treasure in a maze situated beneath a desert filled with illusions. The maze's layout resembles a tree with n chambers labeled from 1 to n, and n - 1 passageways connecting them, allowing travel between every pair of rooms via various passageways. Each of the rooms, represented by i (1 \u2264 i \u2264 n), possesses a_i illusion rate, and moving from room x to room y requires an existing passage between x and y, consuming max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter tomb raiders, the maze can alter the illusion rate of any given room. Chanek and Indiana will pose q queries. There are two types of queries to address: * 1\\ u\\ c \u2014 Alter the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana seek the least energy sum necessary to retrieve the hidden treasure in room v if starting from room u (1 \u2264 u, v \u2264 n). Assist them to earn a share of the treasure! Your objective is to create a program that effectively processes each query.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to assist his distant relative Indiana Jones in discovering a hidden treasure in a maze situated beneath a desert filled with illusions. The maze's layout resembles a tree with n chambers labeled from 1 to n, and n - 1 passageways connecting them, allowing travel between every pair of rooms via various passageways. Each of the rooms, represented by i (1 \u2264 i \u2264 n), possesses a_i illusion rate, and moving from room x to room y requires an existing passage between x and y, consuming max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter tomb raiders, the maze can alter the illusion rate of any given room. Chanek and Indiana will pose q queries. There are two types of queries to address: * 1\\ u\\ c \u2014 Alter the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana seek the least energy sum necessary to retrieve the hidden treasure in room v if starting from room u (1 \u2264 u, v \u2264 n). Assist them to earn a share of the treasure! Your objective is to create a program that effectively processes each query.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his distant relative Indiana Jones in discovering a hidden treasure in a maze situated beneath a desert filled with illusions. The maze's layout resembles a tree with n chambers labeled from 1 to n. There are n - 1 passageways connecting them, allowing travel between every pair of rooms via various passageways. Each of the rooms, represented by i (1 \u2264 i \u2264 n), possesses a_i illusion rate, and moving from room x to room y requires an existing passage between x and y, consuming max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter tomb raiders, the maze can alter the illusion rate of any given room. Chanek and Indiana will pose q queries. There are two types of queries to address: * 1\\ u\\ c \u2014 Alter the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana seek the least energy sum necessary to retrieve the hidden treasure in room v if starting from room u (1 \u2264 u, v \u2264 n). Assist them to earn a share of the treasure! Your objective is to create a program that effectively processes each query.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his distant relative Indiana Jones in discovering a hidden treasure in a maze situated beneath a desert filled with illusions. The maze's layout resembles a tree with n chambers labeled from 1 to n, and n - 1 passageways connecting them, allowing travel between every pair of rooms via various passageways, with each room i (1 \u2264 i \u2264 n) possessing a_i illusion rate and moving from room x to room y requiring an existing passage between x and y, consuming max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter tomb raiders, the maze can alter the illusion rate of any given room. Chanek and Indiana will pose q queries. There are two types of queries to address: * 1\\ u\\ c \u2014 Alter the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana seek the least energy sum necessary to retrieve the hidden treasure in room v if starting from room u (1 \u2264 u, v \u2264 n). Assist them to earn a share of the treasure! Your objective is to create a program that effectively processes each query.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    \"\"\"Class to represent the tree structure and handle LCA and path queries.\"\"\"\n    \n    def __init__(self, n: int, illusion_rates: List[int], connections: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [[-1] * (n + 1) for _ in range(20)]  # For LCA\n        self.build_tree(connections)\n        self.preprocess_lca()\n\n    def build_tree(self, connections: List[Tuple[int, int]]):\n        \"\"\"Builds the adjacency list for the tree.\"\"\"\n        for u, v in connections:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n\n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Performs DFS to set up parent and depth arrays.\"\"\"\n        self.parent[0][node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def preprocess_lca(self):\n        \"\"\"Preprocesses the tree for LCA queries using binary lifting.\"\"\"\n        self.dfs(1, -1, 0)  # Assuming 1 is the root\n        for i in range(1, 20):\n            for node in range(1, self.n + 1):\n                if self.parent[i - 1][node] != -1:\n                    self.parent[i][node] = self.parent[i - 1][self.parent[i - 1][node]]\n\n    def lca(self, u: int, v: int) -> int:\n        \"\"\"Finds the Least Common Ancestor of nodes u and v.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.parent[i][u]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.parent[i][u] != self.parent[i][v]:\n                u = self.parent[i][u]\n                v = self.parent[i][v]\n        return self.parent[0][u]\n\n    def path_energy(self, u: int, v: int) -> int:\n        \"\"\"Calculates the minimum energy required to travel from u to v.\"\"\"\n        ancestor = self.lca(u, v)\n        return self.calculate_energy(u, ancestor) + self.calculate_energy(v, ancestor)\n\n    def calculate_energy(self, u: int, ancestor: int) -> int:\n        \"\"\"Calculates the energy from node u to the ancestor.\"\"\"\n        energy = 0\n        while u != ancestor:\n            par = self.parent[0][u]\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[par - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[par - 1]))\n            u = par\n        return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], connections: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Processes the queries and returns the results for type 2 queries.\"\"\"\n    tree = Tree(n, illusion_rates, connections)\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1], query[2]\n            tree.illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Path query\n            u, v = query[1], query[2]\n            results.append(tree.path_energy(u, v))\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nconnections = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process and output results\nresults = process_queries(n, q, illusion_rates, connections, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Process the queries to calculate the minimum energy required for type 2 queries and update illusion rates for type 1 queries.\n\n    Args:\n        n (int): Number of rooms.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        edges (List[Tuple[int, int]]): List of edges representing the tree structure.\n        queries (List[Tuple[int, int, int]]): List of queries to process.\n\n    Returns:\n        List[int]: Results for type 2 queries.\n    \"\"\"\n    # Initialize adjacency list for the tree\n    tree = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    # Preprocess the tree using DFS to find parent and depth of each node\n    parent = [-1] * (n + 1)\n    depth = [0] * (n + 1)\n    def dfs(node: int, par: int, dep: int):\n        parent[node] = par\n        depth[node] = dep\n        for neighbor in tree[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n\n    # Start DFS from node 1 (assuming 1 is the root)\n    dfs(1, -1, 0)\n\n    # Function to find LCA of two nodes\n    def find_lca(u: int, v: int) -> int:\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n\n    # Function to calculate energy between two rooms\n    def calculate_energy(a_x: int, a_y: int) -> int:\n        return max(abs(a_x + a_y), abs(a_x - a_y))\n\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Type 1 query: Update illusion rate\n            u, c = query[1], query[2]\n            illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Type 2 query: Calculate minimum energy path\n            u, v = query[1], query[2]\n            lca = find_lca(u, v)\n            energy_sum = 0\n            # Calculate energy from u to lca\n            current = u\n            while current != lca:\n                energy_sum += calculate_energy(illusion_rates[current - 1], illusion_rates[parent[current] - 1])\n                current = parent[current]\n            # Calculate energy from v to lca\n            current = v\n            while current != lca:\n                energy_sum += calculate_energy(illusion_rates[current - 1], illusion_rates[parent[current] - 1])\n                current = parent[current]\n            results.append(energy_sum)\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, edges, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\nimport sys\n\nsys.setrecursionlimit(200000)\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    def dfs(node: int, parent: int, depth: int):\n        \"\"\"Perform DFS to compute parent and depth information.\"\"\"\n        depths[node] = depth\n        parents[node][0] = parent\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, depth + 1)\n\n    def preprocess_lca():\n        \"\"\"Preprocess to fill the parents table for LCA.\"\"\"\n        dfs(0, -1, 0)\n        for j in range(1, LOG):\n            for i in range(n):\n                if parents[i][j - 1] != -1:\n                    parents[i][j] = parents[parents[i][j - 1]][j - 1]\n\n    def lca(u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor of nodes u and v.\"\"\"\n        if depths[u] < depths[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        diff = depths[u] - depths[v]\n        for i in range(LOG):\n            if (diff >> i) & 1:\n                u = parents[u][i]\n        if u == v:\n            return u\n        for i in range(LOG - 1, -1, -1):\n            if parents[u][i] != parents[v][i]:\n                u = parents[u][i]\n                v = parents[v][i]\n        return parents[u][0]\n\n    def calculate_energy(u: int, v: int) -> int:\n        \"\"\"Calculate the energy cost between two nodes.\"\"\"\n        lca_node = lca(u, v)\n        path = []\n        # Collect path from u to LCA\n        while u != lca_node:\n            path.append(u)\n            u = parents[u][0]\n        # Collect path from v to LCA\n        path_v = []\n        while v != lca_node:\n            path_v.append(v)\n            v = parents[v][0]\n        path_v.reverse()\n        path.extend(path_v)\n        path.append(lca_node)\n        \n        # Calculate energy cost along the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            total_energy += max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n        return total_energy\n\n    # Initialize data structures\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n\n    LOG = 17  # log2(100000) is approximately 17\n    parents = [[-1] * LOG for _ in range(n)]\n    depths = [-1] * n\n\n    # Preprocess LCA\n    preprocess_lca()\n\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1] - 1, query[2]\n            illusion_rates[u] = c\n        elif query[0] == 2:\n            # Energy calculation query\n            u, v = query[1] - 1, query[2] - 1\n            if u == v:\n                results.append(0)\n            else:\n                results.append(calculate_energy(u, v))\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results for type 2 queries\nresults = process_queries(n, q, illusion_rates, edges, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_info: List[int], depth_info: List[int]) -> None:\n    \"\"\"Perform Depth First Search to precompute parent and depth information.\"\"\"\n    parent_info[node] = parent\n    depth_info[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_info, depth_info)\n\ndef lca(u: int, v: int, parent_info: List[int], depth_info: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth_info[u] < depth_info[v]:\n        u, v = v, u\n    while depth_info[u] > depth_info[v]:\n        u = parent_info[u]\n    while u != v:\n        u = parent_info[u]\n        v = parent_info[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_info: List[int], depth_info: List[int]) -> int:\n    \"\"\"Calculate the energy required to move from room u to room v.\"\"\"\n    ancestor = lca(u, v, parent_info, depth_info)\n    energy = 0\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent_info[u] - 1]),\n                      abs(illusion_rates[u - 1] - illusion_rates[parent_info[u] - 1]))\n        u = parent_info[u]\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v - 1] + illusion_rates[parent_info[v] - 1]),\n                      abs(illusion_rates[v - 1] - illusion_rates[parent_info[v] - 1]))\n        v = parent_info[v]\n    return energy\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(tree) - 1\n    parent_info = [-1] * (n + 1)\n    depth_info = [-1] * (n + 1)\n    dfs(1, -1, 0, tree, parent_info, depth_info)\n    return calculate_energy(u, v, illusion_rates, parent_info, depth_info)\n\ndef main():\n    \"\"\"Main function to process input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == 2:\n            _, u, v = query\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of the specified room.\n\n    Args:\n        illusion_rates: A list of current illusion rates for each room.\n        u: The index of the room to update (1-based index).\n        c: The new illusion rate for the room.\n    \"\"\"\n    # Update the illusion rate for the room at index u-1 (0-based index)\n    illusion_rates[u - 1] = c\n\ndef calculate_min_energy(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int], u: int, v: int) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        n: The number of rooms.\n        edges: A list of tuples representing the connections between rooms.\n        illusion_rates: A list of current illusion rates for each room.\n        u: The starting room (1-based index).\n        v: The destination room (1-based index).\n\n    Returns:\n        The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Build adjacency list for the tree\n    from collections import defaultdict, deque\n\n    adj_list = defaultdict(list)\n    for s, t in edges:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n\n    # Precompute parent and depth arrays using DFS\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n\n    def dfs(node: int, par: int, dep: int):\n        parent[node] = par\n        depth[node] = dep\n        for neighbor in adj_list[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n\n    # Start DFS from node 1 (assuming 1 is always part of the tree)\n    dfs(1, -1, 0)\n\n    # Function to find LCA of two nodes\n    def find_lca(x: int, y: int) -> int:\n        # Bring both nodes to the same depth\n        while depth[x] > depth[y]:\n            x = parent[x]\n        while depth[y] > depth[x]:\n            y = parent[y]\n        # Move both nodes up until they meet\n        while x != y:\n            x = parent[x]\n            y = parent[y]\n        return x\n\n    # Find LCA of u and v\n    lca = find_lca(u, v)\n\n    # Calculate the energy cost from u to v via LCA\n    def calculate_energy_path(x: int, y: int) -> int:\n        energy = 0\n        while x != y:\n            energy += max(abs(illusion_rates[x - 1] + illusion_rates[parent[x] - 1]),\n                          abs(illusion_rates[x - 1] - illusion_rates[parent[x] - 1]))\n            x = parent[x]\n        return energy\n\n    # Calculate energy from u to LCA and from v to LCA\n    energy_u_to_lca = calculate_energy_path(u, lca)\n    energy_v_to_lca = calculate_energy_path(v, lca)\n\n    # Total energy is the sum of both paths\n    total_energy = energy_u_to_lca + energy_v_to_lca\n    return total_energy\n\n# Input and output interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    edges = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        edges.append((s, t))\n        index += 2\n\n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index + 3])\n        index += 3\n\n    for query in queries:\n        if query[0] == '1':\n            u = int(query[1])\n            c = int(query[2])\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(n, edges, illusion_rates, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient range updates and queries.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        \"\"\"Initialize the Segment Tree with the given data.\"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the Segment Tree from the given data.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Update the value at position `pos` to `value`.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(node: int, parent: int, depth: int, adj: List[List[int]], parent_list: List[int], depth_list: List[int]):\n    \"\"\"Perform DFS to compute parent and depth information.\"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, adj, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of nodes u and v.\"\"\"\n    if depth_list[u] < depth_list[v]:\n        u, v = v, u\n    # Bring u and v to the same depth\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Calculate the energy required to move from room u to room v.\"\"\"\n    ancestor = lca(u, v, parent_list, depth_list)\n    energy = 0\n    # Calculate energy from u to ancestor\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u] + illusion_rates[parent_list[u]]), abs(illusion_rates[u] - illusion_rates[parent_list[u]]))\n        u = parent_list[u]\n    # Calculate energy from v to ancestor\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v] + illusion_rates[parent_list[v]]), abs(illusion_rates[v] - illusion_rates[parent_list[v]]))\n        v = parent_list[v]\n    return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], connections: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Process the queries and return the results for type 2 queries.\"\"\"\n    # Adjust indices to be 0-based\n    adj = [[] for _ in range(n)]\n    for s, t in connections:\n        adj[s - 1].append(t - 1)\n        adj[t - 1].append(s - 1)\n    \n    parent_list = [-1] * n\n    depth_list = [0] * n\n    dfs(0, -1, 0, adj, parent_list, depth_list)\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1] - 1, query[2]\n            segment_tree.update(u, c)\n            illusion_rates[u] = c\n        elif query[0] == 2:\n            # Energy calculation query\n            u, v = query[1] - 1, query[2] - 1\n            energy = calculate_energy(u, v, illusion_rates, parent_list, depth_list)\n            results.append(energy)\n    \n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nconnections = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, connections, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room_index: The index of the room to update (1-based index).\n        new_rate: The new illusion rate to set for the room.\n        illusion_rates: The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room_index - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: Dict[int, List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\n\n    Args:\n        u: The starting room index (1-based index).\n        v: The destination room index (1-based index).\n        illusion_rates: The list of current illusion rates for all rooms.\n        tree: The adjacency list representing the tree structure of rooms.\n\n    Returns:\n        The minimum energy required to move from room u to room v.\n    \"\"\"\n    def dfs(current: int, target: int, visited: set, path: List[int]) -> bool:\n        \"\"\"Depth First Search to find a path from current to target.\n\n        Args:\n            current: The current room index.\n            target: The target room index.\n            visited: A set of visited rooms to avoid cycles.\n            path: The current path being explored.\n\n        Returns:\n            True if a path is found, False otherwise.\n        \"\"\"\n        if current == target:\n            return True\n        visited.add(current)\n        for neighbor in tree[current]:\n            if neighbor not in visited:\n                path.append(neighbor)\n                if dfs(neighbor, target, visited, path):\n                    return True\n                path.pop()\n        return False\n\n    # Find the path from u to v using DFS\n    path = [u]\n    visited = set()\n    dfs(u, v, visited, path)\n\n    # Calculate the total energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = {i: [] for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        s_i = int(data[index])\n        t_i = int(data[index + 1])\n        index += 2\n        tree[s_i].append(t_i)\n        tree[t_i].append(s_i)\n\n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index + 3])\n        index += 3\n\n    for query in queries:\n        if query[0] == '1':\n            u = int(query[1])\n            c = int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy_path(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    def dfs(current: int, target: int, visited: List[bool], path_energy: int) -> int:\n        if current == target:\n            return path_energy\n        visited[current] = True\n        min_energy = float('inf')\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                energy = max(abs(illusion_rates[current - 1] + illusion_rates[neighbor - 1]),\n                             abs(illusion_rates[current - 1] - illusion_rates[neighbor - 1]))\n                min_energy = min(min_energy, dfs(neighbor, target, visited, path_energy + energy))\n        visited[current] = False\n        return min_energy\n\n    visited = [False] * (len(tree))\n    return dfs(u, v, visited, 0)\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    queries = [input().split() for _ in range(q)]\n\n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy_path(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    \"\"\"Calculate the energy required to move between two rooms.\"\"\"\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: int, parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Perform DFS to populate parent and depth information.\"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(tree, neighbor, node, depth + 1, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while depth_list[v] > depth_list[u]:\n        v = parent_list[v]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    \n    # Perform DFS from node 1 (assuming 1-based index)\n    dfs(tree, 1, -1, 0, parent_list, depth_list)\n    \n    # Find LCA of u and v\n    ancestor = lca(u, v, parent_list, depth_list)\n    \n    # Calculate energy from u to ancestor and ancestor to v\n    energy = 0\n    current = u\n    while current != ancestor:\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent_list[current] - 1])\n        current = parent_list[current]\n    \n    current = v\n    while current != ancestor:\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent_list[current] - 1])\n        current = parent_list[current]\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and process queries.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    Process the queries to update illusion rates and calculate the minimum energy cost between rooms.\n\n    Args:\n        n (int): Number of rooms.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        edges (List[Tuple[int, int]]): List of edges representing the tree structure.\n        queries (List[Tuple[int, int, int]]): List of queries to process.\n\n    Returns:\n        List[int]: Results of type 2 queries, representing the minimum energy cost.\n    \"\"\"\n    from collections import defaultdict, deque\n\n    # Helper function to perform DFS and preprocess for LCA\n    def dfs(node: int, parent: int, depth: int):\n        parent_list[node] = parent\n        depth_list[node] = depth\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, depth + 1)\n\n    # Helper function to find LCA of two nodes\n    def find_lca(u: int, v: int) -> int:\n        if depth_list[u] < depth_list[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while depth_list[u] > depth_list[v]:\n            u = parent_list[u]\n        while u != v:\n            u = parent_list[u]\n            v = parent_list[v]\n        return u\n\n    # Helper function to calculate energy cost between two nodes\n    def calculate_energy(u: int, v: int) -> int:\n        lca = find_lca(u, v)\n        path = []\n        # Collect path from u to LCA\n        while u != lca:\n            path.append(u)\n            u = parent_list[u]\n        # Collect path from v to LCA\n        path_v = []\n        while v != lca:\n            path_v.append(v)\n            v = parent_list[v]\n        path_v.reverse()\n        path.extend(path_v)\n        path.append(lca)\n\n        # Calculate total energy cost along the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            total_energy += max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n        return total_energy\n\n    # Initialize tree and other data structures\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n\n    parent_list = [-1] * n\n    depth_list = [-1] * n\n\n    # Preprocess the tree for LCA\n    dfs(0, -1, 0)\n\n    results = []\n\n    # Process each query\n    for query in queries:\n        if query[0] == 1:\n            # Update illusion rate\n            u, c = query[1] - 1, query[2]\n            illusion_rates[u] = c\n        elif query[0] == 2:\n            # Calculate minimum energy cost\n            u, v = query[1] - 1, query[2] - 1\n            energy_cost = calculate_energy(u, v)\n            results.append(energy_cost)\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, edges, queries)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations for treasure retrieval. The tree structure of the maze allows for efficient traversal and query processing using algorithms like DFS or BFS.\nrequirement pool:\n- Implement efficient query processing for type 1 and type 2 queries.\n- Ensure scalability to handle maximum input sizes.\n- Optimize energy calculation for treasure retrieval.\n- Provide clear and accurate output for each query.\n- Develop a user-friendly interface for input and output handling.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the Least Common Ancestor (LCA) for efficient path queries. We will also use a Segment Tree to handle updates and queries efficiently. This approach ensures that we can handle up to 100,000 rooms and queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, which means there is exactly one path between any two nodes.\n    'illusion rate': A value associated with each room that affects the energy cost of moving between rooms.\n    'energy cost': The energy required to move between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute sum and the absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'least': Refers to finding the minimum energy sum required for a path. This can be implemented using algorithms that find the shortest path or minimum cost path, such as Dijkstra's algorithm or BFS/DFS with appropriate modifications.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Use DFS to preprocess the tree and calculate necessary data for LCA (Least Common Ancestor) queries.\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, calculate the minimum energy required to travel from room u to room v using preprocessed LCA data and current illusion rates.\n\n# [edge case]\n    1. Single path tree (e.g., a straight line of rooms): The expected output should correctly calculate energy along this simple path.\n    2. All rooms have zero illusion rate: The expected output should be zero energy for any path since max(|0 + 0|, |0 - 0|) = 0.\n    3. Maximum possible illusion rate changes: Ensure that updates handle large values correctly without overflow.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to large values and ensure efficient updates.\n    - Implement checks for integer overflow if necessary (though Python handles large integers natively).\n    - Ensure that the Segment Tree or data structure used for updates can handle maximum constraints efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to altering room illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must handle large input sizes and ensure accurate energy calculations based on the given formula.\nrequirement pool:\n- Implement efficient query processing for altering illusion rates.\n- Develop a method to calculate minimum energy paths accurately.\n- Optimize the solution to handle large input sizes without performance degradation.\n- Ensure the solution is robust and handles edge cases effectively.\n- Provide clear documentation and user instructions.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the minimum energy path between two nodes. We will use adjacency lists to represent the tree and segment trees to handle updates and queries efficiently. This approach ensures that we can handle the large input sizes and number of queries within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy cost when moving between rooms. It can be altered by queries, impacting the energy calculation.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n chambers and n-1 passageways, allowing travel between rooms without cycles.\n\n    'energy consumption'\n    Explanation: The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy consumption is determined by the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the max function and abs function in Python.\n\n# [degree adverb]\n    'least': This indicates that for type 2 queries, we need to find the minimum sum of energy required to move from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest value.\n\n# [code logic]\n    1. Parse the input to extract the number of rooms, queries, initial illusion rates, and passageways.\n    2. Construct an adjacency list to represent the tree structure of the maze.\n    3. Preprocess the tree using Depth First Search (DFS) to prepare for efficient query handling.\n    4. Implement a segment tree or similar data structure to handle updates to illusion rates and efficiently process type 2 queries.\n    5. For type 1 queries, update the illusion rate of the specified room.\n    6. For type 2 queries, use Lowest Common Ancestor (LCA) to find the path between two rooms and calculate the minimum energy required.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 -10\n    Expected Output: 20\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = max(0, 20) = 20 energy.\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 3 -5\n           2 1 4\n    Expected Output: 15\n    Explanation: Moving from room 1 to room 4 initially requires max(|-5 + (-5)|, |-5 - (-5)|) = max(10, 0) = 10 energy for each segment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will efficiently handle these scenarios by calculating paths and updating rates as needed.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to illusion rate changes and energy calculations in a maze structured as a tree. The solution must handle large input sizes and provide accurate results quickly.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Accurate alteration of room illusion rates\n- User-friendly interface for input and output\n- Scalability to handle large mazes and query numbers\n- Detailed documentation of energy calculation process\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently calculate the minimum energy path in the tree structure. The DFS will help in precomputing necessary data for LCA, and the LCA will allow us to quickly determine the path between any two nodes. We will use adjacency lists to represent the tree and segment trees to handle updates and queries efficiently. Libraries like 'collections' for data structures and 'sys' for fast input/output will be utilized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, where any two nodes are connected by exactly one path.\n    'illusion rate': A value associated with each room that affects the energy cost of moving between rooms.\n    'energy cost': The energy required to move between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy cost is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented as `max(abs(a[x] + a[y]), abs(a[x] - a[y]))`.\n\n# [degree adverb]\n    'least': Refers to finding the minimum energy sum required to travel from one room to another. This can be implemented using algorithms that efficiently find the shortest path, such as DFS combined with LCA.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Use DFS to precompute data necessary for LCA, such as parent and depth information for each node.\n3. Implement a segment tree or similar data structure to handle updates to the illusion rates efficiently.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, use LCA to find the path between the two rooms and calculate the total energy cost using the precomputed data and current illusion rates.\n\n# [edge case]\n    1. Query with u = v (e.g., 2 1 1) = 0\n       Explanation: If starting and ending rooms are the same, no movement is needed, so the energy cost is 0.\n    2. All rooms have the same illusion rate (e.g., all a_i = 0) = 0 for any query\n       Explanation: If all illusion rates are zero, the energy cost between any two rooms is zero.\n    3. Maximum possible illusion rate change (e.g., change a room's rate from -10^9 to 10^9) = Correctly handle large updates\n       Explanation: Ensure that the code handles large values without overflow or performance issues.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For queries where u = v, directly return 0 without further calculations.\n    - Ensure that updates to illusion rates are handled efficiently, possibly using lazy propagation in segment trees to manage large updates.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze. The main challenge is to handle large input sizes and ensure quick updates and calculations of energy consumption. The solution must be optimized for performance and accuracy.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Accurately calculate the minimum energy required for type 2 queries.\n- Optimize the program to handle up to 100,000 queries efficiently.\n- Ensure the solution is scalable for large mazes with up to 100,000 rooms.\n- Provide a user-friendly interface for input and output operations.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the type 2 queries. For type 1 queries, we will simply update the illusion rate in an array. The DFS will help in precomputing necessary data for LCA, and LCA will allow us to quickly find the path between any two nodes in the tree. We will use adjacency lists to represent the tree and segment trees to handle range queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be altered by type 1 queries.\n\n    'energy consumption'\n    Explanation: The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there is exactly one path between any two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy consumption is determined by the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function with `abs` for absolute values.\n\n# [degree adverb]\n    'least energy sum'\n    Explanation: This indicates that for type 2 queries, we need to find the minimum energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to retrieve the number of rooms, queries, initial illusion rates, and connections between rooms.\n2. Construct an adjacency list to represent the tree structure of the maze.\n3. Implement DFS to precompute necessary data for LCA, such as parent and depth information for each node.\n4. Use LCA to efficiently find paths between any two nodes for type 2 queries.\n5. For type 1 queries, update the illusion rate in the array.\n6. For type 2 queries, calculate the energy required for the path using the formula max(|a_x + a_y|, |a_x - a_y|) and output the result.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 0\n           2 1 3\n    Output: 20\n            20\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = 20 energy. After updating room 2's illusion rate to 0, moving from room 1 to room 3 still requires max(|10 + 0|, |10 - 0|) = 20 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle all cases efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze. The main challenge is to handle large input sizes and ensure quick updates and calculations. The program must be robust and scalable, providing accurate results for both types of queries: updating room illusion rates and calculating minimum energy paths.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Optimize the program to handle up to 100,000 queries efficiently.\n- Ensure the program is robust against edge cases.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the type 2 queries for calculating the minimum energy path in the tree structure. For type 1 queries, we will simply update the illusion rate of the specified room. The DFS will help in precomputing necessary information for LCA, and LCA will allow us to quickly find the path between any two nodes in the tree. This approach ensures that both types of queries are handled efficiently, even for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, where any two nodes are connected by exactly one path.\n    'illusion rate': A value associated with each room that affects the energy cost of moving between rooms.\n    'energy cost': The energy required to move between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy cost is determined by the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'least': Refers to finding the minimum energy sum required to travel from one room to another. This can be implemented using algorithms that efficiently find the shortest path, such as DFS combined with LCA.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Precompute necessary information for LCA using DFS, such as parent and depth arrays.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, use LCA to find the path between the two specified rooms and calculate the total energy cost using the given formula.\n6. Output the result for each type 2 query.\n\n# [edge case]\n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: The energy cost between two rooms with zero illusion rates is zero.\n\n    2. Input: 3 1\n             1000000000 -1000000000 0\n             1 2\n             2 3\n             2 1 3\n       Output: 2000000000\n       Explanation: The maximum possible energy cost between two rooms with extreme illusion rates.\n\n    3. Input: 4 1\n             5 -5 5 -5\n             1 2\n             2 3\n             3 4\n             2 1 4\n       Output: 20\n       Explanation: The path from room 1 to room 4 involves alternating illusion rates, resulting in a consistent energy cost.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle these cases correctly by calculating the energy cost based on the given formula for any valid input.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations for treasure retrieval. The tree structure of the maze allows for optimized traversal algorithms.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Scalable solution for large input sizes\n- Accurate updates to room illusion rates\n- User-friendly interface for input and output\n- Detailed documentation for user guidance\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in precomputing necessary data for quick LCA queries, which will be used to determine the path between any two rooms. This approach ensures that we can handle up to 100,000 rooms and queries efficiently. We will also use a Segment Tree to manage updates to the illusion rates, allowing for quick updates and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy cost when moving between rooms. It can be altered by queries.\n\n    'energy consumption'\n    Explanation: The energy required to move between rooms is determined by the maximum of the absolute sum or difference of the illusion rates of the two rooms.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there is exactly one path between any two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or difference of their illusion rates. In code, this can be implemented using the `max` function with `abs` for absolute values.\n\n# [degree adverb]\n    'least'\n    Explanation: In the context of finding the least energy sum, it means calculating the minimum energy required to travel from one room to another. This can be implemented by finding the path with the minimum energy cost using precomputed data structures like LCA.\n\n# [code logic]\n    1. Parse input to get the number of rooms, queries, initial illusion rates, and connections between rooms.\n    2. Construct the tree using adjacency lists based on room connections.\n    3. Use DFS to precompute data for LCA queries, such as parent and depth information.\n    4. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    5. For type 1 queries, update the illusion rate using the Segment Tree.\n    6. For type 2 queries, use LCA to find the path between rooms and calculate the energy cost using precomputed data and current illusion rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 -5\n           2 1 3\n    Output: 20, 25\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = max(0, 20) = 20 energy. After updating room 2's illusion rate to -5, moving from room 1 to room 3 requires max(|10 + (-5)|, |10 - (-5)|) = max(5, 15) = 15 energy from room 1 to room 2 and max(|-5 + 10|, |-5 - 10|) = max(5, 15) = 15 energy from room 2 to room 3, totaling 25 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will correctly compute paths and energy costs even for edge cases.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze. The main challenge is to handle large input sizes and ensure that the energy calculations are accurate and fast. The ability to update room properties dynamically is crucial for adapting to changes in the maze.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Dynamic update of room illusion rates\n- Scalability to handle large mazes and query sets\n- User-friendly interface for input and output\n- Visual representation of the maze structure\nWe will use Depth First Search (DFS) to efficiently calculate the minimum energy path in the tree structure. For dynamic updates of room illusion rates, we will maintain an array to store the current illusion rates and update it as needed. The DFS will be used to traverse the tree and calculate the energy required for each path. This approach is efficient for tree structures and will handle large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes.\n    'illusion rate': This is a property of each room that affects the energy cost of moving between rooms.\n    'energy consumption': The energy required to move between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required to move between two rooms is the maximum of the absolute sum or difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'least': This refers to finding the minimum energy sum necessary for a path. In code, this can be implemented by keeping track of the minimum energy encountered during traversal.\n\n# [code logic]\n1. Parse the input to get the number of rooms `n`, number of queries `q`, initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the room connections.\n3. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, use DFS to find the path from room `u` to room `v` and calculate the total energy required using the given formula.\n4. Output the result for each type 2 query.\n\n# [edge case]\n    1. Minimum number of rooms (n=2) with maximum illusion rates:\n       Input: \n       ```\n       2 1\n       1000000000 -1000000000\n       1 2\n       2 1 2\n       ```\n       Expected Output: \n       ```\n       2000000000\n       ```\n       Explanation: The energy required is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    2. All rooms have zero illusion rate:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       0\n       ```\n       Explanation: The energy required is max(|0 + 0|, |0 - 0|) = 0 for each step.\n\n    3. Single query with no movement (u = v):\n       Input:\n       ```\n       3 1\n       5 -5 10\n       1 2\n       2 3\n       2 1 1\n       ```\n       Expected Output:\n       ```\n       0\n       ```\n       Explanation: No movement is needed if starting and ending rooms are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and updating illusion rates will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on efficiently processing two types of queries: updating the illusion rate of a room and calculating the minimum energy path between two rooms. The solution must handle large input sizes and provide quick responses to ensure a smooth user experience.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy paths.\n- Ensure the solution is scalable to handle the maximum input sizes.\n- Provide clear and accurate output for each query.\n- Optimize the solution for performance improvements.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate paths, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures scalability and quick response times for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': The maze is structured as a tree, meaning there are n chambers and n-1 passageways, forming a connected graph without cycles.\n    'illusion rate': Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n    'energy consumption': The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy consumption is determined by the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'least': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to retrieve the treasure from room v starting from room u.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and passageways.\n    2. Construct the tree using adjacency lists based on the passageways.\n    3. Implement DFS to traverse the tree and calculate paths for type 2 queries.\n    4. Use a Segment Tree to efficiently update illusion rates for type 1 queries and query current rates for type 2 queries.\n    5. For each type 2 query, calculate the minimum energy required using DFS and Segment Tree.\n\n# [edge case]\n    Case 1: Input with minimum values\n    Input: \n    ```\n    2 1\n    0 0\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    0\n    ```\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Case 2: All rooms have the same illusion rate\n    Input:\n    ```\n    3 1\n    5 5 5\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    10\n    ```\n    Explanation: Moving from room 1 to room 3 via room 2 requires max(|5 + 5|, |5 - 5|) = 10 energy for each passage.\n\n    Case 3: Negative illusion rates\n    Input:\n    ```\n    3 1\n    -5 -5 -5\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    10\n    ```\n    Explanation: Similar to Case 2, but with negative rates. The energy calculation remains the same due to absolute values.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree will correctly handle them by considering absolute values and maximum calculations.\n", "requirement analysis:\nThe requirements focus on efficiently processing two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move between two rooms. The solution must handle large input sizes and provide accurate results quickly. The tree structure of the maze allows for efficient traversal and query processing using data structures like segment trees or heavy-light decomposition.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy paths.\n- Ensure the solution is scalable to handle maximum input sizes.\n- Provide clear and accurate output for each query.\n- Optimize the solution for performance on large datasets.\nWe will use a combination of Depth First Search (DFS) and Heavy-Light Decomposition (HLD) to efficiently process the queries. DFS will help in traversing the tree structure, while HLD will allow us to handle path queries efficiently by breaking the tree into chains. This approach is suitable for handling large input sizes and ensures quick query processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, consisting of n chambers and n-1 passageways.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost when moving between rooms.\n\n    'energy consumption'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'least': This indicates that for type 2 queries, we need to find the minimum energy sum required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Implement DFS to traverse the tree and prepare for Heavy-Light Decomposition (HLD).\n4. Use HLD to decompose the tree into chains for efficient path queries.\n5. For type 1 queries, update the illusion rate of a specified room.\n6. For type 2 queries, calculate the minimum energy required to travel from room u to room v using the decomposed chains.\n7. Output the result for each type 2 query.\n\n# [edge case]\n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: With both rooms having an illusion rate of 0, moving between them requires 0 energy.\n\n    2. Input: 3 1\n             1000000000 -1000000000 0\n             1 2\n             2 3\n             2 1 3\n       Output: 2000000000\n       Explanation: The path from room 1 to room 3 involves moving through room 2, with maximum energy consumption due to extreme illusion rates.\n\n    3. Input: 4 2\n             -5 -5 -5 -5\n             1 2\n             2 3\n             3 4\n             1 1 -10\n             2 1 4\n       Output: 15\n       Explanation: After updating room 1's illusion rate, calculate the energy from room 1 to room 4.\n\n# [extra code for edge case]\n    We need extra code to handle updates in type 1 queries efficiently and ensure that type 2 queries reflect these updates accurately.\n    \n```python\ndef update_illusion_rate(room, new_rate):\n    # Update the illusion rate of a specific room\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(u, v):\n    # Calculate minimum energy from room u to v using HLD\n    # Implement logic to traverse chains and calculate energy\n    pass\n\n# Main logic to handle input and process queries\ndef main():\n    # Parse input and initialize data structures\n    # Implement DFS and HLD setup\n    for query in queries:\n        if query.type == 1:\n            update_illusion_rate(query.room, query.new_rate)\n        elif query.type == 2:\n            print(calculate_energy(query.u, query.v))\n```\n\n", "requirement analysis:\nThe requirements focus on efficiently processing a large number of queries related to a tree-structured maze. The key challenges include handling updates to room properties and calculating the minimum energy required for traversal. The solution must be optimized for performance given the constraints on input size and query volume.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Ability to update room illusion rates dynamically\n- Scalability to handle large input sizes and query volumes\n- Robustness against invalid inputs and edge cases\n- User-friendly output format for energy calculations\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in setting up the tree structure and precomputing necessary data for LCA, which will allow us to quickly find the path between any two nodes. For updating the illusion rates, we will directly modify the array storing these rates. This approach ensures that both types of queries can be processed in logarithmic time relative to the number of rooms, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, where any two nodes are connected by exactly one path.\n    'illusion rate': A value associated with each room that affects the energy cost of moving between rooms.\n    'energy cost': The energy required to move between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy cost is determined by the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented as `max(abs(a[x] + a[y]), abs(a[x] - a[y]))`.\n\n# [degree adverb]\n    'least': Refers to finding the minimum energy sum required to travel from one room to another. This can be implemented using algorithms that find the shortest path or minimum cost path, such as Dijkstra's algorithm or BFS in a tree.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Use DFS to preprocess the tree for LCA computation, storing necessary data like parent and depth for each node.\n3. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, use LCA to find the path between the two rooms and calculate the total energy cost using the precomputed data and current illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms (n=2) with maximum illusion rates:\n       Input: \n       ```\n       2 1\n       1000000000 -1000000000\n       1 2\n       2 1 2\n       ```\n       Expected Output: \n       ```\n       2000000000\n       ```\n       Explanation: The energy cost is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    2. All rooms have zero illusion rate:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       0\n       ```\n       Explanation: All energy costs are zero since all illusion rates are zero.\n\n    3. Single query with no change in illusion rates:\n       Input:\n       ```\n       4 1\n       5 -5 10 -10\n       1 2\n       2 3\n       3 4\n       2 1 4\n       ```\n       Expected Output:\n       ```\n       30\n       ```\n       Explanation: The path is 1 -> 2 -> 3 -> 4 with energy costs max(|5 + (-5)|, |5 - (-5)|) = 10, max(|-5 + 10|, |-5 - 10|) = 15, and max(|10 + (-10)|, |10 - (-10)|) = 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle these cases correctly as it computes paths and updates efficiently based on input constraints.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 859, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "rephrase_one", "parent_index": 480}
