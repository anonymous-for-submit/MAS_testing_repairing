{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4. Additionally, for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks that create the boundary.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, and for each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for this sub-rectangle\n                        changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of '0's and '1's.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check top and bottom borders\n    for col in range(start_col + 1, end_col):\n        if grid[start_row][col] != '1':\n            changes += 1\n        if grid[end_row][col] != '1':\n            changes += 1\n\n    # Check left and right borders\n    for row in range(start_row + 1, end_row):\n        if grid[row][start_col] != '1':\n            changes += 1\n        if grid[row][end_col] != '1':\n            changes += 1\n\n    # Check interior\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row][col] != '0':\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = minimal_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Precompute the number of obsidian blocks in each row and column\n        row_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n        col_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                row_obsidian[i][j] = row_obsidian[i][j - 1] + (1 if grid[i - 1][j - 1] == '1' else 0)\n                col_obsidian[i][j] = col_obsidian[i - 1][j] + (1 if grid[i - 1][j - 1] == '1' else 0)\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = 0\n\n                        # Top and bottom borders\n                        changes += b - (row_obsidian[i + 1][j + b] - row_obsidian[i + 1][j])\n                        changes += b - (row_obsidian[i + a][j + b] - row_obsidian[i + a][j])\n\n                        # Left and right borders\n                        changes += a - (col_obsidian[i + a][j + 1] - col_obsidian[i][j + 1])\n                        changes += a - (col_obsidian[i + a][j + b] - col_obsidian[i][j + b])\n\n                        # Inner vacant area\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] == '1':\n                                    changes += 1\n\n                        # Update the minimum changes found\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = minimal_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef minimal_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing:\n        - n (int): Number of rows in the rectangle.\n        - m (int): Number of columns in the rectangle.\n        - grid (list of str): The grid representation of the rectangle.\n\n    Returns:\n    list: A list of integers representing the minimal changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(matrix, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Parameters:\n    matrix (np.ndarray): The grid representation of the rectangle.\n    start_row (int): Starting row index of the sub-rectangle.\n    start_col (int): Starting column index of the sub-rectangle.\n    end_row (int): Ending row index of the sub-rectangle.\n    end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n    int: The number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Ensure the first and last rows have obsidian blocks at all positions except corners\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            changes += 1\n        if matrix[end_row, col] != 1:\n            changes += 1\n\n    # Ensure the first and last columns have obsidian blocks at all positions except corners\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            changes += 1\n        if matrix[row, end_col] != 1:\n            changes += 1\n\n    # Ensure all inner blocks are vacant\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef handle_edge_cases(n: int, m: int) -> float:\n    \"\"\"Check if the grid dimensions are sufficient to form a portal.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n\n    Returns:\n        float: A large number indicating impossibility if dimensions are insufficient.\n    \"\"\"\n    if n < 5 or m < 4:\n        return float('inf')  # Indicate impossibility with a large number\n    return 0\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal changes required to transform sub-rectangles into portals.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and matrices for each test case.\n\n    Returns:\n        list: List of integers representing the minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert matrix to numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n        \n        # Initialize minimum changes to a large number\n        min_changes = handle_edge_cases(n, m)\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Check sub-rectangle of size 5x4\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        # Calculate changes needed to transform current sub-rectangle into a portal\n                        changes = calculate_changes(grid, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n    \n    # Check boundary conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n    \n    # Check internal vacancy\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Call the function and print results\n    results = find_minimal_changes(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimal changes required to transform sub-rectangles into portals.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and matrix of the rectangle.\n\n    Returns:\n        list: Minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_changes = float('inf')\n\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array(matrix)\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Check sub-rectangle of size 5x4\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        # Calculate changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid[i:i+a, j:j+b], a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(sub_grid: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_grid (np.ndarray): The sub-rectangle grid.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the boundary conditions\n    for x in range(1, a - 1):\n        if sub_grid[x, 0] == 0:\n            changes += 1\n        if sub_grid[x, b - 1] == 0:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if sub_grid[0, y] == 0:\n            changes += 1\n        if sub_grid[a - 1, y] == 0:\n            changes += 1\n\n    # Check the interior conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_grid[x, y] == 1:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read the number of test cases\nt = int(input())\n\n# Initialize a list to store test cases\ntest_cases = []\n\n# Read each test case\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print the results\nresults = find_minimal_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef minimal_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimal number of changes required to transform a sub-rectangle into a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing minimal changes for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check the boundary conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the interior for emptiness\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a matrix of blocks.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    def count_changes(matrix: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n        \"\"\"Count the number of changes needed to transform a sub-rectangle into a portal.\n\n        Args:\n            matrix (List[str]): The matrix of blocks.\n            start_row (int): Starting row index of the sub-rectangle.\n            start_col (int): Starting column index of the sub-rectangle.\n            a (int): Number of rows in the sub-rectangle.\n            b (int): Number of columns in the sub-rectangle.\n\n        Returns:\n            int: Number of changes needed.\n        \"\"\"\n        changes = 0\n        # Check top and bottom borders\n        for col in range(start_col, start_col + b):\n            if col != start_col and col != start_col + b - 1:\n                if matrix[start_row][col] != '1':\n                    changes += 1\n                if matrix[start_row + a - 1][col] != '1':\n                    changes += 1\n        # Check left and right borders\n        for row in range(start_row, start_row + a):\n            if row != start_row and row != start_row + a - 1:\n                if matrix[row][start_col] != '1':\n                    changes += 1\n                if matrix[row][start_col + b - 1] != '1':\n                    changes += 1\n        # Check inner blocks\n        for row in range(start_row + 1, start_row + a - 1):\n            for col in range(start_col + 1, start_col + b - 1):\n                if matrix[row][col] != '0':\n                    changes += 1\n        return changes\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        min_changes = float('inf')\n        # Iterate over all possible sub-rectangles of dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        changes = count_changes(test_case, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n        results.append(min_changes)\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append(matrix)\n\n# Output interface\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and grid for each test case.\n\n    Returns:\n        list: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[start_row:start_row + a, start_col:start_col + b]\n                        changes = calculate_changes(sub_rect, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): Sub-rectangle of the grid.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the borders and inner blocks\n    for x in range(a):\n        for y in range(b):\n            if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                # Border conditions\n                if (x > 0 and x < a - 1 and (y == 0 or y == b - 1)) or (y > 0 and y < b - 1 and (x == 0 or x == a - 1)):\n                    if sub_rect[x, y] != 1:\n                        changes += 1\n            else:\n                # Inner conditions\n                if sub_rect[x, y] != 0:\n                    changes += 1\n\n    return changes\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print the results\n    results = find_minimal_changes(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        \n        # Precompute prefix sums for the grid\n        prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                prefix_sum[i][j] = (int(case[i - 1][j - 1]) +\n                                    prefix_sum[i - 1][j] +\n                                    prefix_sum[i][j - 1] -\n                                    prefix_sum[i - 1][j - 1])\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of obsidian blocks in the current sub-rectangle\n                        total_obsidian = (prefix_sum[i + a][j + b] -\n                                          prefix_sum[i][j + b] -\n                                          prefix_sum[i + a][j] +\n                                          prefix_sum[i][j])\n                        \n                        # Calculate the number of changes needed to make this sub-rectangle a portal\n                        border_obsidian = (2 * (a - 2) + 2 * (b - 2))\n                        internal_vacant = (a - 2) * (b - 2)\n                        current_changes = (border_obsidian + internal_vacant - total_obsidian)\n                        \n                        # Update the minimum changes required\n                        min_changes = min(min_changes, current_changes)\n        \n        results.append(min_changes)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n    \n    # Call the function and print results\n    results = minimal_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    def calculate_min_changes(n: int, m: int, grid: List[str]) -> int:\n        # Initialize a large number for comparison\n        min_changes = float('inf')\n        \n        # Precompute the number of obsidian blocks in each row and column\n        row_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n        col_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                row_obsidian[i][j] = row_obsidian[i][j - 1] + (1 if grid[i - 1][j - 1] == '1' else 0)\n                col_obsidian[i][j] = col_obsidian[i - 1][j] + (1 if grid[i - 1][j - 1] == '1' else 0)\n        \n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(1, n - a + 2):\n                    for j in range(1, m - b + 2):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = 0\n                        \n                        # Top and bottom rows\n                        changes += b - (row_obsidian[i][j + b - 1] - row_obsidian[i][j - 1])\n                        changes += b - (row_obsidian[i + a - 1][j + b - 1] - row_obsidian[i + a - 1][j - 1])\n                        \n                        # Left and right columns\n                        changes += a - 2 - (col_obsidian[i + a - 2][j] - col_obsidian[i][j])\n                        changes += a - 2 - (col_obsidian[i + a - 2][j + b - 1] - col_obsidian[i][j + b - 1])\n                        \n                        # Inner vacant area\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x - 1][y - 1] == '1':\n                                    changes += 1\n                        \n                        # Update the minimum changes found\n                        min_changes = min(min_changes, changes)\n        \n        return min_changes\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        result = calculate_min_changes(n, m, test_case)\n        results.append(result)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n    \n    # Call the function and print results\n    results = minimal_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. Efficient algorithms are needed to handle the maximum input size within the given limits.\nrequirement pool:\n- Develop an algorithm to identify sub-rectangles that can be transformed into portals.\n- Optimize the algorithm for minimal changes required.\n- Ensure the solution is scalable for large inputs.\n- Provide clear output for each test case.\n- Implement error handling for invalid inputs.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given n by m grid. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal. This involves checking the border conditions and ensuring the interior is empty. The solution will be optimized by stopping early if a minimal change configuration is found. Given the constraints, this approach should be efficient enough.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions.\n    'obsidian block': A block represented by '1'.\n    'vacant': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    Implementation: Use conditional checks to ensure dimensions meet these criteria.\n\n# [degree adverb]\n    'fewest': The minimal number of changes required to transform a sub-rectangle into a portal.\n    Implementation: Track the number of changes and update the minimum as needed.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the grid dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by:\n   - Ensuring the border conditions are met (obsidian blocks on specified edges).\n   - Ensuring the interior is vacant.\n4. Calculate the number of changes required for each sub-rectangle.\n5. Track the minimum number of changes across all sub-rectangles for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with a grid already forming a portal:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected output: 0\n    Explanation: The grid already forms a portal, so no changes are needed.\n\n    Test case with a grid where no portal can be formed:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: 20\n    Explanation: All blocks need to be changed to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types necessitate a strategic approach to identify potential sub-rectangles and calculate the required changes efficiently.\nrequirement pool:\n- Implement the main algorithm to identify minimal changes.\n- Optimize the algorithm for large inputs.\n- Ensure the solution handles multiple test cases efficiently.\n- Validate the output format for consistency.\n- Document the solution approach and edge cases.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of changes. The function will use dynamic programming to efficiently calculate the number of changes required for each potential portal configuration. This approach ensures that we handle large inputs efficiently while maintaining accuracy.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can either be an obsidian block (represented by '1') or vacant (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria, including having certain rows and columns filled with obsidian blocks and others empty.\n\n    'fewest number of changes'\n    Explanation: The goal is to transform a sub-rectangle into a portal with the minimum number of block type changes.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': This means the dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': This means the dimension 'b' of the portal must be at least 4.\n    'for every 1 < x < a': This indicates a range condition for rows within the portal.\n    'for each 1 < x < b': This indicates a range condition for columns within the portal.\n\n# [degree adverb]\n    'minimal changes': This refers to the smallest number of block type changes needed to form a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to transform it into a portal:\n   - Ensure the borders meet the obsidian block criteria.\n   - Ensure the inner blocks are vacant.\n4. Use dynamic programming to store and reuse results for overlapping sub-rectangles to optimize performance.\n5. Track the minimum number of changes required for each test case.\n6. Output the result for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the correct configuration for a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already forms a portal.\n\n    Case 2: A grid where no possible sub-rectangle can be transformed into a portal without changing every block.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be changed to form a portal.\n\n    Case 3: A grid with multiple potential portals, but one requires fewer changes.\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The grid already contains a portal with no changes needed.\n\n# [extra code for edge case]\nWe do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum changes required will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. Efficient algorithms are needed to handle the potential complexity of large inputs and multiple test cases.\nrequirement pool:\n- Develop an algorithm to identify the minimal changes needed for portal transformation.\n- Ensure the solution is scalable for large rectangles and multiple test cases.\n- Optimize the algorithm for efficiency and accuracy.\n- Handle edge cases and ensure robustness of the solution.\n- Provide clear documentation and output format.\nWe will use a dynamic programming approach to efficiently determine the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of the given dimensions and calculate the cost of transforming each into a portal. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can be either an obsidian block (1) or vacant (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria regarding its dimensions and the arrangement of obsidian blocks and vacant spaces.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5\n    'greater than or equal to 4': b must be at least 4\n    'for every 1 < x < a': means for all rows except the first and last\n    'for each 1 < x < b': means for all columns except the first and last\n\n# [degree adverb]\n    'fewest': means the minimal number of changes needed to achieve the desired configuration\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to transform it into a portal:\n   - Ensure the first and last rows have obsidian blocks at all positions except corners.\n   - Ensure the first and last columns have obsidian blocks at all positions except corners.\n   - Ensure all inner blocks are vacant.\n4. Track the minimum number of changes across all sub-rectangles for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    8\n    Explanation: The entire rectangle is filled with obsidian blocks, so we need to clear the inner blocks to make it a portal.\n\n    Case 2: \n    Input: \n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: \n    16\n    Explanation: The entire rectangle is vacant, so we need to add obsidian blocks to the borders to make it a portal.\n\n    Case 3: \n    Input: \n    1\n    5 4\n    1001\n    1001\n    1001\n    1001\n    1001\n    Expected Output: \n    0\n    Explanation: The rectangle already satisfies the portal conditions, so no changes are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimal changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires identifying sub-rectangles within a given rectangle and transforming them into portals with minimal changes. The constraints on dimensions and block types must be adhered to, ensuring efficient computation for potentially large inputs.\nrequirement pool:\n- Implement the main algorithm to identify minimal changes.\n- Optimize the algorithm for scalability.\n- Ensure accurate output for each test case.\n- Handle edge cases efficiently.\n- Provide clear documentation for the solution.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to convert them into a portal. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can be either an obsidian block (1) or vacant (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria, including boundary conditions and internal vacancy.\n\n    'fewest number of changes'\n    Explanation: The minimum number of block switches required to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The dimension 'a' of the sub-rectangle must be at least 5. In code, this can be checked using `if a >= 5`.\n\n    'greater than or equal to 4': \n    Explanation: The dimension 'b' of the sub-rectangle must be at least 4. In code, this can be checked using `if b >= 4`.\n\n# [degree adverb]\n    'minimal changes':\n    Explanation: This refers to finding the smallest number of block switches needed. In code, this can be implemented by keeping track of the minimum number of changes found during the iteration over possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n4. Use dynamic programming to store and update the minimum number of changes required for each sub-rectangle.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Explanation: If the grid is already a portal, no changes are needed, so the expected output is 0.\n\n    Case 2: A grid with no possible portal due to insufficient dimensions.\n    Explanation: If no sub-rectangle meets the minimum size requirement, the function should handle this gracefully, potentially returning a large number or indicating impossibility.\n\n    Case 3: A grid with all blocks as obsidian.\n    Explanation: The function should calculate the necessary changes to create internal vacancies and adjust boundaries accordingly.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no valid portal can be formed due to size constraints.\n```python\ndef handle_edge_cases(n, m):\n    if n < 5 or m < 4:\n        return float('inf')  # Indicate impossibility with a large number\n```\nThis function can be called before attempting to find portals in grids that do not meet the minimum size requirements.\n", "requirement analysis:\nThe problem requires identifying sub-rectangles within a given rectangle that can be transformed into a portal with minimal changes. The constraints on dimensions and block types must be carefully considered to ensure the solution is both efficient and accurate.\nrequirement pool:\n- Implement the main algorithm to identify portals.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear documentation and examples.\n- Develop a user-friendly interface for input and output.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform sub-rectangles into portals. The algorithm will iterate over possible sub-rectangles and calculate the number of changes needed to meet the portal criteria. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either obsidian or vacant.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria regarding its dimensions and the arrangement of obsidian and vacant blocks.\n\n    'fewest number of changes'\n    Explanation: The minimum number of block switches required to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5.\n    'greater than or equal to 4': b must be at least 4.\n    Implementation: Use conditional checks to ensure dimensions meet these criteria.\n\n# [degree adverb]\n    'minimal': Refers to the smallest number of changes needed.\n    Implementation: Use optimization techniques to find the least number of changes.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, read the grid configuration.\n3. Iterate over all possible sub-rectangles with dimensions at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the boundary conditions are met with obsidian blocks.\n   - Ensure the interior is vacant.\n5. Track the minimum number of changes required for each test case.\n6. Output the minimum changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already meets the portal criteria.\n\n    Case 2: A grid with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All boundary blocks need to be changed to obsidian.\n\n    Case 3: A grid with all obsidian blocks.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 6\n    Explanation: Interior blocks need to be changed to vacant.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying the minimal number of changes to transform a sub-rectangle into a portal. The constraints on dimensions and block types must be adhered to, ensuring the solution is efficient for the maximum input size.\nrequirement pool:\n- Develop an algorithm to find the minimal changes required to form a portal.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for edge cases.\n- Document the solution approach and edge case handling.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal. This involves ensuring the boundary conditions are met and the interior is empty. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions, consisting of rows and columns.\n    'obsidian block': A type of block that can be switched to empty or vice versa.\n    'portal': A sub-rectangle meeting specific criteria for dimensions and block arrangement.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n\n# [degree adverb]\n    'fewest': The minimal number of changes needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed:\n   - Ensure the boundary conditions are met (obsidian blocks on specified edges).\n   - Ensure the interior is empty.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with maximum dimensions:\n    Input:\n    1\n    400 400\n    (all blocks are empty)\n    Output:\n    Calculation required based on the specific arrangement needed to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given matrix into a portal with minimal changes. The constraints on the dimensions and the specific block requirements for a portal are critical. The solution must efficiently handle the maximum input size and provide the minimal number of changes required for each test case.\nrequirement pool:\n- Implement the main algorithm to find the minimal changes required to form a portal.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide detailed output for each transformation step.\n- Optimize the algorithm for speed and accuracy.\n- Include a user-friendly interface for input and output.\nWe will implement a function to find the minimal number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of the given matrix that meet the minimum size requirements for a portal. For each sub-rectangle, we will calculate the number of changes needed to convert it into a portal by checking the border and inner conditions. We will use efficient matrix traversal techniques to ensure the solution handles the maximum input size efficiently. The numpy library will be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block configurations. It must have obsidian blocks on its borders except for the corners, which can be any type, and vacant blocks inside.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5\n    'greater than or equal to 4': b must be at least 4\n    Explanation: These phrases define the minimum dimensions required for a sub-rectangle to be considered a portal. In code, this can be implemented by checking if the dimensions of the sub-rectangle meet these criteria before further processing.\n\n# [degree adverb]\n    'fewest': means we need to minimize the number of changes needed to transform a sub-rectangle into a portal.\n    Explanation: This requires an optimization approach to find the configuration with the minimal changes.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of dimensions at least 5x4 within the given matrix.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n    3. Ensure that the borders meet the obsidian block requirements while the inner blocks are vacant.\n    4. Track the minimum number of changes across all sub-rectangles.\n    5. Return the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A matrix that is already a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The matrix already meets the portal criteria, so no changes are needed.\n\n    Case 2: A matrix with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n    Case 3: A matrix with dimensions larger than required but with incorrect block configuration.\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The matrix already meets the portal criteria, so no changes are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying the minimal number of changes to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The algorithm should focus on optimizing the search for potential portal configurations and calculating the required changes.\nrequirement pool:\n- Develop an algorithm to find the minimal changes for portal formation\n- Ensure the solution is efficient for maximum constraints\n- Output results in the specified format for each test case\n- Optimize the algorithm for specific patterns in the input\n- Provide detailed documentation of the solution approach\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of changes. The function will use a brute-force approach to evaluate each sub-rectangle, but will optimize by stopping early if a valid portal is found with fewer changes than previously recorded. The solution will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can be either an obsidian block (1) or vacant (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria, including dimensions and block configurations.\n\n    'obsidian block'\n    Explanation: A block represented by '1' in the grid, which can be switched to vacant (0) and vice versa.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The dimension 'a' of the portal must be at least 5. In code, this can be checked using `if a >= 5`.\n\n    'greater than or equal to 4': \n    Explanation: The dimension 'b' of the portal must be at least 4. In code, this can be checked using `if b >= 4`.\n\n# [degree adverb]\n    'fewest number of changes':\n    Explanation: The goal is to minimize the number of block switches needed to form a valid portal. This involves finding the optimal solution with the least modifications.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the necessary changes.\n4. Keep track of the minimum number of changes required for each test case.\n5. Output the minimum changes for each test case.\n\n# [edge case]\n    Edge Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Edge Case 2: A grid with no possible portal.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 16\n    Explanation: All blocks need to be changed to form a portal.\n\n    Edge Case 3: A grid with multiple possible portals.\n    Example:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: Multiple sub-rectangles satisfy the portal conditions without any changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimal number of changes to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be efficient to handle the maximum input sizes. The algorithm should focus on identifying potential sub-rectangles and calculating the required changes efficiently.\nrequirement pool:\n- Develop an efficient algorithm to identify sub-rectangles.\n- Optimize the solution for minimal changes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and correct output for each test case.\n- Implement a user-friendly interface for input and output.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to convert each into a portal. We will use a precomputed prefix sum array to quickly calculate the number of obsidian blocks in any sub-rectangle, which will help in determining the number of changes required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific type of rectangle with dimensions a by b, meeting certain criteria for block placement.\n\nExplanation: The requirement involves transforming a sub-rectangle within a larger rectangle into a portal, which is defined by specific block placement rules.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n\nExplanation: These phrases define the minimum dimensions required for a sub-rectangle to be considered a portal.\n\n# [degree adverb]\n    'fewest': Refers to minimizing the number of changes needed to transform a sub-rectangle into a portal.\n\nExplanation: The goal is to find the configuration that requires the least number of changes.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. Use a prefix sum array to efficiently calculate the number of obsidian blocks in each sub-rectangle.\n4. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria.\n5. Track the minimum number of changes required across all sub-rectangles for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    12\n    Explanation: All blocks need to be changed to meet the portal criteria.\n\n    Test case with all obsidian blocks:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    8\n    Explanation: Only internal blocks need to be changed to vacant.\n\n    Test case with mixed blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    10\n    Explanation: Changes are needed to meet both border and internal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle all scenarios by iterating over possible sub-rectangles and calculating changes needed based on the portal criteria.\n", "requirement analysis:\nThe problem requires identifying the minimal number of changes to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must be efficient to handle the maximum input sizes. The algorithm should focus on checking all possible sub-rectangles and calculating the required changes efficiently.\nrequirement pool:\n- Develop an efficient algorithm to identify the minimal changes required.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for speed and scalability.\n- Implement additional features for user interaction and feedback.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and calculates the number of changes required to transform each into a portal. The function will use a dynamic programming approach to efficiently compute the minimal changes needed by storing intermediate results. This approach ensures scalability and efficiency, even for the maximum input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can be either an obsidian block (represented by '1') or vacant (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria regarding its dimensions and the arrangement of obsidian blocks and vacant spaces.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The dimension 'a' of the portal must be at least 5. In code, this can be checked using `a >= 5`.\n    \n    'greater than or equal to 4': \n    Explanation: The dimension 'b' of the portal must be at least 4. In code, this can be checked using `b >= 4`.\n\n# [degree adverb] \n    'fewest number of changes':\n    Explanation: This refers to minimizing the number of block switches needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes for each potential sub-rectangle.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the necessary changes:\n   - Ensure the first and last rows and columns have obsidian blocks where required.\n   - Ensure the inner blocks are vacant.\n4. Use dynamic programming to store intermediate results and minimize redundant calculations.\n5. Track the minimum number of changes needed for each test case and output the result.\n\n# [edge case] \n    Edge Case 1: \n    Input: \n    ```\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    ```\n    Expected Output: 0\n    Explanation: The entire rectangle is already a portal, so no changes are needed.\n\n    Edge Case 2: \n    Input: \n    ```\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    ```\n    Expected Output: 18\n    Explanation: All blocks need to be changed to form a portal, except for the corners which can remain vacant.\n\n    Edge Case 3: \n    Input: \n    ```\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    ```\n    Expected Output: 12\n    Explanation: The alternating pattern requires significant changes to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimal changes will naturally handle these cases.\n"], "scores": [], "pass_results": [true, false, true, true, false, false, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 878, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "parent_index": 509}
