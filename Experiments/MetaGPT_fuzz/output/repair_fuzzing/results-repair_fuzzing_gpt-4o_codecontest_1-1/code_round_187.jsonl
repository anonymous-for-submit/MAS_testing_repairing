{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem carries a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem carries a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem carries a topic a_i. The topic is represented as an integer ranging from 1 to n. It also carries a difficulty b_i (an integer ranging from 1 to n). All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session. Monocarp has n problems that none of his students have seen yet, with the i-th problem carrying a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n), and all problems are unique meaning that no two tasks possess identical topic and difficulty simultaneously. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n\n        for topic, difficulty in problems:\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where neither topics nor difficulties are all different\n        invalid_combinations = 0\n\n        # Calculate invalid combinations based on topics\n        for count in topic_counter.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Calculate invalid combinations based on difficulties\n        for count in difficulty_counter.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting any three problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics or difficulties are not distinct\n        invalid_combinations = 0\n\n        # Subtract combinations where topics are not distinct\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract combinations where difficulties are not distinct\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Frequency dictionaries for topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count frequencies of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Total combinations of selecting 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        # Subtract combinations where topics are not unique\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract combinations where difficulties are not unique\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        pair_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and (topic, difficulty) pair\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            pair_count[(topic, difficulty)] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not distinct\n        invalid_combinations = 0\n\n        # Calculate invalid combinations for topics\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Calculate invalid combinations for difficulties\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract invalid combinations where both topics and difficulties are not distinct\n        for count in pair_count.values():\n            if count >= 2:\n                invalid_combinations -= count * (count - 1) // 2 * (n - 2)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate valid combinations by subtracting invalid combinations from total\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        # Append result for the current test case\n        results.append(valid_combinations)\n\n    return results\n\ndef comb(n: int, k: int) -> int:\n    \"\"\"Calculate the number of combinations of n items taken k at a time.\n\n    Args:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n\n    Returns:\n        int: Number of combinations.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_combinations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of three problems for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers representing the number of valid sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = comb(n, 3)\n\n        # Calculate combinations where topics are not all different\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Calculate combinations where difficulties are not all different\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate combinations where both topics and difficulties are not all different\n        invalid_both_combinations = 0\n        for topic, difficulty in problems:\n            if topic_count[topic] >= 3 and difficulty_count[difficulty] >= 3:\n                invalid_both_combinations += comb(topic_count[topic] - 1, 2) * comb(difficulty_count[difficulty] - 1, 2)\n\n        # Use inclusion-exclusion principle to calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nimport itertools\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n    \n    for n, problems in test_cases:\n        valid_count = 0\n        \n        # Generate all combinations of three problems\n        for combination in itertools.combinations(problems, 3):\n            topics = {problem[0] for problem in combination}\n            difficulties = {problem[1] for problem in combination}\n            \n            # Check if all topics are different or all difficulties are different\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_count += 1\n        \n        results.append(valid_count)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    \n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        for topic, count in topic_count.items():\n            if count >= 2:\n                # Choose 2 problems with the same topic and 1 with a different difficulty\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                # Choose 2 problems with the same difficulty and 1 with a different topic\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract invalid combinations from total to get valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom itertools import combinations\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Count occurrences of each topic and difficulty\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n\n        for topic, difficulty in problems:\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n\n        # Calculate invalid sets where neither condition is satisfied\n        invalid_sets = 0\n        for topic, difficulty in problems:\n            # Calculate the number of invalid sets for this specific problem\n            invalid_sets += (topic_counter[topic] - 1) * (difficulty_counter[difficulty] - 1)\n\n        # Calculate valid sets by subtracting invalid sets from total combinations\n        valid_sets = total_combinations - invalid_sets\n        results.append(valid_sets)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Total ways to choose 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations where all topics are the same\n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_combinations += comb(count, 3)\n\n        # Calculate invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_combinations += comb(count, 3)\n\n        # Calculate invalid combinations where both topics and difficulties are the same\n        invalid_both_combinations = 0\n        problem_count = defaultdict(int)\n        for topic, difficulty in problems:\n            problem_count[(topic, difficulty)] += 1\n\n        for count in problem_count.values():\n            if count >= 3:\n                invalid_both_combinations += comb(count, 3)\n\n        # Calculate valid combinations\n        valid_combinations = (total_combinations - invalid_topic_combinations -\n                              invalid_difficulty_combinations + invalid_both_combinations)\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems across all test cases.\nrequirement pool:\n- Efficiently handle large input sizes\n- Ensure accurate calculation of valid problem sets\n- Optimize for speed and performance\n- Provide clear output format\n- Handle edge cases gracefully\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will utilize collections.Counter from the Python standard library to count occurrences of topics and difficulties, which will help in calculating the number of valid combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is defined by a unique combination of topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of exactly three problems from the given set.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a distinct topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a distinct difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    \n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial counting to determine the number of ways to select three problems such that:\n   - All topics are different.\n   - All difficulties are different.\n4. Use collections.Counter to count occurrences of each topic and difficulty.\n5. Calculate the total number of ways to choose any three problems using combinations.\n6. Subtract invalid combinations where neither topics nor difficulties are all different.\n7. Output the result for each test case.\n\n# [edge case] \n    Test case with minimum n (n=3):\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Test case with all topics or difficulties the same:\n    Input: 1\n           4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected output: 0\n    Explanation: No way to select three problems with all different topics or difficulties.\n\n    Test case with maximum n (n=5):\n    Input: 1\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Expected output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and conditions will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems across all test cases.\nrequirement pool:\n- Efficiently compute combinations of problems meeting the criteria\n- Ensure solution scalability for large input sizes\n- Provide clear output format for easy verification\n- Optimize for performance without sacrificing accuracy\n- Include detailed comments for code maintainability\nWe will use a combinatorial approach to efficiently calculate the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to determine the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n# [phrase showing quantity relationship]\n    'different': In the context of topics and difficulties, it means that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the details of each problem.\n    2. For each test case, initialize dictionaries to count occurrences of each topic and difficulty.\n    3. Calculate the total number of ways to select any three problems using combinatorial logic (n choose 3).\n    4. Adjust this count by subtracting combinations where topics or difficulties are not distinct.\n    5. Use the counts from the dictionaries to determine invalid combinations and subtract them from the total.\n    6. Output the adjusted count for each test case.\n\n# [edge case]\n    Input: \n    3\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one combination (problems 1, 2, and 3) satisfies the condition as all topics and difficulties are different.\n\n    Input: \n    4\n    1 1\n    1 2\n    2 1\n    2 2\n    Output: \n    0\n    Explanation: No combination of three problems can satisfy either condition as there are only two distinct topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial calculations and dictionary counts will naturally account for these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that either their topics or difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring scalability and accuracy.\nrequirement pool:\n- Efficiently handle large input sizes\n- Ensure accurate results for all test cases\n- Optimize for speed and performance\n- Provide clear output format\n- Include detailed error handling\nWe will use a combinatorial approach to efficiently calculate the number of valid problem sets. The key is to count the number of ways to select three problems such that either their topics or difficulties are all different. We will utilize dictionaries to keep track of the frequency of each topic and difficulty, and then use these frequencies to compute the valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in terms of both topic and difficulty, meaning no two problems share the same topic and difficulty pair.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of three problems from the given set of problems.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a unique topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a unique difficulty level.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use dictionaries to count the frequency of each topic and each difficulty.\n4. Calculate the total number of ways to choose any 3 problems from n (using combinations).\n5. Subtract invalid combinations where topics or difficulties are not unique:\n   - For each problem, calculate invalid combinations where its topic or difficulty repeats with others.\n6. Sum up valid combinations for each test case and output the result.\n\n# [edge case] \n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected Output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected Output: 0\n    Explanation: No way to select three problems such that either all topics or all difficulties are different.\n\n    Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected Output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and frequency analysis inherently handles these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that either their topics or difficulties are all different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficiently handle large datasets\n- Ensure accurate problem set selection\n- Provide clear output format\n- Optimize for speed and scalability\n- Enhance user understanding of selection criteria\nWe will use a combinatorial approach to efficiently determine the number of valid problem sets. The key is to count combinations where either topics or difficulties are distinct. We will utilize Python's collections library to count occurrences and calculate combinations using combinatorial mathematics.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial approach'\n    Explanation: This refers to using combinatorial mathematics to count the number of ways to select problems that meet the given conditions. It involves calculating combinations where either topics or difficulties are distinct.\n\n    'distinct topics/difficulties'\n    Explanation: This means that for a valid selection of three problems, either all topics or all difficulties must be different from each other.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select exactly three problems from the given set.\n    Explanation: This means the selection must consist of three problems, no more, no less.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and details for each test case.\n    2. For each test case, read the number of problems and their respective topics and difficulties.\n    3. Use collections to count occurrences of each topic and difficulty.\n    4. Calculate combinations where either topics or difficulties are distinct using combinatorial mathematics.\n    5. Sum up valid combinations for each test case and print the result.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems where both topics and difficulties are distinct.\n\n    Input: 3\n           1 2\n           2 3\n           3 1\n    Output: 1\n    Explanation: Only one way to select three problems where both topics and difficulties are distinct.\n\n    Input: 4\n           1 1\n           2 2\n           3 3\n           4 4\n    Output: 4\n    Explanation: Four ways to select three problems where both topics and difficulties are distinct.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations where either topics or difficulties are distinct will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring performance and scalability.\nrequirement pool:\n- Efficiently compute combinations of problems meeting the criteria\n- Ensure the solution scales with large input sizes\n- Optimize the algorithm for quick computation\n- Validate input constraints and handle edge cases\n- Provide clear output format as specified\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. Specifically, we will leverage the itertools library to generate combinations and use dictionaries to count occurrences of topics and difficulties. This approach ensures that we can efficiently handle large input sizes and quickly compute the number of valid combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': Refers to the unique identifier for each problem's subject matter, represented by integer a_i.\n    'difficulties': Refers to the unique identifier for each problem's complexity level, represented by integer b_i.\n    'combinatorial mathematics': The branch of mathematics dealing with combinations of objects belonging to a finite set in accordance with certain constraints.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select precisely three problems from the given set.\n    'different': Indicates that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems, n.\n2. Initialize dictionaries to count occurrences of each topic and difficulty.\n3. Iterate through the list of problems, updating the topic and difficulty counts.\n4. Calculate the total number of ways to choose any 3 problems from n using combinatorial formula C(n, 3).\n5. For each topic, calculate the number of invalid combinations where all three problems have the same topic.\n6. For each difficulty, calculate the number of invalid combinations where all three problems have the same difficulty.\n7. Subtract these invalid combinations from the total to get the valid combinations.\n8. Output the result for each test case.\n\n# [edge case]\n    Test case 1: \n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) satisfies both conditions.\n\n    Test case 2:\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 4\n    Explanation: All combinations satisfy at least one condition.\n\n    Test case 3:\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations by subtracting invalid ones will handle all edge cases effectively.\n", "requirement analysis:\nThe problem requires selecting three problems from a set such that either their topics or difficulties are all different. The constraints ensure that the solution must be efficient due to the large possible input size. The solution should leverage combinatorial counting and efficient data structures to handle the constraints effectively.\nrequirement pool:\n- Implement an efficient algorithm to count valid problem sets.\n- Ensure the solution handles up to 50000 test cases efficiently.\n- Optimize for large input sizes, up to 2 \u22c5 10^5 problems.\n- Provide clear output format as specified in the requirements.\n- Consider edge cases where n is minimal or maximal.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The approach involves calculating combinations of problems where either topics or difficulties are distinct. We will utilize Python's collections library to count occurrences and combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics of all three selected problems are different'\n    Explanation: This means that when selecting three problems, each problem must have a unique topic number.\n\n    'difficulties of all three selected problems are different'\n    Explanation: This means that when selecting three problems, each problem must have a unique difficulty level.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that we need to select precisely three problems from the list.\n    'at least one of two conditions': This means that the selected problems must satisfy at least one of the two given conditions (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial counting to determine the number of valid sets of three problems:\n   - Count the number of ways to choose three problems with all different topics.\n   - Count the number of ways to choose three problems with all different difficulties.\n   - Use inclusion-exclusion principle to avoid double-counting sets that satisfy both conditions.\n4. Output the result for each test case.\n\n# [edge case] \n    Test case with minimum n (n=3) where all topics and difficulties are different:\n    Input: 1\n           3\n           1 2\n           2 3\n           3 1\n    Expected Output: 1\n    Explanation: There is only one way to select all three problems, and they satisfy both conditions.\n\n    Test case with n=3 where no condition is satisfied:\n    Input: 1\n           3\n           1 1\n           1 1\n           1 1\n    Expected Output: 0\n    Explanation: All problems have the same topic and difficulty, so no valid selection is possible.\n\n    Test case with maximum n (n=5) where all topics and difficulties are different:\n    Input: 1\n           5\n           1 2\n           2 3\n           3 4\n           4 5\n           5 1\n    Expected Output: 10\n    Explanation: All combinations of three problems satisfy at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and inclusion-exclusion principle will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet at least one of the specified conditions. The solution must efficiently handle multiple test cases and large input sizes, ensuring scalability and accuracy.\nrequirement pool:\n- Efficiently calculate combinations of problems meeting criteria\n- Handle large datasets within performance constraints\n- Ensure accuracy across all test cases\n- Optimize for speed and resource usage\n- Provide clear output format as specified\nWe will use combinatorial mathematics to efficiently calculate the number of valid problem sets. Specifically, we will leverage the itertools library to generate combinations and filter them based on the given criteria. This approach ensures scalability and accuracy for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must either have all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    Implementation: Use combinations to select groups of three problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the list of problems for each test case.\n    2. For each test case, generate all possible combinations of three problems.\n    3. For each combination, check if the topics are all different or if the difficulties are all different.\n    4. Count and output the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination is possible, and it satisfies both conditions.\n\n    Test case with all topics or difficulties the same:\n    Input: 3\n           1 1\n           1 2\n           1 3\n    Output: 0\n    Explanation: No valid combinations as all topics are the same.\n\n    Test case with maximum n:\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that they meet at least one of the specified conditions: all topics are different or all difficulties are different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficiently handle large datasets\n- Accurately count valid problem sets\n- Optimize for speed and performance\n- Ensure scalability across multiple test cases\n- Provide clear output format\nWe will use a combinatorial approach to efficiently count the number of valid problem sets. The key is to calculate the total number of ways to choose 3 problems and then subtract the invalid combinations where neither condition is satisfied. We will use dictionaries to count occurrences of each topic and difficulty, which will help in determining invalid combinations. This approach ensures that we handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    Implementation: Use combinations to select 3 items from the list.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the details of each problem.\n2. For each test case, initialize dictionaries to count occurrences of each topic and difficulty.\n3. Calculate the total number of ways to choose 3 problems using combinations.\n4. Determine invalid combinations where neither condition is satisfied by using the topic and difficulty counts.\n5. Subtract invalid combinations from the total to get valid combinations.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all same topics:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Output: 0\n    Explanation: No valid way to select three problems as all have the same topic.\n\n    Test case with all same difficulties:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Output: 0\n    Explanation: No valid way to select three problems as all have the same difficulty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations by subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet at least one of the specified conditions: all topics are different or all difficulties are different. The solution must efficiently handle multiple test cases and large input sizes, ensuring that the constraints are respected.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets for each test case.\n- Ensure the solution handles large input sizes within the given constraints.\n- Provide clear and correct output for each test case.\n- Optimize the algorithm to run within acceptable time limits for all inputs.\n- Implement error handling for unexpected input formats.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The approach involves calculating the total number of ways to select three problems and then subtracting the invalid sets where neither condition is satisfied. We will utilize collections.Counter to efficiently count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems.\n    'different': means that the topics or difficulties must not be the same among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of problems and their respective topics and difficulties.\n    2. Use combinatorial counting to calculate the total number of ways to select three problems.\n    3. Count occurrences of each topic and difficulty using collections.Counter.\n    4. Calculate invalid sets where neither condition is satisfied by considering combinations where topics and difficulties are not all different.\n    5. Subtract invalid sets from total combinations to get valid sets.\n    6. Output the number of valid sets for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one set (1, 2, 3) satisfies the condition as all topics and difficulties are different.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No set of three problems can be formed where either all topics or all difficulties are different.\n\n    Input: 5\n           1 1\n           1 2\n           1 3\n           2 1\n           3 1\n    Output: 10\n    Explanation: Multiple sets can be formed with different topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring scalability and accuracy.\nrequirement pool:\n- Efficient algorithm to count valid problem sets\n- Scalable solution for large input sizes\n- Accurate results for all test cases\n- User-friendly interface for input and output\n- Documentation for understanding the solution approach\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count combinations where either all topics or all difficulties are different. We will utilize collections from the Python standard library to count occurrences and calculate combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial counting'\n    Explanation: This refers to the mathematical technique used to count the number of ways to choose items from a set, considering certain constraints. In this problem, it involves counting combinations of problems where either all topics or all difficulties are different.\n\n    'unique problems'\n    Explanation: Each problem is distinct in terms of its topic and difficulty, meaning no two problems have the same topic and difficulty pair.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select precisely three problems from the given set.\n    \n    'at least one of two conditions': This means that the selected problems must satisfy either one or both of the given conditions (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. Store each problem's topic and difficulty in a list.\n3. Use combinatorial counting to calculate the total number of ways to choose 3 problems from `n` (using combinations formula C(n, 3)).\n4. Count the number of ways where all topics are not different and subtract from the total.\n5. Count the number of ways where all difficulties are not different and subtract from the total.\n6. Add back the cases where both topics and difficulties are not different (as they were subtracted twice).\n7. Output the result for each test case.\n\n# [edge case] \n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 0\n    Explanation: No way to select three problems such that either all topics or all difficulties are different.\n\n    Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems satisfy at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting inherently handles these cases by considering all possible combinations and applying the constraints.\n"], "scores": [], "pass_results": [false, true, false, false, false, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 187, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "rephrase_one", "parent_index": 26}
