{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds, and throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon, inflicting 1 damage in each of the ensuing k seconds, and commencing along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds, and throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon, inflicting 1 damage in each of the ensuing k seconds, and commencing along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds, and throughout this period, Monocarp uses a poisoned dagger to attack the dragon. The i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage. Instead, it initiates a poisonous impact on the dragon, inflicting 1 damage in each of the ensuing k seconds. This effect commences along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in playing yet another computer game. In this game, his character faces the task of slaying a dragon. The fight against the dragon goes on for a duration of 100^{500} seconds, and throughout this period, Monocarp uses a poisoned dagger to attack the dragon; the i-th attack is executed at the onset of the a_i-th second from the beginning of the battle. The dagger itself doesn't cause direct damage, but it initiates a poisonous impact on the dragon, inflicting 1 damage in each of the ensuing k seconds, and commencing along with the exact second the dragon is pierced by the dagger. Nevertheless, if the dragon is already under the influence of poison, then the dagger refreshes the poisonous impact (in other words, nullifies the present poison effect and initiates a fresh one).\n\nFor instance, assume k = 4, and Monocarp pierces the dragon at times 2, 4 and 10. The toxic effect begins at the outset of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the toxic effect is renewed, thereby inflicting precisely 1 damage during the seconds 4, 5, 6 and 7; afterwards, during the 10-th second, the poisonous impact is reinstated, resulting in 1 damage during the seconds 10, 11, 12 and 13. In aggregate, the dragon sustains 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts at least h damage to the dragon during the combat \u2014 he defeats the dragon. Monocarp hasn't settled on the potency of the poison he will employ during the battle. Consequently, he aims to determine the smallest possible value of k (the duration of seconds the poison effect remains active) that suffices to deliver at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h  # high can be set to h as a safe upper bound\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Try larger k\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        left, right = 1, h\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # Set initial bounds for k\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = calculate_damage(n, attacks, mid)\n            \n            if total_damage >= h:\n                high = mid  # Try a smaller k\n            else:\n                low = mid + 1  # Try a larger k\n        \n        results.append(low)\n    \n    return results\n\ndef calculate_damage(n: int, attacks: List[int], k: int) -> int:\n    \"\"\"Calculate the total damage inflicted with a given poison duration k.\"\"\"\n    total_damage = 0\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k  # Last attack always inflicts k damage\n        else:\n            total_damage += min(k, attacks[i + 1] - attacks[i])  # Damage is limited by the time to next attack\n    return total_damage\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        left, right = 1, h\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # Initial bounds for k\n        while left < right:\n            mid = (left + right) // 2\n            if can_inflict_damage(n, h, attack_times, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_inflict_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if a given k can inflict at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to defeat the dragon.\n        attack_times (List[int]): List of attack times.\n        k (int): Duration of poison effect.\n\n    Returns:\n        bool: True if k can inflict at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attack_times[i + 1] - attack_times[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attack_times = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # high is set to h because k cannot be more than h to inflict h damage\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        low, high = 1, h\n        \n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current mid\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n            \n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Try larger k\n        \n        results.append(low)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    test_cases = []\n    \n    # Read each test case\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum poison durations k for each test case.\n    \"\"\"\n    def calculate_damage(n: int, k: int, attack_times: List[int]) -> int:\n        \"\"\"Calculate the total damage inflicted with a given poison duration k.\n\n        Args:\n            n (int): Number of attacks.\n            k (int): Duration of poison effect.\n            attack_times (List[int]): List of attack times.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        for i in range(n):\n            if i == n - 1:\n                total_damage += k\n            else:\n                total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        return total_damage\n\n    results = []\n    for n, h, attack_times in test_cases:\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(n, mid, attack_times) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) needed to inflict at least h damage on the dragon. The solution must efficiently handle large input sizes and multiple test cases, ensuring the output is correctly formatted for each case.\nrequirement pool:\n- Implement an efficient algorithm to calculate the minimum k.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large values of n and h.\n- Provide clear and concise output for each test case.\n- Include comments and documentation for code clarity.\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage inflicted by the poison can be calculated by iterating over the attack times and summing up the effective poison durations. By using binary search on k, we can find the smallest k that results in at least h damage. This approach is efficient and suitable for handling the large input sizes specified in the problem.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect starts when the dragon is pierced and lasts for k seconds, inflicting 1 damage per second. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage inflicted must be greater than or equal to h.\n    Implementation: Use a loop to calculate the total damage for a given k and check if it meets or exceeds h.\n\n# [degree adverb]\n    'smallest': means we need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k.\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for k = mid using attack times.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (try larger k).\n    3. Return low as the minimum k.\n\n# [edge case]\n    Test case: 1 attack, h = 1\n    Explanation: With only one attack, k must be at least 1 to inflict any damage.\n    Test case: n attacks, all at the same second, h = n\n    Explanation: If all attacks occur simultaneously, k must be at least n to inflict n damage.\n    Test case: Large h, sparse attacks\n    Explanation: If h is very large and attacks are sparse, k must be large enough to cover gaps between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe main requirement is to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The solution must efficiently handle large input sizes and multiple test cases, ensuring that the game logic is both scalable and responsive.\nrequirement pool:\n- Implement the core game logic to calculate the minimum poison duration.\n- Ensure the solution can handle the maximum constraints efficiently.\n- Provide clear output for each test case.\n- Optimize the algorithm for performance.\n- Enhance user experience with intuitive input and output handling.\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The binary search will be applied over the possible values of k, and for each k, we will calculate the total damage inflicted using the given attack times. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger initiates a poison effect that lasts for k seconds, inflicting 1 damage per second. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage inflicted must be greater than or equal to h.\n    Implementation: We need to ensure that the sum of damage over the attack times with duration k meets or exceeds h.\n\n# [degree adverb]\n    'smallest': means we need to find the minimum possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = h).\n    2. For each test case, perform binary search:\n        - Calculate mid = (low + high) // 2.\n        - Compute total damage for k = mid using attack times.\n        - If total damage >= h, update high = mid.\n        - Otherwise, update low = mid + 1.\n    3. Return low as the minimum k when binary search completes.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to inflict the required damage.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack, k must be equal to h to inflict the required damage.\n\n    Test case with consecutive attacks:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack refreshes the poison, so k = 1 is sufficient to inflict damage in each second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the boundaries based on the computed damage.\n", "requirement analysis:\nThe main requirement is to calculate the minimum poison duration (k) needed to inflict at least h damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring accurate damage calculation based on attack timings.\nrequirement pool:\n- Implement the algorithm to calculate minimum poison duration k\n- Optimize the solution for handling large input sizes\n- Provide clear output format for test cases\n- Enhance user experience with intuitive feedback\n- Ensure compatibility with various input scenarios\nWe will implement a binary search algorithm to efficiently determine the minimum poison duration k. The key challenge is to handle large numbers and overlapping poison effects. We will iterate over each test case, and for each, use binary search to find the smallest k such that the total damage is at least h. The damage calculation will consider the refresh of poison effects when attacks overlap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger initiates a poisonous effect that lasts for k seconds, inflicting 1 damage per second. If the dragon is already poisoned, the effect is refreshed.\n\n    'refreshes the poisonous impact'\n    Explanation: When a new attack occurs while the dragon is still under poison, the poison duration resets, starting a new k-second period of damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This means we need to find the minimum k such that the sum of damage over all attacks is at least h.\n\n# [degree adverb]\n    'smallest possible value of k'\n    Explanation: We need to find the minimum duration k that ensures the total damage is at least h. This involves optimizing k using binary search.\n\n# [code logic]\n    1. For each test case, initialize binary search bounds for k.\n    2. Calculate total damage for a given k by iterating through attack times and summing up the poison effects.\n    3. Use binary search to adjust k until the minimum value that results in at least h damage is found.\n    4. Return the minimum k for each test case.\n\n# [edge case]\n    Test case with minimal attacks and high h:\n    1 1000000000000000000\n    1\n    Expected output: 1000000000000000000\n    Explanation: With only one attack, k must be equal to h to achieve the required damage.\n\n    Test case with attacks spaced far apart:\n    2 5\n    1 1000000000\n    Expected output: 5\n    Explanation: The attacks are so far apart that each attack must independently cover the required damage.\n\n    Test case with consecutive attacks:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack refreshes the poison, so k=1 is sufficient to cover the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The challenge lies in efficiently calculating this for potentially large input sizes, ensuring the solution is both correct and performant.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k\n- Optimize the algorithm for large input sizes\n- Ensure the solution is accurate and handles edge cases\n- Provide clear documentation and examples\n- Test the solution against a variety of test cases\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. This approach is chosen due to its ability to handle large input sizes effectively, ensuring optimal performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger's attack doesn't cause direct damage but initiates a poison effect that deals 1 damage per second for k seconds. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted by the poison must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb] \n    'smallest possible value'\n    Explanation: We need to find the minimum k such that the total damage is at least h. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the attack times.\n3. Implement a binary search for k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - Calculate the total damage for a mid value of k.\n   - If the damage is at least h, try a smaller k; otherwise, try a larger k.\n4. Output the minimum k for each test case.\n\n# [edge case] \n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack needs to deal its own damage separately.\n\n    Test case 3: n = 3, h = 10, a = [1, 2, 3] => k = 4\n    Explanation: Continuous attacks mean overlapping poison effects; thus, a smaller k suffices.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) needed to inflict at least h damage on the dragon. The solution must efficiently handle large input sizes and multiple test cases, ensuring accurate and quick results.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for performance\n- Provide clear and concise output formatting\n- Include comprehensive test cases for validation\nWe will use a binary search approach to efficiently determine the minimum value of k. The binary search will be applied on the range of possible k values, and for each mid value, we will calculate the total damage inflicted using the given attack times. This approach ensures that we handle large input sizes efficiently, as binary search reduces the time complexity significantly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger initiates a poisonous effect that inflicts damage over a period of k seconds. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum k that satisfies the condition. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k.\n    2. For each mid value of k in the binary search, calculate the total damage inflicted.\n    3. Calculate damage by iterating through attack times and summing up the poison effect duration.\n    4. If total damage is at least h, adjust the binary search to find a smaller k.\n    5. If total damage is less than h, increase k.\n    6. Return the smallest k found.\n\n# [edge case]\n    Test case with minimum attacks and minimum damage:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With one attack, k must be at least 1 to inflict any damage.\n\n    Test case with maximum attack time difference:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: The attacks are far apart, so k=1 is sufficient to inflict damage at each attack time.\n\n    Test case with large h:\n    2 1000000000000000000\n    1 1000000000\n    Expected output: Large value (close to h)\n    Explanation: With very high h, k needs to be large enough to accumulate sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles varying values of n, h, and attack times efficiently.\n", "requirement analysis:\nThe problem requires determining the minimum duration k for which the poison effect must last to inflict at least h damage on the dragon. The solution must efficiently handle large input sizes and multiple test cases, ensuring that the algorithm is optimized for performance.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large values of n and h.\n- Provide detailed comments and documentation for the code.\n- Include edge case handling and validation.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will help in optimizing the performance for large values of n and h, ensuring that the solution can handle up to 1000 test cases efficiently. We will iterate over the attack times and calculate the total damage for each potential k value, adjusting the search range based on whether the damage meets or exceeds h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger initiates a poisonous effect that lasts for k seconds, inflicting 1 damage per second. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the attack times.\n    3. Implement a binary search for k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate total damage for a mid-point k.\n        - Adjust bounds based on whether the damage is sufficient.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to inflict 1 damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: Large value (close to h/n)\n    Explanation: With maximum h and n, k needs to be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 3\n    Explanation: Damage is dealt in seconds [1, 2, 3, 10, 11, 12], totaling 6 damage with k=3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) such that the total damage inflicted is at least h. The solution must efficiently handle large input sizes and constraints, ensuring the output is correct for each test case.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Validate the output format against the requirements\n- Document the solution approach and edge cases\nWe will implement a binary search algorithm to efficiently determine the minimum duration of poison effect (k) required to inflict at least h damage. The approach will involve calculating the total damage for a given k and adjusting k using binary search until the minimum valid k is found. This ensures the solution is optimized for performance given the large input constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The dagger's attack doesn't cause direct damage but initiates a poison effect that deals 1 damage per second for k seconds. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a condition to check if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the attack times.\n3. Implement a binary search for k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - Calculate the total damage for a mid value of k.\n   - If the damage is at least h, adjust the upper bound; otherwise, adjust the lower bound.\n4. Continue until the smallest valid k is found.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Test case 2: n = 100, h = 10000, a = [1, 2, ..., 100] = 100\n    Explanation: With attacks every second, k must be large enough to accumulate 10000 damage over 100 attacks.\n\n    Test case 3: n = 2, h = 10^18, a = [1, 10^9] = 10^18\n    Explanation: With very high h and sparse attacks, k must be extremely large to meet the damage requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe main requirement is to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring that the game logic is both scalable and responsive.\nrequirement pool:\n- Implement the core logic to calculate the minimum k for each test case.\n- Optimize the algorithm to handle large input sizes efficiently.\n- Provide real-time feedback on the damage inflicted.\n- Design a user-friendly interface for input and output.\n- Ensure the game logic is easily understandable and maintainable.\nWe will implement a function to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The approach involves iterating over the attack times and calculating the damage inflicted for a given k. We will use binary search to efficiently find the minimum k that satisfies the condition. This approach ensures that the solution is scalable and can handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect starts when the dagger hits and lasts for k seconds, dealing 1 damage per second. If another attack occurs during this period, the poison effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a loop or binary search to find the smallest k that satisfies this condition.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that meets the requirement.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the attack times.\n3. Implement a binary search for k:\n   - Set low = 1 and high = a_n - a_1 + 1 (maximum possible k).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage contributed by that attack.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n4. Output the value of low for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1.\n\n    Test case 2: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n    Test case 3: n = 100, h = 100, a = [1, 2, ..., 100] => k = 1\n    Explanation: With consecutive attacks and small h, k can be minimal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) needed to inflict at least h damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure output format matches requirements\n- Optimize for large input constraints\n- Test against edge cases\n- Document solution approach\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage inflicted by the poison can be calculated by summing the minimum of k and the difference between consecutive attack times. This allows us to check if a given k is sufficient to inflict at least h damage. By using binary search, we can find the smallest k that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect causes damage over a period of k seconds after each attack. If the dragon is already poisoned, the effect is refreshed.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage must be greater than or equal to h.\n    Implementation: Use a loop or binary search to find the smallest k that results in total damage >= h.\n\n# [degree adverb]\n    'smallest': means we need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize variables for binary search: low = 1, high = maximum possible k (e.g., h).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for current mid using the formula: sum(min(mid, a[i+1] - a[i])) + mid for last attack.\n        c. If total damage >= h, set high = mid - 1 (try smaller k).\n        d. Else, set low = mid + 1 (try larger k).\n    3. Return low as the minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: Only one attack is needed, and k = 1 is sufficient to inflict 1 damage.\n\n    Case 2: n = 2, h = 10, a = [1, 1000000000]\n    Expected output: 10\n    Explanation: The attacks are far apart, so k must be at least h to inflict enough damage.\n\n    Case 3: n = 100, h = 1000000000000000000, a = [1, 2, ..., 100]\n    Expected output: 1000000000000000000\n    Explanation: The dragon has extremely high hit points, requiring maximum poison duration.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect needed to inflict at least h damage to the dragon, given the attack times. The solution must efficiently handle large numbers and multiple test cases, ensuring accurate results.\nrequirement pool:\n- Calculate minimum poison duration for each test case.\n- Optimize algorithm for handling large input sizes.\n- Ensure output format is clear and concise.\n- Provide detailed comments in code for user understanding.\n- Include edge case handling for maximum input values.\nWe will use a binary search algorithm to efficiently determine the minimum poison duration k for each test case. This approach is suitable given the constraints, as it allows us to handle large input sizes and ensures optimal performance. The binary search will be applied over the possible values of k, checking if the total damage inflicted is at least h using a helper function to simulate the damage calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poisonous impact'\n    Explanation: The poison effect causes damage over a period of time after each attack, and it can be refreshed by subsequent attacks.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. Use a helper function to calculate total damage for a given k.\n    3. Perform binary search:\n        - Calculate mid-point k.\n        - Use helper function to check if total damage with k is at least h.\n        - Adjust search boundaries based on whether the condition is met.\n    4. Return the smallest k found.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case with attacks spaced far apart:\n    2 10\n    1 1000000000\n    Expected output: 10\n    Explanation: The poison effect must last long enough to accumulate at least 10 damage, requiring k=10.\n\n    Test case with maximum h:\n    1 1000000000000000000\n    1\n    Expected output: 1000000000000000000\n    Explanation: With only one attack, k must be equal to h to inflict the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the search boundaries based on the damage calculation.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 749, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "condense_two2one", "parent_index": 457}
