{"name": "1618_A. Polycarp and Sums of Subsequences", "description": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "tags": ["math", "sortings"], "difficulty": 7, "id": 1618, "sample_io": [{"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}], "test_list": [{"input": "1\n69696868 69696868 69696868 139393736 139393736 139393736 209090604\n", "output": ["69696868 69696868 69696868 \n"]}, {"input": "2\n1 1 2 69696874 69696875 69696875 69696876\n1 1 1 2 2 2 3\n", "output": ["1 1 69696874\n1 1 1\n"]}, {"input": "1\n1 1 2 69696880 69696881 69696881 69696882\n", "output": ["1 1 69696880\n"]}, {"input": "2\n1 1 2 69696967 69696968 69696968 69696969\n1 1 1 2 2 2 3\n", "output": ["1 1 69696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696868 69696869 69696869 69696870\n1 2 3 4 5 6 7\n", "output": ["1 1 69696868\n1 2 4\n"]}, {"input": "2\n1 1 2 696967 696968 696968 696969\n1 1 1 2 2 2 3\n", "output": ["1 1 696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696873 69696874 69696874 69696875\n1 1 1 2 2 2 3\n", "output": ["1 1 69696873\n1 1 1\n"]}, {"input": "2\n1 1 2 69696889 69696890 69696890 69696891\n1 1 1 2 2 2 3\n", "output": ["1 1 69696889\n1 1 1\n"]}, {"input": "1\n1 2 3 69696875 69696876 69696877 69696878\n", "output": ["1 2 69696875\n"]}, {"input": "2\n1 1 2 69696870 69696871 69696871 69696872\n1 1 1 2 2 2 3\n", "output": ["1 1 69696870\n1 1 1\n"]}, {"input": "2\n1 1 2 69696881 69696882 69696882 69696883\n1 1 1 2 2 2 3\n", "output": ["1 1 69696881\n1 1 1\n"]}, {"input": "2\n1 1 2 598989 598990 598990 598991\n1 3 4 4 5 7 8\n", "output": ["1 1 598989\n1 3 4\n"]}, {"input": "2\n1 1 2 69696875 69696876 69696876 69696877\n1 1 1 2 2 2 3\n", "output": ["1 1 69696875\n1 1 1\n"]}, {"input": "1\n1 1 2 69696884 69696885 69696885 69696886\n", "output": ["1 1 69696884\n"]}, {"input": "1\n1 1 2 69696883 69696884 69696884 69696885\n", "output": ["1 1 69696883\n"]}, {"input": "2\n1 1 2 69696885 69696886 69696886 69696887\n1 1 1 2 2 2 3\n", "output": ["1 1 69696885\n1 1 1\n"]}, {"input": "2\n1 1 2 69696879 69696880 69696880 69696881\n1 1 1 2 2 2 3\n", "output": ["1 1 69696879\n1 1 1\n"]}, {"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}, {"input": "2\n1 1 2 69696886 69696887 69696887 69696888\n1 1 1 2 2 2 3\n", "output": ["1 1 69696886\n1 1 1\n"]}, {"input": "2\n1 1 2 69696869 69696870 69696870 69696871\n1 1 1 2 2 2 3\n", "output": ["1 1 69696869\n1 1 1\n"]}, {"input": "2\n1 1 2 69696887 69696888 69696888 69696889\n1 1 1 2 2 2 3\n", "output": ["1 1 69696887\n1 1 1\n"]}, {"input": "2\n1 1 2 69696877 69696878 69696878 69696879\n1 1 1 2 2 2 3\n", "output": ["1 1 69696877\n1 1 1\n"]}, {"input": "2\n1 1 2 69696871 69696872 69696872 69696873\n1 1 1 2 2 2 3\n", "output": ["1 1 69696871\n1 1 1\n"]}, {"input": "2\n1 1 2 69696882 69696883 69696883 69696884\n1 1 1 2 2 2 3\n", "output": ["1 1 69696882\n1 1 1\n"]}, {"input": "1\n1 2 3 69696887 69696888 69696889 69696890\n", "output": ["1 2 69696887\n"]}, {"input": "2\n1 1 2 69696872 69696873 69696873 69696874\n1 1 1 2 2 2 3\n", "output": ["1 1 69696872\n1 1 1\n"]}, {"input": "2\n1 1 2 69696878 69696879 69696879 69696880\n1 1 1 2 2 2 3\n", "output": ["1 1 69696878\n1 1 1\n"]}], "task_id": "codecontest/132", "prompt": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Your task is to deduce the original array a from the given array b.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "repair_prompt": ["Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Your task is to deduce the original array a from the given array b.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. Then he sorted these numbers to get an array. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Your task is to deduce the original array a from the given array b.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "Polycarp had an array a of 3 positive integers, and he wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Your task is to deduce the original array a from the given array b.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef deduce_original_array(test_cases: List[List[int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Deduce the original array 'a' from the given array 'b' for each test case.\n\n    Args:\n        test_cases: A list of test cases, each containing an array 'b' of 7 integers.\n\n    Returns:\n        A list of tuples, each containing the deduced array 'a' of 3 integers.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in 'b' is the smallest element in 'a'\n        a1 = b[0]\n        # The second smallest element in 'b' is the second smallest element in 'a'\n        a2 = b[1]\n        # The largest element in 'b' is the sum of all elements in 'a'\n        sum_a = b[-1]\n        # Deduce the third element of 'a' by subtracting the first two elements from the sum\n        a3 = sum_a - a1 - a2\n        results.append((a1, a2, a3))\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_cases = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(num_cases)]\n    results = deduce_original_array(test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef deduce_original_array(b: List[int]) -> List[int]:\n    \"\"\"Deduces the original array of three integers from the given sorted sums of all non-empty subsequences.\n\n    Args:\n        b (List[int]): A list of 7 integers representing the sorted sums of all non-empty subsequences.\n\n    Returns:\n        List[int]: A list of 3 integers representing the original array.\n    \"\"\"\n    # The smallest three numbers in the sorted array b are the individual elements of the original array a.\n    # The largest number in array b is the sum of all three elements of array a.\n    a1 = b[0]\n    a2 = b[1]\n    a3 = b[6] - a1 - a2\n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        b = list(map(int, input().split()))\n        result = deduce_original_array(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef restore_original_array(test_cases: List[List[int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Restore the original array from the sorted sums of its non-empty subsequences.\n\n    Args:\n        test_cases: A list of test cases, each containing a list of 7 integers.\n\n    Returns:\n        A list of tuples, each containing 3 integers representing the original array.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest three numbers in b are the individual elements of the original array a.\n        a1 = b[0]\n        a2 = b[1]\n        a3 = b[6] - (a1 + a2)  # The largest number in b is the sum of all three elements of a.\n        results.append((a1, a2, a3))\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(n)]\n    results = restore_original_array(test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef deduce_original_array(test_cases: List[List[int]]) -> List[List[int]]:\n    \"\"\"Deduces the original array 'a' from the given sorted array 'b' of sums of all non-empty subsequences.\n\n    Args:\n        test_cases: A list of test cases, each containing a list of 7 integers representing the array 'b'.\n\n    Returns:\n        A list of lists, where each inner list contains 3 integers representing the deduced array 'a'.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest three numbers in 'b' are the individual elements of 'a'\n        a1 = b[0]\n        a2 = b[1]\n        # The largest number in 'b' is the sum of all three elements of 'a'\n        sum_a = b[-1]\n        # Calculate the third element of 'a'\n        a3 = sum_a - a1 - a2\n        # Append the result for this test case\n        results.append([a1, a2, a3])\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_cases = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(num_cases)]\n    results = deduce_original_array(test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef deduce_original_array(t: int, test_cases: List[List[int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Deduces the original array a from the given sorted array b for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing 7 integers.\n\n    Returns:\n        List[Tuple[int, int, int]]: A list of tuples, each containing the deduced original array a.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The largest number in b is the sum of all three numbers in a\n        sum_all = b[-1]\n        \n        # The smallest, second smallest, and third smallest numbers in b are potential elements of a\n        a1 = b[0]\n        a2 = b[1]\n        a3 = sum_all - a1 - a2\n        \n        # Append the deduced array a to the results\n        results.append((a1, a2, a3))\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read number of test cases\n    n = int(data[0])\n    \n    # Read each test case\n    test_cases = [list(map(int, line.split())) for line in data[1:n+1]]\n    \n    # Get the results\n    results = deduce_original_array(n, test_cases)\n    \n    # Print the results\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef deduce_original_array(b: List[int]) -> List[int]:\n    \"\"\"Deduces the original array of three integers from the given sorted sums.\n\n    Args:\n        b (List[int]): A list of 7 integers representing the sorted sums of all non-empty subsequences\n                       of the original array of three integers.\n\n    Returns:\n        List[int]: The original array of three integers.\n    \"\"\"\n    # The largest number in b is the sum of all three numbers in the original array a.\n    sum_all = b[-1]\n    \n    # The smallest number in b is one of the original numbers.\n    a1 = b[0]\n    \n    # The second smallest number in b is another original number.\n    a2 = b[1]\n    \n    # The third original number can be deduced by subtracting the first two from the total sum.\n    a3 = sum_all - a1 - a2\n    \n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    n = int(input())\n    for _ in range(n):\n        b = list(map(int, input().split()))\n        result = deduce_original_array(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef deduce_original_array(test_cases: List[List[int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Deduces the original array 'a' from the given array 'b' for each test case.\n\n    Args:\n        test_cases: A list of test cases, where each test case is a list of 7 integers\n                    representing the sorted sums of all non-empty subsequences of 'a'.\n\n    Returns:\n        A list of tuples, where each tuple contains three integers representing the\n        deduced original array 'a'.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # Deduce the original array 'a' using the properties of the sorted subsequence sums\n        a1 = b[0]  # The smallest element in 'b' is the smallest element in 'a'\n        a2 = b[6] - b[5]  # The difference between the largest and second largest sums\n        a3 = b[6] - a1 - a2  # The remaining element\n        results.append((a1, a2, a3))\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_cases = int(input().strip())\n    test_cases = [list(map(int, input().strip().split())) for _ in range(num_cases)]\n    \n    results = deduce_original_array(test_cases)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef deduce_original_array(test_cases: List[List[int]]) -> List[List[int]]:\n    \"\"\"Deduces the original array of three integers from the given sorted array of sums of all non-empty subsequences.\n\n    Args:\n        test_cases: A list of test cases, each containing a list of 7 integers.\n\n    Returns:\n        A list of lists, where each inner list contains the three deduced integers.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in b is one of the original integers\n        a1 = b[0]\n        # The largest element in b is the sum of all three original integers\n        sum_all = b[-1]\n        # Deduce the other two integers\n        # a2 + a3 = sum_all - a1\n        # a2 = b[1] - a1\n        # a3 = sum_all - a1 - a2\n        a2 = b[1] - a1\n        a3 = sum_all - a1 - a2\n        results.append([a1, a2, a3])\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_cases = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(num_cases)]\n    results = deduce_original_array(test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef deduce_original_array(t: int, test_cases: list[list[int]]) -> list[list[int]]:\n    \"\"\"Deduces the original array of three integers from the given sorted array of sums of all non-empty subsequences.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (list[list[int]]): A list of test cases, each containing a list of 7 integers.\n\n    Returns:\n        list[list[int]]: A list of results, each containing the deduced original array of three integers.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in b is one of the original integers\n        a1 = b[0]\n        # The largest element in b is the sum of all three original integers\n        sum_all = b[6]\n        # The second smallest element in b is the sum of two of the original integers\n        sum_two = b[1]\n        # Deduce the second integer\n        a2 = sum_two - a1\n        # Deduce the third integer\n        a3 = sum_all - a1 - a2\n        # Append the result\n        results.append([a1, a2, a3])\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(t)]\n    results = deduce_original_array(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef deduce_original_array(test_cases: List[List[int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Deduce the original array 'a' from the given sorted array 'b' of sums of all non-empty subsequences.\n\n    Args:\n        test_cases: A list of test cases, each containing a list of 7 integers representing the sorted array 'b'.\n\n    Returns:\n        A list of tuples, each containing 3 integers representing the deduced original array 'a'.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest three numbers in 'b' are the individual elements of 'a'\n        a1 = b[0]\n        a2 = b[1]\n        # The largest number in 'b' is the sum of all three elements of 'a'\n        a3 = b[-1] - a1 - a2\n        results.append((a1, a2, a3))\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_cases = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(num_cases)]\n    \n    results = deduce_original_array(test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires deducing the original array of three integers from a sorted array of sums of all non-empty subsequences. The key is to identify the smallest, second smallest, and largest elements in the sorted array b, which correspond to the individual elements of array a and their combinations.\nrequirement pool:\n- Implement the main logic to deduce array a from array b.\n- Ensure the solution handles up to 5000 test cases efficiently.\n- Optimize the solution for large integer values in array b.\n- Provide clear and concise output formatting.\n- Include comments and documentation for maintainability.\nWe will deduce the original array 'a' from the given array 'b' by leveraging the properties of the sums of subsequences. The smallest element in 'b' is the smallest element of 'a'. The second smallest element in 'b' is the second smallest element of 'a'. The largest element in 'b' is the sum of all elements in 'a'. Using these properties, we can efficiently reconstruct 'a'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'array a of 3 positive integers'\n    Explanation: The original array 'a' consists of exactly three positive integers.\n\n    'sums of all non-empty subsequences'\n    Explanation: A subsequence is any sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For an array of 3 elements, there are 7 non-empty subsequences.\n\n# [phrase showing quantity relationship]\n    'non-decreasing order'\n    Explanation: The array 'b' is sorted in a way that each element is greater than or equal to the previous one.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Identify the smallest element in 'b', which corresponds to the smallest element in 'a'.\n2. Identify the second smallest element in 'b', which corresponds to the second smallest element in 'a'.\n3. Identify the largest element in 'b', which is the sum of all elements in 'a'.\n4. Deduce the third element of 'a' by subtracting the first two elements from the largest element.\n\n# [edge case]\n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are the same, so the original array consists of three identical elements.\n\n    b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest element is 1, the second smallest is 2, and the sum of all elements is 7. The third element is deduced as 7 - (1 + 2) = 4.\n\n    b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = 1000000000 1000000000 1000000000\n    Explanation: All elements are large but identical, so the original array consists of three identical large numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of identifying the smallest and largest elements and deducing the third element will naturally handle these cases.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from the given sorted sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases and large integer values, ensuring the output is correct and formatted as specified.\nrequirement pool:\n- Implement the main logic to deduce the original array from the given subsequence sums.\n- Ensure the solution can handle the maximum constraints effectively.\n- Optimize the solution for performance with large input sizes.\n- Provide a clear and concise output format for easy verification.\n- Include error handling for unexpected input formats.\nWe will implement a function that deduces the original array of three integers from the given sorted sums of all non-empty subsequences. The key observation is that the smallest three numbers in the sorted array b are the individual elements of the original array a, and the largest number is the sum of all three elements. This allows us to directly deduce the original array from the given array b.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements. Non-empty means that the subsequence must contain at least one element.\n\n    'sorted in non-decreasing order'\n    Explanation: The array b is sorted such that each element is less than or equal to the next element.\n\n# [phrase showing quantity relationship]\n    '3 positive integers': The array a consists of exactly three integers, each greater than zero.\n    \n    '7 integers': The array b consists of exactly seven integers.\n\n# [degree adverb] \n    'largest': Refers to the largest number in array b, which is the sum of all three elements of array a.\n\n# [code logic]\n1. Identify the smallest three numbers in the sorted array b. These represent the individual elements of the original array a.\n2. The largest number in array b is the sum of all three elements of array a.\n3. Use these observations to deduce the original array a.\n\n# [edge case] \n    Case 1: b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are the same, so the original array a consists of three identical numbers.\n    \n    Case 2: b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest three numbers are 1, 2, and 3. The largest number is 7, which is the sum of all three elements.\n    \n    Case 3: b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = 1000000000 1000000000 1000000000\n    Explanation: All elements are large and identical, so the original array a consists of three identical large numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of identifying the smallest three numbers and using the largest number as their sum inherently handles these cases.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from the sorted sums of its non-empty subsequences. The solution must efficiently handle up to 5000 test cases, ensuring scalability and correctness. The output format must strictly adhere to the specified requirements.\nrequirement pool:\n- Efficiently deduce the original array from the given subsequence sums.\n- Ensure the solution is scalable to handle up to 5000 test cases.\n- Provide clear and accurate output for each test case.\n- Handle large numbers efficiently.\n- Maintain simplicity in implementation.\nWe will use a simple mathematical approach to deduce the original array from the given sorted sums of its non-empty subsequences. The key observation is that the smallest three numbers in the sorted array b correspond to the individual elements of the original array a. The largest number in b is the sum of all three elements of a. This approach is efficient and scalable, handling up to 5000 test cases with large numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed without changing the order of the remaining elements. Non-empty subsequences mean that at least one element is present in each subsequence.\n\n    'sorted in non-decreasing order'\n    Explanation: The array b is sorted such that each element is greater than or equal to the previous element.\n\n# [phrase showing quantity relationship]\n    'sum of all non-empty subsequences'\n    Explanation: This refers to the sum of elements in each possible non-empty subsequence of the array a. In code, this means calculating all possible sums of combinations of elements from a.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Identify the smallest three numbers in the sorted array b, which correspond to the individual elements of the original array a.\n    2. The largest number in b is the sum of all three elements of a.\n    3. Use these observations to deduce the values of a_1, a_2, and a_3.\n    4. For each test case, extract the first, second, and third smallest numbers from b as a_1, a_2, and a_3 respectively.\n    5. Print these values for each test case.\n\n# [edge case]\n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are the same, so the original array consists of three identical elements.\n\n    b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest three numbers are 1, 2, and 3. The largest number is the sum of all three elements.\n\n    b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = 1000000000 1000000000 1000000000\n    Explanation: All elements are large and identical; hence the original array consists of three identical large numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of extracting the smallest three numbers and using them as the elements of array a will suffice.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from a sorted list of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases and large integer values, ensuring correct output for each test case.\nrequirement pool:\n- Implement the main logic to deduce the original array from the given sums.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize the solution for performance with large inputs.\n- Provide clear and correct output for each test case.\n- Include comprehensive test cases to validate the solution.\nWe will deduce the original array 'a' from the given sorted array 'b' of sums of all non-empty subsequences. The key observation is that the smallest three numbers in 'b' are the individual elements of 'a', and the largest number in 'b' is the sum of all three elements of 'a'. Therefore, the original array 'a' can be reconstructed by taking the smallest element, the second smallest element, and the difference between the largest element and the sum of the two smallest elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements. Non-empty means that the subsequence must contain at least one element.\n\n    'sorted in non-decreasing order'\n    Explanation: The array 'b' is sorted such that each element is greater than or equal to the previous one.\n\n# [phrase showing quantity relationship]\n    '3 positive integers': The array 'a' consists of exactly three integers, each greater than zero.\n    \n    '7 integers': The array 'b' consists of exactly seven integers, which are the sums of all non-empty subsequences of 'a'.\n\n# [degree adverb]\n    'largest': Refers to the largest number in the array 'b', which is the sum of all three elements of 'a'.\n\n# [code logic]\n1. For each test case, read the array 'b' of 7 integers.\n2. Identify the smallest three numbers in 'b', which correspond to the individual elements of 'a'.\n3. Identify the largest number in 'b', which is the sum of all three elements of 'a'.\n4. Calculate the third element of 'a' by subtracting the sum of the two smallest elements from the largest element.\n5. Return the three elements as the reconstructed array 'a'.\n\n# [edge case]\n    b = [1, 1, 1, 2, 2, 2, 3] = a = [1, 1, 1]\n    Explanation: All elements in 'a' are the same, and their sums form a repetitive pattern in 'b'.\n\n    b = [1, 2, 3, 4, 5, 6, 7] = a = [1, 2, 4]\n    Explanation: The elements in 'a' are distinct and form a simple increasing sequence.\n\n    b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = a = [1000000000, 1000000000, 1000000000]\n    Explanation: All elements in 'a' are large and equal, leading to large sums in 'b'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of identifying the smallest three numbers and using them to reconstruct 'a' will handle these cases correctly.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from a sorted array of sums of its non-empty subsequences. The solution must efficiently handle up to 5000 test cases, each with large integer values, and produce the correct output format.\nrequirement pool:\n- Implement the main algorithm to deduce array a from array b.\n- Ensure the solution handles up to 5000 test cases efficiently.\n- Optimize the algorithm for large integer values.\n- Provide clear and correct output formatting.\n- Include comments and documentation for better understanding.\nWe will implement a simple function to deduce the original array a from the given sorted array b. The key observation is that the largest number in b is the sum of all three numbers in a. The smallest number in b is one of the numbers in a. The second smallest number in b is another number in a. The third smallest number in b is the third number in a. This approach is efficient and straightforward, allowing us to handle up to 5000 test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where elements are selected without changing their order. Non-empty means that the subsequence must contain at least one element.\n\n    'sorted in non-decreasing order'\n    Explanation: The array b is sorted such that each element is greater than or equal to the previous element.\n\n# [phrase showing quantity relationship]\n    'sum of all three numbers'\n    Explanation: The largest number in array b is the sum of all three numbers in array a. This can be implemented by identifying the largest number in b and using it to deduce the sum of a_1, a_2, and a_3.\n\n# [degree adverb]\n    'largest'\n    Explanation: The largest number in array b represents the sum of all elements in array a. This can be implemented by selecting the last element in the sorted array b.\n\n# [code logic]\n    1. For each test case, read the array b.\n    2. Identify the smallest, second smallest, and third smallest numbers in b as potential elements of array a.\n    3. Identify the largest number in b as the sum of all elements in a.\n    4. Deduce the original array a using these observations.\n    5. Print the deduced array a for each test case.\n\n# [edge case]\n    Input: 1 1 1 2 2 2 3\n    Output: 1 1 1\n    Explanation: All elements are identical, and their sum matches the largest number in b.\n\n    Input: 1 1 2 999999998 999999999 999999999 1000000000\n    Output: 999999998 1 1\n    Explanation: The largest number is the sum of all elements, and the smallest numbers are part of a.\n\n    Input: 300000000 300000000 300000000 600000000 600000000 600000000 900000000\n    Output: 300000000 300000000 300000000\n    Explanation: All elements are identical, and their sum matches the largest number in b.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of identifying the smallest, second smallest, and third smallest numbers along with the largest number as the sum will handle these cases correctly.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from the given sorted sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases and large integer values, ensuring correct and formatted output for each test case.\nrequirement pool:\n- Implement the main algorithm to deduce the original array from the given sums.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize the solution for speed and clarity.\n- Provide clear and correct output for each test case.\n- Include comments and documentation for better understanding.\nWe will implement a simple function to deduce the original array from the given sorted sums. The key observation is that the largest number in the array b is the sum of all three numbers in the original array a. The smallest number in b is one of the original numbers. The second smallest number in b is another original number. The third smallest number in b is the third original number. This approach is efficient and handles the constraints effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed without changing the order of the remaining elements. Non-empty subsequences mean that at least one element is present in each subsequence.\n\n    'sorted in non-decreasing order'\n    Explanation: The array b is sorted such that each element is greater than or equal to the previous element.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    No degree adverb in the requirement.\n\n# [code logic]\n    1. The largest number in array b is the sum of all three numbers in array a.\n    2. The smallest number in array b is one of the original numbers in array a.\n    3. The second smallest number in array b is another original number in array a.\n    4. The third smallest number in array b is the third original number in array a.\n    5. Return these three numbers as the original array a.\n\n# [edge case]\n    Input: 1 1 1 2 2 2 3\n    Output: 1 1 1\n    Explanation: All numbers are the same, and their sums are repeated, but the logic still holds as the largest number is the sum of all three numbers.\n\n    Input: 1 1 2 2 3 3 4\n    Output: 1 2 1\n    Explanation: The smallest numbers are used to deduce the original array, and the largest number confirms the sum.\n\n    Input: 1000000000 1000000000 1000000000 2000000000 2000000000 2000000000 3000000000\n    Output: 1000000000 1000000000 1000000000\n    Explanation: Large numbers are handled similarly, with repeated sums confirming the original numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases effectively by using the sorted nature of array b and its constraints.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from a given sorted array of sums of all non-empty subsequences. The solution must handle up to 5000 test cases efficiently, ensuring that the output is correct and formatted as specified. The constraints guarantee that a valid solution exists for each test case.\nrequirement pool:\n- Implement the main logic to deduce array a from array b.\n- Ensure the solution handles up to 5000 test cases efficiently.\n- Optimize the solution for large integer values.\n- Provide clear and formatted output for each test case.\n- Consider edge cases and validate input constraints.\nWe will deduce the original array 'a' from the given array 'b' by leveraging the properties of sums of subsequences. Since 'b' is sorted and contains sums of all non-empty subsequences of 'a', the smallest element in 'b' is the smallest element in 'a'. The largest element in 'b' is the sum of all elements in 'a'. The second largest element in 'b' is the sum of the two largest elements in 'a'. By using these properties, we can efficiently reconstruct 'a'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: This refers to all possible combinations of elements from the array 'a' that can be formed without leaving any element out, except for the empty set. For an array of 3 elements, there are 7 such subsequences.\n\n    'sorted in non-decreasing order'\n    Explanation: The array 'b' is sorted such that each element is less than or equal to the next, which helps in identifying the smallest and largest sums.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    'smallest': The smallest element in 'b' corresponds to the smallest element in 'a'.\n    'largest': The largest element in 'b' corresponds to the sum of all elements in 'a'.\n\n# [code logic]\n1. Identify the smallest element in 'b', which corresponds to the smallest element in 'a'.\n2. Identify the largest element in 'b', which is the sum of all elements in 'a'.\n3. Identify the second largest element in 'b', which is the sum of the two largest elements in 'a'.\n4. Deduce the three elements of 'a' using these properties:\n   - a_1 = b[0] (smallest element)\n   - a_2 = b[6] - b[5] (difference between largest and second largest sums)\n   - a_3 = b[6] - a_1 - a_2 (remaining element)\n\n# [edge case]\n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are the same, so each subsequence sum is a multiple of that element.\n    \n    b = [1, 2, 3, 4, 5, 6, 7] = 4 1 2\n    Explanation: The smallest element is 1, and the largest sum is 7. The second largest sum is 6, which helps deduce the other two elements.\n    \n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = 300000000 300000000 300000000\n    Explanation: All elements are equal, so each subsequence sum is a multiple of that element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios by leveraging sorted properties and sum relationships.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from a sorted array of sums of all non-empty subsequences. The solution must handle multiple test cases efficiently and ensure the output format is correct. Given constraints ensure that a valid solution exists for each test case.\nrequirement pool:\n- Implement the main algorithm to deduce the original array.\n- Ensure the solution handles large numbers efficiently.\n- Optimize the solution for performance across all test cases.\n- Validate the output format for correctness.\n- Provide clear documentation for the solution.\nWe will deduce the original array of three integers from the given sorted array of sums of all non-empty subsequences. The key observation is that the smallest element in the array b is one of the original integers, and the largest element is the sum of all three original integers. By using these observations, we can efficiently reconstruct the original array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements. Non-empty means that the subsequence must contain at least one element.\n\n    'sorted in non-decreasing order'\n    Explanation: The array b is sorted such that each element is greater than or equal to the previous one.\n\n# [phrase showing quantity relationship]\n    '3 positive integers': The original array a consists of three integers, each greater than zero.\n    \n    '7 integers': The array b contains exactly seven integers, which are the sums of all non-empty subsequences of array a.\n\n# [degree adverb]\n    'largest': The largest integer in array b is the sum of all three integers in array a.\n\n# [code logic]\n1. For each test case, read the array b of 7 integers.\n2. Identify the smallest integer in b, which corresponds to one of the original integers in a.\n3. Identify the largest integer in b, which is the sum of all three integers in a.\n4. Use the smallest and largest values to deduce the other two integers by considering the possible sums that can be formed.\n5. Return the three integers as the reconstructed array a.\n\n# [edge case]\n    1 3 4 4 5 7 8 = 1 4 3\n    Explanation: The smallest number is 1, and the largest number is 8. The other numbers can be deduced by considering possible sums: 1 + 4 = 5, 1 + 3 = 4, and 4 + 3 = 7.\n\n    1 2 2 3 3 4 5 = 1 2 2\n    Explanation: The smallest number is 1, and the largest number is 5. The other numbers can be deduced by considering possible sums: 1 + 2 = 3, and two occurrences of 2 indicate it is part of the original array.\n\n    300000000 300000000 300000000 600000000 600000000 600000000 900000000 = 300000000 300000000 300000000\n    Explanation: All numbers are either the same or their sums, indicating that all original numbers are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of identifying the smallest and largest numbers and deducing the others based on possible sums will naturally handle these cases.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from a sorted array of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases and large integer values, ensuring the output format is consistent and clear.\nrequirement pool:\n- Efficiently deduce the original array from the given array\n- Ensure the solution is scalable for multiple test cases\n- Handle large integer values efficiently\n- Provide clear and accurate output for each test case\n- Optimize computational resources\nWe will deduce the original array of three integers from the given sorted array of sums of all non-empty subsequences. The key observation is that the smallest element in the sorted array b is one of the original integers, and the largest element is the sum of all three integers. By using these observations, we can efficiently reconstruct the original array. We will use simple arithmetic operations to derive the original integers from the given array b.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed without changing the order of the remaining elements. Non-empty subsequences mean that at least one element is present in each subsequence.\n\n    'sorted in non-decreasing order'\n    Explanation: The array b is sorted such that each element is greater than or equal to the previous element.\n\n# [phrase showing quantity relationship]\n    'sum of all non-empty subsequences'\n    Explanation: This refers to the sum of elements in each possible non-empty subsequence of the array a. In code, this means calculating all possible sums of combinations of elements from a.\n\n# [degree adverb]\n    'largest'\n    Explanation: The largest integer in array b represents the sum of all three integers in array a.\n\n# [code logic]\n    1. Identify the smallest element in array b, which corresponds to one of the integers in array a.\n    2. Identify the largest element in array b, which corresponds to the sum of all three integers in array a.\n    3. Use the second smallest and second largest elements in array b to deduce the other two integers in array a.\n    4. Return the three integers as the original array a.\n\n# [edge case]\n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are identical, so the original array consists of three identical integers.\n    \n    b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest element is 1, and the largest is 7. The second smallest and second largest help deduce the other two integers.\n    \n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = 300000000 300000000 300000000\n    Explanation: All elements are multiples of a large number, indicating identical integers in array a.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of identifying smallest and largest elements and using arithmetic operations will suffice.\n", "requirement analysis:\nThe task requires deducing the original array of three integers from the given sorted sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases, each with large integer values. The output must strictly follow the specified format.\nrequirement pool:\n- Implement the main algorithm to deduce the original array from the subsequence sums.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the output format is correct and matches the requirements.\n- Test the solution with various edge cases to ensure accuracy.\n- Document the code for better understanding and maintenance.\nWe will deduce the original array 'a' from the given sorted array 'b' of sums of all non-empty subsequences. The key observation is that the smallest three numbers in 'b' are the individual elements of 'a', and the largest number in 'b' is the sum of all three elements of 'a'. Thus, we can directly deduce 'a' by taking the smallest, second smallest, and the difference between the largest and the sum of the smallest two numbers in 'b'. This approach is efficient and works within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed without changing the order of the remaining elements. Non-empty means that at least one element is present in the subsequence.\n\n    'sorted in non-decreasing order'\n    Explanation: The array 'b' is sorted such that each element is greater than or equal to the previous element.\n\n# [phrase showing quantity relationship]\n    'sum of all non-empty subsequences'\n    Explanation: This refers to the sum of elements in each possible non-empty subsequence of the array 'a'. In code, this means calculating all possible sums of combinations of elements from 'a'.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the sorted array 'b' of 7 integers.\n    2. Identify the smallest three numbers in 'b' as the individual elements of 'a'.\n    3. The largest number in 'b' is the sum of all three elements of 'a'.\n    4. Deduce the third element of 'a' by subtracting the sum of the smallest two numbers from the largest number in 'b'.\n    5. Output the three deduced integers as the array 'a'.\n\n# [edge case]\n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are identical, so the original array consists of three identical numbers.\n    \n    b = [1, 2, 3, 4, 5, 6, 7] = 4 1 2\n    Explanation: The smallest three numbers are 1, 2, and 3. The largest number is 7, which is the sum of all three elements. Thus, a = [4, 1, 2].\n    \n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = 300000000 300000000 300000000\n    Explanation: All elements are identical and large. The original array consists of three identical large numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for deducing the array 'a' from 'b' inherently handles these cases correctly.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 995, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "mutate_method": "add_1_sentence_at_end", "parent_index": 43}
