{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with n rows and m columns of blocks, measuring n \u00d7 m. Each block of the rectangle can either be an obsidian block or vacant. CQXYM has the ability to switch an obsidian block to a vacant block or vice versa in a single operation. \n\nA rectangle M with dimensions a \u00d7 b is deemed a portal if it fulfills the following criteria:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nBe aware that the rectangle should have a rows and b columns. It should not have b rows and a columns, and corners can be any type.\n\nCQXYM is eager to determine the smallest number of modifications required to convert at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with n rows and m columns of blocks, measuring n \u00d7 m. Each block of the rectangle can either be an obsidian block or vacant. CQXYM has the ability to switch an obsidian block to a vacant block or vice versa in a single operation. \n\nA rectangle M with dimensions a \u00d7 b is deemed a portal if it fulfills the following criteria:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nBe aware that the rectangle should have a rows and b columns. It should not have b rows and a columns, and corners can be any type.\n\nCQXYM is eager to determine the smallest number of modifications required to convert at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with n rows and m columns of blocks, measuring n \u00d7 m. Each block of the rectangle can either be an obsidian block or vacant. CQXYM has the ability to switch an obsidian block to a vacant block or vice versa in a single operation. \n\nA rectangle M with dimensions a \u00d7 b is deemed a portal if it fulfills the following criteria:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nBe aware that the rectangle should have a rows and b columns. A rectangle with b rows and a columns does not fit the criteria and should not be considered. Corners can be any type.\n\nCQXYM is eager to determine the smallest number of modifications required to convert at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with n rows and m columns of blocks, measuring n \u00d7 m, where each block can either be an obsidian block or vacant, and CQXYM has the ability to switch an obsidian block to a vacant block or vice versa in a single operation. \n\nA rectangle M with dimensions a \u00d7 b is deemed a portal if it fulfills the following criteria:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nBe aware that the rectangle should have a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM is eager to determine the smallest number of modifications required to convert at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\nimport numpy as np\n\ndef min_modifications_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of modifications required for each test case to form a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum modifications for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate modifications needed for current sub-rectangle\n                        modifications = calculate_modifications(matrix, start_row, start_col, end_row, end_col)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of modifications needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The grid represented as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of modifications needed\n    \"\"\"\n    modifications = 0\n\n    # Check borders for obsidian blocks\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            modifications += 1\n        if matrix[row, end_col] != 1:\n            modifications += 1\n\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            modifications += 1\n        if matrix[end_row, col] != 1:\n            modifications += 1\n\n    # Check inner blocks for vacant blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                modifications += 1\n\n    return modifications\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_modifications_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_modifications_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of modifications required to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum modifications required for each test case.\n    \"\"\"\n    def calculate_modifications(grid: List[str], n: int, m: int) -> int:\n        \"\"\"Calculate the minimum modifications needed for a single grid.\n\n        Args:\n            grid (List[str]): Grid of blocks.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n\n        Returns:\n            int: Minimum number of modifications required.\n        \"\"\"\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        modifications = 0\n\n                        # Check the borders and inner blocks\n                        for i in range(start_row, end_row + 1):\n                            for j in range(start_col, end_col + 1):\n                                if i == start_row or i == end_row or j == start_col or j == end_col:\n                                    # Border conditions\n                                    if (i == start_row or i == end_row) and (j > start_col and j < end_col):\n                                        if grid[i][j] != '1':\n                                            modifications += 1\n                                    elif (j == start_col or j == end_col) and (i > start_row and i < end_row):\n                                        if grid[i][j] != '1':\n                                            modifications += 1\n                                else:\n                                    # Inner block conditions\n                                    if grid[i][j] != '0':\n                                        modifications += 1\n\n                        # Update the minimum modifications found\n                        min_modifications = min(min_modifications, modifications)\n\n        return min_modifications\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        result = calculate_modifications(test_case, n, m)\n        results.append(result)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_modifications_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        if n < 5 or m < 4:\n            results.append(\"Not applicable\")\n            continue\n\n        # Convert matrix to numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    :param grid: The numpy array representation of the matrix\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check borders for obsidian blocks\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            changes += 1\n        if grid[row, end_col] != 1:\n            changes += 1\n\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            changes += 1\n        if grid[end_row, col] != 1:\n            changes += 1\n\n    # Check inner blocks for vacant blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_modifications_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of modifications required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum modifications for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate modifications for the current sub-rectangle\n                        modifications = calculate_modifications(matrix, start_row, start_col, a, b)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of modifications needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The numpy array representing the grid\n    :param start_row: The starting row of the sub-rectangle\n    :param start_col: The starting column of the sub-rectangle\n    :param a: The number of rows in the sub-rectangle\n    :param b: The number of columns in the sub-rectangle\n    :return: The number of modifications needed\n    \"\"\"\n    modifications = 0\n\n    # Check the borders (except corners)\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] != 1:\n            modifications += 1\n        if matrix[start_row + x, start_col + b - 1] != 1:\n            modifications += 1\n\n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] != 1:\n            modifications += 1\n        if matrix[start_row + a - 1, start_col + y] != 1:\n            modifications += 1\n\n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] != 0:\n                modifications += 1\n\n    return modifications\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_modifications_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimum_modifications(t: int, test_cases: list) -> list:\n    \"\"\"Finds the minimum number of modifications required to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: A list of minimum modifications for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        modifications = calculate_modifications(sub_rect, a, b)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculates the number of modifications needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: The number of modifications required.\n    \"\"\"\n    modifications = 0\n\n    # Check the border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            modifications += 1\n        if sub_rect[x, b - 1] != 1:\n            modifications += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            modifications += 1\n        if sub_rect[a - 1, y] != 1:\n            modifications += 1\n\n    # Check the inner blocks for vacant blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                modifications += 1\n\n    return modifications\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_minimum_modifications(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\nimport numpy as np\n\ndef min_modifications_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of modifications needed to transform sub-rectangles into portals.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a matrix of blocks.\n\n    Returns:\n        List[int]: List of minimum modifications required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        matrix = np.array([list(row) for row in case], dtype=int)\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate modifications needed for current sub-rectangle\n                        modifications = calculate_modifications(matrix, start_row, start_col, end_row, end_col)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of modifications needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix of blocks.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of modifications needed.\n    \"\"\"\n    modifications = 0\n\n    # Check borders (except corners)\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            modifications += 1\n        if matrix[row, end_col] != 1:\n            modifications += 1\n\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            modifications += 1\n        if matrix[end_row, col] != 1:\n            modifications += 1\n\n    # Check inner blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                modifications += 1\n\n    return modifications\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append(matrix)\n\n# Output interface\nresults = min_modifications_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_modifications(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of modifications required to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum modifications required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        modifications = calculate_modifications(grid, i, j, a, b)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of modifications needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of modifications needed.\n    \"\"\"\n    modifications = 0\n\n    # Check the borders and inside of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            current_block = grid[start_row + x][start_col + y]\n            if x == 0 or x == a - 1:\n                if 1 <= y < b - 1 and current_block != '1':\n                    modifications += 1\n            elif y == 0 or y == b - 1:\n                if 1 <= x < a - 1 and current_block != '1':\n                    modifications += 1\n            else:\n                if current_block != '0':\n                    modifications += 1\n\n    return modifications\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_modifications(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_modifications_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of modifications needed to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing grid dimensions and grid data.\n\n    Returns:\n        list: List of minimum modification counts for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate modifications needed for current sub-rectangle\n                        modifications = calculate_modifications(grid_array, start_row, start_col, end_row, end_col)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of modifications needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of modifications needed.\n    \"\"\"\n    modifications = 0\n\n    # Check borders (except corners)\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            modifications += 1\n        if grid[row, end_col] != 1:\n            modifications += 1\n\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            modifications += 1\n        if grid[end_row, col] != 1:\n            modifications += 1\n\n    # Check inner blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                modifications += 1\n\n    return modifications\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of n, m and the grid\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_modifications_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_modifications_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of modifications required to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum modifications required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        modifications = calculate_modifications(grid, start_row, start_col, end_row, end_col)\n                        min_modifications = min(min_modifications, modifications)\n\n        results.append(min_modifications)\n\n    return results\n\ndef calculate_modifications(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of modifications needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of modifications required.\n    \"\"\"\n    modifications = 0\n\n    # Check the edges of the sub-rectangle\n    for row in range(start_row + 1, end_row):\n        if grid[row][start_col] != '1':\n            modifications += 1\n        if grid[row][end_col] != '1':\n            modifications += 1\n\n    for col in range(start_col + 1, end_col):\n        if grid[start_row][col] != '1':\n            modifications += 1\n        if grid[end_row][col] != '1':\n            modifications += 1\n\n    # Check the interior of the sub-rectangle\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row][col] != '0':\n                modifications += 1\n\n    return modifications\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_modifications_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_modifications_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of modifications needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, and the grid.\n\n    Returns:\n        List[int]: List of minimum modifications required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_modifications = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        modifications = 0\n\n                        # Check the border conditions for the portal\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] != '1':\n                                modifications += 1\n                            if grid[start_row + x][start_col + b - 1] != '1':\n                                modifications += 1\n\n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] != '1':\n                                modifications += 1\n                            if grid[start_row + a - 1][start_col + y] != '1':\n                                modifications += 1\n\n                        # Check the inner conditions for the portal\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] != '0':\n                                    modifications += 1\n\n                        # Update the minimum modifications found\n                        if modifications < min_modifications:\n                            min_modifications = modifications\n\n        results.append(min_modifications)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    results = min_modifications_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal modifications. The constraints on dimensions and block types are crucial for ensuring the portal's validity. The solution must efficiently handle multiple test cases and large input sizes while providing accurate results.\nrequirement pool:\n- Implement the main algorithm to find the minimum modifications.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear and concise output.\n- Validate portal formation accurately.\nWe will implement a function to determine the minimum number of modifications required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and to handle large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block arrangements. It must have obsidian blocks on its borders and vacant blocks inside, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This indicates that the dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions meeting these criteria.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of modifications required to transform a sub-rectangle into a portal.\n    Implementation: Use an algorithm to calculate and compare the number of modifications for each possible sub-rectangle, keeping track of the minimum.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of modifications needed to meet the portal criteria:\n        - Ensure borders are obsidian blocks.\n        - Ensure inner blocks are vacant.\n        - Allow corners to be any type.\n    4. Track the minimum number of modifications across all sub-rectangles for each test case.\n    5. Output the minimum number of modifications for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meets the portal criteria.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No modifications are needed as it already forms a portal.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Calculation based on converting all necessary blocks to obsidian.\n\n    Case 3: A rectangle with dimensions exactly matching the minimum required (5x4) but with incorrect block types.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Calculation based on converting all necessary blocks to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the rectangle already meets the portal criteria or has no obsidian blocks.\n        if is_portal(sub_rectangle):\n            return 0\n        # Additional logic to handle rectangles with no obsidian blocks or incorrect dimensions.\n", "requirement analysis:\nThe problem requires finding the minimum number of modifications to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The key challenge is ensuring the solution is both correct and performant.\nrequirement pool:\n- Implement the main algorithm to find the minimum modifications.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution is easy to understand and maintain.\n- Provide comprehensive test cases to validate the solution.\n- Document the code for clarity and future reference.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of modifications needed to transform it into a portal. The function will keep track of the minimum number of modifications required across all sub-rectangles. This approach ensures that we efficiently handle the constraints while maintaining clarity and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with rows and columns.\n    'obsidian block': A block represented by '1'.\n    'vacant block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range of rows within the portal.\n    'For all 1 < x < b': Indicates a range of columns within the portal.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of modifications needed to create a portal.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size at least 5x4 within the n x m grid.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting necessary modifications:\n        - Ensure the borders (except corners) are obsidian blocks.\n        - Ensure the inner blocks are vacant.\n    3. Track the minimum number of modifications required across all sub-rectangles.\n    4. Return the minimum modification count for each test case.\n\n# [edge case]\n    Case 1: A grid with exactly one possible portal configuration.\n    Explanation: The grid is already configured as a portal, requiring zero modifications.\n    \n    Case 2: A grid where all blocks are obsidian.\n    Explanation: Requires maximum modifications to convert inner blocks to vacant while maintaining border conditions.\n    \n    Case 3: A grid where all blocks are vacant.\n    Explanation: Requires maximum modifications to convert border blocks to obsidian while maintaining inner vacant conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through sub-rectangles and calculating modifications will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining valid portals. Efficient handling of multiple test cases and large matrices is essential.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations required\n- Optimize the solution for large matrices\n- Ensure the program can handle multiple test cases efficiently\n- Provide clear and concise output format\n- Develop error handling for invalid inputs\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block arrangements, where certain blocks must be obsidian and others vacant.\n\n    'obsidian block' and 'vacant block'\n    Explanation: These are the two types of blocks in the rectangle, represented by '1' for obsidian and '0' for vacant.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. This means any sub-rectangle considered must meet these minimum size requirements.\n    Implementation: Use loops to iterate over possible sub-rectangles starting from these minimum dimensions.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum number of modifications required to convert a sub-rectangle into a portal.\n    Implementation: Track the number of changes for each sub-rectangle and update the minimum count accordingly.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n       - Ensure the borders are obsidian blocks as required.\n       - Ensure the inner blocks are vacant.\n    4. Track the minimum number of changes across all sub-rectangles for each test case.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meets the portal criteria.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No modifications are needed as it already forms a portal.\n\n    Case 2: A rectangle with no possible portal formation due to insufficient dimensions.\n    Example:\n    Input:\n    1\n    4 3\n    111\n    101\n    101\n    111\n    Expected Output: Not applicable (since dimensions are less than required).\n\n    Case 3: A rectangle with all blocks vacant.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Number of changes needed to form a portal (calculate based on criteria).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where dimensions are less than required.\n        if n < 5 or m < 4:\n            print(\"Not applicable\")\n        else:\n            # Proceed with original logic to find minimum changes needed.\n", "requirement analysis:\nThe task requires identifying sub-rectangles within a given rectangle and transforming them into portals with minimal modifications. The constraints on dimensions and block types must be strictly adhered to, ensuring efficient computation even for large inputs.\nrequirement pool:\n- Implement efficient algorithm to find sub-rectangles\n- Ensure accurate transformation to portal\n- Optimize for large input sizes\n- Provide clear output format\n- Handle edge cases effectively\nWe will implement a function to find the minimum number of modifications required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and to handle large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A geometric shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria regarding the arrangement of obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates a range for x, meaning all rows except the first and last must have specific block types.\n    'For all 1 < x < b': This indicates a range for x, meaning all columns except the first and last must have specific block types.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of modifications required to convert a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of modifications needed to meet the portal criteria:\n        - Ensure the borders (except corners) are obsidian blocks.\n        - Ensure the inner blocks are vacant.\n    4. Track the minimum number of modifications required across all sub-rectangles for each test case.\n    5. Output the minimum number of modifications for each test case.\n\n# [edge case]\n    Case 1: A rectangle with exactly 5 rows and 4 columns, all blocks are obsidian.\n    Expected output: The number of modifications needed to convert inner blocks to vacant and ensure borders are obsidian.\n    Explanation: The entire rectangle needs to be modified except for the borders.\n\n    Case 2: A rectangle with dimensions larger than 5x4 but no possible portal configuration due to block arrangement.\n    Expected output: The minimum number of modifications needed to create a portal from any sub-rectangle.\n    Explanation: The function should still find the least modifications needed even if no perfect portal exists initially.\n\n    Case 3: A rectangle with dimensions exactly matching a portal configuration but with incorrect block types.\n    Expected output: The number of modifications needed to correct block types to match portal criteria.\n    Explanation: Only incorrect blocks need modification.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating modifications will inherently handle these cases.\n", "requirement analysis:\nThe problem requires identifying the minimum number of modifications to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must iterate over possible sub-rectangles and calculate the required changes while adhering to the portal criteria.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum modifications.\n- Ensure the solution handles edge cases and maximum constraints.\n- Optimize the algorithm for both small and large inputs.\n- Provide clear documentation and output format.\n- Implement additional features for user interaction.\nWe will use a brute-force approach to iterate over all possible sub-rectangles of size at least 5x4 within the given n x m rectangle. For each sub-rectangle, we will calculate the number of modifications needed to transform it into a portal. The solution will leverage numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A geometric shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria regarding the arrangement of obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range for x where the condition must be met.\n    'For all 1 < x < b': Indicates a range for x where the condition must be met.\n    'For all 1<x<a,1<y<b': Indicates a range for both x and y where the condition must be met.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of modifications required to convert a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of modifications needed.\n    4. Keep track of the minimum number of modifications required for each test case.\n    5. Output the minimum number of modifications for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    Explanation: The entire rectangle needs to be converted into a portal, requiring maximum modifications.\n\n    Test case with all blocks already forming a portal:\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: \n    Explanation: No modifications are needed as the rectangle already forms a portal.\n\n    Test case with alternating blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    Explanation: Requires significant modifications to form a portal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n        - Implement checks for minimum dimensions and ensure that the logic accounts for rectangles that are already portals or require maximum modifications.\n", "requirement analysis:\nThe task requires identifying sub-rectangles within a given matrix that can be transformed into portals with the least number of modifications. The constraints on dimensions and block types must be strictly adhered to, ensuring efficient computation even for large matrices.\nrequirement pool:\n- Implement efficient matrix traversal to identify potential portal areas.\n- Develop an algorithm to calculate the minimum modifications needed.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Provide clear output for each test case.\n- Optimize the code for performance improvements.\nWe will implement a function to efficiently traverse the matrix and identify potential sub-rectangles that can be transformed into portals. The function will calculate the minimum number of modifications needed by checking each possible sub-rectangle of size at least 5x4 and counting the number of changes required to meet the portal criteria. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'vacant block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure sub-rectangles considered are of size at least 5x4.\n    \n# [degree adverb]\n    'smallest': Refers to the minimum number of modifications required.\n    Implementation: Track the minimum number of changes needed across all sub-rectangles.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of modifications needed to meet the portal criteria:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are vacant.\n4. Track the minimum number of modifications required for each test case.\n5. Output the minimum number of modifications for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected output: 0\n    Explanation: The rectangle already meets the portal criteria, so no modifications are needed.\n\n    Test case with a rectangle filled entirely with obsidian blocks:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected output: 12\n    Explanation: All inner blocks need to be converted to vacant blocks, requiring a total of 12 modifications.\n\n    Test case with a rectangle filled entirely with vacant blocks:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: 12\n    Explanation: All border blocks (except corners) need to be converted to obsidian blocks, requiring a total of 12 modifications.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will naturally account for these scenarios by calculating the necessary modifications for any given sub-rectangle.\n", "requirement analysis:\nThe problem requires determining the minimum number of modifications to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be efficient to handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the necessary changes efficiently.\nrequirement pool:\n- Develop an algorithm to find the minimum modifications for a portal.\n- Optimize the solution for large input sizes.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear documentation and examples for users.\n- Implement a user-friendly interface for input and output.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of modifications required to convert it into a portal. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints are met. This approach is feasible given the constraints, as the maximum grid size is 400x400, and the sum of dimensions across all test cases does not exceed 400.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with rows and columns, where each cell can be either an obsidian block or vacant.\n    'portal': A specific sub-rectangle configuration within the grid that meets certain criteria.\n\nExplanation: The requirement involves identifying sub-rectangles within a larger grid and transforming them into a specific configuration called a portal, which has defined properties regarding the arrangement of obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'smallest number of modifications': The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal.\n\nExplanation: The requirement specifies minimum dimensions for the portal and aims to find the configuration with the least modifications needed.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of changes required to achieve the desired portal configuration.\n\nExplanation: The requirement seeks to minimize the number of operations needed to convert a sub-rectangle into a portal.\n\n# [code logic]\n1. Iterate over all possible sub-rectangles of size at least 5x4 within the given grid.\n2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of modifications needed.\n3. Ensure that the constraints for a portal are met (obsidian blocks on specified borders and vacant blocks inside).\n4. Track the minimum number of modifications across all sub-rectangles.\n5. Output the minimum number of modifications for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already configured as a portal.\n    Expected output: 0\n    Explanation: No modifications are needed as the grid already meets the portal criteria.\n\n    Case 2: A grid with no obsidian blocks.\n    Expected output: Number of modifications equal to filling all required obsidian positions.\n    Explanation: All positions that need obsidian blocks must be changed from vacant to obsidian.\n\n    Case 3: A grid with dimensions exactly 5x4 and random block configuration.\n    Expected output: Calculate based on specific block arrangement.\n    Explanation: The number of modifications will depend on how close the current configuration is to a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating modifications will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires determining the minimum number of modifications needed to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The problem involves checking sub-rectangles and counting necessary changes, which suggests a need for an optimized approach to avoid excessive computation.\nrequirement pool:\n- Develop an algorithm to find the minimum modifications for portal creation.\n- Ensure the solution is efficient for maximum input sizes.\n- Provide clear output for each test case.\n- Optimize the algorithm for speed and complexity balance.\n- Consider edge cases and ensure robustness.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of modifications needed to convert it into a portal. The solution will leverage numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with rows and columns.\n    'obsidian block': A block represented by '1'.\n    'vacant block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure sub-rectangles considered are at least 5x4 in size.\n    'smallest number of modifications': Minimize the number of changes needed to convert a sub-rectangle into a portal.\n    Implementation: Track and compare the number of modifications for each sub-rectangle.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of changes required.\n    Implementation: Use a variable to store the minimum number of modifications found.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be converted into a portal by counting necessary modifications:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are vacant.\n4. Track the minimum number of modifications needed for each test case.\n5. Output the minimum modification count for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    8\n    Explanation: The entire grid is obsidian, requiring conversion of inner blocks to vacant.\n\n    Test case with alternating blocks:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output:\n    12\n    Explanation: Alternating pattern requires significant changes to meet portal criteria.\n\n    Test case with already a portal:\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Output:\n    0\n    Explanation: The grid already meets portal criteria, no modifications needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all sub-rectangles and counting modifications will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum number of modifications to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The key challenge is to identify the optimal sub-rectangle and calculate the necessary changes.\nrequirement pool:\n- Develop an algorithm to find the minimum modifications for a portal.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution is easy to understand and maintain.\n- Test the solution against edge cases and maximum constraints.\n- Provide detailed documentation and examples.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of modifications required to transform it into a portal. The function will keep track of the minimum number of modifications needed across all sub-rectangles. This approach ensures that we efficiently handle the constraints while maintaining simplicity. We will use basic Python data structures and avoid complex libraries to keep the implementation straightforward.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with rows and columns, where each cell can be either an obsidian block or vacant.\n    'portal': A specific sub-rectangle configuration within the grid that meets certain criteria.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'smallest number of modifications': The goal is to minimize the number of changes needed to convert a sub-rectangle into a portal.\n\n# [degree adverb]\n    'smallest': Refers to the least number of changes required to achieve the desired portal configuration.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size at least 5x4 within the n x m grid.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of modifications needed.\n    3. Ensure that the edges of the sub-rectangle meet the obsidian block criteria, while the interior is vacant.\n    4. Keep track of the minimum number of modifications required across all sub-rectangles.\n    5. Return the minimum number of modifications for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already configured as a portal.\n    Explanation: No modifications are needed, so the expected output is 0.\n    \n    Case 2: A grid with no obsidian blocks.\n    Explanation: The entire portal needs to be formed, requiring maximum modifications.\n    \n    Case 3: A grid with dimensions exactly 5x4 and already configured as a portal except for corners.\n    Explanation: Only corner modifications might be needed, resulting in minimal changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through sub-rectangles and calculating modifications will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying the minimum number of changes needed to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must iterate over possible sub-rectangles and calculate the required changes while adhering to the portal conditions.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum modifications.\n- Ensure the solution handles edge cases and maximum constraints.\n- Optimize the algorithm for speed and memory usage.\n- Provide clear documentation and examples for users.\n- Implement additional features for user interaction and feedback.\nWe will use a brute-force approach to iterate over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of modifications needed to transform it into a portal. This involves checking the conditions for the portal and counting the mismatches. The solution will be optimized by breaking early if the number of modifications exceeds the current minimum found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with rows and columns.\n    'obsidian block': A block represented by '1'.\n    'vacant block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range of rows from 2 to a-1.\n    'For all 1 < x < b': Indicates a range of columns from 2 to b-1.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of modifications required.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size at least 5x4 within the n x m grid.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting mismatches.\n    3. Keep track of the minimum number of modifications required across all sub-rectangles.\n    4. Output the minimum number of modifications for each test case.\n\n# [edge case]\n    Case 1: A grid with exactly one possible portal configuration.\n    Explanation: The grid is already a portal, so no modifications are needed.\n    \n    Case 2: A grid where all blocks are obsidian.\n    Explanation: Maximum modifications are needed to create a portal with empty blocks inside.\n    \n    Case 3: A grid where all blocks are vacant.\n    Explanation: Maximum modifications are needed to create a portal with obsidian borders.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and counting mismatches will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 986, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "expand_one2two", "parent_index": 614}
