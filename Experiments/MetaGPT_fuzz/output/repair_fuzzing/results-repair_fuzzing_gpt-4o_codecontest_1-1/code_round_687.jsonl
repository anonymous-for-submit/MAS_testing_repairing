{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks on the first and last columns must be obsidian for every row in between.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks, where each block is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or vice versa in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing:\n        - n (int): Number of rows in the rectangle.\n        - m (int): Number of columns in the rectangle.\n        - grid (list of str): The grid representation of the rectangle.\n\n    Returns:\n    list: A list of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        matrix = np.array([[int(char) for char in row] for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_rectangle = matrix[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rectangle, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rectangle: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Parameters:\n    sub_rectangle (np.ndarray): The sub-rectangle to be transformed.\n    a (int): Number of rows in the sub-rectangle.\n    b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n    int: The number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and transform the borders\n    for x in range(1, a - 1):\n        if sub_rectangle[x, 0] != 1:\n            operations += 1\n        if sub_rectangle[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rectangle[0, y] != 1:\n            operations += 1\n        if sub_rectangle[a - 1, y] != 1:\n            operations += 1\n\n    # Check and transform the inner part\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rectangle[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a given sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param end_row: Ending row of the sub-rectangle\n    :param end_col: Ending column of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check the borders (except corners)\n    for i in range(start_row + 1, end_row):\n        if grid[i, start_col] == 0:\n            operations += 1\n        if grid[i, end_col] == 0:\n            operations += 1\n\n    for j in range(start_col + 1, end_col):\n        if grid[start_row, j] == 0:\n            operations += 1\n        if grid[end_row, j] == 0:\n            operations += 1\n\n    # Check the inner blocks\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i, j] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to form a portal in each test case.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient manipulation\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate the number of operations needed to transform this sub-rectangle into a portal\n                        operations = calculate_operations(sub_rect, a, b)\n                        \n                        # Update the minimum operations if the current one is smaller\n                        if operations < min_operations:\n                            min_operations = operations\n        \n        # Append the result for the current test case\n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n    \n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Check the borders (except corners) for obsidian blocks\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n    \n    # Check the inner blocks for empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_matrix = matrix[i:i+a, j:j+b]\n                        operations = calculate_operations(sub_matrix, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_matrix: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-matrix into a portal.\n\n    :param sub_matrix: The sub-matrix to be transformed\n    :param a: Number of rows in the sub-matrix\n    :param b: Number of columns in the sub-matrix\n    :return: Number of operations required\n    \"\"\"\n    operations = 0\n\n    # Ensure the first and last columns (except corners) are obsidian\n    for x in range(1, a - 1):\n        if sub_matrix[x, 0] != 1:\n            operations += 1\n        if sub_matrix[x, b - 1] != 1:\n            operations += 1\n\n    # Ensure the first and last rows (except corners) are obsidian\n    for y in range(1, b - 1):\n        if sub_matrix[0, y] != 1:\n            operations += 1\n        if sub_matrix[a - 1, y] != 1:\n            operations += 1\n\n    # Ensure all inner blocks are empty\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_matrix[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations needed for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n\n                        # Check the first and last columns of rows 2 to a-1\n                        for row in range(start_row + 1, end_row):\n                            if grid[row][start_col] != '1':\n                                operations += 1\n                            if grid[row][end_col] != '1':\n                                operations += 1\n\n                        # Check the first and last rows of columns 2 to b-1\n                        for col in range(start_col + 1, end_col):\n                            if grid[start_row][col] != '1':\n                                operations += 1\n                            if grid[end_row][col] != '1':\n                                operations += 1\n\n                        # Check all inner blocks (2 to a-1, 2 to b-1) are empty\n                        for row in range(start_row + 1, end_row):\n                            for col in range(start_col + 1, end_col):\n                                if grid[row][col] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a submatrix into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the matrix as a list of strings\n    :return: List of integers, each representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        matrix_np = np.array([[int(char) for char in row] for row in matrix])\n        min_changes = float('inf')\n\n        # Iterate over all possible submatrices of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of changes needed for the current submatrix\n                        changes = calculate_changes(matrix_np, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a submatrix into a portal.\n\n    :param matrix: The numpy array representing the matrix\n    :param start_row: The starting row of the submatrix\n    :param start_col: The starting column of the submatrix\n    :param a: The number of rows in the submatrix\n    :param b: The number of columns in the submatrix\n    :return: The number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check the first and last columns of rows 2 to a-1\n    for i in range(1, a - 1):\n        if matrix[start_row + i, start_col] != 1:\n            changes += 1\n        if matrix[start_row + i, start_col + b - 1] != 1:\n            changes += 1\n\n    # Check the first and last rows of columns 2 to b-1\n    for j in range(1, b - 1):\n        if matrix[start_row, start_col + j] != 1:\n            changes += 1\n        if matrix[start_row + a - 1, start_col + j] != 1:\n            changes += 1\n\n    # Check all inner blocks (2 \u2264 x < a, 2 \u2264 y < b) are empty\n    for i in range(1, a - 1):\n        for j in range(1, b - 1):\n            if matrix[start_row + i, start_col + j] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The grid as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check borders (except corners)\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            operations += 1\n        if matrix[row, end_col] != 1:\n            operations += 1\n\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            operations += 1\n        if matrix[end_row, col] != 1:\n            operations += 1\n\n    # Check interior (except borders)\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a matrix of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = calculate_operations(case, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (List[str]): The matrix representing the grid.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check top and bottom borders\n    for col in range(start_col, end_col + 1):\n        if col != start_col and col != end_col:\n            if matrix[start_row][col] != '1':\n                operations += 1\n            if matrix[end_row][col] != '1':\n                operations += 1\n\n    # Check left and right borders\n    for row in range(start_row, end_row + 1):\n        if row != start_row and row != end_row:\n            if matrix[row][start_col] != '1':\n                operations += 1\n            if matrix[row][end_col] != '1':\n                operations += 1\n\n    # Check interior\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row][col] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append(matrix)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions and matrix of a test case.\n\n    Returns:\n        list: Minimum number of operations needed for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        operations = calculate_operations(matrix, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix representing the test case.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the borders\n    for x in range(a):\n        for y in range(b):\n            current_value = matrix[start_row + x, start_col + y]\n            if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                # Border conditions\n                if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                    # Corners can be any type, no operation needed\n                    continue\n                if current_value == 0:\n                    operations += 1\n            else:\n                # Inner blocks must be empty\n                if current_value == 1:\n                    operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [list(map(int, input().strip())) for _ in range(n)]\n        test_cases.append((n, m, np.array(matrix)))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_operations_to_portal(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing the dimensions\n            of the grid and the grid itself.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges of the sub-rectangle\n    for x in range(start_row + 1, end_row):\n        if grid[x][start_col] != '1':\n            operations += 1\n        if grid[x][end_col] != '1':\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row][y] != '1':\n            operations += 1\n        if grid[end_row][y] != '1':\n            operations += 1\n\n    # Check the inner part of the sub-rectangle\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x][y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires transforming a given rectangle into a portal with specific conditions. The solution must efficiently calculate the minimum number of operations needed to achieve this transformation for multiple test cases, considering constraints on the dimensions of the rectangle.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations.\n- Ensure solution handles maximum constraints effectively.\n- Optimize code for speed and accuracy.\n- Provide clear and concise output format.\n- Test solution against diverse test cases.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of operations. The function will use a brute-force approach to evaluate each sub-rectangle, but will be optimized to skip unnecessary checks using the constraints provided. The solution will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    '1 < x < a': For rows between the first and last, certain blocks must be obsidian.\n    '1 < x < b': For columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the given rectangle.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\n    4. Keep track of the minimum number of operations across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already satisfies the portal conditions.\n    Explanation: If a sub-rectangle already meets the portal conditions, no operations are needed, so the expected output is 0.\n\n    Case 2: A rectangle with dimensions exactly equal to the minimum required (5 \u00d7 4) but with all blocks needing transformation.\n    Explanation: This requires transforming all blocks to meet portal conditions, resulting in a higher number of operations.\n\n    Case 3: A rectangle with dimensions larger than required but with no possible sub-rectangle meeting portal conditions without transformation.\n    Explanation: This requires evaluating multiple sub-rectangles to find the one with the least transformations needed.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no transformation is needed or where multiple sub-rectangles need evaluation.\n        if all_conditions_met(sub_rectangle):\n            return 0\n        else:\n            evaluate_all_sub_rectangles(rectangle)\n            return min_operations\n\nNote: The function `all_conditions_met` checks if a sub-rectangle already meets portal conditions, and `evaluate_all_sub_rectangles` iterates over possible sub-rectangles to find the minimum operations needed.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and provide accurate results.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations\n- Ensure correct handling of input and output formats\n- Optimize for large input sizes\n- Provide clear documentation for users\n- Enhance user interface for better experience\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block or an empty block. The dimensions n and m specify the number of rows and columns, respectively.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An action where a block is changed from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves calculating the number of changes for each potential sub-rectangle and keeping track of the smallest number found.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and then the grid itself.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to meet the portal conditions:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n5. Track the minimum number of changes required for any sub-rectangle in each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Edge Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no operations are needed.\n\n    Edge Case 2: A grid with all blocks as obsidian.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The inner blocks need to be changed to empty, requiring a total of 12 operations.\n\n    Edge Case 3: A grid with all blocks as empty.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The border blocks (except corners) need to be changed to obsidian, requiring a total of 12 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum number of changes will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints on dimensions and block types must be carefully handled to ensure accurate results. The solution should efficiently process multiple test cases and handle maximum input sizes.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the algorithm for large input sizes.\n- Ensure accurate portal formation according to given conditions.\n- Handle edge cases and validate input constraints.\n- Provide clear and concise output for each test case.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 within the given n x m rectangle and calculating the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of dimensions a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to changing an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This indicates that the dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions meeting these minimum requirements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the borders (except corners) are obsidian blocks.\n        - Ensure the inner blocks are empty.\n    4. Track the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already satisfies the portal conditions.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal conditions, so no operations are needed.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Minimum operations needed to create a portal from scratch.\n\n    Case 3: A rectangle with all obsidian blocks.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: Minimum operations needed to create a portal by converting inner blocks to empty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must efficiently handle the maximum input size. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an algorithm to identify potential portal sub-rectangles.\n- Calculate the minimum operations needed for transformation.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution is robust against edge cases.\n- Provide detailed comments and documentation for the code.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to satisfy the portal conditions. We will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the grid or matrix of size n rows and m columns, where each cell can either be an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the larger rectangle that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes required for each potential portal.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the first and last columns (except corners) are obsidian.\n   - Ensure the first and last rows (except corners) are obsidian.\n   - Ensure all inner blocks are empty.\n4. Track the minimum number of changes required across all sub-rectangles.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already satisfies the portal conditions.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: All inner blocks need to be changed to empty, requiring a total of 12 changes.\n\n    Case 3: A rectangle with alternating blocks.\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: 8\n    Explanation: The pattern requires changes to form a valid portal, specifically changing the inner blocks to empty and ensuring the borders are obsidian.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The algorithm should focus on identifying potential sub-rectangles and calculating the necessary transformations.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for each test case.\n- Ensure the solution handles edge cases and maximum constraints effectively.\n- Provide clear and concise output for each test case.\n- Optimize the code for readability and maintainability.\n- Include comments and documentation for better understanding.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints are met. The algorithm will be optimized to handle the maximum constraints efficiently by limiting the search space and using efficient counting techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed:\n   - Ensure the first and last columns of rows 2 to a-1 are obsidian.\n   - Ensure the first and last rows of columns 2 to b-1 are obsidian.\n   - Ensure all inner blocks (2 to a-1, 2 to b-1) are empty.\n4. Track the minimum number of operations needed for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2:\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: \n    16\n    Explanation: All blocks need to be changed to form a portal, with specific blocks needing to be obsidian.\n\n    Case 3:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    12\n    Explanation: The alternating pattern requires significant changes to meet portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on dimensions and block types are crucial for ensuring valid portal formation. The solution must efficiently handle multiple test cases and large matrices while providing accurate results.\nrequirement pool:\n- Implement efficient matrix transformation algorithm.\n- Ensure accurate counting of operations.\n- Optimize for large input sizes.\n- Provide clear output format.\n- Include detailed transformation steps in output.\nWe will implement a function to determine the minimum number of operations required to transform a given matrix into a portal. The function will iterate over all possible submatrices of size at least 5x4 and calculate the number of changes needed to convert each into a portal. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the initial matrix with n rows and m columns, where each element is either an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the placement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over submatrices that meet these minimum size requirements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each matrix.\n2. For each test case, iterate over all possible submatrices of size at least 5x4.\n3. For each submatrix, check if it can be transformed into a portal by counting the number of changes needed:\n   - Ensure the first and last columns of rows 2 to a-1 are obsidian.\n   - Ensure the first and last rows of columns 2 to b-1 are obsidian.\n   - Ensure all inner blocks (2 \u2264 x < a, 2 \u2264 y < b) are empty.\n4. Track the minimum number of changes required for any submatrix to become a portal.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire matrix is already a portal, so no changes are needed.\n\n    Case 2:\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: \n    16\n    Explanation: All blocks need to be changed to form a portal, except for the corners which can remain empty.\n\n    Case 3:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    12\n    Explanation: The alternating pattern requires significant changes to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible submatrices and calculating the minimum number of changes will naturally handle these cases.\n", "requirement analysis:\nThe task requires identifying sub-rectangles within a larger rectangle and transforming them into portals with minimal operations. The constraints on dimensions and block types must be adhered to, ensuring the solution is both efficient and accurate.\nrequirement pool:\n- Implement efficient algorithm to find and transform sub-rectangles into portals.\n- Ensure solution handles maximum input sizes within constraints.\n- Optimize for speed without sacrificing accuracy.\n- Provide clear and concise output for each test case.\n- Consider edge cases and ensure robustness.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions, including having obsidian blocks on its borders and empty blocks inside, except for the corners.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating the number of changes for each potential sub-rectangle and keeping track of the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal conditions:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior (except borders) is empty blocks.\n4. Track the minimum number of changes required for any sub-rectangle in each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: The entire rectangle is filled with obsidian blocks, so we need to change the interior to empty blocks.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The entire rectangle is empty, so we need to change the borders to obsidian blocks.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The rectangle already satisfies the portal conditions, so no changes are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum number of changes will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on dimensions and block types are clear, ensuring the solution must efficiently handle matrix transformations while adhering to the portal conditions.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure accurate counting of operations\n- Optimize for large input sizes\n- Provide clear input/output instructions\n- Enhance user interface for better experience\nWe will implement a function that iterates over all possible sub-rectangles of the given matrix that can potentially be transformed into a portal. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal and keep track of the minimum operations required. The solution will efficiently handle large matrices by limiting the search space to only valid sub-rectangles and using optimized operations counting.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions, including having a border of obsidian blocks and an interior of empty blocks, except for the corners.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means we only consider sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed:\n   - Ensure the border conditions are met (obsidian blocks on the edges except corners).\n   - Ensure the interior conditions are met (empty blocks inside).\n4. Keep track of the minimum number of operations needed for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    1. A rectangle that is already a portal:\n       Input: \n       ```\n       1\n       5 4\n       1111\n       1001\n       1001\n       1001\n       1111\n       ```\n       Expected output: 0\n       Explanation: The rectangle already satisfies the portal conditions, so no operations are needed.\n\n    2. A rectangle with all blocks as obsidian:\n       Input:\n       ```\n       1\n       5 4\n       1111\n       1111\n       1111\n       1111\n       1111\n       ```\n       Expected output: 12\n       Explanation: The entire interior needs to be converted to empty blocks, requiring a significant number of operations.\n\n    3. A rectangle with all blocks as empty:\n       Input:\n       ```\n       1\n       5 4\n       0000\n       0000\n       0000\n       0000\n       0000\n       ```\n       Expected output: 12\n       Explanation: The entire border needs to be converted to obsidian blocks, requiring a significant number of operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints on dimensions and block types must be carefully handled to ensure accurate results. The solution should efficiently process multiple test cases and large input sizes.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations\n- Ensure accurate portal formation according to given conditions\n- Optimize solution for large input sizes\n- Provide clear and concise output\n- Develop user-friendly interface for input and output\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes required to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, where each block can be either an obsidian block or empty.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates that for all rows except the first and last, certain conditions must be met.\n    'For all 1 < x < b': This indicates that for all columns except the first and last, certain conditions must be met.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal conditions:\n        - Ensure the borders (except corners) are obsidian blocks.\n        - Ensure the inner blocks are empty.\n    4. Track the minimum number of changes required across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already satisfies portal conditions.\n    Explanation: If a rectangle already meets the portal conditions, no operations are needed, so the expected output is 0.\n\n    Case 2: A rectangle with dimensions exactly 5x4 but all blocks are empty.\n    Explanation: The entire border needs to be changed to obsidian blocks, resulting in a high number of operations.\n\n    Case 3: A rectangle with dimensions larger than 5x4 but only one possible sub-rectangle can be transformed into a portal.\n    Explanation: The algorithm should correctly identify and transform this sub-rectangle with minimal operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be optimized to handle the maximum input size efficiently. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for each test case.\n- Ensure the solution handles edge cases and maximum constraints effectively.\n- Provide a clear and concise output format for the results.\n- Optimize the code for readability and maintainability.\n- Include comments and documentation for better understanding.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. This involves checking the conditions for a portal and counting the mismatches. The solution will be optimized by limiting the search space to only valid sub-rectangles and using efficient counting techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with rows and columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A specific sub-rectangle with defined conditions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range of rows within the portal.\n    'For all 1 < x < b': Indicates a range of columns within the portal.\n\n# [degree adverb]\n    'minimum': The least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size at least 5x4 within the n x m grid.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting mismatches with portal conditions.\n    3. Calculate the number of operations needed for each sub-rectangle.\n    4. Keep track of the minimum number of operations across all sub-rectangles.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    8\n    Explanation: All blocks are obsidian, requiring conversion to empty blocks inside the portal.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All blocks are empty, requiring conversion to obsidian blocks on the edges.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    10001\n    10001\n    10001\n    10001\n    10001\n    10001\n    Expected Output: \n    0\n    Explanation: The sub-rectangle already satisfies the portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the number of operations will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 687, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 437}
