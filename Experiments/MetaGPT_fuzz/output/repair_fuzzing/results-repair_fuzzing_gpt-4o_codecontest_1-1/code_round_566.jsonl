{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM uncovered a rectangular area A with size dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal. Consider all possible sub-rectangles to find the optimal solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM uncovered a rectangular area A with size dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal. Consider all possible sub-rectangles to find the optimal solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM uncovered a rectangular area A with size dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block. CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5. Additionally, the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal. Consider all possible sub-rectangles to find the optimal solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM uncovered a rectangular area A with size dimensions n by m consisting of n rows and m columns of blocks. Each block can be an obsidian block or an empty block, and CQXYM can switch between these block types with a single operation. \n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For 1 < x < a, blocks M_{x,1} and M_{x,b} as well as M_{1,x} and M_{a,x} for 1 < x < b must be obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal. Consider all possible sub-rectangles to find the optimal solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(n: int, m: int, grid: list[list[int]]) -> int:\n    \"\"\"Calculate the minimum number of operations needed to create a portal.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[list[int]]): The grid representing the blocks, where 0 is an empty block and 1 is an obsidian block.\n\n    Returns:\n        int: The minimum number of operations needed to transform a sub-rectangle into a portal.\n    \"\"\"\n    min_operations = float('inf')\n\n    # Iterate over all possible top-left corners of sub-rectangles\n    for top in range(n - 4):\n        for left in range(m - 3):\n            # Iterate over all possible bottom-right corners of sub-rectangles\n            for bottom in range(top + 4, n):\n                for right in range(left + 3, m):\n                    # Calculate operations needed for the current sub-rectangle\n                    operations = 0\n\n                    # Check the border conditions\n                    for x in range(left + 1, right):\n                        if grid[top][x] != 1:\n                            operations += 1\n                        if grid[bottom][x] != 1:\n                            operations += 1\n\n                    for y in range(top + 1, bottom):\n                        if grid[y][left] != 1:\n                            operations += 1\n                        if grid[y][right] != 1:\n                            operations += 1\n\n                    # Check the inner conditions\n                    for y in range(top + 1, bottom):\n                        for x in range(left + 1, right):\n                            if grid[y][x] != 0:\n                                operations += 1\n\n                    # Update the minimum operations found\n                    min_operations = min(min_operations, operations)\n\n    return min_operations\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [list(map(int, input().strip())) for _ in range(n)]\n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_for_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing grid dimensions and grid data.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over possible top-left corners of sub-rectangles\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rectangle = grid_array[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rectangle, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rectangle: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rectangle (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if sub_rectangle[x, 0] != 1:\n            operations += 1\n        if sub_rectangle[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rectangle[0, y] != 1:\n            operations += 1\n        if sub_rectangle[a - 1, y] != 1:\n            operations += 1\n\n    # Check internal conditions for empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rectangle[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_for_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to create a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: Numpy array representing the grid\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check border conditions\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Check inner conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list[list[str]]) -> list[int]:\n    \"\"\"Finds the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[list[str]]): List of matrices for each test case.\n\n    Returns:\n        list[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        matrix = np.array([[int(char) for char in row] for row in case])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculates the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check border conditions\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] == 0:\n            operations += 1\n        if matrix[x, end_col] == 0:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] == 0:\n            operations += 1\n        if matrix[end_row, y] == 0:\n            operations += 1\n\n    # Check inner conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    matrices = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        matrices.append(matrix)\n\n    # Call the function and print results\n    results = find_min_operations(t, matrices)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_create_portal(n: int, m: int, grid: list[str]) -> int:\n    \"\"\"Calculate the minimum number of operations needed to create a portal.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[str]): The grid represented as a list of strings.\n\n    Returns:\n        int: Minimum number of operations needed to create a portal.\n    \"\"\"\n    # Convert grid to numpy array for efficient manipulation\n    grid_array = np.array([list(row) for row in grid], dtype=int)\n    \n    # Initialize the minimum operations to a large number\n    min_operations = float('inf')\n    \n    # Iterate over all possible sub-rectangles with dimensions at least 5x4\n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            for end_row in range(start_row + 4, n):\n                for end_col in range(start_col + 3, m):\n                    # Calculate the number of operations needed for this sub-rectangle\n                    operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                    # Update the minimum operations if this is a better solution\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n    \n    # Check and count operations for the border conditions\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n    \n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n    \n    # Check and count operations for the interior conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        result = min_operations_to_create_portal(n, m, grid)\n        results.append(result)\n    \n    # Output interface\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n\n                        # Check and convert border blocks\n                        for x in range(start_row, end_row + 1):\n                            if x == start_row or x == end_row:\n                                # Top and bottom borders\n                                for y in range(start_col + 1, end_col):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right borders\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][end_col] != '1':\n                                    operations += 1\n\n                        # Check and convert inner blocks\n                        for x in range(start_row + 1, end_row):\n                            for y in range(start_col + 1, end_col):\n                                if grid[x][y] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    def compute_operations_for_subrectangle(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n        \"\"\"Compute the number of operations needed for a specific sub-rectangle to become a portal.\n\n        Args:\n            grid (List[str]): The grid of blocks.\n            start_row (int): Starting row of the sub-rectangle.\n            start_col (int): Starting column of the sub-rectangle.\n            a (int): Number of rows in the sub-rectangle.\n            b (int): Number of columns in the sub-rectangle.\n\n        Returns:\n            int: Number of operations needed.\n        \"\"\"\n        operations = 0\n        # Ensure border is obsidian and inner is empty as per portal definition\n        for i in range(start_row, start_row + a):\n            for j in range(start_col, start_col + b):\n                if (i == start_row or i == start_row + a - 1 or j == start_col or j == start_col + b - 1):\n                    # Border condition\n                    if grid[i][j] == '0':\n                        operations += 1\n                else:\n                    # Inner condition\n                    if grid[i][j] == '1':\n                        operations += 1\n        return operations\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for start_row in range(n - a + 1):\n                    for start_col in range(m - b + 1):\n                        operations = compute_operations_for_subrectangle(test_case, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n    \n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_create_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed for current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        # Handle edge case where no valid sub-rectangle exists\n        if min_operations == float('inf'):\n            results.append(-1)  # Indicating impossibility\n        else:\n            results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check boundary blocks\n    for row in range(start_row, end_row + 1):\n        for col in range(start_col, end_col + 1):\n            if (row == start_row or row == end_row or col == start_col or col == end_col):\n                if not ((row == start_row and col == start_col) or\n                        (row == start_row and col == end_col) or\n                        (row == end_row and col == start_col) or\n                        (row == end_row and col == end_col)):\n                    if grid[row][col] != '1':  # Should be obsidian\n                        operations += 1\n            else:\n                if grid[row][col] != '0':  # Should be empty\n                    operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_create_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_for_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions and grid of a test case.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        operations = 0\n                        \n                        # Check boundary conditions\n                        for x in range(start_row, end_row + 1):\n                            if x == start_row or x == end_row:\n                                for y in range(start_col, end_col + 1):\n                                    if (x == start_row or x == end_row) and (y == start_col or y == end_col):\n                                        continue\n                                    if grid_array[x, y] != 1:\n                                        operations += 1\n                            else:\n                                if grid_array[x, start_col] != 1:\n                                    operations += 1\n                                if grid_array[x, end_col] != 1:\n                                    operations += 1\n                        \n                        # Check inner blocks\n                        for x in range(start_row + 1, end_row):\n                            for y in range(start_col + 1, end_col):\n                                if grid_array[x, y] != 0:\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Call the function and print results\n    results = min_operations_for_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(n: int, m: int, grid: list[str]) -> int:\n    \"\"\"Calculate the minimum operations needed to form a portal in the grid.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[str]): List of strings representing the grid.\n\n    Returns:\n        int: Minimum number of operations required to form a portal.\n    \"\"\"\n    # Convert grid to a numpy array for efficient operations\n    grid_array = np.array([list(map(int, row)) for row in grid])\n\n    # Initialize the minimum operations to a large number\n    min_operations = float('inf')\n\n    # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    # Extract the sub-rectangle\n                    sub_rect = grid_array[i:i + a, j:j + b]\n\n                    # Calculate the number of operations needed to transform this sub-rectangle into a portal\n                    operations = calculate_operations(sub_rect, a, b)\n\n                    # Update the minimum operations if the current one is smaller\n                    if operations < min_operations:\n                        min_operations = operations\n\n    return min_operations\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check the inner conditions for empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read dimensions of the grid\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = [input().strip() for _ in range(n)]\n    \n    # Calculate and print the result\n    result = min_operations_to_portal(n, m, grid)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given rectangular area into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the optimal solution. Efficient handling of multiple test cases and large inputs is necessary.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output format.\n- Document the solution process for user understanding.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations required to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates that for rows between the first and last, certain blocks must be obsidian.\n    'For all 1 < x < b': This indicates that for columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to meet the portal criteria.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria\n    Explanation: If a sub-rectangle already meets the portal criteria, the expected output is 0 operations.\n    \n    Case 2: A rectangle with all blocks as obsidian\n    Explanation: Transforming such a rectangle into a portal will require converting some blocks to empty, potentially resulting in a high number of operations.\n    \n    Case 3: A rectangle with all blocks as empty\n    Explanation: Transforming such a rectangle into a portal will require converting some blocks to obsidian, potentially resulting in a high number of operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must consider all possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Implement an efficient algorithm to find the minimum operations for portal creation.\n- Optimize the solution to handle the maximum constraints effectively.\n- Ensure the solution is tested against multiple test cases for accuracy.\n- Provide clear documentation and examples for user understanding.\n- Consider edge cases and validate the solution thoroughly.\nWe will use a brute-force approach to evaluate all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. The solution will leverage numpy for efficient matrix manipulation and iteration over sub-rectangles.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: The action of switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles with these minimum dimensions.\n\n    '1 < x < a' and '1 < y < b':\n    Explanation: These conditions define the range for the internal blocks of the portal that must be checked. In code, this translates to iterating over the internal rows and columns of the sub-rectangle.\n\n# [degree adverb]\n    'minimum':\n    Explanation: We need to find the smallest number of operations required to transform any sub-rectangle into a portal. In code, this involves keeping track of the minimum operations found across all sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and each grid.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Check the border conditions for obsidian blocks.\n   - Check the internal conditions for empty blocks.\n   - Count the number of changes needed.\n4. Track the minimum number of operations across all sub-rectangles.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian.\n\n    Case 3: A grid with alternating blocks.\n    Example:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Calculated based on specific changes needed to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a grid of blocks into a portal with minimal operations. The constraints on grid size and block types are clear, and the solution must efficiently handle multiple test cases while ensuring accurate results.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation.\n- Ensure solution handles maximum grid size constraints effectively.\n- Provide clear output format for each test case.\n- Optimize for speed and accuracy in computation.\n- Include detailed comments and documentation for code clarity.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations required to convert each into a portal. We will use numpy for efficient matrix manipulation and to handle large grid sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates that for rows between the first and last, certain blocks must be obsidian.\n    'For all 1 < x < b': This indicates that for columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    - Iterate over all possible sub-rectangles of size at least 5x4 within the given n by m grid.\n    - For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n    - An operation is defined as switching a block from obsidian to empty or vice versa.\n    - Keep track of the minimum number of operations required across all sub-rectangles.\n\n# [edge case]\n    Case 1: A grid with all blocks as obsidian (e.g., 5x4 grid of all '1's)\n    Expected output: The number of operations needed to convert the inner blocks to empty blocks while keeping the border blocks as obsidian.\n    Case 2: A grid with all blocks as empty (e.g., 5x4 grid of all '0's)\n    Expected output: The number of operations needed to convert the border blocks to obsidian while keeping the inner blocks empty.\n    Case 3: A grid with alternating obsidian and empty blocks (e.g., checkerboard pattern)\n    Expected output: The number of operations needed to meet the portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement logic to specifically handle grids that are entirely obsidian or entirely empty, ensuring correct transformation into a portal.\n        - Consider special patterns like checkerboard and calculate operations accordingly.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on matrix dimensions and block types are crucial for determining the optimal solution. The solution must efficiently handle multiple test cases and provide clear output for each.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure output format matches requirements\n- Optimize for minimal operations\n- Handle edge cases effectively\n- Provide detailed documentation\nWe will implement a function that iterates over all possible sub-rectangles of the given matrix and calculates the number of operations needed to transform each into a portal. The function will use efficient matrix manipulation techniques to ensure quick computation even for large matrices. We will utilize numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the matrix, represented by '1' and '0', respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. This can be implemented by iterating over all possible sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each matrix.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed:\n   - Ensure the border conditions for obsidian blocks are met.\n   - Ensure the inner conditions for empty blocks are met.\n4. Keep track of the minimum number of operations needed across all sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 0\n    Explanation: The entire matrix is already a portal, so no operations are needed.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The matrix already satisfies the portal conditions, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a grid of blocks into a portal with minimal operations. The constraints on grid size and block types are clear, and the solution must efficiently handle multiple test cases while ensuring accuracy.\nrequirement pool:\n- Implement efficient algorithm to determine minimum operations for portal creation.\n- Ensure solution handles multiple test cases accurately.\n- Optimize performance for large grid sizes.\n- Provide clear and concise output format.\n- Develop user-friendly interface for input and output.\nWe will implement a function that iterates over all possible sub-rectangles of the given grid and checks if they can be transformed into a portal with the minimum number of operations. The function will use a brute-force approach to evaluate each sub-rectangle, but will optimize by stopping early if a valid portal is found with fewer operations. The use of numpy will help in efficiently handling the grid operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of the grid that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles with these minimum dimensions.\n\n    '1 < x < a', '1 < y < b':\n    Explanation: These phrases define the range of indices for which certain conditions must be met. In code, this means iterating over these indices to check and enforce the conditions.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to find the sub-rectangle that can be transformed into a portal with the least number of operations. In code, this involves keeping track of the minimum operations required across all sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met by counting necessary changes.\n   - Ensure the interior conditions are met by counting necessary changes.\n4. Keep track of the minimum number of operations needed for any valid portal configuration.\n5. Output the minimum number of operations for each test case.\n\n# [edge case] \n    Edge Case 1: A grid that is already a portal.\n    Explanation: If the grid is already a portal, no operations are needed, so the expected output is 0.\n\n    Edge Case 2: A grid with no possible portal configuration.\n    Explanation: If no sub-rectangle can be transformed into a portal, the function should return a high number indicating infeasibility, but since we are guaranteed a solution, this case should not occur.\n\n    Edge Case 3: A grid with multiple minimal solutions.\n    Explanation: If there are multiple sub-rectangles that can be transformed into a portal with the same minimum number of operations, any of these solutions is valid, and the output should reflect the minimum operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations inherently handles these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, and the solution should efficiently handle the maximum input size. The output must be formatted correctly for each test case.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for portal creation.\n- Optimize the solution to handle edge cases and large inputs efficiently.\n- Ensure the output format is consistent with the requirements.\n- Test the solution with various test cases to ensure accuracy.\n- Document the code for better understanding and maintenance.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of operations needed to convert each into a portal. We will use a brute-force method with optimizations to handle the constraints efficiently. The function will calculate the cost of converting each sub-rectangle and keep track of the minimum cost found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b (where a \u2265 5 and b \u2265 4) that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': This indicates that the condition applies to rows between the first and last row of the sub-rectangle.\n    '1 < x < b': This indicates that the condition applies to columns between the first and last column of the sub-rectangle.\n\n# [degree adverb]\n    'minimum': This means we need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and for each test case, read the dimensions n and m, followed by the grid of blocks.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the border conditions are met by checking and converting blocks as necessary.\n   - Count the number of operations required for each conversion.\n4. Keep track of the minimum number of operations needed across all sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring maximum operations.\n\n    Case 3: A grid with alternating blocks.\n    Example:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Calculated based on specific conversions needed to meet portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, given the potential size of the input. The solution should consider all possible sub-rectangles and find the optimal one with the least operations.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal creation.\n- Ensure the solution handles maximum constraints effectively.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for edge cases.\n- Document the solution approach for better understanding.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations required to convert each into a portal. The solution will use a dynamic programming approach to efficiently calculate the number of operations for each sub-rectangle, leveraging precomputed sums for quick access to the number of obsidian and empty blocks in any given sub-rectangle.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b (where a \u2265 5 and b \u2265 4) that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching a block from an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions meeting these minimum requirements.\n\n# [degree adverb]\n    'minimum': This refers to finding the least number of operations needed to transform a sub-rectangle into a portal.\n    Implementation: Use an optimization approach (e.g., dynamic programming) to find the configuration requiring the fewest operations.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the border blocks are obsidian as required.\n   - Ensure the inner blocks are empty.\n4. Use dynamic programming to efficiently compute the number of operations by leveraging precomputed sums of obsidian and empty blocks.\n5. Track the minimum number of operations across all sub-rectangles for each test case.\n6. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: All blocks are obsidian, so converting the inner blocks to empty requires 12 operations.\n\n    Case 2:\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: 16\n    Explanation: All blocks are empty, so converting the border blocks to obsidian requires 16 operations.\n\n    Case 3:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: 8\n    Explanation: Alternating pattern requires converting half of the border and inner blocks.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling edge cases)\n        # Example code snippet:\n        def calculate_operations(grid, n, m):\n            # Initialize variables and precompute sums for quick access\n            min_operations = float('inf')\n            for start_row in range(n - 4):\n                for start_col in range(m - 3):\n                    # Calculate operations for current sub-rectangle\n                    operations = compute_operations_for_subrectangle(grid, start_row, start_col)\n                    min_operations = min(min_operations, operations)\n            return min_operations\n\n        def compute_operations_for_subrectangle(grid, start_row, start_col):\n            # Logic to compute operations needed for a specific sub-rectangle\n            # Ensure border is obsidian and inner is empty as per portal definition\n            pass\n\n        # Main function to handle input/output and call calculation functions\n", "requirement analysis:\nThe requirements focus on transforming a grid of blocks into a portal with minimal operations. The constraints on grid size and block types are clear, and the solution must efficiently handle multiple test cases while ensuring accurate results.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation\n- Ensure solution handles maximum grid size constraints\n- Provide clear output format for user understanding\n- Optimize for speed and accuracy\n- Include detailed comments and documentation\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to convert the boundary and interior blocks to meet the portal criteria. We will use efficient iteration and calculation techniques to handle the constraints of grid size and multiple test cases. The solution will be implemented in Python, leveraging its built-in data structures for efficient computation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a rectangle of size a \u00d7 b with specific criteria for block types on its boundary and interior. The boundary must have obsidian blocks except for the corners, which can be any type, and the interior must have empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The rectangle must have at least 5 rows and 4 columns. This means any sub-rectangle considered must meet these minimum dimensions.\n    Implementation: Ensure that any sub-rectangle considered in the code has dimensions satisfying these conditions.\n\n# [degree adverb]\n    'minimum': \n    Explanation: The goal is to find the least number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Use an optimization approach to calculate the number of operations for each sub-rectangle and keep track of the smallest number found.\n\n# [code logic]\n    - Iterate over all possible sub-rectangles of size at least 5x4 within the given grid.\n    - For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n        - Check and count changes needed for boundary blocks to become obsidian.\n        - Check and count changes needed for interior blocks to become empty.\n    - Keep track of the minimum number of operations across all sub-rectangles.\n    - Return the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in portal configuration.\n    Explanation: No operations are needed, so the expected output is 0.\n    \n    Case 2: A grid where no possible sub-rectangle can be transformed into a portal due to insufficient dimensions.\n    Explanation: Since no valid sub-rectangle exists, the expected output should be handled gracefully, possibly returning a large number indicating impossibility.\n    \n    Case 3: A grid with exactly one possible sub-rectangle that can be transformed into a portal with minimal changes.\n    Explanation: Calculate the exact number of changes needed for this specific sub-rectangle.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for grid dimensions before attempting transformations.\n        - Handle cases where no valid sub-rectangle exists by returning a predefined large number or a specific message indicating impossibility.\n        - Ensure efficient calculation by breaking early if a perfect portal configuration is found.\n", "requirement analysis:\nThe requirements focus on transforming a grid of blocks into a portal with minimal operations. The constraints on the grid size and block types are clear, and the solution must efficiently handle multiple test cases while ensuring accurate results.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation\n- Ensure solution handles maximum grid size constraints\n- Provide clear output format for test case results\n- Optimize code for fast computation\n- Validate input data for consistency and correctness\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations needed to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size at least 5x4 that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching a block from an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles that meet these minimum dimensions.\n\n    '1 < x < a' and '1 < y < b':\n    Explanation: These conditions define the range for the inner blocks of the sub-rectangle that must be checked for being empty or obsidian. In code, this involves iterating over these indices to verify and count necessary operations.\n\n# [degree adverb] \n    'minimum': \n    Explanation: We need to find the smallest number of operations required to transform any sub-rectangle into a portal. In code, this involves keeping track of the minimum operations found across all valid sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check the boundary conditions and count the number of operations needed to transform it into a portal.\n4. Keep track of the minimum number of operations required for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case] \n    Case 1: A grid that is already a portal (e.g., all boundary conditions are met).\n    Expected output: 0\n    Explanation: No operations are needed if the grid already satisfies the portal conditions.\n\n    Case 2: A grid with no obsidian blocks.\n    Expected output: The number of operations required to convert the necessary blocks to obsidian.\n    Explanation: All boundary blocks need to be converted to obsidian, and inner blocks need to be converted to empty.\n\n    Case 3: A grid with alternating obsidian and empty blocks.\n    Expected output: The number of operations required to meet the portal criteria.\n    Explanation: This requires careful counting of operations needed to switch blocks to meet the portal conditions.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already a portal or has no obsidian blocks.\n    \n```python\ndef min_operations_to_portal(test_cases):\n    results = []\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        operations = 0\n                        # Check boundary conditions\n                        for x in range(start_row, end_row + 1):\n                            if x == start_row or x == end_row:\n                                for y in range(start_col, end_col + 1):\n                                    if (x == start_row or x == end_row) and (y == start_col or y == end_col):\n                                        continue\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][end_col] != '1':\n                                    operations += 1\n                        # Check inner blocks\n                        for x in range(start_row + 1, end_row):\n                            for y in range(start_col + 1, end_col):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        min_operations = min(min_operations, operations)\n        results.append(min_operations)\n    return results\n```\n\n", "requirement analysis:\nThe requirements focus on transforming a given rectangular area into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the portal structure. Efficient handling of multiple test cases and large inputs is necessary to meet user expectations.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation.\n- Ensure output format is consistent with requirements.\n- Optimize code for handling large inputs efficiently.\n- Include edge case handling for various input scenarios.\n- Provide clear documentation for user understanding.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of operations. The function will use a brute-force approach to evaluate each sub-rectangle, but will be optimized by early exits and efficient counting of required changes. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this can be implemented by iterating over all possible sub-rectangles with dimensions satisfying these conditions.\n\n# [degree adverb]\n    'minimum': \n    Explanation: We need to find the sub-rectangle that requires the least number of operations to transform into a portal. This involves calculating the number of changes needed for each candidate sub-rectangle and selecting the one with the smallest count.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each test case.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in portal configuration.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as the grid is already a portal.\n\n    Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Number of operations needed to convert all required blocks to obsidian.\n\n    Case 3: A grid with alternating obsidian and empty blocks.\n    Example:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Number of operations needed to convert alternating pattern into a portal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        # Check if the grid is already a portal and return 0 if true.\n        # Implement logic to efficiently count operations for grids with uniform patterns (all empty or all obsidian).\n        # Optimize counting for alternating patterns by pre-calculating potential changes.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 566, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "parent_index": 320}
