{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect starts with the same second when the dragon was stabbed by the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect starts with the same second when the dragon was stabbed by the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect starts with the same second when the dragon was stabbed by the dagger. The poison begins to affect the dragon as soon as it is stabbed with the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game and in this game, his character has to kill a dragon. The i-th attack is performed at the beginning of the a_i-th second from the battle start during the 100^{500} seconds the battle with the dragon lasts. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect starts with the same second when the dragon was stabbed by the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of the poison effect needed to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search range based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration needed to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, attack_times[-1] - attack_times[0] + 1\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Increase k\n\n        results.append(low)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration needed to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing number of attacks, required damage, and attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        answer = h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                answer = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(answer)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # k cannot be more than h\n        while left < right:\n            mid = (left + right) // 2\n            if can_deal_damage(n, h, attacks, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if the given k can deal at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to slay the dragon.\n        attacks (List[int]): List of attack times.\n        k (int): Duration of the poison effect.\n\n    Returns:\n        bool: True if k can deal at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # high is set to h because k cannot be more than h to deal h damage\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        left, right = 1, h\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Hit points of the dragon.\n            - attacks: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum poison duration for each test case.\n    \"\"\"\n    def calculate_damage(n: int, k: int, attacks: List[int]) -> int:\n        \"\"\"Calculate the total damage dealt with a given poison duration k.\n\n        Args:\n            n: Number of attacks.\n            k: Poison duration.\n            attacks: List of attack times.\n\n        Returns:\n            Total damage dealt.\n        \"\"\"\n        total_damage = 0\n        for i in range(n - 1):\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(n, mid, attacks) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    test_cases.append((n, h, attacks))\n\n# Output interface\nresults = minimum_poison_duration(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, 10**18\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Check if the total damage is at least h\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        low, high = 1, 10**9  # Initialize binary search boundaries\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given the sequence of attack times. The solution must efficiently handle up to 1000 test cases with large values for h and attack times.\nrequirement pool:\n- Calculate minimum k for each test case\n- Optimize for large input sizes\n- Ensure output format is clear and concise\n- Handle edge cases with maximum values\n- Provide detailed error messages for invalid inputs\nWe will implement a function to calculate the minimum duration of the poison effect (k) needed to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the total damage for a given k using a binary search approach to efficiently find the minimum k. This approach ensures that we handle large input sizes effectively. We will use Python's built-in capabilities for handling large integers and efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs during this period, the poison effect is reset to start from that attack.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    'next k seconds': The poison effect lasts for k seconds after each attack.\n\n# [degree adverb]\n    'minimum': We need to find the smallest possible value of k that satisfies the condition.\n\n# [code logic]\n1. For each test case, initialize a binary search for k between 1 and a large number (e.g., h).\n2. For each mid value of k in the binary search:\n   - Calculate the total damage dealt by iterating over the attack times.\n   - For each attack, add damage for the next k seconds, but ensure not to double count damage if another attack occurs within those k seconds.\n3. If the total damage is at least h, adjust the binary search to find a smaller k.\n4. If not, increase k.\n5. Return the smallest k found that satisfies the condition.\n\n# [edge case]\n    Test case 1: 1 1\n                 1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case 2: 2 2\n                 1 2\n    Expected output: 1\n    Explanation: Two attacks at consecutive seconds mean k=1 is enough to deal 2 damage.\n\n    Test case 3: 3 10\n                 1 5 10\n    Expected output: 3\n    Explanation: With attacks spaced out, k=3 ensures continuous damage coverage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, considering the sequence of attacks. The solution must efficiently handle up to 1000 test cases with large values for n and h.\nrequirement pool:\n- Calculate minimum k value for each test case\n- Optimize algorithm for large input sizes\n- Ensure output format is clear and concise\n- Handle edge cases with maximum input values\n- Provide detailed error messages for invalid inputs\nWe will implement a function to calculate the minimum poison duration (k) needed to deal at least h damage to the dragon. The approach involves iterating over the attack times and calculating the damage dealt by the poison effect. We will use binary search to efficiently find the minimum k value, ensuring the solution handles large input sizes effectively. The Python standard library will be sufficient for this task.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs during this period, the poison effect is reset to start from that attack.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt by the poison effect is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Ensure the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = a_n - a_1 + 1 (maximum possible k).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage contributed by that attack.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n5. Output the value of low as the minimum k for each test case.\n\n# [edge case]\n    Test case 1: 1 1\n                 1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal the required damage.\n\n    Test case 2: 2 2\n                 1 1000000000\n    Expected output: 1\n    Explanation: The attacks are far apart, so each attack must deal its own damage, requiring k = 1.\n\n    Test case 3: 3 10\n                 1 2 3\n    Expected output: 4\n    Explanation: With attacks at consecutive seconds, k must be at least 4 to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum duration of poison effect needed to defeat the dragon, considering multiple attack timings and ensuring the poison effect is maximized. The solution must handle large numbers efficiently and provide accurate results for each test case.\nrequirement pool:\n- Calculate minimum k value for poison effect\n- Handle multiple test cases efficiently\n- Optimize for large input sizes\n- Ensure output format is clear and concise\n- Consider edge cases with maximum input values\nWe will implement a binary search algorithm to efficiently determine the minimum k value for each test case. The binary search will be used to find the smallest k such that the total damage is at least h. This approach is chosen because it allows us to handle large input sizes efficiently, as required by the problem constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs while the poison is active, it resets the poison duration.\n\n    'minimum possible value of k'\n    Explanation: The task is to find the smallest duration k for which the total damage dealt by the poison is at least h, ensuring the dragon is slain.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by calculating the total damage for a given k and checking if it meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k (e.g., h).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for k = mid using the attack sequence.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. Return low as the minimum k that satisfies the condition.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10000, a_i = i (for i in range(1, 101))\n    Expected output: 100\n    Explanation: Each attack occurs at consecutive seconds, requiring k to be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 10^18, a_1 = 1, a_2 = 10^9\n    Expected output: 10^18\n    Explanation: The gap between attacks is large, requiring a very large k to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect needed to deal at least h damage to the dragon, considering the sequence of attacks. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Calculate minimum poison duration for each test case\n- Optimize for large input sizes\n- Ensure output clarity and correctness\n- Handle edge cases effectively\n- Provide detailed error messages for invalid inputs\nWe will implement a function to calculate the minimum poison duration needed to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the damage dealt by the poison effect, considering the overlap of poison effects. We will use binary search to efficiently find the minimum k that satisfies the condition for each test case. This approach ensures optimal performance even for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds starting from the second of the attack, and it can be reapplied if another attack occurs during its duration.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt by the poison effect must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. For each test case, initialize variables to store the number of attacks and required damage.\n    2. Use binary search to find the minimum k:\n        - Set low = 1 and high = maximum possible k (e.g., h).\n        - While low <= high, calculate mid = (low + high) // 2.\n        - Calculate total damage for k = mid by iterating over attack times and summing up the damage considering overlaps.\n        - If total damage >= h, update high = mid - 1 and store mid as a potential answer.\n        - If total damage < h, update low = mid + 1.\n    3. Output the minimum k found for each test case.\n\n# [edge case]\n    Test case with minimum attacks and damage:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Test case with maximum attacks but minimum damage:\n    100 1\n    1 2 3 ... 100\n    Expected output: 1\n    Explanation: Even with maximum attacks, needing only 1 damage means k = 1 is sufficient.\n\n    Test case with attacks spaced far apart:\n    3 10\n    1 1000 2000\n    Expected output: 10\n    Explanation: Each attack is spaced far apart, requiring k to be at least equal to the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated total damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration k for which the poison effect must last to deal at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large values of h and n, ensuring that the output is correct and follows the specified format.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for edge cases\n- Provide clear and formatted output\n- Document the code for maintainability\nWe will implement a binary search algorithm to efficiently determine the minimum k for each test case. The binary search will be used to find the smallest k such that the total damage is at least h. This approach is chosen because it allows us to efficiently handle large input sizes and ensures that we can quickly converge on the correct value of k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds and is reapplied with each attack, canceling any existing poison effect.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this means summing the damage over the effective seconds and ensuring it meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Implement a binary search for k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - Calculate total damage for a mid-point k.\n   - Adjust bounds based on whether the damage meets or exceeds h.\n5. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with attacks at consecutive seconds:\n    Input: 2 2\n           1 2\n    Expected output: 1\n    Explanation: With k=1, damage is dealt in seconds [1, 2].\n\n    Test case with maximum h:\n    Input: 1 10^18\n           1\n    Expected output: 10^18\n    Explanation: Only one attack, so k must be equal to h to deal enough damage.\n\n    Test case with attacks spaced far apart:\n    Input: 3 3\n           1 1000 2000\n    Expected output: 1\n    Explanation: With k=1, damage is dealt in seconds [1, 1000, 2000].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe game requires a balance between strategic planning and computational efficiency. The player must be able to understand the mechanics of poison application and strategize accordingly. The game should provide immediate feedback on the effectiveness of the player's strategy and allow for replayability to test different approaches.\nrequirement pool:\n- Implement the core game mechanics for poison application and damage calculation\n- Optimize the game for handling large numbers and complex calculations efficiently\n- Develop a user interface that provides clear instructions and feedback\n- Ensure the game is replayable with different strategies\n- Integrate a scoring system to track player performance\nWe will implement a function to calculate the minimum value of k using a binary search approach. This will efficiently handle large numbers and complex calculations by leveraging the sorted nature of attack times and the cumulative damage calculation. We will use Python's built-in capabilities for handling large integers and efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds and is reapplied with each attack.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by ensuring the cumulative damage from all attacks meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set low = 1 and high = a_n - a_1 + 1 (maximum possible k).\n        - While low < high:\n            - Calculate mid = (low + high) // 2.\n            - Calculate total damage for k = mid.\n            - If total damage >= h, set high = mid.\n            - Else, set low = mid + 1.\n    4. Output the value of low as the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/n\n    Explanation: The attacks are evenly spaced, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 10^9, a = [1, 10^9]\n    Expected output: 10^9\n    Explanation: The attacks are far apart, requiring k to be large enough to cover the gap.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on cumulative damage calculations.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage dealt to the dragon meets or exceeds its hit points (h). The solution must efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and requiring damage calculations over potentially large time spans.\nrequirement pool:\n- Implement the main logic to calculate the minimum k for each test case\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm to minimize time complexity\n- Provide clear and accurate output for each test case\n- Include comments and documentation for maintainability\nWe will implement a binary search algorithm to efficiently determine the minimum value of k for each test case. The binary search will be applied on the possible values of k, ranging from 1 to the maximum possible time span between attacks. For each candidate k, we will simulate the damage dealt to the dragon and check if it meets or exceeds the required hit points h. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp stabs the dragon, dealing 1 damage per second for the next k seconds. If the dragon is already poisoned, the effect is reset.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this means summing up the damage over time and checking if it meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. For each test case, initialize the search range for k from 1 to a large number (e.g., maximum time span between attacks).\n2. Use binary search to find the minimum k:\n   - Calculate the total damage for a mid value of k.\n   - If the damage is at least h, try a smaller k by adjusting the search range.\n   - If not, increase k by adjusting the search range.\n3. For each mid value of k, simulate the damage:\n   - Initialize total damage to 0.\n   - Iterate through each attack time.\n   - Calculate the damage contributed by each attack considering overlapping poison effects.\n4. Return the minimum k found for each test case.\n\n# [edge case]\n    Test case with minimum values (e.g., n=1, h=1, a_1=1) = 1\n    Explanation: With only one attack and h=1, k=1 is sufficient to deal the required damage.\n\n    Test case with maximum h and minimum n (e.g., n=1, h=10^18, a_1=1) = 10^18\n    Explanation: With only one attack, k must be equal to h to deal enough damage.\n\n    Test case with attacks at consecutive seconds (e.g., n=3, h=3, a_1=1, a_2=2, a_3=3) = 1\n    Explanation: Each attack can deal 1 damage per second without overlap, so k=1 is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirements focus on determining the minimum duration of poison effect needed to deal sufficient damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring accurate and optimized results.\nrequirement pool:\n- Implement efficient game logic to calculate minimum poison duration\n- Ensure output format is clear and concise\n- Optimize performance for large input constraints\n- Test solution against multiple test cases for accuracy\n- Provide documentation for understanding game logic\nWe will implement a function to calculate the minimum poison duration using a binary search approach to efficiently handle large input constraints. This approach will allow us to find the minimum k by checking the total damage dealt for each k value and adjusting based on whether the damage is sufficient or not. We will use Python's built-in capabilities to handle large integers and ensure the solution is optimized for performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds and deals 1 damage per second. If a new attack occurs while the poison is active, the poison duration resets.\n\n    'minimum possible value of k'\n    Explanation: The goal is to find the smallest duration k such that the total damage dealt is at least h, the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This means we need to ensure that the sum of damage over all seconds is not less than h.\n    Implementation: Use a loop or binary search to find the minimum k that satisfies this condition.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible k that achieves the required damage.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, get n (number of attacks), h (hit points), and the list of attack times.\n2. Implement a function to calculate the total damage for a given k.\n3. Use binary search to find the minimum k such that the total damage is at least h.\n4. For each test case, output the minimum k found.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and 1 hit point, k=1 is sufficient.\n\n    Test case with attacks at consecutive seconds:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack occurs at consecutive seconds, so k=1 is enough to deal 3 damage.\n\n    Test case with large h:\n    2 10^18\n    1 10^9\n    Expected output: Large value close to 10^18/n\n    Explanation: With very large h, k needs to be large enough to accumulate sufficient damage over n attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given a sequence of attack times. The solution must efficiently handle large values of h and n, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Verify the output format matches the requirements\n- Conduct thorough testing with diverse test cases\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be used to find the smallest k such that the total damage is at least h. For each k, we will simulate the damage calculation based on the attack times and check if it meets the required damage h. This approach ensures that we handle large values of h and n efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack applies a poison that deals damage over a period of k seconds. If a new attack occurs while the poison is active, it resets the poison duration.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k for which the total damage from all attacks is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases, and for each test case, get n, h, and the list of attack times.\n    2. Implement a binary search for k, starting from 1 to a large number (e.g., 10^9).\n    3. For each k in the binary search, simulate the damage calculation:\n        - Initialize total damage to 0.\n        - Iterate through attack times and calculate the damage for each attack considering the poison effect duration k.\n        - If a new attack occurs before the current poison effect ends, reset the poison effect.\n    4. Check if the total damage is at least h.\n    5. Adjust the binary search bounds based on whether the current k meets the damage requirement.\n    6. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient to deal at least h damage.\n\n    Test case with attacks spaced far apart:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: Each attack can independently deal damage with k = 1, so k = 1 is sufficient.\n\n    Test case with large h:\n    3 1000000000000000000\n    1 2 3\n    Expected output: A large value (e.g., close to h/n)\n    Explanation: With very large h, k needs to be large enough to accumulate sufficient damage over multiple attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on whether the accumulated damage meets or exceeds h.\n", "requirement analysis:\nThe requirements focus on determining the minimum value of k for Monocarp's attacks to deal at least h damage to the dragon. The solution must efficiently handle large input sizes and multiple test cases, ensuring the algorithm is optimized for performance and scalability.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Provide clear output format for test cases\n- Test the solution against a variety of test cases\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. This approach is suitable given the constraints, as it allows us to handle large input sizes and multiple test cases effectively. The binary search will be used to find the smallest k such that the total damage is at least h. We will calculate the damage for each k by iterating over the attack times and summing the damage intervals.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. It lasts for k seconds and is reapplied with each attack, canceling any current poison effect.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt to the dragon must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all attack intervals meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k (e.g., 10^9).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for k = mid:\n            - Initialize total_damage = 0.\n            - Iterate over attack times:\n                - For each attack time, calculate the damage interval considering overlaps.\n                - Add the damage from each interval to total_damage.\n        c. If total_damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. Return low as the minimum k.\n\n# [edge case]\n    Case 1: \n    Input: 1 1\n           1\n    Expected Output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Case 2:\n    Input: 2 2\n           1 3\n    Expected Output: 1\n    Explanation: Two attacks at seconds 1 and 3 with k=1 will deal exactly 2 damage.\n\n    Case 3:\n    Input: 3 10\n           1 2 3\n    Expected Output: 4\n    Explanation: With attacks at consecutive seconds, k=4 ensures continuous damage without gaps.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by evaluating the total damage for each candidate k and adjusting accordingly.\n"], "scores": [], "pass_results": [true, true, true, true, false, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 463, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "add_1_sentence_at_end", "parent_index": 310}
