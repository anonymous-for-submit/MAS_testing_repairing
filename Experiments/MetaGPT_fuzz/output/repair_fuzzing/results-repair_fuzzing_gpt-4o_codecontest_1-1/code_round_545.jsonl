{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe maze's design is arranged as a tree with n rooms labeled from 1 to n. These rooms are linked by n - 1 tunnels in such a manner that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to develop a program that processes each request efficiently. Efficient execution of the program is key to ensuring smooth navigation through the maze.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe maze's design is arranged as a tree with n rooms labeled from 1 to n. These rooms are linked by n - 1 tunnels in such a manner that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to develop a program that processes each request efficiently. Efficient execution of the program is key to ensuring smooth navigation through the maze.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe maze's design is arranged as a tree with n rooms labeled from 1 to n. The structure of the rooms is such that they are connected in a specific way. These rooms are linked by n - 1 tunnels in such a manner that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to develop a program that processes each request efficiently. Efficient execution of the program is key to ensuring smooth navigation through the maze.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert. The maze's design is arranged as a tree with n rooms labeled from 1 to n, and these rooms are linked by n - 1 tunnels in such a manner that enables travel between any pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y, and moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries. Queries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to develop a program that processes each request efficiently. Efficient execution of the program is key to ensuring smooth navigation through the maze.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        int: The minimum energy required to move from room u to room v.\n    \"\"\"\n    # Precompute necessary data for LCA\n    n = len(illusion_rates)\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n\n    def dfs(node: int, par: int, dep: int):\n        \"\"\"Depth First Search to compute parent and depth information.\"\"\"\n        visited[node] = True\n        parent[node] = par\n        depth[node] = dep\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, dep + 1)\n\n    # Start DFS from node 1 (assuming 1-based index)\n    dfs(1, -1, 0)\n\n    def lca(x: int, y: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor of nodes x and y.\"\"\"\n        if depth[x] < depth[y]:\n            x, y = y, x\n        # Bring x and y to the same depth\n        while depth[x] > depth[y]:\n            x = parent[x]\n        while x != y:\n            x = parent[x]\n            y = parent[y]\n        return x\n\n    # Find LCA of u and v\n    ancestor = lca(u, v)\n\n    # Calculate the energy required to move from u to v\n    def calculate_energy(x: int, y: int) -> int:\n        \"\"\"Calculate energy between two rooms.\"\"\"\n        return max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]),\n                   abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n\n    # Traverse from u to ancestor and from v to ancestor\n    energy = 0\n    current = u\n    while current != ancestor:\n        energy += calculate_energy(current, parent[current])\n        current = parent[current]\n\n    current = v\n    while current != ancestor:\n        energy += calculate_energy(current, parent[current])\n        current = parent[current]\n\n    return energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nsys.setrecursionlimit(200000)\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.preprocess()\n\n    def preprocess(self):\n        \"\"\"Preprocess the tree to find parent and depth of each node.\"\"\"\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Depth First Search to set parent and depth.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Update the illusion rate of a specified room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def min_energy_to_treasure(self, start_room: int, end_room: int) -> int:\n        \"\"\"Calculate the minimum energy required to move from start_room to end_room.\"\"\"\n        path = self.find_path(start_room, end_room)\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u, v = path[i], path[i + 1]\n            energy = max(abs(self.illusion_rates[u - 1] + self.illusion_rates[v - 1]),\n                         abs(self.illusion_rates[u - 1] - self.illusion_rates[v - 1]))\n            total_energy += energy\n        return total_energy\n\n    def find_path(self, start: int, end: int) -> List[int]:\n        \"\"\"Find the path from start to end using parent information.\"\"\"\n        path_start = []\n        path_end = []\n        while start != -1:\n            path_start.append(start)\n            start = self.parent[start]\n        while end != -1:\n            path_end.append(end)\n            end = self.parent[end]\n        # Find the common ancestor\n        i, j = len(path_start) - 1, len(path_end) - 1\n        while i >= 0 and j >= 0 and path_start[i] == path_end[j]:\n            i -= 1\n            j -= 1\n        # Combine paths\n        return path_start[:i + 1] + path_end[j + 1:][::-1]\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    maze = Maze(n, illusion_rates, tunnels)\n\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            maze.update_illusion_rate(u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = maze.min_energy_to_treasure(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], depths: List[int], parents: List[int]) -> None:\n    \"\"\"Performs Depth First Search to precompute depths and parent nodes for LCA.\"\"\"\n    depths[node] = depth\n    parents[node] = parent\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, depths, parents)\n\ndef lca(u: int, v: int, depths: List[int], parents: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    if depths[u] < depths[v]:\n        u, v = v, u\n    while depths[u] > depths[v]:\n        u = parents[u]\n    while u != v:\n        u = parents[u]\n        v = parents[v]\n    return u\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    depths = [-1] * (n + 1)\n    parents = [-1] * (n + 1)\n    \n    # Precompute depths and parents using DFS\n    dfs(1, -1, 0, tree, depths, parents)\n    \n    # Find the path using LCA\n    ancestor = lca(u, v, depths, parents)\n    \n    # Calculate energy along the path\n    energy = 0\n    current = u\n    while current != ancestor:\n        next_room = parents[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    \n    current = v\n    while current != ancestor:\n        next_room = parents[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input parsing and query processing.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_map: List[int], depth_map: List[int]) -> None:\n    \"\"\"Perform DFS to populate parent and depth maps.\"\"\"\n    parent_map[node] = parent\n    depth_map[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_map, depth_map)\n\ndef lca(u: int, v: int, parent_map: List[int], depth_map: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if depth_map[u] < depth_map[v]:\n        u, v = v, u\n    while depth_map[u] > depth_map[v]:\n        u = parent_map[u]\n    while u != v:\n        u = parent_map[u]\n        v = parent_map[v]\n    return u\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], parent_map: List[int], depth_map: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    ancestor = lca(u, v, parent_map, depth_map)\n    energy = 0\n    current = u\n    while current != ancestor:\n        next_room = parent_map[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]), abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    current = v\n    while current != ancestor:\n        next_room = parent_map[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]), abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    parent_map = [-1] * (n + 1)\n    depth_map = [0] * (n + 1)\n    dfs(1, -1, 0, tree, parent_map, depth_map)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = calculate_min_energy(query[1], query[2], illusion_rates, tree, parent_map, depth_map)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef preprocess_tree(n: int, tree: List[List[int]], illusion_rates: List[int]) -> Tuple:\n    \"\"\"Preprocesses the tree using DFS to prepare data for LCA calculations.\"\"\"\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    def dfs(node: int, dep: int):\n        visited[node] = True\n        depth[node] = dep\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor, dep + 1)\n    \n    # Start DFS from node 1 (assuming 1 is the root)\n    dfs(1, 0)\n    \n    return parent, depth\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], lca_data: Tuple) -> int:\n    \"\"\"Calculates the minimum energy required to travel between two rooms.\"\"\"\n    parent, depth = lca_data\n    \n    def find_lca(x: int, y: int) -> int:\n        # Bring both nodes to the same depth\n        while depth[x] > depth[y]:\n            x = parent[x]\n        while depth[y] > depth[x]:\n            y = parent[y]\n        # Find the common ancestor\n        while x != y:\n            x = parent[x]\n            y = parent[y]\n        return x\n    \n    lca = find_lca(u, v)\n    \n    def calculate_energy(x: int, y: int) -> int:\n        return max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    # Calculate energy from u to lca and lca to v\n    energy = 0\n    current = u\n    while current != lca:\n        energy += calculate_energy(current, parent[current])\n        current = parent[current]\n    \n    current = v\n    while current != lca:\n        energy += calculate_energy(current, parent[current])\n        current = parent[current]\n    \n    return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    lca_data = preprocess_tree(n, tree, illusion_rates)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == 2:\n            _, u, v = query\n            result = calculate_min_energy(u, v, illusion_rates, tree, lca_data)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\nsys.setrecursionlimit(200000)\n\ndef update_illusion_rate(room_illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of the u-th room to c.\"\"\"\n    room_illusion_rates[u - 1] = c\n\ndef calculate_min_energy(n: int, room_illusion_rates: List[int], tunnels: List[Tuple[int, int]], u: int, v: int) -> int:\n    \"\"\"Calculate the minimum sum of energy needed to travel from room u to room v.\"\"\"\n    # Build the adjacency list for the tree\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Use DFS to find the path from u to v and calculate the energy\n    def dfs(current: int, target: int, parent: int, path_energy: int) -> int:\n        if current == target:\n            return path_energy\n        for neighbor in adjacency_list[current]:\n            if neighbor != parent:\n                energy = max(abs(room_illusion_rates[current - 1] + room_illusion_rates[neighbor - 1]),\n                             abs(room_illusion_rates[current - 1] - room_illusion_rates[neighbor - 1]))\n                result = dfs(neighbor, target, current, path_energy + energy)\n                if result != -1:\n                    return result\n        return -1\n\n    return dfs(u, v, -1, 0)\n\ndef main():\n    # Read input\n    n, q = map(int, input().split())\n    room_illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    # Process each query\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(room_illusion_rates, u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(n, room_illusion_rates, tunnels, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int, illusion_rates: List[int], edges: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.segment_tree = SegmentTree(illusion_rates)\n        \n        for s, t in edges:\n            self.tree[s].append(t)\n            self.tree[t].append(s)\n        \n        self._dfs(1, 0)\n\n    def _dfs(self, node: int, parent: int):\n        self.parent[node] = parent\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self.depth[neighbor] = self.depth[node] + 1\n                self._dfs(neighbor, node)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.segment_tree.update(room - 1, new_rate)\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        lca = self._find_lca(u, v)\n        path = self._get_path(u, lca) + self._get_path(v, lca)[::-1][1:]\n        energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.segment_tree.query(path[i] - 1)\n            a_y = self.segment_tree.query(path[i + 1] - 1)\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n\n    def _find_lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def _get_path(self, u: int, lca: int) -> List[int]:\n        path = []\n        while u != lca:\n            path.append(u)\n            u = self.parent[u]\n        path.append(lca)\n        return path\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, index: int, value: int):\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n    def query(self, index: int) -> int:\n        return self.tree[index + self.n]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, q = int(data[0]), int(data[1])\n    illusion_rates = list(map(int, data[2:n+2]))\n    edges = [(int(data[i]), int(data[i+1])) for i in range(n+2, n+2+(n-1)*2, 2)]\n    queries = [list(map(int, data[i:i+3])) for i in range(n+2+(n-1)*2, len(data), 3)]\n    \n    tree = Tree(n, illusion_rates, edges)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            tree.update_illusion_rate(query[1], query[2])\n        elif query[0] == 2:\n            result = tree.calculate_min_energy(query[1], query[2])\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Updates the illusion rate of the specified room.\n\n    Args:\n        illusion_rates: A list of integers representing the illusion rates of each room.\n        u: The index of the room to update (1-based index).\n        c: The new illusion rate for the room.\n    \"\"\"\n    illusion_rates[u - 1] = c\n\ndef find_min_energy_path(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int], u: int, v: int) -> int:\n    \"\"\"Finds the minimum energy path between two rooms using DFS and LCA.\n\n    Args:\n        n: The number of rooms in the maze.\n        edges: A list of tuples representing the connections between rooms.\n        illusion_rates: A list of integers representing the illusion rates of each room.\n        u: The starting room index (1-based index).\n        v: The destination room index (1-based index).\n\n    Returns:\n        The minimum energy required to move from room u to room v.\n    \"\"\"\n    # Precompute parent and depth information using DFS\n    parent = [-1] * n\n    depth = [0] * n\n    adj_list = [[] for _ in range(n)]\n    \n    for s, t in edges:\n        adj_list[s - 1].append(t - 1)\n        adj_list[t - 1].append(s - 1)\n    \n    def dfs(node: int, par: int, dep: int):\n        parent[node] = par\n        depth[node] = dep\n        for neighbor in adj_list[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n    \n    dfs(0, -1, 0)\n    \n    # Function to find LCA of two nodes\n    def lca(x: int, y: int) -> int:\n        if depth[x] < depth[y]:\n            x, y = y, x\n        while depth[x] > depth[y]:\n            x = parent[x]\n        while x != y:\n            x = parent[x]\n            y = parent[y]\n        return x\n    \n    # Calculate the minimum energy path using LCA\n    def calculate_energy(x: int, y: int) -> int:\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    total_energy = 0\n    current = u - 1\n    target = v - 1\n    ancestor = lca(current, target)\n    \n    # Traverse from current to ancestor\n    while current != ancestor:\n        total_energy += calculate_energy(current, parent[current])\n        current = parent[current]\n    \n    # Traverse from target to ancestor\n    while target != ancestor:\n        total_energy += calculate_energy(target, parent[target])\n        target = parent[target]\n    \n    return total_energy\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = find_min_energy_path(n, edges, illusion_rates, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Updates the illusion rate of the u-th room to c.\"\"\"\n    illusion_rates[u - 1] = c\n\ndef calculate_min_energy(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int], u: int, v: int) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    # Build adjacency list for the tree representation of the maze\n    adjacency_list = [[] for _ in range(n)]\n    for s, t in edges:\n        adjacency_list[s - 1].append(t - 1)\n        adjacency_list[t - 1].append(s - 1)\n\n    # Perform DFS to find the path from u to v and calculate the energy\n    def dfs(current: int, target: int, visited: List[bool], path_energy: int) -> int:\n        if current == target:\n            return path_energy\n        visited[current] = True\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                energy = max(abs(illusion_rates[current] + illusion_rates[neighbor]),\n                             abs(illusion_rates[current] - illusion_rates[neighbor]))\n                result = dfs(neighbor, target, visited, path_energy + energy)\n                if result != -1:\n                    return result\n        visited[current] = False\n        return -1\n\n    visited = [False] * n\n    return dfs(u - 1, v - 1, visited, 0)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    edges = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        edges.append((s, t))\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        queries.append((query_type, u, v))\n        index += 3\n    \n    for query in queries:\n        if query[0] == 1:\n            u, c = query[1], query[2]\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == 2:\n            u, v = query[1], query[2]\n            result = calculate_min_energy(n, edges, illusion_rates, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.preprocess()\n\n    def preprocess(self):\n        \"\"\"Preprocess the tree to calculate parent and depth for each node.\"\"\"\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Depth-First Search to set parent and depth.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Update the illusion rate of a specific room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n        lca = self.find_lca(u, v)\n        path = self.get_path(u, lca) + self.get_path(v, lca)[::-1][1:]\n        total_energy = 0\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            ax, ay = self.illusion_rates[x - 1], self.illusion_rates[y - 1]\n            total_energy += max(abs(ax + ay), abs(ax - ay))\n        return total_energy\n\n    def find_lca(self, u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor (LCA) of nodes u and v.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def get_path(self, u: int, v: int) -> List[int]:\n        \"\"\"Get the path from node u to node v.\"\"\"\n        path = []\n        while u != v:\n            path.append(u)\n            u = self.parent[u]\n        path.append(v)\n        return path\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            maze.update_illusion_rate(u, c)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = maze.calculate_min_energy(u, v)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations for navigation queries. The tree structure of the maze allows for efficient traversal algorithms, and the constraints on illusion rates require careful handling to avoid overflow or precision errors.\nrequirement pool:\n- Efficient query processing for both update and navigation queries\n- Accurate energy calculation using the given formula\n- Scalability to handle maximum input constraints\n- User-friendly interface for input and output\n- Optimization for large-scale data handling\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the navigation queries. For the update queries, we will directly update the illusion rate in an array. The DFS will help in precomputing necessary data for LCA, and LCA will allow us to quickly find the path between any two nodes in the tree. This approach ensures that both types of queries are processed in logarithmic time relative to the number of rooms, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and is used in calculations for determining the energy needed for movement.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing for a unique path between any two rooms.\n\n    'queries'\n    Explanation: There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves taking the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'smallest'\n    Explanation: In the context of type 2 queries, it refers to finding the minimum sum of energy required to move from one room to another. This involves calculating the path with the least energy cost using precomputed data from DFS and LCA.\n\n# [code logic]\n    1. Parse input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Perform DFS to precompute data necessary for LCA, such as parent and depth information.\n    4. Implement LCA to efficiently find paths between any two rooms.\n    5. For type 1 queries, update the illusion rate in the array.\n    6. For type 2 queries, use LCA to find the path and calculate the energy using the max(|a_x + a_y|, |a_x - a_y|) formula.\n    7. Output results for type 2 queries.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Expected Output: 3000000000\n    Explanation: The initial path requires maximum energy due to high illusion rates. After updating, the path still requires significant energy.\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 4 -5\n           2 1 4\n    Expected Output: 30\n                     30\n    Explanation: The illusion rates are negative but equal, resulting in consistent energy calculations before and after updates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will efficiently handle all cases including edge cases due to its comprehensive path calculation approach.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 queries and room updates, ensuring that each query is processed in optimal time. The tree structure of the maze allows for efficient traversal and pathfinding, which should be leveraged to minimize energy calculations. Dynamic updates to room illusion rates must be handled seamlessly to ensure accurate energy calculations.\nrequirement pool:\n- Efficient query processing for energy calculations\n- Dynamic updates to room illusion rates\n- Accurate pathfinding within the maze\n- User-friendly interface for input and output\n- Scalability to handle large mazes and query volumes\nWe will use Depth First Search (DFS) for pathfinding in the tree structure of the maze. To efficiently handle updates and queries, we will utilize a Segment Tree or Fenwick Tree (Binary Indexed Tree) to manage the illusion rates dynamically. This approach allows us to efficiently update and query the minimum energy required for traversal.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is organized as a tree, meaning there are n rooms connected by n-1 tunnels, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the max function and abs function.\n\n# [degree adverb]\n    'smallest': In the context of queries, it refers to finding the minimum sum of energy needed to access the treasure from one room to another. This can be implemented by finding the shortest path in terms of energy cost.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree structure using adjacency lists.\n    3. Implement DFS to find paths between rooms.\n    4. Use a Segment Tree or Fenwick Tree to manage dynamic updates to illusion rates.\n    5. For type 1 queries, update the illusion rate of a specified room.\n    6. For type 2 queries, calculate the minimum energy required using DFS and current illusion rates.\n\n# [edge case]\n    Case 1: When all rooms have an illusion rate of zero.\n    Input: \n    ```\n    3 2\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: \n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, no energy is required to move between any rooms.\n\n    Case 2: When there is only one query and it updates an illusion rate.\n    Input:\n    ```\n    2 1\n    5 -5\n    1 2\n    1 1 -10\n    ```\n    Expected Output: \n    ```\n    (No output for type 1 query)\n    ```\n    Explanation: The query updates the illusion rate but does not require an output as it is not a type 2 query.\n\n    Case 3: When there are multiple paths with equal energy cost.\n    Input:\n    ```\n    4 1\n    3 -3 3 -3\n    1 2\n    2 3\n    3 4\n    2 1 4\n    ```\n    Expected Output: \n    ```\n    12\n    ```\n    Explanation: Both paths (1 \u2192 2 \u2192 3 \u2192 4 and any other combination) have equal energy cost due to symmetry in illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and dynamic data structures will handle these cases efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating room illusion rates and calculating the minimum energy required for navigation. The solution must handle large input sizes and ensure quick response times for both types of queries.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy required.\n- Ensure the solution can handle the maximum constraints of n and q.\n- Optimize the algorithm for quick response times.\n- Provide clear and accurate output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and dynamic updates. The DFS will help in precomputing necessary data for quick LCA queries, which will be used to determine the path between any two rooms. We will also maintain an array to store the illusion rates, allowing for efficient updates and energy calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes.\n    'illusion rate': This is a value associated with each room that affects the energy required to move between rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'smallest': Refers to finding the minimum energy sum required to access the secret treasure. In code, this involves calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Implement DFS to precompute necessary data for LCA queries.\n    4. For type 1 queries, update the illusion rate of the specified room.\n    5. For type 2 queries, use LCA to find the path between rooms u and v, and calculate the energy required using the precomputed data.\n    6. Output the minimum energy for each type 2 query.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Output: 20\n    Explanation: The path from room 1 to room 3 is via room 2, requiring max(|10 + (-10)|, |10 - (-10)|) = 20 energy.\n\n    Input: 4 1\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Output: 0\n    Explanation: All rooms have the same illusion rate, so moving between them requires no energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of calculating energy using max(|a_x + a_y|, |a_x - a_y|) inherently handles these scenarios correctly.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to navigate a dynamically changing maze. The solution must handle updates to room illusion rates and calculate the minimum energy required for navigation. The tree structure of the maze and the constraints on room connections must be considered for optimal pathfinding.\nrequirement pool:\n- Efficient query processing for navigation\n- Dynamic updates to room illusion rates\n- Minimize energy consumption for pathfinding\n- Robust handling of tree structure and constraints\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) algorithms to efficiently process the queries. The DFS will help in traversing the tree structure of the maze, while LCA will assist in finding the shortest path between two rooms. We will use adjacency lists to represent the tree and segment trees for dynamic updates of the illusion rates. Libraries like 'collections' for efficient data handling and 'sys' for fast input/output operations will be utilized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected acyclic graph, which in this context represents the maze structure with rooms as nodes and tunnels as edges.\n    'illusion rate': A numerical value associated with each room that affects the energy required to move between rooms.\n    'energy': The cost of moving between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'n - 1 tunnels': Indicates that there are exactly n-1 connections, forming a tree structure.\n    'max(|a_x + a_y|, |a_x - a_y|)': This is the formula to calculate the energy required to move between two rooms x and y.\n\n# [degree adverb]\n    'smallest': Refers to finding the minimum energy sum required to travel from one room to another.\n\n# [code logic]\n1. Parse the input to read the number of rooms (n), number of queries (q), and the initial illusion rates.\n2. Construct the tree using adjacency lists based on the given tunnels.\n3. Implement DFS to preprocess the tree for LCA computation, storing necessary information like parent and depth of each node.\n4. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), use LCA to find the path between the two rooms and calculate the total energy using the given formula.\n5. Output the result for each type 2 query.\n\n# [edge case]\n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 1\n             1000000000 -1000000000 1000000000\n             1 2\n             2 3\n             2 1 3\n       Output: 3000000000\n       Explanation: The path is 1 \u2192 2 \u2192 3, with energies max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 and max(|-1000000000 + 1000000000|, |-1000000000 - 1000000000|) = 1000000000.\n\n    3. Input: 4 2\n             -5 -5 -5 -5\n             1 2\n             2 3\n             3 4\n             1 1 -10\n             2 1 4\n       Output: 20\n       Explanation: After updating room 1's illusion rate to -10, the path is 1 \u2192 2 \u2192 3 \u2192 4 with energies max(|-10 + (-5)|, |-10 - (-5)|) = 15, max(|-5 + (-5)|, |-5 - (-5)|) = 10, and max(|-5 + (-5)|, |-5 - (-5)|) = 10. Total energy is reduced by the update.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle these cases correctly by ensuring that all paths and updates are processed accurately.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates are processed quickly and accurately. Energy calculations should be optimized to minimize computational overhead, especially for large datasets.\nrequirement pool:\n- Efficient query processing for type 2 queries\n- Dynamic updates to room illusion rates for type 1 queries\n- Accurate energy calculations for navigation\n- Scalability to handle large numbers of rooms and queries\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the type 2 queries. For type 1 queries, we will simply update the illusion rate in an array. The DFS will help in precomputing necessary data for LCA, which will allow us to quickly compute the path and energy required between any two rooms. We will use adjacency lists to represent the tree structure of the maze.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, where any two nodes are connected by exactly one path.\n    'illusion rate': A value associated with each room that affects the energy required to move between rooms.\n    'energy': The cost of moving between rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'n - 1 tunnels': Indicates that the number of tunnels is one less than the number of rooms, which is characteristic of a tree structure.\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase describes the calculation of energy required to move between two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest energy sum': Refers to finding the minimum energy required to travel between two rooms. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to get the number of rooms `n`, number of queries `q`, initial illusion rates, and the connections between rooms.\n2. Construct an adjacency list to represent the tree structure of the maze.\n3. Use Depth First Search (DFS) to precompute necessary data for Lowest Common Ancestor (LCA) calculations.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, use LCA to determine the path between two rooms and calculate the total energy required using the given formula.\n6. Output the result for each type 2 query.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1\n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: 10\n       Explanation: Only one path exists, and energy is calculated as max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: All illusion rates are zero, so energy is max(|0 + 0|, |0 - 0|) = 0 for any path.\n\n    3. Maximum possible illusion rate change:\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected Output: 2000000000\n       Explanation: After updating room 1's illusion rate, energy is max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle these cases correctly as it calculates paths and updates efficiently.\n", "requirement analysis:\nThe main requirement is to efficiently handle two types of queries: updating the illusion rate of a room and calculating the minimum energy required to reach a specific room. The solution must be optimized for large inputs, given the constraints of up to 100,000 rooms and queries. The tree structure of the maze allows for efficient traversal algorithms, which should be leveraged to minimize computational overhead.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries\n- Optimize energy calculation for large datasets\n- Ensure the program handles edge cases and large inputs\n- Provide clear and concise output for each query\n- Develop a user-friendly interface for input and output\nWe will use Depth First Search (DFS) to traverse the tree structure of the maze efficiently. For type 2 queries, we will precompute the paths using DFS and store the results in a data structure that allows quick retrieval of the minimum energy required. For type 1 queries, we will update the illusion rate directly in the list and ensure the precomputed paths are updated accordingly. The use of DFS ensures that we can handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is organized as a tree, meaning there are n rooms connected by n-1 tunnels, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between rooms x and y is calculated using max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of rooms x and y.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb]\n    'smallest': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to retrieve the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree structure using adjacency lists.\n3. Implement DFS to traverse the tree and precompute paths for type 2 queries.\n4. For type 1 queries, update the illusion rate of the specified room and adjust precomputed paths if necessary.\n5. For type 2 queries, use precomputed paths to quickly retrieve and calculate the minimum energy required.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2000000000\n    Explanation: The maximum possible illusion rate difference is used, resulting in high energy consumption.\n\n    Input: 4 3\n           1 -1 1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 6\n    Explanation: The path from room 1 to room 4 involves alternating illusion rates, resulting in moderate energy consumption.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and precomputed paths will handle these scenarios efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating room conditions and calculating the minimum energy required for navigation. The solution must handle large input sizes and provide accurate results quickly. The tree structure of the maze allows for efficient traversal and updates.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy required.\n- Ensure the solution can handle the maximum input size efficiently.\n- Provide clear and accurate output for each query.\n- Optimize the solution for both time and space complexity.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and process the queries. The DFS will help in precomputing necessary information for each node, and LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and affects the calculation of energy.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each movement between two rooms, we need to calculate both |a_x + a_y| and |a_x - a_y|, and take the maximum of these two values as the energy cost.\n\n# [degree adverb] \n    'smallest': In the context of the query type 2, it refers to finding the minimum sum of energy needed to travel from room u to room v.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Use DFS to precompute necessary information for each node, such as parent and depth.\n3. Implement LCA (Lowest Common Ancestor) to find the path between any two nodes efficiently.\n4. Use a Segment Tree or similar data structure to handle updates to the illusion rates efficiently.\n5. For each type 2 query, calculate the energy required to move from room u to room v using the precomputed information and current illusion rates.\n\n# [edge case] \n    1. Query with u = v (e.g., 2 1 1) = 0\n       Explanation: If the start and end rooms are the same, no movement is needed, so the energy required is 0.\n    \n    2. All rooms have the same illusion rate (e.g., all a_i = 0) = 0\n       Explanation: If all rooms have an illusion rate of 0, then max(|a_x + a_y|, |a_x - a_y|) will always be 0 for any path.\n    \n    3. Maximum possible illusion rate change (e.g., update query with c = 10^9) = depends on subsequent queries\n       Explanation: This tests the ability of the program to handle large updates efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases specifically, as they are naturally handled by the logic of calculating energy and using efficient data structures like Segment Trees for updates. However, ensuring that our data structures can handle large values and updates efficiently is crucial.\n", "requirement analysis:\nThe requirements focus on efficiently processing a large number of queries on a tree-structured maze. The key challenges include handling dynamic updates to the illusion rates and computing the minimum energy path between rooms. The solution must be optimized for performance given the constraints on the number of rooms and queries.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Support dynamic updates to room illusion rates.\n- Optimize energy calculation for pathfinding.\n- Ensure scalability for large mazes.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the pathfinding queries. For dynamic updates, we will maintain an array of illusion rates and update it as needed. The DFS will help in precomputing necessary data for LCA, and LCA will allow us to quickly find the path between any two nodes in the tree. This approach ensures that both update and query operations are efficient, even for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute value of the sum and the absolute value of the difference of their illusion rates. In code, this can be implemented using the `max` function with `abs` for absolute values.\n\n# [degree adverb]\n    'smallest'\n    Explanation: For type 2 queries, we need to find the smallest energy sum required to reach the treasure from a starting room. This involves calculating the path with the minimum energy cost.\n\n# [code logic]\n    - Initialize an array to store illusion rates for each room.\n    - Use DFS to precompute data necessary for LCA, such as parent and depth information for each node.\n    - Implement LCA to efficiently find paths between nodes.\n    - For type 1 queries, update the illusion rate of a specified room.\n    - For type 2 queries, calculate the minimum energy required using precomputed LCA data and current illusion rates.\n\n# [edge case]\n    1 1 -3 = No output (update operation)\n    Explanation: This query updates the illusion rate of room 1 to -3, so no output is expected.\n    \n    2 1 1 = 0\n    Explanation: If the start and end room are the same, no movement is needed, hence zero energy is required.\n    \n    2 3 3 = 0\n    Explanation: Similarly, if both start and end rooms are room 3, no movement is needed, hence zero energy is required.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic already accounts for scenarios where no movement is needed by returning zero energy when start and end rooms are identical.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates are processed quickly and that energy calculations are accurate. The tree structure of the maze allows for efficient traversal and query processing using algorithms such as DFS or BFS.\nrequirement pool:\n- Efficient query processing for type 2 queries\n- Dynamic updates to illusion rates for type 1 queries\n- Accurate energy calculation using max(|a_x + a_y|, |a_x - a_y|)\n- Handle large input sizes without performance degradation\n- User-friendly output format\nWe will use Depth First Search (DFS) to efficiently traverse the tree structure of the maze for type 2 queries. For type 1 queries, we will directly update the illusion rate in an array. The DFS will help in calculating the minimum energy required to move between rooms by maintaining a path and calculating the energy using the given formula. We will use adjacency lists to represent the tree structure and handle updates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': The maze is structured as a tree, meaning there are no cycles, and there is exactly one path between any two rooms.\n    'illusion rate': Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n    'energy calculation': The energy required to move between rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest': In type 2 queries, we need to find the smallest energy sum required to reach the treasure. This involves finding the minimum path energy using DFS traversal.\n\n# [code logic]\n    1. Parse the input to get the number of rooms and queries, initial illusion rates, and tunnel connections.\n    2. Represent the maze as a tree using adjacency lists.\n    3. For type 1 queries, update the illusion rate of the specified room directly in an array.\n    4. For type 2 queries, use DFS to traverse from the starting room to the target room, calculating the energy required for each step using the given formula.\n    5. Accumulate the energy for each path and return the total for type 2 queries.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2) with maximum illusion rates.\n    Input: \n    ```\n    2 1\n    1000000000 -1000000000\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    Explanation: The energy calculation will be max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = max(0, 2000000000) = 2000000000.\n\n    Case 2: All rooms have zero illusion rate.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: \n    Explanation: The energy calculation will be max(|0 + 0|, |0 - 0|) = max(0, 0) = 0 for each step.\n\n    Case 3: Single query with no movement needed (same start and end room).\n    Input:\n    ```\n    4 1\n    5 -5 10 -10\n    1 2\n    2 3\n    3 4\n    2 3 3\n    ```\n    Expected Output: \n    Explanation: Since the start and end room are the same, no movement is needed, so the energy required is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS traversal and direct updates for type 1 queries will naturally handle these scenarios.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 queries and room updates, ensuring that each query is processed in a time-efficient manner. The tree structure of the maze allows for traversal using depth-first search or breadth-first search algorithms, which can be optimized for energy calculation. Dynamic updates to room illusion rates require efficient data structures to maintain and update values.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Dynamic updates to room illusion rates\n- Handle large input sizes efficiently\n- Ensure accurate energy calculations\n- Provide a user-friendly interface for input and output\nWe will use a combination of Depth-First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will help in managing the dynamic updates of the illusion rates and efficiently calculating the minimum energy required for each query. This approach ensures that both update and query operations are handled in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, where any two nodes are connected by exactly one path.\n    'illusion rate': A value associated with each room that affects the energy required to move between rooms.\n    'energy': The cost of moving between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'n - 1 tunnels': Indicates that there are exactly n-1 connections, forming a tree structure.\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase describes the calculation of energy required to move between two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest': Refers to finding the minimum energy sum required for a path. This can be implemented using algorithms that find the shortest path or minimum cost path in a tree.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Use Depth-First Search (DFS) to preprocess the tree for efficient Lowest Common Ancestor (LCA) queries, which will help in finding paths between any two nodes.\n3. Implement a Segment Tree or similar data structure to handle updates to the illusion rates and efficiently compute energy costs.\n4. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), use LCA to determine the path and calculate the total energy required using the current illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1, with an update query.\n       Explanation: The simplest case with only two rooms and one update query. The output should reflect the updated illusion rate.\n    2. All rooms have zero illusion rate initially: n = 3, q = 1, with a path query.\n       Explanation: Since all illusion rates are zero, any path should have zero energy cost.\n    3. Maximum possible illusion rate change: n = 3, q = 1, with an update query setting an illusion rate to 10^9.\n       Explanation: Tests handling of large numbers and ensures no overflow occurs in calculations.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large numbers and ensure efficient updates and queries.\n    - Ensure that the Segment Tree or data structure used can handle large values without overflow.\n    - Implement checks for edge cases where all illusion rates are zero to optimize calculations.\n"], "scores": [], "pass_results": [true, true, true, true, false, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 545, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 260}
