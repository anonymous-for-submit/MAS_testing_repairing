{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. This means for a given integer n, you can represent special numbers using the distinct powers of n in their sum. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. This means for a given integer n, you can represent special numbers using the distinct powers of n in their sum. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. This means for a given integer n, you can represent special numbers using the distinct powers of n in their sum. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2. The number 4^0 equals 1 and 4^2 equals 16, so when you add them, the result is 17. But unlike this example, 9 is not special.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n, meaning for a given integer n, you can represent special numbers using the distinct powers of n in their sum. For example, for n = 4 number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of a given integer n.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers where each integer is the k-th special number\n        modulo 10^9+7 for the corresponding test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        # Initialize the result for this test case\n        special_number = 0\n        power = 1\n        index = 0\n        \n        # Use bit manipulation to determine which powers of n to include\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n            index += 1\n        \n        results.append(special_number)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Process each test case\n    results = find_kth_special_number(test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    MOD = 10**9 + 7\n    results = []\n\n    for n, k in test_cases:\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(result)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1  # Start with n^0 which is 1\n        while k > 0:\n            if k & 1:  # Check if the least significant bit is set\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO  # Move to the next power of n\n            k >>= 1  # Shift k to process the next bit\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k >>= 1\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of a given integer n.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers where each integer is the k-th special number\n        modulo 10^9+7 for the corresponding test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Compute results\n    results = find_kth_special_number(t, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        k -= 1  # Convert k to zero-based index\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        special_number = (special_number + 1) % MOD  # Add the n^0 term\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of a given integer n.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        result = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                result = (result + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(result)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples containing n and k for each test case.\n\n    Returns:\n        List[int]: List of k-th special numbers modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 0\n        while k > 0:\n            if k & 1:  # Check if the least significant bit is set\n                special_number = (special_number + pow(n, power, MOD)) % MOD\n            k >>= 1  # Right shift k to process the next bit\n            power += 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe task requires computing the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large inputs efficiently and return results modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number.\n- Handle large values of n and k within constraints.\n- Implement modular arithmetic to ensure results fit within limits.\n- Optimize for multiple test cases in a single run.\n- Provide clear and concise output format.\nWe will use a combination of bit manipulation and modular arithmetic to efficiently compute the k-th special number. The key insight is that each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will generate these numbers using bit manipulation and sort them to find the k-th special number. Given the constraints, we will ensure the solution is optimized for large values of n and k by leveraging Python's inherent handling of large integers and using modulo operations to keep numbers within limits.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Use bit manipulation to generate numbers that are sums of distinct powers of n.\n3. For each integer i from 0 to k-1, interpret the binary representation of i as a selection of powers of n.\n4. Calculate the sum of these selected powers to form a special number.\n5. Store these special numbers and sort them.\n6. Retrieve the k-th special number from the sorted list.\n7. Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: (a large number modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the solution handles large values efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using bit manipulation and modulo operations inherently handles these cases efficiently.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The challenge lies in efficiently computing this for large values of n and k, ensuring results are within the modulo constraint.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Ensure results are modulo 10^9+7\n- Optimize for performance and memory usage\n- Provide clear and concise output format\nWe will use a combination of bit manipulation and mathematical properties to efficiently compute the k-th special number. The key insight is that each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will leverage Python's built-in capabilities for handling large integers and use modular arithmetic to ensure results are within the specified constraint.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be represented as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over possible powers of n and checking combinations that sum to the desired number.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This affects how we generate and select the k-th special number.\n\n# [code logic]\n    - Parse the input to get the number of test cases t.\n    - For each test case, read integers n and k.\n    - Generate special numbers using combinations of distinct powers of n.\n    - Sort these numbers in increasing order.\n    - Select the k-th special number from the sorted list.\n    - Return the result modulo 10^9+7.\n\n# [edge case]\n    For n = 2, k = 1: The sequence starts with [1], so the 1st special number is 1.\n    Explanation: The smallest power of 2 is 2^0 = 1, which is the first special number.\n\n    For n = 10^9, k = 1: The sequence starts with [1], so the 1st special number is 1.\n    Explanation: Regardless of n, the smallest power is always n^0 = 1.\n\n    For n = 3, k = 10^9: The sequence includes very large numbers, but we need to ensure computation efficiency and correct modulo operation.\n    Explanation: The sequence grows rapidly, and handling large k requires efficient computation and modular arithmetic.\n\n# [extra code for edge case]\n    We need extra code to handle large values of n and k efficiently.\n        def find_kth_special_number(n, k):\n            MOD = 10**9 + 7\n            special_numbers = []\n            i = 0\n            while len(special_numbers) < k:\n                num = sum(n**j for j in range(i+1))\n                special_numbers.append(num)\n                i += 1\n            special_numbers.sort()\n            return special_numbers[k-1] % MOD\n\n        (other code)\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where special numbers are sums of distinct powers of n. The solution must handle up to 10,000 test cases efficiently, with n and k values as large as 10^9. The output must be modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support multiple test cases\n- Provide clear and correct output format\nWe will use a combination of bit manipulation and mathematical properties to efficiently compute the k-th special number. The key insight is that special numbers can be represented as binary numbers where each bit represents a power of n. By iterating over the binary representation of k, we can construct the k-th special number using powers of n. This approach leverages Python's ability to handle large integers and ensures efficient computation even for large values of n and k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is a non-negative integer. In code, this can be implemented by iterating over the binary representation of k and using each bit to determine whether to include a corresponding power of n in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when finding the k-th special number, we are looking for the k-th smallest number in this sequence.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Initialize a variable to store the k-th special number.\n3. Iterate over the binary representation of k.\n4. For each bit in the binary representation, if the bit is set (i.e., it is 1), add the corresponding power of n to the special number.\n5. Since the result may be large, take modulo 10^9+7 at each step to ensure the number remains manageable.\n6. Output the k-th special number modulo 10^9+7 for each test case.\n\n# [edge case]\n    Test case: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Test case: n = 2, k = 2\n    Expected output: 2\n    Explanation: The second special number for n = 2 is 2^1 = 2.\n\n    Test case: n = 3, k = 5\n    Expected output: 10\n    Explanation: The sequence of special numbers for n = 3 is [1, 3, 4, 9, 10...]. The fifth special number is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over the binary representation of k and constructing the special number using powers of n inherently handles these cases.\n", "requirement analysis:\nThe problem requires finding the k-th special number for a given base n, where special numbers are sums of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, outputting results modulo 10^9+7.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for both time and space complexity\nWe will use a binary representation approach to efficiently compute the k-th special number. The idea is to treat the number k as a binary number and use its bits to determine which powers of n to sum. This approach leverages the fact that each bit in the binary representation of k corresponds to a power of n, allowing us to construct the k-th special number directly. This method is efficient and can handle large values of n and k due to its logarithmic nature in terms of the number of operations required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0, 1, 2, ...).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    - Convert the integer k into its binary representation.\n    - For each bit in the binary representation of k, if the bit is set (i.e., 1), include the corresponding power of n in the sum.\n    - Calculate the sum of these powers to get the k-th special number.\n    - Return the result modulo 10^9+7 to handle large numbers.\n\n# [edge case]\n    Input: 2 1\n    Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Input: 2 2\n    Output: 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Input: 3 1\n    Output: 1\n    Explanation: The first special number for n=3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by considering the binary representation of k and calculating the sum of powers accordingly.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where special numbers are sums of distinct powers of n. The solution must handle up to 10,000 test cases efficiently, with n and k values as large as 10^9. The output must be modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Scalability for large n and k values\n- Accurate results within constraints\n- Robust handling of multiple test cases\n- Correct output formatting\nWe will use a binary representation approach to efficiently compute the k-th special number. The k-th special number can be derived by interpreting k as a binary number and using the positions of the '1's to determine which powers of n to sum. This approach is efficient and scalable for large values of n and k. We will use Python's built-in capabilities to handle large integers and modular arithmetic to ensure results are within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is a non-negative integer. In code, this can be implemented by iterating over the binary representation of k and summing the corresponding powers of n where the binary digit is 1.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or accessing these numbers, they should be considered in ascending order.\n\n# [code logic]\n1. Read the number of test cases, t.\n2. For each test case, read the integers n and k.\n3. Convert k to its binary representation.\n4. Initialize a variable to store the special number.\n5. Iterate over each bit in the binary representation of k:\n   - If the bit is 1, add the corresponding power of n to the special number.\n6. Take the result modulo 10^9+7 to ensure it fits within the required constraints.\n7. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 2: (n=10^9, k=1) = 1\n    Explanation: Even for large n, the first special number remains 1.\n\n    Edge Case 3: (n=2, k=10^9) = (result modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the calculation handles large numbers correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modular arithmetic inherently handles these cases efficiently.\n", "requirement analysis:\nThe problem requires finding the k-th special number for a given base n. A special number is defined as a sum of distinct powers of n. The solution must efficiently compute this number even for large values of n and k, and return the result modulo 10^9+7. The challenge lies in handling the large input constraints and ensuring the computation is performed within a reasonable time frame.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Ensure correct output format\n- Optimize for speed and memory usage\nWe will use a mathematical approach to generate the k-th special number by considering the binary representation of k and using powers of n. This approach leverages the fact that each special number can be represented as a sum of distinct powers of n, which corresponds to the binary digits of k. We will use Python's built-in capabilities to handle large integers and perform modulo operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking if they contribute to the sum based on the binary representation of k.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest. This implies that when generating the sequence, we need to ensure the numbers are ordered correctly.\n\n# [code logic]\n    1. Read the number of test cases, t.\n    2. For each test case, read integers n and k.\n    3. Convert k to its binary representation.\n    4. Initialize a variable to store the special number.\n    5. Iterate over each bit in the binary representation of k:\n        - If the bit is set (i.e., 1), add the corresponding power of n to the special number.\n    6. Compute the result modulo 10^9+7.\n    7. Output the result for each test case.\n\n# [edge case]\n    Input: 2 1\n    Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Input: 2 2\n    Output: 2\n    Explanation: For n = 2, the second special number is 2, which corresponds to n^1.\n\n    Input: 3 1\n    Output: 1\n    Explanation: The first special number for n = 3 is also 1, corresponding to n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by considering the binary representation of k and computing powers of n accordingly.\n", "requirement analysis:\nThe problem requires finding the k-th special number for a given base n, where special numbers are sums of distinct powers of n. The solution must efficiently handle large values of n and k, and return results modulo 10^9+7. The challenge lies in efficiently computing these numbers without generating all possible combinations.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Implement modulo operation for large numbers\n- Optimize for performance and memory usage\n- Provide clear and concise output format\nWe will use a mathematical approach to generate the k-th special number by considering the binary representation of k and using powers of n. This avoids generating all combinations and efficiently computes the result. The modulo operation will be applied to handle large numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special numbers'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or positive). In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that the k-th special number is the k-th smallest number in this sorted sequence.\n\n# [code logic]\n    - Convert k to its binary representation.\n    - For each bit in the binary representation, if the bit is set (1), add the corresponding power of n to the sum.\n    - Apply modulo 10^9+7 to the result to handle large numbers.\n    - Return the computed sum as the k-th special number.\n\n# [edge case]\n    1. Input: 2 1\n       Output: 1\n       Explanation: The first special number for n=2 is 2^0 = 1.\n       \n    2. Input: 10^9 1\n       Output: 1\n       Explanation: The first special number for n=10^9 is 10^9^0 = 1.\n       \n    3. Input: 2 10^9\n       Output: (large number modulo 10^9+7)\n       Explanation: The k-th special number for large k will be computed using powers of 2, and the result will be modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modulo operation inherently handles these cases efficiently.\n", "requirement analysis:\nThe problem requires finding the k-th special number for a given base n, where special numbers are sums of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, outputting results modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Optimize for performance and memory usage\n- Ensure output is modulo 10^9+7\n- Provide clear and concise output format\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k-1 to its base-n representation, we can determine the k-th special number by interpreting each digit as a power of n. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are within the specified modulo constraint.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special numbers'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and summing them based on the binary representation of k-1.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that the k-th special number is the k-th smallest number in this sequence.\n\n# [code logic]\n    1. Convert k-1 to its base-n representation.\n    2. Interpret each digit in this representation as a power of n.\n    3. Sum these powers to get the k-th special number.\n    4. Apply modulo 10^9+7 to the result to handle large numbers.\n\n# [edge case]\n    For n = 2, k = 1 = 1\n    Explanation: The first special number for n=2 is simply 2^0 = 1.\n\n    For n = 10^9, k = 1 = 1\n    Explanation: Even for very large n, the first special number is always 1 because it corresponds to n^0.\n\n    For n = 2, k = 10^9 = (result modulo 10^9+7)\n    Explanation: This tests the upper limit of k, ensuring that the code handles large values and applies the modulo correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by using base-n representation and applying modulo arithmetic.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where special numbers are sums of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a combination of bit manipulation and mathematical properties to efficiently compute the k-th special number. The key insight is that each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will leverage this by iterating over binary numbers and computing the sum of powers of n for each binary number until we reach the k-th special number. This approach ensures scalability and efficiency even for large values of n and k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Initialize a variable to store the k-th special number.\n3. Use bit manipulation to iterate over binary numbers:\n   - For each binary number, calculate the sum of powers of n corresponding to the positions of 1s in the binary representation.\n   - Keep track of how many special numbers have been generated.\n4. Once the k-th special number is found, take it modulo 10^9+7 and store the result.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case with smallest values: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Test case with large n and small k: (n=10^9, k=1) = 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Test case with large k: (n=2, k=10^9) = (result modulo 10^9+7)\n    Explanation: This tests the efficiency and correctness of handling large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using bit manipulation and modulo operation will handle all cases efficiently.\n", "requirement analysis:\nThe problem requires finding the k-th special number for a given base n. A special number is defined as a sum of distinct powers of n. The solution must efficiently compute this number even for large values of n and k, and return the result modulo 10^9+7. The challenge lies in handling the large input sizes and ensuring the computation is performed within reasonable time limits.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Ensure results are modulo 10^9+7\n- Optimize for speed and accuracy\n- Provide clear and concise output format\nWe will use a binary representation approach to solve the problem. The k-th special number can be derived by interpreting the binary representation of k as a sum of powers of n. This approach is efficient because it directly maps the binary digits to powers of n, allowing us to compute the k-th special number in logarithmic time relative to k. We will use Python's built-in capabilities to handle large integers and perform modular arithmetic to ensure results are within the specified modulo.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or positive). In code, this can be implemented by iterating over the binary representation of k and using each bit to determine whether to include a corresponding power of n in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted in increasing order, meaning each subsequent number is greater than or equal to the previous one. This affects how we determine the k-th special number, as we need to ensure the sequence is correctly ordered.\n\n# [code logic]\n    1. Read the number of test cases t.\n    2. For each test case, read integers n and k.\n    3. Convert k to its binary representation.\n    4. Initialize a variable to store the special number.\n    5. Iterate over each bit in the binary representation of k:\n        - If the bit is set (1), add n raised to the power of the bit's position to the special number.\n    6. Apply modulo 10^9+7 to the result.\n    7. Output the result for each test case.\n\n# [edge case]\n    Case 1: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Case 2: n = 10^9, k = 1\n    Expected output: 1\n    Explanation: Even for large n, the first special number is always 1 (n^0).\n\n    Case 3: n = 2, k = 10^9\n    Expected output: A large number modulo 10^9+7\n    Explanation: This tests the ability to handle large values of k and ensure results are within modulo constraints.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles all cases by using binary representation and modular arithmetic.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 865, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "expand_one2two", "parent_index": 539}
