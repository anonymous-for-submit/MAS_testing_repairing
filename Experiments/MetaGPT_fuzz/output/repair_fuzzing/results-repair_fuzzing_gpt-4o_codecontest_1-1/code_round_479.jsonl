{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, assisting his long-lost relative Indiana Jones, in locating a hidden treasure in a maze buried beneath a desert filled with illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, joined by n - 1 tunnels enabling travel between every pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and to move from the x-th room to the y-th room, there must exist a tunnel between x and y, which requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| represents the absolute value of z. To guard against grave robbers, the maze can alter the illusion rate of any room in it, and Chanek and Indiana would make q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 Change the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Make sure your solution is efficient to handle large inputs.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, assisting his long-lost relative Indiana Jones, in locating a hidden treasure in a maze buried beneath a desert filled with illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, joined by n - 1 tunnels enabling travel between every pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and to move from the x-th room to the y-th room, there must exist a tunnel between x and y, which requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| represents the absolute value of z. To guard against grave robbers, the maze can alter the illusion rate of any room in it, and Chanek and Indiana would make q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 Change the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Make sure your solution is efficient to handle large inputs.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, assisting his long-lost relative Indiana Jones, in locating a hidden treasure in a maze buried beneath a desert filled with illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. These rooms are joined by n - 1 tunnels enabling travel between every pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and to move from the x-th room to the y-th room, there must exist a tunnel between x and y, which requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| represents the absolute value of z. To guard against grave robbers, the maze can alter the illusion rate of any room in it, and Chanek and Indiana would make q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 Change the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Make sure your solution is efficient to handle large inputs.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, assisting his long-lost relative Indiana Jones, in locating a hidden treasure in a maze buried beneath a desert filled with illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, joined by n - 1 tunnels enabling travel between every pair of rooms via multiple tunnels, and to move from the x-th room to the y-th room, there must exist a tunnel between x and y, which requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| represents the absolute value of z. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To guard against grave robbers, the maze can alter the illusion rate of any room in it, and Chanek and Indiana would make q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 Change the illusion rate of the x-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Make sure your solution is efficient to handle large inputs.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle dynamic updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Update the value at index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef find_path(u: int, v: int, tunnels: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the path from room u to room v using BFS.\"\"\"\n    adj_list = defaultdict(list)\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n\n    queue = deque([(u, [u])])\n    visited = set()\n\n    while queue:\n        current, path = queue.popleft()\n        if current == v:\n            return path\n        visited.add(current)\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                queue.append((neighbor, path + [neighbor]))\n\n    return []  # Return empty if no path found, though it should not happen in a tree\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    path = find_path(u, v, tunnels)\n    \n    energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient updates and queries.\"\"\"\n    \n    def __init__(self, n: int):\n        \"\"\"Initialize the segment tree with a given size.\"\"\"\n        self.n = n\n        self.tree = [0] * (4 * n)\n\n    def update(self, idx: int, value: int, node: int = 1, node_left: int = 0, node_right: int = None):\n        \"\"\"Update the value at a specific index in the segment tree.\"\"\"\n        if node_right is None:\n            node_right = self.n - 1\n\n        if node_left == node_right:\n            self.tree[node] = value\n            return\n\n        mid = (node_left + node_right) // 2\n        if idx <= mid:\n            self.update(idx, value, node * 2, node_left, mid)\n        else:\n            self.update(idx, value, node * 2 + 1, mid + 1, node_right)\n\n        self.tree[node] = max(self.tree[node * 2], self.tree[node * 2 + 1])\n\n    def query(self, left: int, right: int, node: int = 1, node_left: int = 0, node_right: int = None) -> int:\n        \"\"\"Query the maximum value in a given range.\"\"\"\n        if node_right is None:\n            node_right = self.n - 1\n\n        if right < node_left or left > node_right:\n            return float('-inf')\n\n        if left <= node_left and node_right <= right:\n            return self.tree[node]\n\n        mid = (node_left + node_right) // 2\n        return max(self.query(left, right, node * 2, node_left, mid),\n                   self.query(left, right, node * 2 + 1, mid + 1, node_right))\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy path between two rooms.\"\"\"\n    # Build adjacency list for the tree\n    adj_list = defaultdict(list)\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n\n    # Perform BFS to find the path from u to v\n    parent = {u: None}\n    queue = deque([u])\n    while queue:\n        current = queue.popleft()\n        if current == v:\n            break\n        for neighbor in adj_list[current]:\n            if neighbor not in parent:\n                parent[neighbor] = current\n                queue.append(neighbor)\n\n    # Backtrack to find the path\n    path = []\n    step = v\n    while step is not None:\n        path.append(step)\n        step = parent[step]\n    path.reverse()\n\n    # Calculate the energy cost along the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n\n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    segment_tree = SegmentTree(n)\n    for i, rate in enumerate(illusion_rates):\n        segment_tree.update(i, rate)\n\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = min_energy_path(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef handle_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    Handles the queries for updating illusion rates and calculating minimum energy paths in a tree structure.\n\n    Args:\n        n (int): Number of rooms.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        tunnels (List[Tuple[int, int]]): List of tunnels connecting rooms.\n        queries (List[Tuple[int, int, int]]): List of queries to process.\n\n    Returns:\n        List[int]: Results of type 2 queries (minimum energy paths).\n    \"\"\"\n    # Build adjacency list for the tree\n    from collections import defaultdict, deque\n\n    adjacency_list = defaultdict(list)\n    for u, v in tunnels:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    # Function to perform DFS and calculate the path energy\n    def dfs(u: int, v: int, visited: set) -> int:\n        if u == v:\n            return 0\n        visited.add(u)\n        for neighbor in adjacency_list[u]:\n            if neighbor not in visited:\n                energy = max(abs(illusion_rates[u - 1] + illusion_rates[neighbor - 1]),\n                             abs(illusion_rates[u - 1] - illusion_rates[neighbor - 1]))\n                result = dfs(neighbor, v, visited)\n                if result != -1:\n                    return energy + result\n        return -1\n\n    # Process each query\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update the illusion rate of a room\n            u, c = query[1], query[2]\n            illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Calculate the minimum energy path from room u to room v\n            u, v = query[1], query[2]\n            visited = set()\n            energy = dfs(u, v, visited)\n            results.append(energy)\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = handle_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]):\n    \"\"\"Update the illusion rate of a specific room and update the segment tree.\"\"\"\n    # Update the illusion rate in the list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree with the new rate\n    update_segment_tree(segment_tree, 0, len(illusion_rates) - 1, 0, room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], segment_tree: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    # Use DFS to find the path from u to v\n    path = find_path(u, v, tree)\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return energy\n\ndef update_segment_tree(segment_tree: List[int], start: int, end: int, node: int, idx: int, value: int):\n    \"\"\"Update the segment tree with a new value at a specific index.\"\"\"\n    if start == end:\n        segment_tree[node] = value\n    else:\n        mid = (start + end) // 2\n        if start <= idx <= mid:\n            update_segment_tree(segment_tree, start, mid, 2 * node + 1, idx, value)\n        else:\n            update_segment_tree(segment_tree, mid + 1, end, 2 * node + 2, idx, value)\n        segment_tree[node] = max(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n\ndef find_path(u: int, v: int, tree: List[List[int]]) -> List[int]:\n    \"\"\"Find the path from room u to room v using DFS.\"\"\"\n    visited = [False] * len(tree)\n    path = []\n    def dfs(current: int, target: int) -> bool:\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target):\n                    return True\n        path.pop()\n        return False\n    dfs(u, v)\n    return path\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    segment_tree = [0] * (4 * n)\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree, segment_tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]):\n    \"\"\"Performs DFS to calculate depth and parent for each node.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth: List[int]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    ancestor = lca(u, v, depth, parent_list)\n    energy = 0\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u] + illusion_rates[parent_list[u]]), abs(illusion_rates[u] - illusion_rates[parent_list[u]]))\n        u = parent_list[u]\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v] + illusion_rates[parent_list[v]]), abs(illusion_rates[v] - illusion_rates[parent_list[v]]))\n        v = parent_list[v]\n    return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Processes the queries and returns the results.\"\"\"\n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    # Preprocess using DFS\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_list)\n    \n    # Initialize Segment Tree\n    segment_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1], query[2]\n            segment_tree.update(u - 1, c)\n            illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Energy calculation query\n            u, v = query[1], query[2]\n            energy = calculate_energy(u, v, illusion_rates, parent_list, depth)\n            results.append(energy)\n    \n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room and update the segment tree.\"\"\"\n    # Update the illusion rate in the list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree with the new rate\n    update_segment_tree(segment_tree, 0, len(illusion_rates) - 1, room - 1, new_rate, 0)\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], segment_tree: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    # Find the path from u to v using DFS\n    path = find_path(tree, u, v)\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return energy\n\ndef update_segment_tree(segment_tree: List[int], start: int, end: int, idx: int, value: int, node: int) -> None:\n    \"\"\"Update the segment tree for a specific index.\"\"\"\n    if start == end:\n        segment_tree[node] = value\n    else:\n        mid = (start + end) // 2\n        if start <= idx <= mid:\n            update_segment_tree(segment_tree, start, mid, idx, value, 2 * node + 1)\n        else:\n            update_segment_tree(segment_tree, mid + 1, end, idx, value, 2 * node + 2)\n        segment_tree[node] = max(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n\ndef find_path(tree: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"Find the path from start to end using DFS.\"\"\"\n    visited = [False] * len(tree)\n    path = []\n    if dfs(tree, start, end, visited, path):\n        return path\n    return []\n\ndef dfs(tree: List[List[int]], current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n    \"\"\"Depth First Search to find a path from current to target.\"\"\"\n    visited[current] = True\n    path.append(current)\n    if current == target:\n        return True\n    for neighbor in tree[current]:\n        if not visited[neighbor]:\n            if dfs(tree, neighbor, target, visited, path):\n                return True\n    path.pop()\n    return False\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    segment_tree = [0] * (4 * n)  # Placeholder for segment tree initialization\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == 2:\n            _, u, v = query\n            result = min_energy_path(u, v, illusion_rates, segment_tree, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficient updates and queries on illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree from the initial data.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], current: int, parent: int, depth: List[int], parent_list: List[int]):\n    \"\"\"Performs DFS to calculate depth and parent for each node.\"\"\"\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            depth[neighbor] = depth[current] + 1\n            parent_list[neighbor] = current\n            dfs(tree, neighbor, current, depth, parent_list)\n\ndef find_lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor (LCA) of nodes u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(illusion_rates: List[int], path: List[int]) -> int:\n    \"\"\"Calculates the energy required for a given path.\"\"\"\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Processes the queries and returns the results for type 2 queries.\"\"\"\n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    # Initialize the segment tree\n    segment_tree = SegmentTree(illusion_rates)\n    \n    # Prepare for LCA calculation\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_list)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1], query[2]\n            segment_tree.update(u - 1, c)\n        elif query[0] == 2:\n            # Minimum energy query\n            u, v = query[1], query[2]\n            lca = find_lca(u, v, depth, parent_list)\n            path_u_to_lca = []\n            path_v_to_lca = []\n            \n            # Collect path from u to LCA\n            while u != lca:\n                path_u_to_lca.append(u)\n                u = parent_list[u]\n            path_u_to_lca.append(lca)\n            \n            # Collect path from v to LCA\n            while v != lca:\n                path_v_to_lca.append(v)\n                v = parent_list[v]\n            \n            # Combine paths\n            path = path_u_to_lca + path_v_to_lca[::-1]\n            energy = calculate_energy(segment_tree.tree[segment_tree.n:], path)\n            results.append(energy)\n    \n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, pos: int, value: int):\n        # Update the value at position pos\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1])\n\n    def query(self, left: int, right: int) -> int:\n        # Query the minimum value in the range [left, right)\n        result = float('inf')\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result = min(result, self.tree[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                result = min(result, self.tree[right])\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]):\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    # Bring u and v to the same depth\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while depth[v] > depth[u]:\n        v = parent_list[v]\n    # Find the common ancestor\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth: List[int]) -> int:\n    ancestor = lca(u, v, depth, parent_list)\n    energy = 0\n    # Calculate energy from u to ancestor\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u] + illusion_rates[parent_list[u]]), abs(illusion_rates[u] - illusion_rates[parent_list[u]]))\n        u = parent_list[u]\n    # Calculate energy from v to ancestor\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v] + illusion_rates[parent_list[v]]), abs(illusion_rates[v] - illusion_rates[parent_list[v]]))\n        v = parent_list[v]\n    return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n\n    # Prepare for LCA and depth calculation\n    depth = [0] * (n + 1)\n    parent_list = [0] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_list)\n\n    # Process queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1], query[2]\n            illusion_rates[u] = c\n        elif query[0] == 2:\n            # Minimum energy query\n            u, v = query[1], query[2]\n            if u == v:\n                results.append(0)\n            else:\n                energy = calculate_energy(u, v, illusion_rates, parent_list, depth)\n                results.append(energy)\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = [0] + list(map(int, input().split()))  # 1-based index\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process the queries and get results\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.segment_tree = SegmentTree(illusion_rates)\n\n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        self.segment_tree.update(room, new_rate)\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        path = self.find_path(u, v)\n        energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.segment_tree.query(path[i])\n            a_y = self.segment_tree.query(path[i + 1])\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n\n    def find_path(self, start: int, end: int) -> List[int]:\n        visited = [False] * (self.n + 1)\n        path = []\n        self.dfs(start, end, visited, path)\n        return path\n\n    def dfs(self, current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        visited[current] = True\n        path.append(current)\n        if current == target:\n            return True\n        for neighbor in self.adj_list[current]:\n            if not visited[neighbor]:\n                if self.dfs(neighbor, target, visited, path):\n                    return True\n        path.pop()\n        return False\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]) -> None:\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, index: int, value: int) -> None:\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n    def query(self, index: int) -> int:\n        return self.tree[index + self.n]\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    maze = Maze(n, illusion_rates, tunnels)\n\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            maze.update_illusion_rate(u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = maze.calculate_min_energy(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Performs a Depth First Search to preprocess the tree for LCA queries.\"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth_list[u] < depth_list[v]:\n        u, v = v, u\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    \"\"\"Calculates the energy required to move between two rooms.\"\"\"\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    \n    # Preprocess the tree using DFS\n    dfs(1, -1, 0, tree, parent_list, depth_list)\n    \n    # Find the path from u to v using LCA\n    ancestor = lca(u, v, parent_list, depth_list)\n    \n    # Calculate the energy required along the path\n    energy_sum = 0\n    current = u\n    while current != ancestor:\n        parent = parent_list[current]\n        energy_sum += calculate_energy(illusion_rates[current - 1], illusion_rates[parent - 1])\n        current = parent\n    \n    current = v\n    while current != ancestor:\n        parent = parent_list[current]\n        energy_sum += calculate_energy(illusion_rates[current - 1], illusion_rates[parent - 1])\n        current = parent\n    \n    return energy_sum\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations for treasure retrieval.\nrequirement pool:\n- Efficiently handle large inputs and queries.\n- Accurately calculate energy requirements.\n- Allow dynamic updates to illusion rates.\n- Ensure solution scalability.\n- Provide user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate the path energy, while Segment Tree will allow us to update the illusion rates dynamically and query the minimum energy efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, forming a hierarchical structure without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'query'\n    Explanation: There are two types of queries: one to change the illusion rate of a room and another to calculate the minimum energy required to move from one room to another.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy calculation for moving between two rooms. It requires taking the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to move from one room to another. This involves calculating the path with the least energy consumption.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to traverse the tree and calculate path energies.\n    4. Use a Segment Tree to handle dynamic updates of illusion rates and efficiently query minimum energy paths.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n    6. For type 2 queries, use DFS combined with Segment Tree to find and return the minimum energy path.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n           2 1 3\n    Output: 2000000000\n            1000000000\n    Explanation: The first query calculates maximum energy with extreme values, while the second query reflects an updated illusion rate.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 2:\n            return max(abs(a[0] + a[1]), abs(a[0] - a[1]))\n        # Additional logic for handling extreme values in illusion rates\n        # Ensure Segment Tree updates and queries are efficient for large values\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and compute the minimum energy path in a tree structure. The solution must be optimized for large inputs, ensuring quick response times for both types of queries. The tree structure allows for efficient traversal and pathfinding, but dynamic updates require careful management of data structures.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Compute minimum energy path between any two rooms quickly.\n- Ensure the solution scales well with large numbers of rooms and queries.\n- Provide clear and concise output for each query.\n- Maintain a simple and intuitive user interface.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle updates to the illusion rates and compute the minimum energy path between rooms. DFS will help in traversing the tree structure, while the Segment Tree will allow for quick updates and queries on the illusion rates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of the query, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented using algorithms that find the shortest path or minimum cost path in a tree, such as DFS or BFS.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Implement a DFS to traverse the tree and calculate initial energy costs between connected rooms.\n4. Use a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n5. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, calculate the minimum energy required to travel from room u to room v using updated illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: 2 1\n              5 -5\n              1 2\n              2 1 2\n       Expected Output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, moving between any rooms requires zero energy.\n\n    3. Maximum possible illusion rate change:\n       Input: 3 2\n              0 0 0\n              1 2\n              2 3\n              1 1 1000000000\n              2 1 3\n       Expected Output: max(|1000000000 + 0|, |1000000000 - 0|) = 1000000000\n       Explanation: After changing the illusion rate of room 1 to the maximum possible value, moving from room 1 to room 3 requires maximum energy.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently due to potentially large input sizes.\n    Implementing a Segment Tree or similar data structure will allow for efficient updates and queries on illusion rates.\n    \n```python\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n\n    def update(self, idx, value, node=1, node_left=0, node_right=None):\n        if node_right is None:\n            node_right = self.n - 1\n\n        if node_left == node_right:\n            self.tree[node] = value\n            return\n\n        mid = (node_left + node_right) // 2\n        if idx <= mid:\n            self.update(idx, value, node * 2, node_left, mid)\n        else:\n            self.update(idx, value, node * 2 + 1, mid + 1, node_right)\n\n        self.tree[node] = max(self.tree[node * 2], self.tree[node * 2 + 1])\n\n    def query(self, left, right, node=1, node_left=0, node_right=None):\n        if node_right is None:\n            node_right = self.n - 1\n\n        if right < node_left or left > node_right:\n            return float('-inf')\n\n        if left <= node_left and node_right <= right:\n            return self.tree[node]\n\n        mid = (node_left + node_right) // 2\n        return max(self.query(left, right, node * 2, node_left, mid),\n                   self.query(left, right, node * 2 + 1, mid + 1, node_right))\n```\nThis code snippet provides a basic structure for a Segment Tree that can be used to handle updates and queries efficiently.\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of queries requires a flexible data structure.\nrequirement pool:\n- Efficient handling of large inputs and queries\n- Accurate calculation of energy requirements\n- Dynamic updates to room illusion rates\n- User-friendly interface for understanding calculations\n- Integration with existing maze-solving tools\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the dynamic updates and queries on the tree structure. DFS will help in traversing the tree and calculating paths, while the Segment Tree will allow for quick updates and queries on the illusion rates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms. The illusion rate can be dynamically updated.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the path with the minimum sum of energy. This can be implemented using algorithms that find the shortest path or minimum cost path in a tree, such as DFS or Dijkstra's algorithm.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists to represent tunnels between rooms.\n3. Implement DFS to traverse the tree and calculate paths.\n4. Use a Segment Tree to handle dynamic updates to illusion rates efficiently.\n5. For type 1 queries, update the illusion rate of a specified room.\n6. For type 2 queries, calculate the minimum sum of energy required to move from room u to room v using the current illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1\n       Input: \n       ```\n       2 1\n       0 0\n       1 2\n       2 1 2\n       ```\n       Expected output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. All rooms have zero illusion rate:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected output: 0\n       Explanation: All rooms have an illusion rate of 0, so any path will have an energy cost of 0.\n\n    3. Maximum possible illusion rate change:\n       Input:\n       ```\n       3 2\n       10^9 -10^9 10^9\n       1 2\n       2 3\n       1 1 -10^9\n       2 1 3\n       ```\n       Expected output: max(|-10^9 + (-10^9)|, |-10^9 - (-10^9)|) = max(0, |0|) = 0\n       Explanation: After changing the illusion rate of room 1 to -10^9, moving from room 1 to room 3 results in zero energy cost due to cancellation.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree will naturally handle these scenarios due to their inherent properties in managing updates and queries efficiently.\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of queries requires a flexible data structure.\nrequirement pool:\n- Efficiently handle large inputs and queries.\n- Accurately calculate energy requirements between rooms.\n- Enable dynamic updates to room illusion rates.\n- Ensure the solution is user-friendly and intuitive.\n- Provide detailed error messages for invalid inputs.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The tree structure allows us to use DFS to calculate paths, while the Segment Tree will handle dynamic updates to the illusion rates and efficiently compute the required energy for queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the path with the minimum sum of energy. This can be implemented using algorithms that find the shortest path in a tree, such as DFS or BFS.\n\n# [code logic]\n1. Parse the input to construct the tree and store the initial illusion rates.\n2. Use DFS to precompute necessary information for efficient path queries (e.g., parent-child relationships, subtree sizes).\n3. Implement a Segment Tree or similar data structure to handle dynamic updates to illusion rates.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, calculate the minimum energy required to move from room u to room v using precomputed information and current illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: 2 1\n              5 -5\n              1 2\n              2 1 2\n       Expected output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All rooms have zero illusion rate:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected output: 0\n       Explanation: Since all illusion rates are zero, the energy required for any path is zero.\n\n    3. Maximum possible illusion rate change:\n       Input: 3 2\n              0 0 0\n              1 2\n              2 3\n              1 1 1000000000\n              2 1 3\n       Expected output: max(|1000000000 + 0|, |1000000000 - 0|) = 1000000000\n       Explanation: After changing the illusion rate of room 1 to the maximum possible value, the energy required is determined by this large value.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of updating and querying using DFS and Segment Tree. The original logic should be robust enough to handle these scenarios efficiently.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates and energy calculations are performed in optimal time. The tree structure of the maze allows for efficient traversal and pathfinding, which should be leveraged to minimize computational overhead.\nrequirement pool:\n- Efficiently handle up to 100,000 queries and rooms.\n- Accurately calculate the minimum energy required for room transitions.\n- Support dynamic updates to room illusion rates.\n- Ensure the solution is scalable and performs well with large data sets.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary data for LCA, which will then be used to find the minimum energy path between any two rooms. We will also use a Segment Tree to handle dynamic updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each tunnel, the energy required is the maximum of the absolute sum or difference of the illusion rates of the connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': In the context of the queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Use DFS to preprocess the tree and prepare data structures for LCA computation.\n3. Implement a Segment Tree to handle updates to illusion rates efficiently.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate using the Segment Tree.\n   - If it's a type 2 query, use LCA to find the path between the two rooms and calculate the minimum energy required using the preprocessed data.\n\n# [edge case]\n    1. Minimum number of rooms (n=2) with maximum illusion rates:\n       Input: 2 1\n              10^9 -10^9\n              1 2\n              2 1 2\n       Expected Output: 2 * 10^9\n       Explanation: The only path is between room 1 and room 2, requiring max(|10^9 + (-10^9)|, |10^9 - (-10^9)|) = 2 * 10^9 energy.\n\n    2. All rooms have zero illusion rate:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, any path will require zero energy.\n\n    3. Single query with no change in illusion rate:\n       Input: 3 1\n              5 -5 5\n              1 2\n              2 3\n              2 1 3\n       Expected Output: max(|5 + (-5)|, |5 - (-5)|) + max(|-5 + 5|, |-5 - 5|) = 10\n       Explanation: The path from room 1 to room 3 goes through room 2, requiring a total of 10 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS, LCA, and Segment Tree will naturally handle these scenarios as they are part of the general solution framework.\n", "requirement analysis:\nThe project requires efficient handling of tree structures and dynamic updates to node values. The main challenge is to ensure that the solution can handle up to 100,000 rooms and queries efficiently. The energy calculation involves absolute values and maximum functions, which need to be optimized for quick computation. The user interface should be simple yet effective in displaying results.\nrequirement pool:\n- Implement efficient data structures for tree representation and updates.\n- Optimize energy calculation for quick response to queries.\n- Design a user-friendly interface for input and output.\n- Ensure the solution can handle edge cases and large inputs.\n- Provide detailed documentation for users to understand the process.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the tree structure and dynamic updates. The DFS will help in flattening the tree to an array, which allows us to use a Segment Tree for efficient range queries and updates. This approach ensures that we can handle up to 100,000 rooms and queries efficiently. The Segment Tree will be used to manage the illusion rates and calculate the energy required for each path query.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, forming a hierarchical structure without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is determined by the maximum of the absolute sum or difference of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute value of the sum or difference of their illusion rates. In code, this can be implemented using the `max` function with `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy needed to move from one room to another. This involves finding the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to get the number of rooms and queries, initial illusion rates, and tunnel connections.\n    2. Use DFS to flatten the tree structure into an array representation.\n    3. Implement a Segment Tree to handle dynamic updates to illusion rates and efficiently calculate energy for type 2 queries.\n    4. For type 1 queries, update the illusion rate of a specified room.\n    5. For type 2 queries, calculate the minimum energy required to move from one room to another using the Segment Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Output: 20\n    Explanation: Moving from room 1 to room 3 via room 2 requires max(|10 + (-10)|, |10 - (-10)|) = 20 energy.\n\n    Input: 4 2\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           1 1 -10\n           2 1 4\n    Output: 30\n    Explanation: After updating room 1's illusion rate to -10, moving from room 1 to room 4 requires max(|-10 + (-5)|, |-10 - (-5)|) = 15 energy for each segment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle these scenarios by ensuring correct updates and queries.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of queries requires a robust data structure to manage updates.\nrequirement pool:\n- Efficiently handle large inputs and queries.\n- Accurately calculate energy requirements between rooms.\n- Allow dynamic updates to room illusion rates.\n- Ensure the system is scalable and responsive.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The tree structure allows us to use DFS to find paths and calculate energy requirements. The Segment Tree will help in efficiently updating the illusion rates and querying the minimum energy path.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms. It can be altered by specific queries.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum and absolute difference of their illusion rates. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb] \n    'minimum': This indicates that for type 2 queries, we need to find the path with the least energy requirement from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest value.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement DFS to traverse the tree and calculate paths.\n3. Use a Segment Tree to handle updates to illusion rates efficiently.\n4. For type 1 queries, update the Segment Tree with the new illusion rate.\n5. For type 2 queries, use DFS to find all paths from u to v, calculate their energy using the given formula, and return the minimum energy path.\n\n# [edge case] \n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: \n       ```\n       10\n       ```\n       Explanation: With only two rooms, the only path is directly between them, and energy is calculated as max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       0\n       ```\n       Explanation: Since all illusion rates are zero, any path will have zero energy requirement.\n\n    3. Large number of rooms with maximum illusion rate:\n       Input:\n       ```\n       3 1\n       1000000000 -1000000000 1000000000\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       3000000000\n       ```\n       Explanation: The path from room 1 to room 3 through room 2 will have maximum energy due to large illusion rates.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large input sizes and ensure efficient updates and queries.\n    \n    ```python\n    # Pseudocode for handling large inputs efficiently\n    def update_illusion_rate(segment_tree, index, new_value):\n        # Update the segment tree with new illusion rate at index\n        pass\n\n    def query_minimum_energy(segment_tree, start_room, end_room):\n        # Use DFS and segment tree to find minimum energy path from start_room to end_room\n        pass\n\n    # Main function to process queries\n    def process_queries(n, q, initial_illusion_rates, tunnels, queries):\n        # Build tree and segment tree\n        # Process each query using update_illusion_rate and query_minimum_energy functions\n        pass\n    ```\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of queries necessitates a robust data structure for updates.\nrequirement pool:\n- Efficient handling of large inputs and queries.\n- Accurate calculation of energy required for room transitions.\n- Easy updates to room illusion rates.\n- User-friendly interface for input and output.\n- Scalability to accommodate future expansions of the maze.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The tree structure allows us to use DFS to preprocess the tree and calculate the path between any two nodes. The Segment Tree will help in efficiently updating the illusion rates and querying the minimum energy required for a path.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb] \n    'minimum': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Use Depth First Search (DFS) to preprocess the tree and calculate paths between nodes.\n3. Implement a Segment Tree to handle updates to illusion rates efficiently.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, calculate the minimum energy required to travel from one room to another using preprocessed path information and current illusion rates.\n\n# [edge case] \n    1. Query with u = v (e.g., 2 1 1) = 0\n    Explanation: If the starting room and destination room are the same, no movement is needed, so the energy required is 0.\n\n    2. All rooms have zero illusion rate initially (e.g., 6 1; 0 0 0 0 0 0; 1 2; 2 3; 3 4; 4 5; 5 6; 2 1 6) = 0\n    Explanation: If all rooms have an illusion rate of zero, any path will require zero energy since max(|0 + 0|, |0 - 0|) = 0.\n\n    3. Maximum possible illusion rate change (e.g., change a room's rate to -10^9 or +10^9) = Handle large values\n    Explanation: Ensure that calculations handle large values without overflow or errors.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large values and self-loop queries.\n    \n```python\ndef handle_query(u, v):\n    if u == v:\n        return 0\n    # Continue with normal path calculation logic\n\ndef update_illusion_rate(room, new_rate):\n    # Ensure new_rate is within bounds\n    if abs(new_rate) > 10**9:\n        raise ValueError(\"Illusion rate out of bounds\")\n    # Update logic\n```\n\nThis ensures that self-loop queries return zero energy and that updates respect the constraints on illusion rates.\n", "requirement analysis:\nThe requirements focus on efficiently calculating the minimum energy required to traverse a tree-structured maze with dynamic updates to room illusion rates. The solution must handle large inputs and provide accurate results for each query type.\nrequirement pool:\n- Efficiently calculate minimum energy for room traversal.\n- Support dynamic updates to room illusion rates.\n- Ensure solution handles large inputs efficiently.\n- Provide accurate results for each query type.\n- Optimize for user-friendly interface and interaction.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will help in managing the dynamic updates of the illusion rates and efficiently calculating the minimum energy required for traversal between rooms. This approach ensures that we handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that for each tunnel, the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of the connected rooms. In code, this can be implemented using the `max` function with `abs` for absolute values.\n\n# [degree adverb] \n    'minimum sum of energy': This indicates that we need to find the smallest possible total energy required to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Implement a DFS to traverse the tree and calculate initial energy requirements.\n4. Use a Segment Tree to handle updates to illusion rates efficiently.\n5. For each query:\n   - If it's a type 1 query, update the illusion rate in the Segment Tree.\n   - If it's a type 2 query, use DFS and Segment Tree to calculate and return the minimum energy required for the path.\n\n# [edge case] \n    1. Minimum number of rooms (n=2) with maximum illusion rates = 10^9\n       Explanation: This tests if the code can handle extreme values for energy calculation.\n       Expected output: max(|10^9 + 10^9|, |10^9 - 10^9|) = 2 * 10^9\n\n    2. All rooms have zero illusion rate\n       Explanation: This tests if the code correctly handles zero values in energy calculation.\n       Expected output: 0 for any path since max(|0 + 0|, |0 - 0|) = 0\n\n    3. A single path from start to end with alternating positive and negative illusion rates\n       Explanation: This tests if the code correctly calculates energy with alternating signs.\n       Expected output: Sum of max values for each segment along the path.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree should handle these scenarios efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle up to 100,000 queries and room updates while ensuring accurate energy calculations. The solution must leverage data structures that allow quick updates and path calculations in a tree structure.\nrequirement pool:\n- Implement efficient pathfinding algorithm for tree structure.\n- Optimize energy calculation for room transitions.\n- Allow dynamic updates to room illusion rates.\n- Ensure the solution handles maximum input constraints smoothly.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle path queries in the tree structure. For dynamic updates of the illusion rates, we will use a Segment Tree or Fenwick Tree (Binary Indexed Tree) to allow quick updates and queries. This approach ensures that both update and query operations are efficient, even for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` and `abs` functions: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb] \n    'minimum': This indicates that for type 2 queries, we need to find the path with the minimum sum of energy. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Implement a DFS to preprocess the tree for LCA queries.\n4. Use a Segment Tree or Fenwick Tree to handle updates to illusion rates efficiently.\n5. For type 1 queries, update the illusion rate of a specified room.\n6. For type 2 queries, calculate the minimum energy required to move from room u to room v using LCA and preprocessed data.\n7. Output the result for each type 2 query.\n\n# [edge case] \n    Edge Case 1: n = 2, q = 1, a = [0, 0], queries = [(2, 1, 2)]\n    Expected Output: 0\n    Explanation: With only two rooms and both having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Edge Case 2: n = 3, q = 1, a = [10^9, -10^9, 0], queries = [(2, 1, 3)]\n    Expected Output: max(|10^9 + 0|, |10^9 - 0|) = 10^9\n    Explanation: The path from room 1 to room 3 directly requires max(|10^9 + 0|, |10^9 - 0|) = 10^9 energy.\n\n    Edge Case 3: n = 4, q = 2, a = [1, -1, 1, -1], queries = [(1, 1, -1), (2, 1, 4)]\n    Expected Output: max(|-1 + (-1)|, |-1 - (-1)|) + max(|-1 + (-1)|, |-1 - (-1)|) = 2\n    Explanation: After updating room 1's illusion rate to -1, moving from room 1 to room 4 requires minimal energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA with efficient data structures like Segment Tree or Fenwick Tree will handle these cases correctly.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 479, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "condense_two2one", "parent_index": 300}
