{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe average of an array with n elements is obtained by dividing the total of the elements by the count of these elements. The sum is then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe average of an array with n elements is obtained by dividing the total of the elements by the count of these elements. The sum is then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe average of an array with n elements is obtained by dividing the total of the elements by the count of these elements. First, calculate the sum of the array elements. The sum is then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe average of an array with n elements is obtained by dividing the total of the elements by the count of these elements. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            element_count[a[i]] -= 1  # Temporarily remove the current element\n            complement = required_sum - a[i]\n\n            # Check if the complement exists in the remaining elements\n            if complement in element_count and element_count[complement] > 0:\n                valid_pairs += element_count[complement]\n\n            element_count[a[i]] += 1  # Restore the current element count\n\n        # Since each pair is counted twice (once for each element), divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices (i, j) such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n\n        # Calculate the required sum of two elements to be removed\n        required_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in case:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for num in case:\n            # Calculate the required pair element\n            required_pair = required_sum - num\n\n            # Decrease the count of the current element\n            count_map[num] -= 1\n\n            # Check if the required pair exists in the hashmap\n            if required_pair in count_map and count_map[required_pair] > 0:\n                valid_pairs += count_map[required_pair]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        test_cases.append(array)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        valid_pairs = 0\n        \n        # Iterate through the array to find valid pairs\n        for i in range(n):\n            complement = target_sum - a[i]\n            if complement in element_count:\n                # Count pairs (i, j) where i < j\n                valid_pairs += element_count[complement]\n                # If complement is the same as the current element, decrement by one\n                if complement == a[i]:\n                    valid_pairs -= 1\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, indicating the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        original_mean = total_sum / n\n\n        # Calculate the required sum for the remaining elements\n        required_sum = original_mean * (n - 2)\n\n        # Use a hashmap to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        for num in case:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the pair\n                pair_sum = case[i] + case[j]\n                # Check if removing this pair keeps the mean unchanged\n                if total_sum - pair_sum == required_sum:\n                    # Check if the pair is valid considering the occurrences\n                    if case[i] == case[j]:\n                        # If both elements are the same, ensure there are at least two occurrences\n                        if element_count[case[i]] > 1:\n                            valid_pairs += 1\n                    else:\n                        # If elements are different, ensure both exist\n                        if element_count[case[i]] > 0 and element_count[case[j]] > 0:\n                            valid_pairs += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nnumber_of_test_cases = int(input())\ntest_cases = []\nfor _ in range(number_of_test_cases):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Output interface\nresults = count_valid_pairs(number_of_test_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices (i, j) such that removing\n    these elements keeps the mean of the remaining elements unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the count of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for array in test_cases:\n        n = len(array)\n        total_sum = sum(array)\n        original_mean = total_sum / n\n        target_sum = original_mean * (n - 2)\n\n        # Use a hashmap to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        for num in array:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate through the array to find valid pairs\n        for i in range(n):\n            element_count[array[i]] -= 1\n            for j in range(i + 1, n):\n                element_count[array[j]] -= 1\n                remaining_sum = total_sum - array[i] - array[j]\n                if remaining_sum == target_sum:\n                    valid_pairs += 1\n                element_count[array[j]] += 1\n            element_count[array[i]] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the number of elements\n                                      followed by the elements of the array.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Calculate the target sum for the remaining elements\n        target_sum = mean * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        valid_pairs = 0\n        \n        # Iterate through the array to find valid pairs\n        for i in range(n):\n            a_i = a[i]\n            # Calculate the required value a_j\n            required_value = total_sum - target_sum - a_i\n            \n            # Check if the required value exists in the hashmap\n            if required_value in element_count:\n                # If a_i and required_value are the same, we need to ensure there are at least two occurrences\n                if a_i == required_value:\n                    valid_pairs += element_count[required_value] - 1\n                else:\n                    valid_pairs += element_count[required_value]\n        \n        # Since each pair is counted twice, divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append([n] + a)\n\n    # Call the function and print the results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results, each representing the number of valid pairs for a test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map: Dict[int, int] = {}\n        for num in case:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate through the array to find valid pairs\n        for num in case:\n            complement = target_sum - num\n\n            # Decrease the count of the current number in the map\n            count_map[num] -= 1\n\n            # Check if the complement exists in the map\n            if complement in count_map and count_map[complement] > 0:\n                valid_pairs += count_map[complement]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # Calculate the required sum of two elements to be removed\n        required_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for num in a:\n            # Decrease the count of the current element\n            count_map[num] -= 1\n\n            # Calculate the complement that would sum with num to required_sum\n            complement = required_sum - num\n\n            # Check if the complement exists in the map\n            if complement in count_map and count_map[complement] > 0:\n                valid_pairs += count_map[complement]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of pairs of positions [i, j] such that removing these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = (n - 2) * mean\n\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n\n        valid_pairs = 0\n\n        for num in a:\n            target = total_sum - required_sum - num\n            if target in element_count:\n                valid_pairs += element_count[target]\n            element_count[num] -= 1\n\n        results.append(valid_pairs // 2)  # Each pair is counted twice\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices (i, j) such that removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        original_mean = total_sum / n\n        valid_pairs_count = 0\n        \n        # Dictionary to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate through each pair (i, j) where i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                # Check if the mean of the remaining elements equals the original mean\n                if remaining_mean == original_mean:\n                    valid_pairs_count += 1\n        \n        results.append(valid_pairs_count)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe task requires identifying pairs of elements in an array that can be removed while maintaining the original mean. The solution must handle large input sizes efficiently and ensure accurate results. The challenge lies in optimizing the algorithm to process up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 elements.\n- Accurately calculate the number of valid pairs for each test case.\n- Optimize the algorithm for speed and performance.\n- Ensure the output format is consistent with the requirements.\n- Provide clear documentation and comments in the code.\nWe will use a hashmap to efficiently count occurrences of each element in the array. This will allow us to quickly determine pairs of elements that can be removed while maintaining the original mean. The approach leverages the mathematical property that the sum of the remaining elements must equal the sum of the original array minus twice the mean times the number of elements removed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the original array must be equal to the mean of the array after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean (k) of the array.\n2. For each element in the array, calculate the required sum of two elements that need to be removed to maintain the mean.\n3. Use a hashmap to count occurrences of each element.\n4. For each element, check if there exists another element such that their sum equals the required sum.\n5. Count valid pairs and ensure no double counting by considering only pairs where i < j.\n\n# [edge case]\n    Input: 4, 8 8 8 8\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3, 50 20 10\n    Output: 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct and do not satisfy the condition.\n\n    Input: 5, 1 4 7 3 5\n    Output: 2\n    Explanation: Removing elements at positions (1,3) or (4,5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should handle all cases as it checks for valid pairs and ensures no double counting.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must handle up to 10,000 test cases efficiently, with each array having up to 200,000 elements. The sum of all elements across test cases will not exceed 200,000.\nrequirement pool:\n- Efficiently calculate valid pairs for each test case.\n- Handle large input sizes within performance constraints.\n- Provide clear and concise output for each test case.\n- Ensure the solution is easy to understand and maintain.\n- Optimize memory usage where possible.\nWe will use a hashmap to efficiently count occurrences of each element in the array. This will allow us to quickly determine valid pairs of indices that can be removed without changing the mean of the remaining elements. The approach will focus on optimizing performance for large input sizes by minimizing unnecessary computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean, or average, of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, it is crucial to maintain the same mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct indices in the array such that the first index is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the initial mean `k` of the array.\n2. For each test case, use a hashmap to count occurrences of each element.\n3. Iterate through each element in the array and calculate the required sum of the two elements to be removed such that the mean remains unchanged.\n4. For each element `a[i]`, calculate the required `a[j]` such that `a[i] + a[j] = 2 * k`.\n5. Use the hashmap to count valid pairs `(i, j)` where `i < j`.\n6. Return the total count of such pairs for each test case.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean because removing any pair changes the mean.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing pairs (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where all elements are equal or where no valid pairs exist.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle up to 10,000 test cases with a total of up to 200,000 elements across all test cases. The algorithm should be optimized to minimize time complexity, likely requiring a linear or near-linear approach.\nrequirement pool:\n- Implement an efficient algorithm to find valid pairs of elements to remove\n- Ensure the solution handles the maximum constraints effectively\n- Optimize the code for readability and maintainability\n- Provide detailed comments and documentation for the code\n- Include edge case handling and validation\nWe will use a hashmap to efficiently count occurrences of each element in the array. The key insight is that for two elements to be removed such that the mean remains unchanged, their sum must equal twice the mean of the original array. This allows us to find pairs in linear time by iterating over the array and checking for complement pairs using the hashmap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the original array must remain unchanged after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array.\n\n    'equal to k'\n    Explanation: The mean of the remaining elements after removing two must be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean (k).\n2. For each element in the array, calculate the required complement that, when summed with the current element, equals twice the mean.\n3. Use a hashmap to count occurrences of each element.\n4. Iterate through the array and for each element, check if its complement exists in the hashmap.\n5. Count valid pairs and ensure each pair is counted only once by maintaining order (i < j).\n\n# [edge case]\n    Input: 4, 8 8 8 8\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3, 50 20 10\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: 5, 1 4 7 3 5\n    Output: 2\n    Explanation: Removing elements at positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where all elements are equal or where no valid pairs exist.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle up to 10,000 test cases with a total of up to 200,000 elements across all test cases. The algorithm should be optimized to minimize time complexity, likely requiring a linear or near-linear approach.\nrequirement pool:\n- Efficiently calculate the number of valid pairs for each test case\n- Ensure the solution handles the maximum constraints effectively\n- Provide clear and concise output for each test case\n- Optimize the algorithm to minimize computational complexity\n- Include comments and documentation for code clarity\nWe will use a hashmap to efficiently count occurrences of each element in the array. This will allow us to quickly determine the number of valid pairs that can be removed to maintain the mean. The approach will be linear in complexity, leveraging the properties of arithmetic mean and the constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean, or average, of a set of numbers is calculated by dividing the sum of the numbers by the count of the numbers. In this requirement, the mean of the array must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'equal to': The mean of the remaining elements must be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the sum of the array and the original mean.\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a hashmap to count occurrences and efficiently find valid pairs.\n    4. Iterate through each element and calculate the required sum for the remaining elements.\n    5. Check if there exists a pair that satisfies the condition using the hashmap.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = Output: 6\n    Explanation: Any pair can be removed since all elements are equal, resulting in 6 possible pairs.\n    \n    Input: 3, [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged as all elements are different.\n    \n    Input: 5, [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Removing elements at positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap efficiently handles all cases by checking possible pairs and their sums.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of averages and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Ensure accurate mean calculation\n- Optimize for large input sizes\n- Provide clear output format\n- Handle edge cases and errors gracefully\nWe will calculate the mean of the array and then iterate through all possible pairs of elements to check if removing them keeps the mean unchanged. To optimize, we will use a hashmap to count occurrences of each element and use this to efficiently find valid pairs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, it is the average value of the array elements.\n\n    'delete exactly two elements'\n    Explanation: We need to find pairs of indices such that removing these two elements keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove two elements from the array.\n    'equal to': The mean of the remaining elements must be equal to the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Calculate the sum of the array and determine the original mean.\n2. For each test case, iterate through all possible pairs of indices (i, j) with i < j.\n3. For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\n4. Check if the mean of the remaining elements equals the original mean.\n5. Use a hashmap to count occurrences of each element to optimize finding valid pairs.\n6. Return the count of valid pairs for each test case.\n\n# [edge case] \n    Test case with all identical elements: \n    Input: [4, 4, 4, 4] = 6\n    Explanation: Any pair can be removed since all elements are equal, and the mean remains unchanged.\n\n    Test case with no valid pairs:\n    Input: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Test case with multiple valid pairs:\n    Input: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing pairs (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through pairs and checking if removing them keeps the mean unchanged will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Efficiently calculate valid pairs for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and formatted output for each test case.\n- Optimize the algorithm to reduce unnecessary computations.\n- Include comments and documentation for code clarity.\nWe will use a hashmap to efficiently count occurrences of each element in the array. This will allow us to quickly determine the number of valid pairs that can be removed without changing the mean. The approach leverages the mathematical property that the sum of the remaining elements must be equal to the original sum minus the sum of the two removed elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the original array must remain unchanged after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We need to remove exactly two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean (k).\n2. For each test case, iterate through the array and use a hashmap to count occurrences of each element.\n3. For each element a_i, calculate the required value a_j such that removing a_i and a_j keeps the mean unchanged.\n4. Use the hashmap to count valid pairs (a_i, a_j) where i < j.\n5. Return the total count of such pairs for each test case.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged because the elements are distinct and do not satisfy the condition.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a hashmap to count occurrences and check pairs will handle all cases efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 200,000 elements across all test cases, ensuring performance and correctness.\nrequirement pool:\n- Efficiently calculate valid pairs of indices\n- Handle large input sizes within constraints\n- Ensure output format is strictly followed\n- Account for edge cases like identical elements\n- Optimize for both time and space complexity\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to find pairs of elements whose sum equals twice the mean using the hashmap for quick lookups.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean, or average, of an array is calculated by dividing the sum of all elements by the number of elements. In this problem, the mean of the array must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'sum of the removed elements must equal twice the mean': This means that the sum of the two elements removed should be equal to twice the average of the original array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the sum of the array and determine the mean.\n    2. For each test case, iterate through the array and use a hashmap to count occurrences of each element.\n    3. For each element, check if there exists another element such that their sum equals twice the mean.\n    4. Use the hashmap to efficiently find pairs and count valid pairs.\n    5. Return the count of valid pairs for each test case.\n\n# [edge case]\n    Input: 4\n           4\n           8 8 8 8\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3\n           50 20 10\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: 5\n           1 4 7 3 5\n    Output: 2\n    Explanation: Removing elements at positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap efficiently handles all cases by checking pairs whose sum equals twice the mean.\n", "requirement analysis:\nThe task requires calculating pairs of positions in an array where removing these elements keeps the mean unchanged. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements in total. The challenge lies in optimizing the algorithm to ensure quick computation and accurate results.\nrequirement pool:\n- Implement efficient algorithm to calculate valid pairs\n- Ensure the solution handles maximum constraints effectively\n- Optimize for performance to handle large inputs\n- Provide clear output format as specified\n- Include error handling for edge cases\nWe will use a hashmap to count occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to efficiently find pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We need to remove exactly two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean (k) of the array.\n2. For each element in the array, calculate the required sum of two elements that need to be removed to keep the mean unchanged.\n3. Use a hashmap to count occurrences of each element.\n4. For each element, check if there exists another element such that their sum equals twice the mean.\n5. Count valid pairs and ensure no double counting by considering only pairs where i < j.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to find pairs that satisfy the condition will handle all cases efficiently.\n", "requirement analysis:\nThe task requires calculating pairs of elements that can be removed from an array while maintaining the original mean. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements in total. The output should be a single integer for each test case, representing the number of valid pairs.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Optimize for large input sizes\n- Ensure accurate mean calculation\n- Provide clear output format\n- Handle edge cases gracefully\nWe will use a mathematical approach to determine the number of pairs that can be removed while maintaining the mean. The key observation is that the sum of the remaining elements must be equal to the sum of the original array minus twice the mean. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. The task requires maintaining this mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We need to remove exactly two elements from the array to check if the mean remains the same.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean.\n2. For each element, calculate the required sum of the remaining elements after removing two elements.\n3. Use a hashmap to count occurrences of each element.\n4. For each element, calculate how many pairs can be formed with it such that the mean remains unchanged.\n5. Iterate through the array and use the hashmap to find valid pairs.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct and do not satisfy the condition.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a hashmap to count occurrences and check pairs will handle all cases efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle multiple test cases and large arrays, ensuring performance optimization and accurate results.\nrequirement pool:\n- Implement efficient algorithm to calculate valid pairs\n- Optimize for large input sizes\n- Ensure accurate mean calculation\n- Provide clear output format\n- Handle edge cases gracefully\nWe will implement a function that calculates the number of valid pairs of indices (i, j) such that removing these elements keeps the mean of the array unchanged. The key observation is that the sum of the remaining elements should be equal to the original sum minus the sum of the removed elements. We will use a dictionary to count occurrences of each element and efficiently find pairs that satisfy the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, we need to ensure that the mean remains unchanged after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array.\n\n    'equal to k'\n    Explanation: The mean of the remaining elements after removing two should be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the original mean.\n2. For each pair of elements (a[i], a[j]), calculate the sum of the remaining elements.\n3. Check if the mean of the remaining elements equals the original mean.\n4. Use a dictionary to count occurrences of each element to efficiently find valid pairs.\n5. Iterate through possible pairs and count those that satisfy the condition.\n\n# [edge case]\n    Input: 4, 8 8 8 8\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3, 50 20 10\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: 5, 1 4 7 3 5\n    Output: 2\n    Explanation: Removing positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where all elements are equal or where no valid pairs exist.\n"], "scores": [], "pass_results": [true, true, true, true, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 101, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 99}
