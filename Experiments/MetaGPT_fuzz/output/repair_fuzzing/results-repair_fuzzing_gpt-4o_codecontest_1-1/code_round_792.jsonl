{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "prompt": "Luntik has decided to try singing. He has a songs lasting one minute, b songs lasting two minutes, and c songs lasting three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe desires to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "repair_prompt": ["Luntik has decided to try singing. He has a songs lasting one minute, b songs lasting two minutes, and c songs lasting three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe desires to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "Luntik has decided to try singing. He has a songs lasting one minute, b songs lasting two minutes, and c songs lasting three minutes. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.\n\nHe desires to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "Luntik has decided to try singing. He has a songs lasting one minute, b songs lasting two minutes, and c songs lasting three minutes, and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He desires to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 1 and b == 0 and c == 0:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach to find the closest possible duration to half of total_duration\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1 and dp[j - 1]:\n                    dp[j] = True\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2 and dp[j - 2]:\n                    dp[j] = True\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3 and dp[j - 3]:\n                    dp[j] = True\n        \n        # Find the closest possible duration to half_duration\n        closest_duration = 0\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                closest_duration = i\n                break\n        \n        # Calculate the minimal difference\n        other_concert_duration = total_duration - closest_duration\n        minimal_difference = abs(other_concert_duration - closest_duration)\n        results.append(minimal_difference)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Call the function and print results\nresults = minimal_difference(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimize_concert_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute,\n            two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is zero, the difference is zero\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Initialize the minimum difference to a large number\n        min_diff = float('inf')\n        \n        # Iterate over possible partitions\n        # We will use a greedy approach to try to balance the concerts\n        for i in range(a + 1):\n            for j in range(b + 1):\n                for k in range(c + 1):\n                    concert1_duration = i * 1 + j * 2 + k * 3\n                    concert2_duration = total_duration - concert1_duration\n                    current_diff = abs(concert1_duration - concert2_duration)\n                    min_diff = min(min_diff, current_diff)\n        \n        results.append(min_diff)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    results = minimize_concert_difference(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_difference(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing three integers a, b, c.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Initialize the dp array\n        dp = [False] * (total_duration + 1)\n        dp[0] = True\n        \n        # Update dp array for one-minute songs\n        for _ in range(a):\n            for j in range(total_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Update dp array for two-minute songs\n        for _ in range(b):\n            for j in range(total_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Update dp array for three-minute songs\n        for _ in range(c):\n            for j in range(total_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to half of the total duration\n        closest_sum = max(i for i in range(total_duration // 2 + 1) if dp[i])\n        \n        # Calculate the minimal difference\n        minimal_diff = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_diff)\n    \n    return results\n\n# Input and output handling\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    # Get results\n    results = minimal_difference(t, test_cases)\n    # Print results\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples where each tuple contains\n            three integers representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Initialize DP array\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Update DP array for one-minute songs\n        for _ in range(a):\n            for i in range(half_duration, 0, -1):\n                if i >= 1:\n                    dp[i] = dp[i] or dp[i - 1]\n        \n        # Update DP array for two-minute songs\n        for _ in range(b):\n            for i in range(half_duration, 0, -1):\n                if i >= 2:\n                    dp[i] = dp[i] or dp[i - 2]\n        \n        # Update DP array for three-minute songs\n        for _ in range(c):\n            for i in range(half_duration, 0, -1):\n                if i >= 3:\n                    dp[i] = dp[i] or dp[i - 3]\n        \n        # Find the largest possible sum that is less than or equal to half of the total duration\n        max_possible_sum = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_sum = i\n        \n        # Calculate the minimal difference\n        minimal_diff = abs(total_duration - 2 * max_possible_sum)\n        results.append(minimal_diff)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Call the function and print results\nresults = minimal_difference(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimize_concert_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute,\n                                                 two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is even, we can split it into two equal parts\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            # If the total duration is odd, the minimal difference is 1\n            results.append(1)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    \n    # Call the function and print results\n    results = minimize_concert_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute, \n                                                 two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Initialize DP array to track possible sums\n        possible_sums = [False] * (total_duration + 1)\n        possible_sums[0] = True\n        \n        # Update DP array based on song durations\n        for _ in range(a):\n            for j in range(total_duration, 0, -1):\n                if j >= 1 and possible_sums[j - 1]:\n                    possible_sums[j] = True\n        for _ in range(b):\n            for j in range(total_duration, 0, -1):\n                if j >= 2 and possible_sums[j - 2]:\n                    possible_sums[j] = True\n        for _ in range(c):\n            for j in range(total_duration, 0, -1):\n                if j >= 3 and possible_sums[j - 3]:\n                    possible_sums[j] = True\n        \n        # Find the closest possible sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = 0\n        for i in range(half_duration + 1):\n            if possible_sums[i]:\n                closest_sum = i\n        \n        # Calculate minimal absolute difference\n        minimal_diff = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_diff)\n    \n    return results\n\n# Input and output interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    # Get results\n    results = minimal_difference(t, test_cases)\n    # Print results\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimize_concert_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples where each tuple contains\n            three integers representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(max(a, b, c))\n            continue\n        \n        # Dynamic programming approach\n        # Initialize a DP array where each index represents a possible sum of durations\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Iterate over each song type and update the DP array to reflect possible sums\n        for duration, count in zip([1, 2, 3], [a, b, c]):\n            for _ in range(count):\n                for j in range(half_duration, duration - 1, -1):\n                    if dp[j - duration]:\n                        dp[j] = True\n        \n        # Find the closest sum to half of the total duration\n        closest_sum = max(i for i, can_achieve in enumerate(dp) if can_achieve)\n        \n        # Calculate the minimal difference using the closest sum found\n        minimal_difference = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_difference)\n    \n    return results\n\n# Input interface\nnum_test_cases = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(num_test_cases)]\n\n# Output interface\nresults = minimize_concert_difference(num_test_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimize_concert_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute, \n                                                 two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(max(a, b, c))\n            continue\n        \n        # Dynamic programming approach\n        # We will use a boolean array to track possible sums\n        possible_sums = [False] * (total_duration + 1)\n        possible_sums[0] = True\n        \n        # Update possible sums with one-minute songs\n        for _ in range(a):\n            for j in range(total_duration, 0, -1):\n                if possible_sums[j - 1]:\n                    possible_sums[j] = True\n        \n        # Update possible sums with two-minute songs\n        for _ in range(b):\n            for j in range(total_duration, 1, -1):\n                if possible_sums[j - 2]:\n                    possible_sums[j] = True\n        \n        # Update possible sums with three-minute songs\n        for _ in range(c):\n            for j in range(total_duration, 2, -1):\n                if possible_sums[j - 3]:\n                    possible_sums[j] = True\n        \n        # Find the minimal difference\n        half_duration = total_duration // 2\n        minimal_difference = total_duration\n        \n        for i in range(half_duration + 1):\n            if possible_sums[i]:\n                difference = abs(total_duration - 2 * i)\n                minimal_difference = min(minimal_difference, difference)\n        \n        results.append(minimal_difference)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = minimize_concert_difference(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef minimize_concert_difference(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimal possible difference between concert durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing three integers (a, b, c)\n                           representing the number of one-minute, two-minute, and\n                           three-minute songs respectively.\n\n    Returns:\n        list: A list of integers representing the minimal possible difference for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a + 2 * b + 3 * c\n        dp = np.zeros(total_duration // 2 + 1, dtype=bool)\n        dp[0] = True\n        \n        for count, duration in [(a, 1), (b, 2), (c, 3)]:\n            for _ in range(count):\n                dp[duration:] |= dp[:-duration]\n        \n        min_diff = float('inf')\n        for i in range(len(dp)):\n            if dp[i]:\n                min_diff = min(min_diff, abs(total_duration - 2 * i))\n        \n        results.append(min_diff)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [list(map(int, input(): \").split())) for _ in range(n)]\n\n# Function call\nresult = minimize_concert_difference(n, test_cases)\n\n# Output interface\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers\n            representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: A list of integers representing the minimal possible difference for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Dynamic programming approach to find minimal difference\n        # Initialize DP array\n        dp = [False] * (total_duration // 2 + 1)\n        dp[0] = True\n        \n        # Update DP array for each song type\n        for _ in range(a):\n            for j in range(total_duration // 2, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(total_duration // 2, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(total_duration // 2, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to total_duration / 2\n        closest_sum = max(i for i in range(total_duration // 2 + 1) if dp[i])\n        minimal_diff = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_diff)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Function call\n    results = minimal_difference(n, test_cases)\n    \n    # Output interface\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The input consists of multiple test cases, each specifying the number of songs of different durations. The output should be the minimal possible difference for each test case. The solution should efficiently handle up to 1000 test cases with large values for a, b, and c.\nrequirement pool:\n- Efficiently calculate minimal difference for each test case\n- Ensure output format is consistent with requirements\n- Optimize for large input values\n- Provide clear user instructions\n- Enhance UI for better user experience\nWe will use a dynamic programming approach to solve this problem. The goal is to partition the songs into two groups such that the absolute difference in their total durations is minimized. We can use a knapsack-like approach where we try to balance the total duration of songs in each concert. Given the constraints, we need an efficient solution that can handle large input values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': means the non-negative difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute, two-minute, three-minute': indicates the duration of each type of song.\n    Explanation: Each song has a fixed duration, and we need to consider these durations when distributing songs between concerts.\n    Implementation: Use these durations to calculate the total duration of songs in each concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible value.\n    Explanation: We need to find the smallest possible absolute difference between the durations of the two concerts.\n    Implementation: Use dynamic programming or a greedy approach to minimize the difference.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use a dynamic programming approach to find a subset of songs that can form one concert with a duration as close as possible to half of the total duration.\n    3. Calculate the duration of the other concert as the remaining duration.\n    4. Compute the absolute difference between the two concert durations.\n    5. Return the minimal absolute difference for each test case.\n\n# [edge case]\n    Case 1: 1 0 0 = 1\n    Explanation: Only one song with one-minute duration, it must be in one concert, resulting in a difference of 1 minute.\n    \n    Case 2: 0 0 0 = 0\n    Explanation: No songs, so both concerts have a duration of 0, resulting in a difference of 0 minutes.\n    \n    Case 3: 1000000000 1000000000 1000000000 = 0\n    Explanation: Large number of songs, but they can be perfectly balanced between two concerts, resulting in a difference of 0 minutes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a == 1 and b == 0 and c == 0:\n            return 1\n        (other code for dynamic programming approach)\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. This involves calculating the total duration of songs and finding a way to split them optimally. The challenge lies in handling large numbers efficiently.\nrequirement pool:\n- Implement efficient algorithm to minimize duration difference\n- Ensure accurate song distribution between concerts\n- Optimize performance for large input values\n- Provide clear output format for test cases\n- Develop user-friendly interface for input and output\nWe will use a greedy algorithm to distribute the songs into two concerts. The idea is to calculate the total duration of all songs and then try to partition them into two subsets such that the difference between their sums is minimized. This can be efficiently achieved by iterating over possible partitions and calculating the difference. Given the constraints, this approach will be efficient enough.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': the non-negative difference between the total durations of the two concerts.\n    'minimize': reduce the absolute difference to the smallest possible value.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': refers to the duration of each type of song.\n    'as much as possible': indicates the goal is to make the absolute difference as small as possible.\n\n# [degree adverb]\n    'minimal': means the smallest possible value for the absolute difference between concert durations.\n\n# [code logic]\n1. Calculate the total duration of all songs: `total_duration = a * 1 + b * 2 + c * 3`.\n2. The goal is to split this total duration into two parts such that the absolute difference between them is minimized.\n3. Iterate over possible partitions of songs, trying to balance the total duration between two concerts.\n4. Use a greedy approach to assign songs to each concert, aiming to keep their durations as close as possible.\n5. Calculate the absolute difference for each partition and track the minimum found.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: No songs to distribute, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    1 1 1 = 0\n    Explanation: Distribute one one-minute and one two-minute song in one concert, and one three-minute song in another, resulting in equal durations and a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where there are no songs or only one type of song.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        # Implement logic to find minimal difference\n        # This is a placeholder for the actual logic\n        min_diff = float('inf')\n        # Iterate over possible partitions\n        # Update min_diff accordingly\n        results.append(min_diff)\n    return results\n```\n", "requirement analysis:\nThe problem requires distributing songs into two concerts to minimize the absolute difference in their durations. The solution must efficiently handle up to 1000 test cases with large values for a, b, and c, ensuring accurate results.\nrequirement pool:\n- Implement an efficient algorithm to minimize the difference in concert durations.\n- Ensure the solution handles large input values accurately.\n- Optimize the algorithm for speed and computational efficiency.\n- Provide clear input and output handling for multiple test cases.\n- Consider edge cases and ensure robustness of the solution.\nWe will use a dynamic programming approach to solve this problem efficiently. The key is to calculate the total duration of all songs and then try to partition them into two subsets with minimal difference. This is similar to the subset sum problem, which can be solved using dynamic programming. We will use a boolean array to track possible sums and find the closest sum to half of the total duration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': the non-negative difference between the total durations of the two concerts.\n    'duration': the total time of songs in a concert.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': refers to the duration of each type of song.\n    'minimize': means to make the absolute difference as small as possible.\n\n# [degree adverb]\n    'minimal': means the smallest possible absolute difference between the durations of the two concerts.\n\n# [code logic]\n1. Calculate the total duration of all songs: `total_duration = a * 1 + b * 2 + c * 3`.\n2. Initialize a boolean array `dp` where `dp[i]` indicates if a sum `i` is possible with the given songs.\n3. Set `dp[0] = True` because a sum of 0 is always possible.\n4. Iterate over each song type and update the `dp` array to reflect possible sums.\n5. Find the closest sum to `total_duration // 2` that is possible using the `dp` array.\n6. Calculate the minimal difference as `abs(total_duration - 2 * closest_sum)`.\n7. Repeat for each test case.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: Only one song of one minute, so one concert will have 1 minute and the other will have 0 minutes, resulting in a difference of 1.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs to distribute, so both concerts have a duration of 0, resulting in a difference of 0.\n\n    Edge Case 3: (1000000000, 1000000000, 1000000000) = 0\n    Explanation: With equal numbers of each type of song, they can be perfectly balanced between two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no songs are present or when there is only one song.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        dp = [False] * (total_duration + 1)\n        dp[0] = True\n        for _ in range(a):\n            for j in range(total_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        for _ in range(b):\n            for j in range(total_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        for _ in range(c):\n            for j in range(total_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        closest_sum = max(i for i in range(total_duration // 2 + 1) if dp[i])\n        results.append(abs(total_duration - 2 * closest_sum))\n    return results\n```\n\n", "requirement analysis:\nThe problem requires distributing songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases efficiently, with each test case having potentially large numbers of songs. The algorithm should be optimized for both performance and memory usage, ensuring accurate results across all test cases.\nrequirement pool:\n- Implement the main algorithm to minimize the difference in concert durations\n- Ensure the solution handles large inputs efficiently\n- Optimize for performance and memory usage\n- Validate the solution with multiple test cases\n- Provide clear and concise output format\nWe will use a dynamic programming approach to solve this problem. The goal is to partition the songs into two groups such that the absolute difference in their total durations is minimized. This is a variation of the partition problem, which can be efficiently solved using dynamic programming. Given the constraints, we will optimize the solution to handle large inputs by using a 1D DP array to track possible sums.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': the non-negative difference between the total durations of the two concerts.\n    'minimize': to make the absolute difference as small as possible.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': these phrases indicate the duration of each type of song.\n    'exactly one concert': each song must be assigned to one and only one concert.\n\n# [degree adverb]\n    'minimal': indicates the smallest possible value for the absolute difference between concert durations.\n\n# [code logic]\n1. Calculate the total duration of all songs.\n2. Use dynamic programming to find a subset of songs that can form a sum closest to half of the total duration.\n3. Initialize a DP array where dp[i] is True if a sum of i minutes can be achieved with the available songs.\n4. Iterate over each song type and update the DP array to reflect possible sums.\n5. Find the largest possible sum that is less than or equal to half of the total duration.\n6. Calculate the minimal difference as the absolute difference between twice this sum and the total duration.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, it must be assigned to one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0 minutes.\n    \n    1 1 1 = 0\n    Explanation: As explained in the example, songs can be distributed to achieve a zero difference.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles cases with zero or minimal songs by ensuring that all possible sums are considered, including zero.\n", "requirement analysis:\nThe task is to distribute songs of different durations into two concerts such that the absolute difference in their total durations is minimized. The solution should efficiently handle up to 1000 test cases with large values for a, b, and c, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to distribute songs minimizing the duration difference.\n- Optimize the solution for large input values.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output for each test case.\n- Consider user experience in terms of input and output format.\nWe will use a dynamic programming approach to solve the problem of distributing songs into two concerts such that the absolute difference in their total durations is minimized. The key is to balance the total duration of songs in each concert by considering all possible combinations of song distributions. Given the constraints, we will optimize the solution to handle large input values efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute songs between two concerts such that the difference in their total durations is as small as possible.\n\n    'duration of the concert'\n    Explanation: The total time of all songs included in a concert.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes'\n    Explanation: These phrases indicate the duration of each type of song. In code, these durations can be represented as constants or variables to calculate the total duration of each concert.\n\n# [degree adverb]\n    'minimal possible difference'\n    Explanation: This means finding the smallest absolute difference between the total durations of the two concerts.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming or a greedy approach to try different combinations of song distributions between the two concerts.\n    3. Track the distribution that results in the smallest absolute difference between the two concert durations.\n    4. Return the minimal difference for each test case.\n\n# [edge case]\n    Case 1: a = 0, b = 0, c = 0\n    Expected output: 0\n    Explanation: No songs to distribute, so both concerts have a duration of 0, resulting in a difference of 0.\n\n    Case 2: a = 1, b = 0, c = 0\n    Expected output: 1\n    Explanation: Only one song with a duration of 1 minute, so one concert will have a duration of 1 and the other will have 0, resulting in a difference of 1.\n\n    Case 3: a = 0, b = 1, c = 1\n    Expected output: 1\n    Explanation: One song with a duration of 2 minutes and one with a duration of 3 minutes. Distribute them such that one concert has a duration of 3 and the other has a duration of 2, resulting in a difference of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        elif a == 1 and b == 0 and c == 0:\n            return 1\n        elif a == 0 and b == 1 and c == 1:\n            return abs(3 - 2)\n        (other code for handling general cases)\n", "requirement analysis:\nThe problem requires distributing songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 3 billion songs in total. The algorithm should be optimized for performance and accuracy, ensuring it can process large inputs within reasonable time limits.\nrequirement pool:\n- Implement an efficient algorithm to minimize the difference in concert durations.\n- Ensure the solution handles large numbers and multiple test cases accurately.\n- Optimize the algorithm for performance across different scenarios.\n- Provide clear input and output instructions for users.\n- Test the solution against edge cases to ensure robustness.\nWe will use a dynamic programming approach to solve this problem. The key idea is to treat it as a variation of the partition problem, where we aim to split the songs into two groups with minimal difference in their total durations. We will use a 1D DP array to keep track of possible sums of durations and update it iteratively based on the songs' durations. This approach efficiently handles large inputs and multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': means the non-negative difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': indicates the duration of each type of song.\n    Implementation: Use these values to calculate the total duration of songs in each concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible value for the absolute difference between concert durations.\n    Implementation: Use dynamic programming to find the smallest possible difference.\n\n# [code logic]\n    1. Initialize a DP array to track possible sums of durations.\n    2. For each test case, iterate over the number of songs and update the DP array based on song durations.\n    3. Calculate the total duration of all songs and find the closest possible sum to half of this total using the DP array.\n    4. Compute the minimal absolute difference using this closest sum.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: Only one song, so it must be in one concert, resulting in a difference of 1.\n    \n    Test case: 0 0 0 = 0\n    Explanation: No songs, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    Test case: 1000000000 1000000000 1000000000 = 0\n    Explanation: Large numbers but equal distribution possible, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where there are no songs or only one song.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a + b + c == 1:\n            return min(1, 2, 3) # depending on which song is present\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 10^9 songs of varying durations.\nrequirement pool:\n- Implement efficient algorithm to minimize duration difference\n- Ensure solution handles large input values effectively\n- Provide clear output format as specified\n- Optimize for speed and accuracy\n- Consider edge cases and test thoroughly\nWe will use a dynamic programming approach to solve this problem efficiently. The key idea is to use a knapsack-like algorithm to distribute the songs into two groups such that the absolute difference in their total durations is minimized. Given the constraints, we will focus on optimizing the solution to handle large numbers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': refers to the non-negative difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': indicates the duration of each type of song.\n    Explanation: These phrases define the duration of each song type, which is crucial for calculating the total duration of each concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible value for the difference between concert durations.\n    Explanation: The goal is to achieve the smallest possible absolute difference between the total durations of the two concerts.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming to find a subset of songs that can be distributed to one concert such that the absolute difference between the two concerts is minimized.\n    3. Initialize a DP array where each index represents a possible sum of durations.\n    4. Iterate over each song type and update the DP array to reflect possible sums.\n    5. Find the closest sum to half of the total duration, which will help minimize the difference.\n    6. Calculate the minimal difference using the closest sum found.\n\n# [edge case]\n    Input: 1 0 0\n    Output: 1\n    Explanation: With only one song, it must be placed in one concert, resulting in a difference equal to its duration.\n    \n    Input: 0 0 0\n    Output: 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    Input: 1000000000 1000000000 1000000000\n    Output: 0\n    Explanation: With equal numbers of each song type, they can be perfectly balanced between two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where there are no songs or only one song.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a + b + c == 1:\n            return max(a, b, c)\n        (other code for dynamic programming approach)\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 10^9 songs of varying durations.\nrequirement pool:\n- Efficiently handle large numbers of songs\n- Minimize the difference in concert durations\n- Provide accurate results for all test cases\n- Optimize for speed and performance\n- Ensure the solution is scalable\nWe will use a dynamic programming approach to solve this problem efficiently. The idea is to calculate the total duration of all songs and then try to partition them into two subsets such that the difference between their sums is minimized. This is similar to the subset sum problem, which can be solved using dynamic programming. Given the constraints, we will optimize the algorithm to handle large numbers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': means the non-negative difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': these phrases indicate the duration of each type of song. In code, these can be represented as constants or variables that contribute to the total duration calculation.\n    'minimize': implies finding the smallest possible value for the absolute difference between concert durations.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming to find a subset of songs that approximates half of the total duration.\n    3. Calculate the difference between this subset and the remaining songs.\n    4. Return the minimal absolute difference for each test case.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: With only one song, it must be placed in one concert, resulting in a difference equal to its duration.\n    \n    Test case: 0 0 0 = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    Test case: 1000000000 1000000000 1000000000 = 0\n    Explanation: With equal numbers of each type of song, they can be perfectly balanced between the two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where there are no songs or only one type of song.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a + b + c == 1:\n            return max(a, b, c)\n        (other code for dynamic programming approach)\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 3 billion songs in total. The output should be the minimal possible difference for each test case.\nrequirement pool:\n- Efficiently calculate minimal duration difference for each test case.\n- Handle large input values without performance degradation.\n- Ensure output format is consistent and easy to interpret.\n- Provide clear documentation for the solution approach.\n- Optimize algorithm for faster execution time.\nWe will use a dynamic programming approach to solve this problem efficiently. The key is to balance the total duration of songs between two concerts by considering all possible distributions of songs. We will utilize the numpy library for efficient array operations to handle large input values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is minimized.\n\n    'dynamic programming'\n    Explanation: A method for solving complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the number of songs by their respective durations to calculate total time.\n\n# [degree adverb]\n    'minimal possible'\n    Explanation: This indicates that the solution should aim for the smallest possible difference in concert durations. In code, this involves finding the smallest value of the absolute difference between the two concert durations.\n\n# [code logic]\n1. Calculate the total duration of all songs.\n2. Use dynamic programming to explore all possible distributions of songs between two concerts.\n3. Initialize a DP array where each index represents a possible total duration for one concert.\n4. Iterate over each type of song and update the DP array to reflect possible durations.\n5. Calculate the minimal possible difference by checking all possible durations and finding the one that results in the smallest absolute difference.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    0 0 0 = 0\n    Explanation: No songs to distribute, so the difference is naturally 0.\n\n    1000000000 1000000000 1000000000 = 0\n    Explanation: With equal numbers of each type of song, they can be perfectly balanced between two concerts, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n```python\nimport numpy as np\n\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a + 2 * b + 3 * c\n        dp = np.zeros(total_duration // 2 + 1, dtype=bool)\n        dp[0] = True\n        \n        for count, duration in [(a, 1), (b, 2), (c, 3)]:\n            for _ in range(count):\n                dp[duration:] |= dp[:-duration]\n        \n        min_diff = float('inf')\n        for i in range(len(dp)):\n            if dp[i]:\n                min_diff = min(min_diff, abs(total_duration - 2 * i))\n        \n        results.append(min_diff)\n    \n    return results\n\n# Example usage:\nt = 4\ntest_cases = [(1, 1, 1), (2, 1, 3), (5, 5, 5), (1, 1, 2)]\nprint(minimal_difference(t, test_cases))\n```\nThis code uses dynamic programming to efficiently calculate the minimal possible difference for each test case.\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 10^9 songs of varying durations.\nrequirement pool:\n- Efficiently handle large input sizes\n- Accurately calculate minimal difference in concert durations\n- Provide clear output format\n- Optimize for speed and performance\n- Ensure code readability and maintainability\nWe will use a dynamic programming approach to solve this problem efficiently. The key idea is to calculate the total duration of all songs and then try to partition them into two subsets such that the absolute difference between their sums is minimized. This is similar to the 'Partition Problem' which can be solved using a dynamic programming approach. Given the constraints, we will optimize the solution to handle large numbers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': the non-negative difference between the total durations of the two concerts.\n    'minimize': to make the absolute difference as small as possible.\n\n# [phrase showing quantity relationship]\n    'one minute', 'two minutes', 'three minutes': refers to the duration of each type of song.\n    'exactly one concert': each song must be assigned to one and only one concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible value for the absolute difference between the concert durations.\n\n# [code logic]\n1. Calculate the total duration of all songs: `total_duration = a * 1 + b * 2 + c * 3`.\n2. The goal is to find two subsets of songs such that the absolute difference between their total durations is minimized.\n3. Use a dynamic programming approach to determine if it's possible to achieve a certain sum with a subset of songs.\n4. Iterate over possible sums and find the closest sum to `total_duration / 2`.\n5. Calculate the minimal possible difference using this closest sum.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs to distribute, so the difference is naturally 0.\n\n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: Distribute one one-minute song and one two-minute song in one concert, and one three-minute song in another, resulting in a balanced distribution with a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        # Dynamic programming approach to find minimal difference\n        # Initialize DP array\n        dp = [False] * (total_duration // 2 + 1)\n        dp[0] = True\n        \n        # Update DP array for each song type\n        for _ in range(a):\n            for j in range(total_duration // 2, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(total_duration // 2, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(total_duration // 2, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to total_duration / 2\n        closest_sum = max(i for i in range(total_duration // 2 + 1) if dp[i])\n        minimal_diff = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_diff)\n    \n    return results\n```\n\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 792, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "rephrase_one", "parent_index": 128}
