{"name": "1598_E. Staircases", "description": "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "tags": ["brute force", "combinatorics", "data structures", "dfs and similar", "dp", "implementation", "math"], "difficulty": 11, "id": 1598, "sample_io": [{"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n"]}, {"input": "1000 1000 2\n239 634\n239 634\n", "output": ["1332632508\n1333333000\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n1\n0\n"]}], "test_list": [{"input": "1 1 1\n1 1\n", "output": ["0\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n238\n233\n222\n207\n186\n180\n162\n140\n151\n144\n137\n144\n137\n111\n109\n91\n82\n77\n87\n78\n76\n83\n81\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 2\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n12\n8\n13\n23\n19\n15\n"]}, {"input": "1 1 2\n1 1\n1 1\n", "output": ["0\n1\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n86\n81\n91\n82\n80\n86\n84\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 1\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n3\n6\n2\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n77\n68\n66\n72\n70\n"]}, {"input": "3 4 10\n1 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n31\n45\n25\n17\n15\n12\n14\n16\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n17\n14\n12\n15\n17\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n16\n14\n"]}, {"input": "1000 1000 2\n252 634\n239 634\n", "output": ["1332594366\n1331893874\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n74\n69\n79\n70\n68\n74\n72\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n9\n6\n5\n4\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n78\n76\n64\n77\n74\n80\n71\n69\n75\n73\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n14\n12\n8\n13\n23\n31\n27\n"]}, {"input": "1000 1000 2\n59 634\n239 634\n", "output": ["1333160628\n1332460136\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n162\n140\n135\n124\n111\n104\n117\n114\n94\n92\n80\n77\n85\n101\n92\n90\n96\n94\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n90\n76\n64\n77\n74\n80\n69\n67\n71\n69\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n78\n70\n56\n62\n56\n"]}, {"input": "1000 1000 2\n239 634\n418 634\n", "output": ["1332632508\n1331406830\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n74\n65\n63\n69\n67\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n75\n72\n"]}, {"input": "3 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n"]}, {"input": "1000 1000 2\n59 323\n239 634\n", "output": ["1333014458\n1332313966\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n142\n137\n126\n116\n109\n103\n99\n91\n77\n65\n78\n73\n79\n68\n66\n70\n69\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n52\n54\n49\n47\n41\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n66\n63\n"]}, {"input": "2 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "1000 1000 2\n59 323\n239 999\n", "output": ["1333014458\n1333011116\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n83\n72\n70\n74\n73\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n75\n73\n67\n70\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n124\n113\n123\n119\n111\n97\n85\n98\n88\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n194\n183\n154\n151\n138\n130\n121\n129\n126\n119\n118\n106\n100\n95\n105\n92\n90\n76\n79\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n77\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n109\n101\n96\n106\n93\n95\n81\n84\n"]}, {"input": "6 3 4\n1 2\n1 3\n2 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n63\n61\n"]}, {"input": "2 1 2\n1 1\n1 1\n", "output": ["1\n3\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n27\n23\n31\n21\n25\n18\n15\n13\n"]}, {"input": "1000 1000 2\n341 634\n239 634\n", "output": ["1332333240\n1331632748\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n116\n109\n112\n109\n83\n81\n69\n78\n73\n83\n74\n72\n77\n75\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n17\n15\n12\n14\n16\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n179\n163\n157\n135\n130\n119\n112\n108\n103\n100\n80\n78\n64\n73\n70\n76\n67\n65\n71\n69\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n35\n31\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 4\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n43\n33\n26\n24\n"]}, {"input": "1000 1000 2\n252 634\n239 877\n", "output": ["1332594366\n1332358004\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n112\n100\n97\n92\n102\n93\n91\n97\n87\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n234\n229\n218\n195\n188\n186\n164\n144\n133\n126\n119\n114\n111\n91\n89\n71\n62\n59\n65\n56\n54\n60\n58\n"]}, {"input": "3 3 10\n1 2\n2 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n11\n14\n18\n14\n25\n35\n25\n21\n"]}, {"input": "1000 1000 2\n59 634\n239 35\n", "output": ["1333160628\n1332948862\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n107\n98\n96\n102\n100\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n98\n86\n99\n96\n90\n68\n64\n68\n66\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n23\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n10\n5\n2\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n78\n75\n"]}, {"input": "1000 1000 2\n59 323\n448 634\n", "output": ["1333014458\n1331700760\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 1\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n170\n165\n150\n122\n115\n109\n105\n97\n83\n71\n84\n79\n85\n74\n72\n76\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n74\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n5 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n83\n81\n72\n75\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n127\n113\n101\n114\n104\n92\n81\n79\n83\n82\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n102\n105\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n21\n17\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n208\n197\n174\n159\n153\n131\n126\n113\n110\n121\n124\n121\n95\n93\n81\n90\n85\n95\n86\n84\n89\n87\n"]}, {"input": "3 4 10\n1 4\n2 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n29\n25\n19\n11\n9\n8\n5\n6\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n1 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n197\n181\n175\n152\n157\n139\n132\n128\n123\n120\n97\n93\n79\n93\n90\n96\n81\n79\n73\n71\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n21\n17\n"]}, {"input": "1000 1000 2\n142 634\n239 877\n", "output": ["1332917106\n1332680744\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 5\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n110\n98\n95\n90\n100\n93\n91\n98\n88\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n180\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n56\n"]}, {"input": "1000 1000 2\n59 634\n239 24\n", "output": ["1333160628\n1333015896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n127\n115\n109\n117\n133\n122\n120\n127\n119\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 2\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n119\n107\n120\n117\n111\n81\n77\n81\n78\n"]}, {"input": "3 3 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["26\n18\n15\n14\n"]}, {"input": "2 3 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["12\n18\n12\n7\n10\n18\n10\n7\n"]}, {"input": "3 3 4\n1 3\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n5 2\n2 3\n3 1\n", "output": ["31\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n223\n212\n195\n169\n163\n128\n125\n114\n107\n101\n108\n105\n98\n97\n83\n80\n75\n85\n72\n70\n72\n69\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n120\n108\n105\n116\n106\n94\n88\n86\n93\n92\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n2 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n127\n130\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n180\n164\n158\n135\n132\n114\n107\n103\n98\n95\n87\n85\n71\n76\n73\n79\n66\n64\n58\n56\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n60\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n137\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n34\n26\n23\n"]}, {"input": "6 3 4\n1 1\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n75\n71\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n132\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 4\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 4\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n113\n112\n92\n90\n70\n61\n56\n61\n52\n50\n56\n58\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n126\n133\n136\n"]}, {"input": "3 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n4 2\n7 2\n2 3\n3 0\n", "output": ["39\n33\n43\n53\n"]}, {"input": "6 3 4\n1 1\n2 3\n1 2\n2 3\n1 3\n1 5\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n71\n68\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n5 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n118\n111\n83\n90\n110\n107\n95\n89\n94\n100\n85\n87\n94\n97\n"]}, {"input": "3 6 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 4\n2 2\n5 2\n2 3\n3 1\n", "output": ["79\n59\n56\n50\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n197\n"]}, {"input": "2 5 1\n1 4\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["26\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n179\n181\n"]}, {"input": "12 3 4\n2 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["177\n173\n170\n174\n"]}, {"input": "2 5 1\n1 2\n1 6\n2 1\n1 3\n4 1\n3 2\n0 3\n0 4\n1 3\n3 1\n", "output": ["25\n"]}, {"input": "1 2 1\n1 1\n", "output": ["1\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n244\n239\n225\n210\n189\n183\n165\n143\n154\n145\n138\n147\n140\n114\n112\n94\n85\n82\n74\n65\n63\n70\n68\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n28\n39\n29\n23\n17\n22\n20\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n116\n123\n120\n100\n98\n86\n95\n90\n100\n91\n89\n95\n93\n"]}, {"input": "3 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n30\n39\n22\n14\n12\n9\n11\n9\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n2 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n272\n251\n209\n205\n194\n171\n164\n159\n137\n132\n121\n114\n107\n102\n100\n80\n78\n66\n75\n72\n78\n69\n67\n73\n71\n"]}, {"input": "3 4 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n29\n27\n41\n21\n17\n13\n10\n14\n15\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n20\n22\n25\n29\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n2 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n10\n19\n9\n13\n11\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 2\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n18\n14\n12\n9\n6\n4\n"]}, {"input": "1000 1000 2\n494 634\n239 634\n", "output": ["1331884338\n1331183846\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n111\n99\n96\n91\n101\n86\n84\n91\n89\n"]}, {"input": "3 4 6\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n98\n78\n74\n62\n82\n79\n85\n76\n74\n80\n78\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n106\n99\n112\n109\n101\n99\n87\n84\n92\n108\n95\n93\n87\n85\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n96\n88\n74\n80\n96\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n96\n93\n79\n78\n66\n75\n72\n75\n66\n64\n70\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n170\n160\n128\n123\n116\n109\n102\n109\n102\n88\n87\n81\n76\n71\n81\n72\n74\n80\n77\n"]}, {"input": "3 3 3\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n57\n"]}, {"input": "1000 1000 2\n59 323\n239 587\n", "output": ["1333014458\n1332224196\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n78\n82\n71\n69\n73\n72\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 7\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n112\n110\n98\n91\n86\n96\n81\n79\n72\n75\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n1 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n144\n137\n136\n129\n109\n104\n114\n101\n103\n89\n92\n"]}, {"input": "3 4 10\n1 1\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n33\n22\n20\n28\n20\n26\n19\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 3\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n132\n125\n118\n115\n89\n87\n75\n84\n79\n87\n78\n76\n83\n81\n"]}, {"input": "1000 1000 2\n252 412\n239 877\n", "output": ["1332147258\n1331910896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n80\n72\n80\n71\n69\n75\n70\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n15\n10\n14\n11\n7\n"]}, {"input": "1000 1000 2\n59 722\n239 35\n", "output": ["1333201988\n1332990222\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n75\n73\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n2 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 1\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["25\n23\n31\n22\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 6\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n282\n259\n227\n220\n209\n187\n174\n166\n134\n130\n123\n116\n107\n114\n111\n97\n96\n84\n78\n73\n83\n74\n72\n81\n78\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n565\n560\n549\n532\n517\n511\n476\n473\n462\n455\n448\n455\n452\n445\n444\n420\n417\n404\n470\n457\n447\n449\n446\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 3\n1 3\n1 3\n3 3\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n77\n79\n77\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n85\n83\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["79\n77\n71\n73\n"]}, {"input": "6 3 4\n2 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 2\n2 3\n3 1\n", "output": ["69\n65\n63\n61\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n27\n25\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 10\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n278\n230\n223\n212\n189\n163\n157\n135\n130\n117\n114\n121\n124\n121\n95\n93\n79\n88\n83\n93\n84\n82\n87\n85\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n37\n32\n28\n31\n20\n18\n"]}, {"input": "1000 1000 2\n63 634\n239 24\n", "output": ["1333148892\n1333004160\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n137\n125\n120\n128\n144\n129\n127\n134\n126\n"]}, {"input": "3 3 4\n1 3\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["31\n23\n19\n20\n"]}, {"input": "3 3 4\n1 2\n1 2\n1 2\n1 3\n1 3\n3 3\n4 2\n5 2\n2 3\n3 1\n", "output": ["25\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n222\n217\n200\n169\n163\n128\n125\n114\n109\n99\n104\n101\n94\n93\n79\n76\n73\n78\n65\n63\n65\n62\n"]}, {"input": "2 4 1\n2 4\n1 6\n2 1\n1 2\n4 3\n3 2\n1 3\n0 4\n1 3\n3 1\n", "output": ["20\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 3\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n264\n216\n231\n220\n197\n158\n152\n145\n140\n129\n132\n121\n131\n127\n108\n96\n90\n101\n91\n87\n81\n79\n86\n85\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["132\n126\n138\n120\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 7\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n56\n54\n66\n68\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n143\n137\n145\n161\n131\n127\n134\n142\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n25\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n3 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n223\n213\n202\n179\n161\n153\n137\n126\n115\n108\n105\n100\n96\n76\n74\n66\n59\n56\n62\n53\n51\n57\n59\n"]}, {"input": "2 4 1\n1 2\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["17\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n185\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n29\n43\n33\n43\n33\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 8\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n346\n323\n306\n290\n246\n212\n206\n195\n172\n157\n151\n129\n124\n113\n106\n104\n111\n108\n88\n86\n82\n91\n86\n96\n87\n89\n95\n93\n"]}, {"input": "6 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["144\n128\n120\n130\n110\n78\n76\n71\n73\n65\n"]}, {"input": "3 8 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["115\n100\n98\n113\n90\n86\n79\n74\n81\n82\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n1 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n21\n19\n21\n25\n"]}, {"input": "1000 1000 2\n494 749\n239 634\n", "output": ["1332338588\n1331638096\n"]}, {"input": "5 10 15\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n1 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n106\n86\n82\n70\n90\n87\n93\n84\n82\n88\n86\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 4\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n104\n97\n84\n81\n78\n76\n64\n61\n69\n79\n68\n66\n63\n61\n"]}, {"input": "3 4 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["39\n33\n43\n33\n25\n15\n10\n15\n23\n21\n"]}, {"input": "3 3 4\n1 2\n1 3\n2 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n0 1\n", "output": ["25\n23\n12\n14\n"]}, {"input": "5 7 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["243\n216\n187\n192\n243\n227\n209\n162\n168\n184\n"]}, {"input": "5 10 30\n5 3\n5 8\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n372\n354\n328\n313\n297\n268\n234\n229\n218\n180\n165\n159\n124\n119\n112\n104\n97\n92\n89\n75\n74\n70\n79\n76\n79\n70\n72\n86\n83\n"]}, {"input": "3 4 4\n1 4\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["49\n41\n31\n35\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n5 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n69\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 4\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n119\n109\n98\n92\n88\n79\n77\n65\n78\n74\n78\n69\n67\n70\n69\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 4\n2 3\n3 1\n", "output": ["132\n126\n138\n148\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n3 3\n1 3\n1 3\n2 2\n3 2\n2 3\n2 1\n", "output": ["79\n77\n85\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 10\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n78\n70\n78\n69\n67\n73\n68\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n18\n11\n8\n6\n4\n"]}, {"input": "5 10 28\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 10\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n611\n606\n595\n548\n527\n521\n486\n480\n469\n462\n458\n465\n458\n451\n450\n420\n417\n404\n470\n457\n447\n450\n447\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 9\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n89\n87\n"]}, {"input": "6 3 4\n1 3\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["85\n89\n79\n75\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 1\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n15\n13\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 4\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n24\n20\n17\n21\n26\n37\n35\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n5 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n228\n213\n206\n171\n166\n151\n119\n112\n144\n151\n174\n170\n158\n153\n161\n177\n154\n152\n137\n128\n"]}, {"input": "6 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["536\n474\n446\n413\n358\n342\n336\n280\n267\n262\n245\n214\n208\n173\n170\n159\n154\n144\n149\n146\n139\n138\n116\n113\n108\n121\n108\n102\n104\n101\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 3\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n136\n130\n138\n144\n114\n102\n109\n114\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 2\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n14\n11\n14\n17\n"]}, {"input": "6 3 4\n1 1\n1 3\n2 2\n2 3\n1 3\n1 8\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n75\n62\n60\n"]}, {"input": "12 3 3\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n3 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "2 4 1\n1 4\n1 6\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 0\n", "output": ["25\n23\n31\n23\n"]}], "task_id": "codecontest/62", "prompt": "You are given a grid consisting of n rows and m columns, and the rows are numbered from top to bottom, while the columns are numbered from left to right.\n\nEach cell of the matrix can either be free or locked.\n\nLet's name a route in the matrix a staircase if it:\n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou need to handle q queries, each of which toggles the state of a specific cell, so if a cell is currently free, it becomes locked, and if it is presently locked, it turns free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "repair_prompt": ["You are given a grid consisting of n rows and m columns, and the rows are numbered from top to bottom, while the columns are numbered from left to right.\n\nEach cell of the matrix can either be free or locked.\n\nLet's name a route in the matrix a staircase if it:\n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou need to handle q queries, each of which toggles the state of a specific cell, so if a cell is currently free, it becomes locked, and if it is presently locked, it turns free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a grid consisting of n rows and m columns, and the rows are numbered from top to bottom. The columns are numbered from left to right.\n\nEach cell of the matrix can either be free or locked.\n\nLet's name a route in the matrix a staircase if it:\n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou need to handle q queries, each of which toggles the state of a specific cell. If a cell is currently free, it becomes locked, and if it is presently locked, it turns free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a grid consisting of n rows and m columns, and the rows are numbered from top to bottom, while the columns are numbered from left to right. Each cell of the matrix can either be free or locked.\n\nLet's name a route in the matrix a staircase if it: starts and ends in the free cell, visits only free cells, and has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase. Here are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free. You need to handle q queries, each of which toggles the state of a specific cell, so if a cell is currently free, it becomes locked, and if it is presently locked, it turns free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Count the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free\n    grid = [['free' for _ in range(m)] for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        if grid[x][y] == 'free':\n            grid[x][y] = 'locked'\n        else:\n            grid[x][y] = 'free'\n    \n    # Function to perform DFS and count staircases\n    def dfs(x: int, y: int, direction: int, path: List[Tuple[int, int]]) -> None:\n        if (x, y) in path or grid[x][y] == 'locked':\n            return\n        path.append((x, y))\n        if direction == 0:  # Right then Down\n            if y + 1 < m:\n                dfs(x, y + 1, 1, path)\n            if x + 1 < n:\n                dfs(x + 1, y, 0, path)\n        else:  # Down then Right\n            if x + 1 < n:\n                dfs(x + 1, y, 0, path)\n            if y + 1 < m:\n                dfs(x, y + 1, 1, path)\n    \n    # Function to count unique staircases\n    def count_unique_staircases() -> int:\n        unique_staircases = set()\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'free':\n                    path = []\n                    dfs(i, j, 0, path)\n                    unique_staircases.add(tuple(path))\n                    path = []\n                    dfs(i, j, 1, path)\n                    unique_staircases.add(tuple(path))\n        return len(unique_staircases)\n    \n    # Handle edge cases\n    if n == 1 and m == 1:\n        return [1 if grid[0][0] == 'free' else 0 for _ in range(len(queries))]\n    elif all(grid[i][j] == 'locked' for i in range(n) for j in range(m)):\n        return [0] * len(queries)\n    \n    # Process each query and count staircases\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)  # Adjust for 0-based index\n        results.append(count_unique_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_unique_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a grid after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries to toggle the state of cells.\n\n    Returns:\n        List[int]: List of counts of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells marked as free\n    grid = [['free' for _ in range(m)] for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        if grid[x][y] == 'free':\n            grid[x][y] = 'locked'\n        else:\n            grid[x][y] = 'free'\n    \n    # Function to count staircases in the current grid\n    def count_staircases() -> int:\n        visited = set()\n        \n        def is_valid(x, y):\n            return 0 <= x < n and 0 <= y < m and grid[x][y] == 'free'\n        \n        def explore(x, y, direction):\n            path = []\n            while is_valid(x, y):\n                path.append((x, y))\n                visited.add((x, y))\n                if direction == 'right':\n                    x, y = x, y + 1\n                    direction = 'down'\n                else:\n                    x, y = x + 1, y\n                    direction = 'right'\n            return path\n        \n        unique_staircases = set()\n        \n        for i in range(n):\n            for j in range(m):\n                if (i, j) not in visited and grid[i][j] == 'free':\n                    path1 = explore(i, j, 'right')\n                    path2 = explore(i, j, 'down')\n                    if path1:\n                        unique_staircases.add(tuple(path1))\n                    if path2:\n                        unique_staircases.add(tuple(path2))\n        \n        return len(unique_staircases)\n    \n    # Handle edge cases\n    def handle_single_cell(x: int, y: int) -> int:\n        return 1 if grid[x][y] == 'free' else 0\n    \n    def handle_fully_locked() -> int:\n        return 0\n    \n    results = []\n    for x, y in queries:\n        # Adjust indices to be zero-based\n        x -= 1\n        y -= 1\n        \n        # Toggle the cell state\n        toggle_cell(x, y)\n        \n        # Count staircases after the toggle\n        if n == 1 and m == 1:\n            results.append(handle_single_cell(x, y))\n        elif all(grid[i][j] == 'locked' for i in range(n) for j in range(m)):\n            results.append(handle_fully_locked())\n        else:\n            results.append(count_staircases())\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_unique_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef toggle_cell(grid: List[List[bool]], x: int, y: int) -> None:\n    \"\"\"Toggle the state of a cell in the grid.\"\"\"\n    grid[x][y] = not grid[x][y]\n\ndef bfs_staircase_count(grid: List[List[bool]], n: int, m: int) -> int:\n    \"\"\"Count unique staircases using BFS.\"\"\"\n    visited = set()\n    unique_staircases = set()\n\n    def bfs(start_x: int, start_y: int) -> None:\n        \"\"\"Perform BFS to find staircases starting from a given cell.\"\"\"\n        queue = deque([(start_x, start_y, 0, [(start_x, start_y)])])\n        while queue:\n            x, y, direction, path = queue.popleft()\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            unique_staircases.add(tuple(path))\n\n            # Determine next moves based on current direction\n            if direction % 2 == 0:  # Move right then down\n                if y + 1 < m and grid[x][y + 1]:\n                    queue.append((x, y + 1, direction + 1, path + [(x, y + 1)]))\n                if x + 1 < n and grid[x + 1][y]:\n                    queue.append((x + 1, y, direction + 1, path + [(x + 1, y)]))\n            else:  # Move down then right\n                if x + 1 < n and grid[x + 1][y]:\n                    queue.append((x + 1, y, direction + 1, path + [(x + 1, y)]))\n                if y + 1 < m and grid[x][y + 1]:\n                    queue.append((x, y + 1, direction + 1, path + [(x, y + 1)]))\n\n    # Start BFS from each free cell\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] and (i, j) not in visited:\n                bfs(i, j)\n\n    return len(unique_staircases)\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process queries and return the number of unique staircases after each query.\"\"\"\n    grid = [[True] * m for _ in range(n)]  # Initialize all cells as free\n    results = []\n\n    for x, y in queries:\n        toggle_cell(grid, x - 1, y - 1)  # Toggle the cell state\n        results.append(bfs_staircase_count(grid, n, m))\n\n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Count the number of unique staircases in a grid after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries where each query toggles the state of a cell.\n\n    Returns:\n        List[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the grid with all cells free\n    grid = [[True] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        grid[x][y] = not grid[x][y]\n\n    # Function to count staircases in the current grid\n    def count_current_staircases() -> int:\n        # Use dynamic programming to count staircases\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n        \n        total_staircases = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:  # If the cell is free\n                    # Single cell is a staircase\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n                    total_staircases += 1\n                    \n                    # Check for staircases ending at (i, j) with right-down pattern\n                    if i > 0 and j > 0:\n                        dp_right[i][j] += dp_down[i-1][j-1]\n                        total_staircases += dp_down[i-1][j-1]\n                    \n                    # Check for staircases ending at (i, j) with down-right pattern\n                    if i > 0 and j > 0:\n                        dp_down[i][j] += dp_right[i-1][j-1]\n                        total_staircases += dp_right[i-1][j-1]\n        \n        return total_staircases\n\n    results = []\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        x -= 1\n        y -= 1\n        \n        # Toggle the cell\n        toggle_cell(x, y)\n        \n        # Count staircases after the toggle\n        results.append(count_current_staircases())\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef toggle_cell(grid: List[List[bool]], x: int, y: int) -> None:\n    \"\"\"Toggle the state of a cell in the grid.\"\"\"\n    grid[x][y] = not grid[x][y]\n\ndef count_staircases(grid: List[List[bool]], n: int, m: int) -> int:\n    \"\"\"Count the number of unique staircases in the grid using dynamic programming.\"\"\"\n    # Initialize a 2D list to store the number of staircases ending at each cell\n    dp_right = [[0] * m for _ in range(n)]\n    dp_down = [[0] * m for _ in range(n)]\n\n    # Count staircases for each cell\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                # A single cell is a staircase\n                dp_right[i][j] = 1\n                dp_down[i][j] = 1\n\n                # Check for staircases ending with a right move\n                if j > 0 and grid[i][j - 1]:\n                    dp_right[i][j] += dp_down[i][j - 1]\n\n                # Check for staircases ending with a down move\n                if i > 0 and grid[i - 1][j]:\n                    dp_down[i][j] += dp_right[i - 1][j]\n\n    # Sum up all unique staircases\n    total_staircases = sum(dp_right[i][j] + dp_down[i][j] - 1 for i in range(n) for j in range(m) if grid[i][j])\n    return total_staircases\n\ndef count_staircases_after_queries(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process queries and return the number of unique staircases after each query.\"\"\"\n    # Initialize the grid with all cells free\n    grid = [[True for _ in range(m)] for _ in range(n)]\n    results = []\n\n    # Process each query\n    for x, y in queries:\n        toggle_cell(grid, x - 1, y - 1)\n        results.append(count_staircases(grid, n, m))\n\n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    # Output interface\n    result = count_staircases_after_queries(n, m, queries)\n    for res in result:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef toggle_and_count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Toggle cell states and calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (list[tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        list[int]: List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free (True represents free, False represents locked)\n    grid = [[True] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        grid[x][y] = not grid[x][y]\n\n    # Function to calculate the number of unique staircases\n    def count_unique_staircases() -> int:\n        unique_staircases = set()\n        \n        # Check for staircases starting from each free cell\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:  # If the cell is free\n                    # Check both staircase patterns\n                    check_staircase(i, j, unique_staircases, pattern=1)\n                    check_staircase(i, j, unique_staircases, pattern=2)\n        \n        return len(unique_staircases)\n\n    # Function to check and add staircases to the set\n    def check_staircase(x: int, y: int, staircases: set, pattern: int):\n        path = [(x, y)]\n        while True:\n            if pattern == 1:\n                # Move right then down\n                if len(path) % 2 == 1:  # Odd index, move right\n                    y += 1\n                else:  # Even index, move down\n                    x += 1\n            else:\n                # Move down then right\n                if len(path) % 2 == 1:  # Odd index, move down\n                    x += 1\n                else:  # Even index, move right\n                    y += 1\n            \n            # Check bounds and if the cell is free\n            if 0 <= x < n and 0 <= y < m and grid[x][y]:\n                path.append((x, y))\n            else:\n                break\n        \n        if len(path) > 1:  # Only consider paths with more than one cell\n            staircases.add(tuple(path))\n\n    # Process each query and calculate the number of unique staircases\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)  # Adjust for 0-based index\n        results.append(count_unique_staircases())\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Call the function and print results\n    results = toggle_and_count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef handle_edge_cases(n: int, m: int, q: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Handle specific edge cases efficiently.\"\"\"\n    if n == 1 and m == 1:\n        return [0] * q\n    if q == 0:\n        return []\n    # Additional logic for handling other edge cases can be added here.\n    return None\n\ndef count_unique_staircases(n: int, m: int, q: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Count the number of unique staircases after each query.\"\"\"\n    # Initialize the grid with all cells free (True)\n    grid = np.ones((n, m), dtype=bool)\n    \n    # Handle edge cases\n    edge_case_result = handle_edge_cases(n, m, q, queries)\n    if edge_case_result is not None:\n        return edge_case_result\n\n    # Function to count staircases\n    def count_staircases():\n        # Dynamic programming table to store the number of staircases ending at each cell\n        dp_right = np.zeros((n, m), dtype=int)\n        dp_bottom = np.zeros((n, m), dtype=int)\n        \n        # Count single cell staircases\n        total_staircases = np.sum(grid)\n        \n        # Fill the DP tables\n        for i in range(n):\n            for j in range(m):\n                if grid[i, j]:\n                    if j > 0 and grid[i, j - 1]:\n                        dp_right[i, j] = dp_bottom[i, j - 1] + 1\n                    if i > 0 and grid[i - 1, j]:\n                        dp_bottom[i, j] = dp_right[i - 1, j] + 1\n                    total_staircases += dp_right[i, j] + dp_bottom[i, j]\n        \n        return total_staircases\n\n    results = []\n    for x, y in queries:\n        # Toggle the state of the cell (1-based to 0-based index)\n        grid[x - 1, y - 1] = not grid[x - 1, y - 1]\n        \n        # Recalculate the number of unique staircases\n        results.append(count_staircases())\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresult = count_unique_staircases(n, m, q, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\ndef toggle_and_count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Toggle the state of a cell and count the number of unique staircases.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (list[tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        list[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the grid with all cells free (True)\n    grid = [[True for _ in range(m)] for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        grid[x][y] = not grid[x][y]\n\n    # Function to count staircases\n    def count_staircases() -> int:\n        # Efficiently count staircases by recalculating only affected areas\n        count = 0\n        # Use a set to track visited cells to avoid double counting\n        visited = set()\n        \n        def dfs(x, y, direction):\n            \"\"\"Depth-first search to explore staircases.\"\"\"\n            if (x, y) in visited or not (0 <= x < n and 0 <= y < m) or not grid[x][y]:\n                return\n            visited.add((x, y))\n            nonlocal count\n            count += 1\n            if direction == 'right':\n                dfs(x, y + 1, 'down')\n            elif direction == 'down':\n                dfs(x + 1, y, 'right')\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] and (i, j) not in visited:\n                    # Start a new staircase from this cell\n                    dfs(i, j, 'right')\n                    dfs(i, j, 'down')\n        \n        return count\n\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)  # Convert to 0-based index\n        results.append(count_staircases())\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    q = int(data[2])\n    \n    queries = []\n    index = 3\n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        queries.append((x, y))\n        index += 2\n    \n    # Call the function and print results\n    results = toggle_and_count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef toggle_cell(grid: List[List[bool]], x: int, y: int) -> None:\n    \"\"\"Toggle the state of the specified cell in the grid.\"\"\"\n    grid[x][y] = not grid[x][y]\n\ndef dfs(grid: List[List[bool]], x: int, y: int, visited: set, path: List[Tuple[int, int]], direction: int) -> None:\n    \"\"\"Perform DFS to explore potential staircases starting from a free cell.\"\"\"\n    n, m = len(grid), len(grid[0])\n    if (x, y) in visited or not grid[x][y]:\n        return\n    visited.add((x, y))\n    path.append((x, y))\n    \n    # Explore zigzag patterns based on the current direction\n    if direction == 0:  # Right then Down\n        if y + 1 < m and grid[x][y + 1]:\n            dfs(grid, x, y + 1, visited, path, 1)\n    if direction == 1:  # Down then Right\n        if x + 1 < n and grid[x + 1][y]:\n            dfs(grid, x + 1, y, visited, path, 0)\n\ndef count_staircases(grid: List[List[bool]]) -> int:\n    \"\"\"Count the number of unique staircases in the grid.\"\"\"\n    n, m = len(grid), len(grid[0])\n    unique_staircases = set()\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                visited = set()\n                path = []\n                # Explore both zigzag patterns starting from each free cell\n                dfs(grid, i, j, visited, path, 0)\n                if path:\n                    unique_staircases.add(tuple(path))\n                path = []\n                dfs(grid, i, j, visited, path, 1)\n                if path:\n                    unique_staircases.add(tuple(path))\n    \n    return len(unique_staircases)\n\ndef process_queries(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process queries to toggle cells and count unique staircases.\"\"\"\n    # Initialize the grid with all cells free\n    grid = [[True] * m for _ in range(n)]\n    results = []\n    \n    for x, y in queries:\n        toggle_cell(grid, x - 1, y - 1)  # Adjust for 0-based index\n        results.append(count_staircases(grid))\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Call the function and print results\n    results = process_queries(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the grid with all cells marked as free (True)\n    grid = [[True] * m for _ in range(n)]\n    \n    # Function to check if a cell is within grid bounds\n    def is_within_bounds(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m\n    \n    # Function to count staircases in the grid\n    def count_staircases_in_grid() -> int:\n        unique_staircases = set()\n        \n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:  # If the cell is free\n                    # Check right-down-right pattern\n                    path = []\n                    x, y = i, j\n                    while is_within_bounds(x, y) and grid[x][y]:\n                        path.append((x, y))\n                        y += 1\n                        if is_within_bounds(x, y) and grid[x][y]:\n                            path.append((x, y))\n                            x += 1\n                    if path:\n                        unique_staircases.add(tuple(path))\n                    \n                    # Check down-right-down pattern\n                    path = []\n                    x, y = i, j\n                    while is_within_bounds(x, y) and grid[x][y]:\n                        path.append((x, y))\n                        x += 1\n                        if is_within_bounds(x, y) and grid[x][y]:\n                            path.append((x, y))\n                            y += 1\n                    if path:\n                        unique_staircases.add(tuple(path))\n        \n        return len(unique_staircases)\n    \n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Toggle the state of the specified cell\n        grid[x-1][y-1] = not grid[x-1][y-1]\n        \n        # Recalculate the number of unique staircases\n        results.append(count_staircases_in_grid())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling a grid of cells where each cell can be toggled between free and locked states. The main challenge is to accurately count the number of unique staircases after each query, considering the constraints of large matrix sizes and numerous queries. The solution must be optimized for performance to handle real-time processing of queries.\nrequirement pool:\n- Efficiently process queries to toggle cell states\n- Accurately count unique staircases after each query\n- Optimize performance for large matrices\n- Provide clear user instructions for inputting queries\n- Ensure the application is responsive and provides quick results\nWe will use a 2D list to represent the grid and a set to keep track of unique staircases. For each query, we will toggle the state of the specified cell and recalculate the number of unique staircases. The challenge is efficiently counting staircases, which can be achieved by checking possible staircase paths starting from each free cell. We will use a depth-first search (DFS) approach to explore potential staircases, ensuring that we only count valid paths. Given the constraints, we will optimize the DFS to avoid redundant calculations by caching results where possible.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific structures: alternating right and down movements or alternating down and right movements.\n\n    'toggle'\n    Explanation: Each query changes the state of a specific cell from free to locked or from locked to free.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of a staircase. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, with all cells initially set to free.\n    2. For each query, toggle the state of the specified cell.\n    3. Use a depth-first search (DFS) to explore potential staircases starting from each free cell.\n    4. Ensure that each path follows the staircase structure and only visits free cells.\n    5. Use a set to keep track of unique staircases by storing paths as tuples of cell coordinates.\n    6. After processing each query, count the number of unique staircases and store the result.\n\n# [edge case]\n    Edge Case 1: A grid with all cells initially locked.\n    Explanation: No staircases can exist, so the expected output after any query is 0.\n\n    Edge Case 2: A grid with only one cell.\n    Explanation: The single cell is a staircase itself if it is free, so toggling it will result in outputs of 1 and 0 alternately.\n\n    Edge Case 3: A grid with alternating locked and free cells in a checkerboard pattern.\n    Explanation: Depending on the query, staircases may be limited due to blocked paths, resulting in fewer unique staircases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            # Special handling for single-cell grid\n            return [1 if grid[0][0] == 'free' else 0 for _ in range(q)]\n        elif all(grid[i][j] == 'locked' for i in range(n) for j in range(m)):\n            # Special handling for fully locked grid\n            return [0] * q\n        # Additional logic for checkerboard pattern can be integrated into DFS logic\n        (other code)\n", "requirement analysis:\nThe requirements focus on efficiently handling a grid of cells where each cell can be toggled between free and locked states. The main challenge is to accurately calculate the number of unique staircases after each query, considering the constraints of large matrix sizes and numerous queries. The solution must be optimized for performance to handle real-time processing of queries.\nrequirement pool:\n- Implement efficient data structures to manage cell states and queries.\n- Develop algorithms to accurately count unique staircases after each query.\n- Optimize performance for handling large matrices and high query volumes.\n- Ensure the solution is scalable and can handle edge cases effectively.\n- Provide clear documentation and examples for user understanding.\nWe will use a combination of efficient data structures such as sets and dictionaries to manage the state of the grid and track unique staircases. The algorithm will dynamically update the count of staircases after each query by checking the affected cells and their neighbors. Libraries like NumPy can be used for efficient matrix operations, but given the constraints, custom logic will be implemented to ensure performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A matrix consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the grid that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n    'query': An operation that toggles the state of a specific cell in the grid.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a grid with all cells marked as free.\n2. For each query, toggle the state of the specified cell.\n3. After each toggle, update the count of unique staircases:\n   - Check if the toggled cell affects any existing staircases.\n   - Recalculate staircases by exploring possible paths starting from each free cell.\n4. Use efficient data structures to track and count unique staircases.\n\n# [edge case]\n    1. A grid with only one cell (1x1) = 1\n       Explanation: The only possible staircase is the single cell itself.\n    2. A grid where all cells are initially locked = 0\n       Explanation: No staircases can exist if all cells are locked.\n    3. A grid with alternating free and locked cells in a checkerboard pattern = Depends on specific queries\n       Explanation: The number of staircases will vary based on which cells are toggled.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For a single-cell grid, directly return 1 if the cell is free or 0 if locked.\n    - For a fully locked grid, return 0 without further calculations.\n    - Implement logic to efficiently handle toggling in a checkerboard pattern:\n        ```python\n        def handle_single_cell(grid, x, y):\n            return 1 if grid[x][y] == 'free' else 0\n\n        def handle_fully_locked(grid):\n            return 0\n\n        def handle_checkerboard_pattern(grid, queries):\n            # Implement logic to efficiently count staircases in a checkerboard pattern\n            pass\n        ```\n", "requirement analysis:\nThe requirements focus on efficiently handling matrix queries to determine unique staircases. The solution must toggle cells and calculate paths accurately, even for large matrices. Performance optimization is crucial due to the high number of queries.\nrequirement pool:\n- Efficiently toggle cell states and update matrix.\n- Accurately calculate the number of unique staircases.\n- Optimize performance for large matrices and high query counts.\n- Ensure output format matches the expected results.\n- Handle edge cases and ensure robustness.\nWe will use a 2D list to represent the grid and a set to track unique staircases. For each query, we will toggle the cell state and recalculate the number of unique staircases. The challenge is efficiently updating the staircase count after each toggle, which can be optimized by only recalculating affected staircases. We will use a breadth-first search (BFS) approach to explore possible staircases starting from each free cell.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A 2D matrix consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the grid that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the grid, with all cells initially set to free.\n2. For each query, toggle the state of the specified cell (free to locked or locked to free).\n3. Use a BFS approach to explore all possible staircases starting from each free cell:\n   - For each free cell, attempt to build a staircase by alternating between moving right and down or down and right.\n   - Track visited cells to avoid counting the same staircase multiple times.\n4. Maintain a set of unique staircases by storing their cell coordinates.\n5. After processing each query, count the number of unique staircases and store the result.\n\n# [edge case]\n    1. Grid with all cells initially locked: After any query, if a cell becomes free, it can form a single-cell staircase.\n       Example: For a 2x2 grid with all cells locked, after toggling (1,1) to free, the output is 1.\n    2. Grid with all cells initially free: The number of staircases is maximized initially, and any query will reduce the count.\n       Example: For a 2x2 grid with all cells free, the initial count is 5 staircases.\n    3. Single row or column grid: Only one type of staircase is possible (horizontal or vertical).\n       Example: For a 1x3 grid, only horizontal staircases are possible.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is either fully locked or fully free initially. This involves checking the initial state of the grid and adjusting the logic for counting staircases accordingly.\n\n```python\ndef toggle_cell(grid, x, y):\n    grid[x][y] = not grid[x][y]\n\ndef count_staircases(grid):\n    # Implement BFS or DFS to count unique staircases\n    pass\n\ndef process_queries(n, m, queries):\n    grid = [[True] * m for _ in range(n)]  # Initialize all cells as free\n    results = []\n    \n    for x, y in queries:\n        toggle_cell(grid, x-1, y-1)  # Toggle the cell state\n        results.append(count_staircases(grid))\n    \n    return results\n```\n\n", "requirement analysis:\nThe requirements specify a grid-based problem where the goal is to count unique staircases after each query that toggles the state of a cell. The challenge lies in efficiently updating the count of staircases as cells are toggled between free and locked states. The solution must handle up to 10,000 queries on a grid of size up to 1000x1000, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient staircase counting algorithm\n- Handle cell state toggling and update staircase count\n- Optimize for large grid sizes and query counts\n- Ensure output format matches requirements\n- Consider edge cases and test thoroughly\nWe will use a grid-based approach to efficiently count staircases. The key challenge is to update the count of staircases dynamically as cells are toggled between free and locked states. We will utilize a combination of data structures to track the state of each cell and the potential staircases originating from each cell. The algorithm will leverage adjacency checks and dynamic programming to efficiently update the staircase count after each query.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific patterns of movement: alternating right and down or alternating down and right.\n\n    'toggle'\n    Explanation: Each query changes the state of a specific cell from free to locked or from locked to free.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of a staircase, where each step moves exactly one cell to the right or one cell down. In code, this can be implemented by adjusting the indices of the matrix by +1 in the respective direction.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and set all cells to free initially.\n    2. For each query, toggle the state of the specified cell.\n    3. After each toggle, update the count of staircases by checking all possible starting points and paths.\n    4. Use dynamic programming to efficiently count staircases by storing intermediate results.\n    5. Print the number of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A grid with only one cell (1x1) and one query toggling that cell.\n    Expected Output: 0\n    Explanation: The single cell is toggled to locked, so no staircases can exist.\n\n    Edge Case 2: A grid with all cells initially locked and queries unlocking them one by one.\n    Expected Output: The number of staircases will increase as cells are unlocked, starting from 0.\n\n    Edge Case 3: A grid with alternating free and locked cells initially, and queries toggling them.\n    Expected Output: The number of staircases will vary based on the specific pattern of free cells.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for single-cell grids to directly return 0 when toggled to locked.\n        - Use dynamic programming to efficiently update staircase counts as cells are toggled.\n        - Ensure adjacency checks are robust to handle varying patterns of free and locked cells.\n", "requirement analysis:\nThe main challenge is to efficiently calculate the number of unique staircases after each query, especially given the constraints of large grid sizes and numerous queries. The solution must toggle cell states and update the staircase count in real-time, ensuring performance does not degrade with increased input size.\nrequirement pool:\n- Efficiently handle grid size up to 1000x1000 and 10^4 queries.\n- Accurately calculate the number of unique staircases after each query.\n- Optimize the algorithm for real-time performance.\n- Provide clear and immediate feedback to the user after each query.\n- Ensure the solution is scalable and maintainable.\nWe will use a combination of data structures to efficiently manage the grid state and calculate the number of unique staircases. A 2D list will represent the grid, and a set will track unique staircases. The algorithm will dynamically update the staircase count by checking possible paths after each query. Libraries like NumPy can be used for efficient grid manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific patterns of movement (alternating right and down or down and right).\n\n    'toggle'\n    Explanation: Each query toggles the state of a specific cell, meaning if a cell is free, it becomes locked, and if it is locked, it becomes free.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase. In code, this can be implemented by checking adjacent cells in the grid (e.g., moving from (i, j) to (i, j+1) for right and (i+1, j) for bottom).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid with all cells initially free.\n    2. Create a function to toggle the state of a cell based on the query.\n    3. Implement a function to count unique staircases by checking possible paths in the grid.\n    4. For each query, toggle the cell state and recalculate the number of unique staircases.\n    5. Use efficient data structures like sets to track unique paths and avoid duplicate counting.\n\n# [edge case]\n    Edge Case 1: A grid with only one cell (1x1) and one query toggling that cell.\n    Expected Output: 0\n    Explanation: After toggling the single cell, it becomes locked, and no staircases can exist.\n\n    Edge Case 2: A grid with all cells initially locked and queries that unlock them one by one.\n    Expected Output: The number of staircases will increase as more cells become free.\n\n    Edge Case 3: A grid with alternating free and locked cells initially, and queries that toggle these cells.\n    Expected Output: The number of staircases will vary based on the pattern of toggling.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def toggle_cell(grid, x, y):\n            grid[x][y] = not grid[x][y]\n\n        def count_staircases(grid):\n            # Implement logic to count staircases based on current grid state\n            pass\n\n        # Initialize grid\n        grid = [[True for _ in range(m)] for _ in range(n)]\n\n        # Process each query\n        for x, y in queries:\n            toggle_cell(grid, x-1, y-1)\n            print(count_staircases(grid))\n", "requirement analysis:\nThe requirements focus on toggling cells in a grid and calculating unique staircases. The challenge lies in efficiently handling large matrices and numerous queries while ensuring accurate staircase calculations. The solution must be optimized for performance and provide clear output after each query.\nrequirement pool:\n- Implement efficient matrix handling for large grids\n- Develop algorithm to accurately count unique staircases\n- Optimize query processing for real-time performance\n- Ensure output format matches specified requirements\n- Provide user-friendly interface for inputting queries\nWe will use a 2D list to represent the grid and a set to track unique staircases. The challenge is efficiently updating the count of unique staircases after each query. We will use a function to toggle the cell state and another to calculate the number of unique staircases. The calculation will involve checking possible staircase paths starting from each free cell. Given the constraints, we will optimize the path checking to avoid redundant calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A 2D matrix consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the grid that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n    'query': An operation that toggles the state of a specific cell in the grid.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the grid, with all cells initially set to free.\n2. Create a function to toggle the state of a cell from free to locked or vice versa.\n3. Create a function to calculate the number of unique staircases:\n   - Iterate over each cell in the grid.\n   - For each free cell, attempt to form staircases following the two defined patterns.\n   - Use a set to track unique staircases based on their cell composition.\n4. For each query, toggle the specified cell and recalculate the number of unique staircases.\n5. Output the number of unique staircases after each query.\n\n# [edge case]\n    1. Grid with all cells initially locked:\n       Input: 1 1 1\n              1 1\n       Output: 0\n       Explanation: No staircases can be formed as all cells are locked.\n\n    2. Single cell grid:\n       Input: 1 1 1\n              1 1\n       Output: 0\n       Explanation: Toggling the single cell does not form a staircase as it requires at least two cells.\n\n    3. Large grid with no queries:\n       Input: 1000 1000 0\n       Output: (No output as there are no queries)\n       Explanation: The grid is initialized but no queries are made, so no staircases are calculated.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the grid is too small or all cells are initially locked.\n    ```python\n    def handle_edge_cases(n, m, q, queries):\n        if n == 1 and m == 1:\n            return [0] * q\n        if q == 0:\n            return []\n        # Additional logic for handling all locked cells initially\n        # This would involve checking if all cells are locked before processing queries\n    ```\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to toggle cell states and accurately calculating the number of unique staircases. The solution must handle large matrices and numerous queries while maintaining performance and accuracy.\nrequirement pool:\n- Implement efficient query handling to toggle cell states.\n- Develop algorithm to accurately count unique staircases.\n- Optimize performance for large matrices and high query volumes.\n- Ensure real-time processing and immediate feedback.\n- Provide clear documentation and user guidance.\nWe will use a grid representation with a 2D list to track the state of each cell (free or locked). For efficient query handling, we will toggle the state of the specified cell and recalculate the number of unique staircases using a dynamic programming approach. This will allow us to efficiently count staircases by leveraging previously computed results. We will use NumPy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A matrix with n rows and m columns where each cell can be free or locked.\n    'staircase': A path in the grid that starts and ends in a free cell, visiting only free cells, and follows a specific zigzag pattern.\n    'query': An operation that toggles the state of a specific cell in the grid.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move one column to the right in the grid.\n    '1 to the bottom': Move one row down in the grid.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the grid, marking all cells as free initially.\n2. For each query, toggle the state of the specified cell (free to locked or locked to free).\n3. After each query, recalculate the number of unique staircases:\n   - Use dynamic programming to count staircases by iterating over each cell and checking possible staircase paths.\n   - Consider both zigzag patterns (right-bottom-right and bottom-right-bottom).\n4. Print the number of unique staircases after each query.\n\n# [edge case] \n    Edge Case 1: A grid with only one cell (1x1) and one query toggling that cell.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: Toggling the only cell makes it locked, so no staircases are possible.\n\n    Edge Case 2: A grid with all cells initially locked and queries unlocking them.\n    Input: 2 2 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Expected Output: 0, 0, 0, 5\n    Explanation: Initially, all cells are locked. As they are unlocked, staircases become possible.\n\n    Edge Case 3: A large grid with no queries.\n    Input: 1000 1000 0\n    Expected Output: No output since there are no queries to process.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid size is minimal or when there are no queries.\n    \n```python\ndef handle_edge_cases(n, m, q, queries):\n    if n == 1 and m == 1:\n        return [0] * q\n    if q == 0:\n        return []\n    # Additional logic for handling other edge cases can be added here.\n```\n\nThis function can be integrated into the main logic to handle specific edge cases efficiently.\n", "requirement analysis:\nThe task requires efficiently managing a grid of cells where each cell can be toggled between free and locked states. The main challenge is to accurately count the number of unique staircases after each toggle, considering the constraints of large grid sizes and numerous queries. The solution must be optimized for performance to handle real-time updates.\nrequirement pool:\n- Implement efficient data structures to manage grid state and queries.\n- Develop an algorithm to accurately count unique staircases.\n- Optimize the solution for large grid sizes and high query volumes.\n- Ensure the solution provides real-time updates after each query.\n- Create a user-friendly interface for visualizing the grid and staircases.\nWe will use a 2D list to represent the grid and a set to keep track of unique staircases. The challenge is efficiently updating the count of staircases after each query. We will use a function to toggle the state of a cell and another function to count staircases by checking possible paths from each free cell. Given the constraints, we will optimize the counting process by only recalculating affected areas after each toggle.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'locked cell', 'staircase', 'query'\n    Explanation: \n    - 'grid': A 2D matrix with n rows and m columns.\n    - 'free cell': A cell in the grid that can be part of a staircase.\n    - 'locked cell': A cell in the grid that cannot be part of a staircase.\n    - 'staircase': A path in the grid that follows specific movement rules and consists only of free cells.\n    - 'query': An operation that toggles the state of a specific cell between free and locked.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: \n    - '1 to the right': Move horizontally to the next column.\n    - '1 to the bottom': Move vertically to the next row.\n    Implementation: Use index manipulation to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, with all cells initially free.\n    2. Create a function to toggle the state of a cell based on queries.\n    3. Create a function to count staircases by checking possible paths from each free cell.\n    4. Optimize counting by recalculating only affected areas after each toggle.\n    5. For each query, toggle the cell and update the count of unique staircases.\n\n# [edge case]\n    Edge cases are based on grid size and query operations:\n    1. Grid with all cells initially locked: After any query, count staircases starting from zero.\n       Explanation: Initially, no staircases exist; toggling a cell may create new staircases.\n    2. Grid with all cells initially free: After any query, count staircases starting from maximum possible staircases.\n       Explanation: Initially, maximum staircases exist; toggling a cell may reduce staircases.\n    3. Single cell grid (1x1): After any query, count staircases as either 0 or 1.\n       Explanation: A single cell can be a staircase if free; otherwise, no staircase exists.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n        def toggle_cell(grid, x, y):\n            grid[x][y] = not grid[x][y]\n\n        def count_staircases(grid):\n            # Implement efficient counting logic considering only affected areas\n            pass\n\n        # Initialize grid\n        grid = [[True for _ in range(m)] for _ in range(n)]\n\n        # Process queries\n        for x, y in queries:\n            toggle_cell(grid, x-1, y-1)\n            print(count_staircases(grid))\n", "requirement analysis:\nThe requirements focus on efficiently managing a grid of cells, toggling their states, and calculating unique staircase paths. The challenge lies in handling large matrices and numerous queries while ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient grid state management.\n- Develop algorithm to count unique staircases.\n- Optimize performance for large matrices.\n- Ensure real-time processing of queries.\n- Provide clear output format for staircase counts.\nWe will use a 2D list to represent the grid and a set to keep track of unique staircases. For each query, we will toggle the state of the specified cell and then recalculate the number of unique staircases. The challenge is efficiently counting staircases, which can be achieved by checking possible staircase paths from each free cell. We will use a depth-first search (DFS) approach to explore potential staircases starting from each free cell.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'locked cell', 'staircase'\n    Explanation: \n    - 'grid': A matrix with n rows and m columns where each cell can be free or locked.\n    - 'free cell': A cell in the grid that can be part of a staircase.\n    - 'locked cell': A cell in the grid that cannot be part of a staircase.\n    - 'staircase': A path in the grid that starts and ends in a free cell, visiting only free cells, with specific movement patterns.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, marking all cells as free initially.\n    2. For each query, toggle the state of the specified cell (free to locked or locked to free).\n    3. Use DFS to explore potential staircases starting from each free cell.\n    4. Maintain a set to keep track of unique staircases by storing paths.\n    5. After processing each query, count the number of unique staircases and store the result.\n\n# [edge case] \n    Edge cases are related to the grid size and query operations:\n    - When all cells are free initially, the number of staircases is maximized.\n    - When all cells are locked, there are no staircases.\n    - When toggling a cell that is part of multiple staircases, it affects multiple paths.\n\n# [extra code for edge case]\n    We need extra code to efficiently handle toggling and recalculating staircases:\n        def toggle_cell(grid, x, y):\n            grid[x][y] = not grid[x][y]\n\n        def count_staircases(grid):\n            # Implement DFS to explore staircases\n            # Use a set to track unique paths\n            pass\n\n        for query in queries:\n            toggle_cell(grid, query[0], query[1])\n            result.append(count_staircases(grid))\n", "requirement analysis:\nThe requirement is to efficiently manage a grid of cells that can be toggled between free and locked states, and to calculate the number of unique staircases after each toggle. The solution must handle large grid sizes and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient data structures to manage grid state and queries.\n- Develop an algorithm to accurately count unique staircases.\n- Optimize the solution for real-time performance.\n- Ensure the solution scales with grid size and query count.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of efficient data structures such as sets and dictionaries to manage the grid state and queries. The algorithm will focus on tracking changes in the grid and recalculating the number of unique staircases efficiently after each query. Libraries like NumPy can be used for efficient matrix operations, but given the constraints, we will primarily rely on native Python data structures for optimal performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A matrix-like structure with rows and columns where each cell can be either free or locked.\n    'staircase': A specific path in the grid that follows a zigzag pattern, either right-down-right or down-right-down, starting and ending in a free cell.\n    'query': An operation that toggles the state of a specific cell in the grid from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a grid with all cells marked as free.\n2. For each query, toggle the state of the specified cell.\n3. After each query, recalculate the number of unique staircases:\n   - Iterate over each cell in the grid.\n   - For each free cell, attempt to form a staircase path in both possible patterns (right-down-right and down-right-down).\n   - Use a set to track unique paths based on the cells they visit.\n4. Output the count of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A grid with only one cell (1x1) and one query.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is toggled to locked, leaving no free cells for a staircase.\n\n    Edge Case 2: A grid with all cells initially locked and multiple queries unlocking them.\n    Input: 2 2 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Expected Output: 0, 0, 0, 5\n    Explanation: Initially, all cells are locked. As they are unlocked, staircases can form.\n\n    Edge Case 3: A large grid with no queries.\n    Input: 1000 1000 0\n    Expected Output: No output since there are no queries to process.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid size is minimal or when there are no queries:\n    ```python\n    if n == 1 and m == 1:\n        print(0)\n        return\n\n    if q == 0:\n        return\n    ```\n\n"], "scores": [], "pass_results": [false, false, false, true, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 225, "examples": "\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "mutate_method": "rephrase_one", "parent_index": 158}
