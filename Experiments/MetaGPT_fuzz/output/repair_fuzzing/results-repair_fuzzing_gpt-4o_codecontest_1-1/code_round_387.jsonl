{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block. CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4. This means it is necessary that the quantity of rows is not less than 5. Moreover, the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m, consisting of n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and matrix for a test case.\n\n    Returns:\n        list: Minimum operations needed for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n\n                        # Calculate operations needed for the current sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    # Border blocks should be obsidian\n                                    if matrix[i + x, j + y] == 0:\n                                        operations += 1\n                                else:\n                                    # Inner blocks should be empty\n                                    if matrix[i + x, j + y] == 1:\n                                        operations += 1\n\n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n\n    # Initialize list to store test cases\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().strip())) for _ in range(n)]\n        test_cases.append((n, m, np.array(matrix)))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions (n, m) and the grid matrix.\n\n    Returns:\n        list: Minimum operations needed for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for the current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid matrix.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for the border conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] == 0:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] == 0:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] == 0:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] == 0:\n            operations += 1\n\n    # Check and count operations for the interior conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the matrix\n# Store all test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print the results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Precompute the number of obsidian blocks in each row and column\n        row_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n        col_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                row_obsidian[i][j] = row_obsidian[i][j - 1] + (1 if case[i - 1][j - 1] == '1' else 0)\n                col_obsidian[i][j] = col_obsidian[i - 1][j] + (1 if case[i - 1][j - 1] == '1' else 0)\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed for the current sub-rectangle\n                        operations = 0\n\n                        # Top and bottom borders\n                        operations += b - (row_obsidian[i + 1][j + b] - row_obsidian[i + 1][j])\n                        operations += b - (row_obsidian[i + a][j + b] - row_obsidian[i + a][j])\n\n                        # Left and right borders\n                        operations += a - 2 - (col_obsidian[i + a - 1][j + 1] - col_obsidian[i + 1][j + 1])\n                        operations += a - 2 - (col_obsidian[i + a - 1][j + b] - col_obsidian[i + 1][j + b])\n\n                        # Interior blocks\n                        interior_empty = (a - 2) * (b - 2)\n                        interior_obsidian = (col_obsidian[i + a - 1][j + b - 1] - col_obsidian[i + 1][j + b - 1]) - \\\n                                            (col_obsidian[i + a - 1][j + 1] - col_obsidian[i + 1][j + 1])\n                        operations += interior_obsidian\n\n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions (n, m) and the matrix.\n\n    Returns:\n        list: List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                        operations = 0\n                        # Check the border blocks\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom rows\n                                for y in range(b):\n                                    if y == 0 or y == b - 1:\n                                        continue  # Corners can be any type\n                                    if grid[i + x, j + y] != 1:\n                                        operations += 1\n                            else:\n                                # Middle rows\n                                if grid[i + x, j] != 1:\n                                    operations += 1\n                                if grid[i + x, j + b - 1] != 1:\n                                    operations += 1\n                        # Check the inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x, j + y] != 0:\n                                    operations += 1\n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the matrix\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions of the rectangle and the matrix.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array(matrix)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for i in range(start_row + 1, end_row):\n        if grid[i, start_col] != 1:\n            operations += 1\n        if grid[i, end_col] != 1:\n            operations += 1\n\n    for j in range(start_col + 1, end_col):\n        if grid[start_row, j] != 1:\n            operations += 1\n        if grid[end_row, j] != 1:\n            operations += 1\n\n    # Check the interior conditions\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i, j] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [list(map(int, input().strip())) for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Determine the minimum number of operations needed to create a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and block matrix.\n\n    Returns:\n        list[int]: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for easier manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for the current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n    \n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing n, m, and the matrix as a list of strings.\n    \n    Returns:\n    list: A list of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        grid = np.array([list(map(int, row)) for row in matrix])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for the current sub-rectangle\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[start_row + x, start_col] == 0:\n                                operations += 1\n                            if grid[start_row + x, start_col + b - 1] == 0:\n                                operations += 1\n                        for y in range(1, b - 1):\n                            if grid[start_row, start_col + y] == 0:\n                                operations += 1\n                            if grid[start_row + a - 1, start_col + y] == 0:\n                                operations += 1\n                        \n                        # Check interior conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x, start_col + y] == 1:\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        # Append the result for the current test case\n        results.append(min_operations)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to form a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid) where grid is a list of strings.\n\n    Returns:\n        list: List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions for obsidian blocks\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Check the inner blocks for empty blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input()) for i in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to form a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions and grid of a test case.\n\n    Returns:\n        list: Minimum number of operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be converted.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check and convert the borders (except corners)\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check and convert the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions n, m and the grid matrix.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array(matrix)\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n\n                        # Check and count operations for the border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x, j] != 1:\n                                operations += 1\n                            if grid[i + x, j + b - 1] != 1:\n                                operations += 1\n\n                        for y in range(1, b - 1):\n                            if grid[i, j + y] != 1:\n                                operations += 1\n                            if grid[i + a - 1, j + y] != 1:\n                                operations += 1\n\n                        # Check and count operations for the interior conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x, j + y] != 0:\n                                    operations += 1\n\n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the matrix\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print results\nresults = find_min_operations(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be efficient to handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal transformation.\n- Ensure the solution handles edge cases and maximum constraints effectively.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for speed and scalability.\n- Document the solution approach and edge case handling.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transformation based on the given criteria. We will utilize numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, where each block can be either an obsidian block or an empty block.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates that for rows between the first and last, certain blocks must be obsidian.\n    'For all 1 < x < b': This indicates that for columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n    3. For each sub-rectangle, calculate the number of operations needed to meet the portal criteria:\n        - Ensure the borders are obsidian blocks as specified.\n        - Ensure the inner blocks are empty.\n    4. Use dynamic programming to efficiently track and update the minimum number of operations needed for each sub-rectangle.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n   0000\n   0000\n   0000\n   0000\n    Expected Output: \n    12\n    Explanation: All border blocks need to be converted to obsidian, requiring a total of 12 operations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through possible sub-rectangles and calculating transformation costs will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must efficiently handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for portal creation\n- Optimize the algorithm for large input sizes\n- Ensure the solution is easy to understand and implement\n- Test the solution against edge cases\n- Provide detailed documentation and examples\nWe will use a dynamic programming approach to efficiently determine the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations required to convert each into a portal. We will leverage numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these minimum dimensions.\n\n    '1 < x < a', '1 < x < b'\n    Explanation: These phrases define the range of indices for which certain conditions must be met. In code, this translates to iterating over these index ranges to check and enforce the conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, read the grid of blocks.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met by checking and counting necessary changes.\n   - Ensure the interior conditions are met by checking and counting necessary changes.\n5. Track the minimum number of operations needed for each test case.\n6. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 0\n    Explanation: The entire grid is already a portal, so no operations are needed.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, and all interior blocks need to remain empty.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an efficient algorithm to identify the optimal sub-rectangle.\n- Implement a method to calculate the minimum operations required.\n- Ensure the solution is scalable for maximum input constraints.\n- Provide clear documentation and examples for understanding.\n- Optimize the code for readability and maintainability.\nWe will use a dynamic programming approach to efficiently identify the optimal sub-rectangle that can be transformed into a portal with the minimum number of operations. The algorithm will iterate over possible sub-rectangles and calculate the cost of transformation using precomputed values for each block. This approach ensures scalability and efficiency for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    Explanation: This sets the minimum size for the portal, ensuring it is large enough to meet the criteria.\n    Implementation: Check if the dimensions of any sub-rectangle are at least 5 rows and 4 columns.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the borders meet the obsidian criteria.\n        - Ensure the interior blocks are empty.\n    4. Use dynamic programming to store and reuse calculations for efficiency.\n    5. Track the minimum number of operations across all sub-rectangles for each test case.\n    6. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The rectangle is already a portal, so no operations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All border blocks need to be converted to obsidian, requiring maximum operations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The rectangle is already a portal, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all possible sub-rectangles and calculating transformation costs will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient for large matrices. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed efficiently.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for a portal.\n- Ensure the solution handles maximum constraints within acceptable time limits.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for edge cases.\n- Document the solution for maintainability and understanding.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, while maintaining a minimum cost. We will utilize numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A geometric shape with four sides and four right angles, defined by its dimensions n by m.\n    'obsidian block': A type of block in the rectangle, represented by '1'.\n    'empty block': Another type of block in the rectangle, represented by '0'.\n    'portal': A specific sub-rectangle within the larger rectangle that meets certain criteria.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': For rows within the sub-rectangle, excluding the first and last row.\n    '1 < x < b': For columns within the sub-rectangle, excluding the first and last column.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the border blocks are obsidian as per the portal criteria.\n        - Ensure the inner blocks are empty.\n    4. Use dynamic programming to keep track of the minimum number of operations needed for each sub-rectangle.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n   0000\n   0000\n   0000\n   0000\n    Expected Output: \n    12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should be able to handle these scenarios by checking each possible sub-rectangle and calculating the necessary operations.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal formation.\n- Ensure the solution handles multiple test cases within the given constraints.\n- Optimize the algorithm for edge cases with maximum input sizes.\n- Provide clear documentation and comments within the code for maintainability.\n- Implement additional test cases to ensure robustness of the solution.\nWe will use a dynamic programming approach to efficiently calculate the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and compute the cost of transforming each into a portal, leveraging memoization to avoid redundant calculations. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid, represented by 1 and 0 respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means checking that any potential portal has dimensions that meet these minimum requirements.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of operations for different sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met (obsidian blocks on specified edges).\n   - Ensure the interior conditions are met (empty blocks inside).\n4. Use dynamic programming to store and reuse results for overlapping sub-rectangles to optimize calculations.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as it already meets the portal criteria.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The interior needs to be converted to empty blocks, requiring multiple operations.\n\n    Case 3: A rectangle with all blocks as empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The border needs to be converted to obsidian blocks, requiring multiple operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the minimum operations for each potential portal will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to determine minimum operations for portal creation\n- Ensure the solution handles multiple test cases efficiently\n- Optimize the algorithm for large input sizes\n- Provide clear output format as specified\n- Include detailed comments and documentation for user understanding\nWe will implement a function to determine the minimum number of operations needed to transform a given rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations required to convert each sub-rectangle into a portal. We will use numpy for efficient matrix manipulation and calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest operation count found.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Keep track of the minimum number of operations needed for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output:\n    12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output:\n    0\n    Explanation: The rectangle already satisfies the portal conditions, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on the dimensions and block types are clear, and the solution must efficiently handle multiple test cases with potentially large matrices.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure solution handles large matrices within constraints\n- Provide clear output format for test case results\n- Optimize for speed and accuracy\n- Include detailed comments and documentation\nWe will implement a function to determine the minimum number of operations needed to transform a given sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes required to meet the portal criteria. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles that meet these minimum dimensions.\n\n    '1 < x < a', '1 < x < b'\n    Explanation: These phrases define the range of indices for which certain conditions must be met. In code, this translates to iterating over these index ranges to check and enforce the conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met (obsidian blocks on specified edges).\n   - Ensure the interior conditions are met (empty blocks in specified areas).\n4. Track the minimum number of operations required for any sub-rectangle to become a portal.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The sub-rectangle is already a portal, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, especially given the maximum dimensions of 400x400. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for portal creation.\n- Optimize the algorithm to handle maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution against various scenarios.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. The function will keep track of the minimum number of operations needed across all sub-rectangles. We will use a brute-force approach with optimizations to ensure efficiency given the constraints. The numpy library will be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where 'n' is the number of rows and 'm' is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria regarding its dimensions and block types.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid, represented by 1 and 0 respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle (portal) must have at least 5 rows and 4 columns. In code, this means checking sub-rectangles with dimensions starting from 5x4.\n\n    'For every 1 < x < a'\n    Explanation: This means for all rows except the first and last in the sub-rectangle, certain conditions must be met.\n\n    'For all 1 < x < b'\n    Explanation: This means for all columns except the first and last in the sub-rectangle, certain conditions must be met.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and then read the n lines of the grid.\n3. Iterate over all possible sub-rectangles of size at least 5x4 within the n x m grid.\n4. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n5. Keep track of the minimum number of operations required to transform any sub-rectangle into a portal.\n6. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire grid is already a portal, so no operations are needed.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All blocks need to be changed to meet the portal criteria.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The grid already contains a portal, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must efficiently handle the maximum input size. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations while adhering to the portal criteria.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for portal creation.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output for each test case.\n- Handle edge cases effectively.\n- Include comments and documentation for better understanding.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of operations needed to convert it into a portal. We will use a brute-force approach with optimizations to handle the constraints efficiently. The solution will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions satisfying these conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty blocks.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already in portal form\n    Explanation: If a rectangle is already a portal, the expected output is 0 operations.\n\n    Case 2: A rectangle with all blocks as obsidian\n    Explanation: The expected output would be the number of operations needed to convert inner blocks to empty blocks while maintaining the portal structure.\n\n    Case 3: A rectangle with all blocks as empty\n    Explanation: The expected output would be the number of operations needed to convert border blocks to obsidian blocks while maintaining the portal structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient for large matrices, and the algorithm should be able to handle multiple test cases. The solution should focus on minimizing operations while adhering to the portal's structural requirements.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal transformation.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance improvements.\n- Document the solution approach and edge case handling.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost. We will utilize numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid, represented by 1 and 0 respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means checking sub-rectangles where the number of rows is at least 5 and the number of columns is at least 4.\n\n    '1 < x < a' and '1 < y < b'\n    Explanation: These conditions specify the range of indices for which certain blocks must be obsidian or empty. In code, this translates to iterating over these ranges to check or set block types.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest operation count found.\n\n# [code logic]\n1. Parse the input to get the number of test cases and for each test case, the dimensions n and m, followed by the grid itself.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met (obsidian blocks on specified borders).\n   - Ensure the interior conditions are met (empty blocks in specified interior).\n4. Keep track of the minimum number of operations needed for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The grid already forms a portal with no operations needed.\n\n    Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All border blocks need to be changed to obsidian, requiring 12 operations.\n\n    Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The grid already forms a portal with no operations needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should handle these cases as it iterates over all possible sub-rectangles and calculates the minimum operations needed.\n"], "scores": [], "pass_results": [true, true, true, false, false, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 387, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 164}
