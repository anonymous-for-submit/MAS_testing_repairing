{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, and during this time, Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison deals 1 damage during each of the next k seconds. The counting starts with the same second when the dragon was stabbed by the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e., cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6, and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, and during this time, Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison deals 1 damage during each of the next k seconds. The counting starts with the same second when the dragon was stabbed by the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e., cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6, and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, and during this time, Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison deals 1 damage during each of the next k seconds. The counting starts with the same second when the dragon was stabbed by the dagger. However, if the dragon has already been poisoned, then the dagger updates the poison effect. It cancels the current poison effect and applies a new one.\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6, and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, and during this time, Monocarp attacks the dragon with a poisoned dagger; the i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds. However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e., cancels the current poison effect and applies a new one). For example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6, and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon receives 10 damage. Monocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # Set high to h as a safe upper bound\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on damage calculation\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration needed to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of tuples containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_poison_duration(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of the poison effect (k) for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to slay the dragon.\n            - attacks: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # Start with a reasonable high bound\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to slay the dragon.\n            - a: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, a[i + 1] - a[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        # The minimum k is the value of low after the loop ends\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of poison effect needed to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_poison_duration(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search boundaries\n        left, right = 1, h\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for the current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search range based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to slay the dragon.\n            - a: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for this mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, a[i + 1] - a[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon. The solution must efficiently handle large input sizes and ensure correct output for all test cases.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Optimize the solution for large input sizes\n- Ensure the solution is scalable and efficient\n- Provide clear documentation and comments in the code\n- Test the solution against edge cases\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be used to find the smallest k such that the total damage is at least h. This approach is efficient and scalable, handling large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. It lasts for k seconds and is reapplied with each attack, canceling any existing poison effect.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt to the dragon must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all poisoned seconds meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n (number of attacks) and h (required damage).\n    3. Read the attack times into a list.\n    4. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., low = 1, high = maximum possible k).\n        - Calculate mid-point k and simulate the damage calculation.\n        - If the damage is at least h, adjust high; otherwise, adjust low.\n    5. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case with attacks spaced far apart:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: Each attack can independently deal enough damage with k=1.\n\n    Test case with large h:\n    3 1000000000000000000\n    1 2 3\n    Expected output: Large value (depends on binary search result)\n    Explanation: Requires a large k to accumulate enough damage over few attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting bounds based on damage calculations.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect needed to deal at least h damage to the dragon. The solution must efficiently handle large input sizes and provide clear output for each test case.\nrequirement pool:\n- Calculate minimum poison duration for each test case.\n- Optimize algorithm for large input sizes.\n- Ensure output clarity and correctness.\n- Handle edge cases with large values of h and a_i.\n- Provide detailed documentation for the solution.\nWe will implement a function to determine the minimum poison duration needed to deal at least h damage to the dragon. The approach involves iterating over the attack times and calculating the damage dealt for a given poison duration k. We will use binary search to efficiently find the minimum k that satisfies the condition, as this will allow us to handle large input sizes effectively. The solution will be optimized for performance and clarity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs during this period, the poison effect is reset.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. For each test case, read n (number of attacks) and h (required damage).\n2. Read the attack times into a list.\n3. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage contributed by that attack.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n4. After binary search, low will be the minimum k that satisfies the condition.\n5. Output the result for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 2, h = 10, a = [1, 1000000000] => Expected output: 10\n    Explanation: The attacks are far apart, so each attack must deal all required damage alone.\n\n    Case 3: n = 3, h = 3, a = [1, 2, 3] => Expected output: 1\n    Explanation: Each attack can contribute to the total damage with k = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these cases by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given a series of attack times. The solution must efficiently handle up to 1000 test cases with large values for h and attack times.\nrequirement pool:\n- Efficiently calculate the minimum k for each test case\n- Handle large input sizes and constraints\n- Provide clear and correct output for each test case\n- Optimize for edge cases with large h values\n- Ensure the solution is easy to understand and maintain\nWe will use a binary search approach to efficiently determine the minimum k. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by iterating over the attack times. By using binary search, we can find the smallest k that satisfies the condition of dealing at least h damage. This approach is efficient and handles large input sizes well.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds starting from the attack second. If another attack occurs during an active poison effect, the poison duration is reset.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Use a condition to check if the cumulative damage is >= h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for this mid value of k:\n       - Initialize total_damage = 0.\n       - Iterate over attack times and calculate damage using current k.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n5. Output the found minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack needs to deal its own damage separately.\n\n    Case 3: n = 3, h = 3, a = [1, 2, 3] => k = 1\n    Explanation: Each attack can deal its own damage without overlapping, so k can be minimal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by checking cumulative damage for each potential k value.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will deal at least h damage to the dragon. The solution must efficiently calculate the damage dealt over time, considering the reapplication of poison effects.\nrequirement pool:\n- Implement the main logic to calculate minimum k.\n- Ensure the solution handles large values of h and a_i efficiently.\n- Optimize the solution for performance.\n- Validate the solution against multiple test cases.\n- Provide clear documentation and comments in the code.\nWe will implement a function to calculate the minimum duration of the poison effect (k) using a binary search approach. This will efficiently handle large values of h and a_i by minimizing the number of calculations needed to determine the correct k. We will use Python's built-in capabilities for handling large integers and efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for k seconds starting from the attack second. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this means summing up the damage over time and checking if it meets or exceeds h.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition of dealing at least h damage. This suggests using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage for each attack considering overlapping effects.\n     - If total damage is at least h, adjust the upper bound of k.\n     - Otherwise, adjust the lower bound.\n4. Output the minimum k for each test case.\n\n# [edge case] \n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 2, h = 10^18, a = [1, 10^9]\n    Expected output: A large k value\n    Explanation: The attacks are far apart, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 100, h = 100, a = [1, 2, ..., 100]\n    Expected output: 1\n    Explanation: Each attack can deal exactly 1 damage per second without overlap, so k = 1 is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on whether the accumulated damage meets or exceeds h.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large input sizes, ensuring the algorithm is optimized for both time and space complexity.\nrequirement pool:\n- Develop an efficient algorithm to calculate the minimum k value.\n- Ensure the solution handles large input sizes and edge cases.\n- Optimize the algorithm for time and space complexity.\n- Provide clear documentation and test cases for validation.\n- Enhance user experience with detailed output explanations.\nWe will implement a function to calculate the minimum poison duration (k) using a binary search approach. This will efficiently handle large input sizes and ensure the solution is optimized for time complexity. We will utilize Python's built-in capabilities for handling large integers and efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. It lasts for k seconds and deals 1 damage per second. If a new attack occurs while the poison is active, the effect is reset.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h.\n    Implementation: Ensure the accumulated damage from all attacks is >= h.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that meets the requirement.\n    Implementation: Use a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases, and for each test case, get n, h, and the list of attack times.\n    2. Implement a binary search to find the minimum k:\n        - Set low = 1 and high = h (or a reasonable upper bound based on attack intervals).\n        - While low <= high:\n            - Calculate mid = (low + high) // 2.\n            - Calculate total damage for k = mid using the attack times.\n            - If total damage >= h, set high = mid - 1 (try smaller k).\n            - Else, set low = mid + 1 (increase k).\n    3. Return low as the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/n\n    Explanation: The attacks are closely spaced, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 5, a = [1, 1000000000]\n    Expected output: 5\n    Explanation: The attacks are far apart, so k must be at least h since no overlap occurs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe game requires efficient calculation of poison duration to meet the dragon's health threshold. The solution should handle large numbers and multiple test cases effectively, ensuring the player receives accurate feedback on the damage dealt.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum poison duration\n- Ensure the game handles large input sizes without performance issues\n- Provide clear feedback on damage dealt after each attack\n- Allow easy input of multiple test cases\n- Optimize UI for intuitive understanding of game mechanics\nWe will implement a binary search algorithm to efficiently determine the minimum poison duration (k) required to deal at least h damage to the dragon. This approach is chosen because it allows us to handle large input sizes and high values of h efficiently. We will iterate over each test case, calculate the damage for a given k, and adjust k using binary search until the minimum k that satisfies the condition is found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs before the current poison effect ends, the poison effect is reset to start from the new attack time.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: This can be checked by summing up the damage over time and comparing it to h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. For each test case, initialize low and high bounds for binary search on k.\n2. While low is less than or equal to high:\n   - Calculate mid as the average of low and high.\n   - Calculate total damage for this mid value of k.\n   - If total damage is at least h, update high to mid - 1 (to find a smaller k).\n   - Otherwise, update low to mid + 1 (to increase k).\n3. The answer for each test case is the value of low after the loop ends.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10000, a = [1, 2, ..., 100] => Expected output: 100\n    Explanation: Each attack can only deal damage for one second without overlap, so k must be at least 100.\n\n    Case 3: n = 2, h = 10^18, a = [1, 10^9] => Expected output: 10^18\n    Explanation: With such a large h and only two attacks far apart, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of poison effect needed to deal at least h damage to the dragon, given the attack timings. The solution must efficiently handle up to 1000 test cases with large values for h and attack timings.\nrequirement pool:\n- Calculate minimum poison duration for each test case\n- Optimize algorithm for large input sizes\n- Ensure output format is clear and concise\n- Handle edge cases with maximum values\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine the minimum duration of the poison effect needed to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the total damage for a given duration k. We will use binary search to efficiently find the minimum k that satisfies the condition. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt to the dragon must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage interval and add to total_damage.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n5. Output the value of low as the minimum k for each test case.\n\n# [edge case] \n    Test case 1: 1 1\n                 1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient to deal the required damage.\n\n    Test case 2: 2 2\n                 1 2\n    Expected output: 1\n    Explanation: Two attacks at consecutive seconds mean k = 1 is enough to deal 2 damage.\n\n    Test case 3: 3 10\n                 1 5 10\n    Expected output: 3\n    Explanation: The attacks are spaced such that k = 3 is needed to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage dealt to the dragon is at least h. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring damage calculations for very large values of h.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Optimize the solution to handle large input sizes efficiently.\n- Ensure the solution is tested against edge cases.\n- Provide clear documentation and comments in the code.\n- Implement additional features for user interaction if needed.\nWe will implement a binary search algorithm to efficiently find the minimum value of k. The key observation is that the damage dealt by the poison can be calculated by iterating over the attack times and summing the effective damage periods. We will use binary search to minimize k by checking if the total damage is at least h for each candidate k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. It lasts for k seconds after each attack, and if another attack occurs during this period, the poison effect is reset.\n\n    'minimum possible value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this means summing the damage over all effective poison periods and checking if it meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k.\n    2. For each test case, perform binary search:\n        - Calculate total damage for a candidate k.\n        - If total damage >= h, adjust search range to find smaller k.\n        - If total damage < h, increase k.\n    3. Return the minimum k found for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k can be 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: Large value of k\n    Explanation: With maximum h and sequential attacks, k needs to be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 2, a = [1, 1000000000]\n    Expected output: 1\n    Explanation: Two attacks far apart mean each attack needs to deal at least 1 damage, so k can be minimal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of poison effect needed to deal at least h damage to the dragon. The solution must efficiently handle large input sizes and provide accurate results for multiple test cases.\nrequirement pool:\n- Calculate minimum poison duration accurately\n- Optimize for large input sizes\n- Ensure output clarity and conciseness\n- Handle edge cases effectively\n- Provide user-friendly interface\nWe will implement a function to calculate the minimum poison duration using a binary search approach to efficiently find the minimum k that satisfies the damage requirement. This approach is chosen due to its ability to handle large input sizes effectively. We will use Python's built-in capabilities for handling large integers and efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum possible value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt to the dragon must be greater than or equal to h. This can be implemented by ensuring the sum of damage over time is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for this mid value of k.\n     - If total damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n5. Output the value of low, which is the minimum k.\n\n# [edge case]\n    Edge Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Edge Case 2: n = 100, h = 10000, a = [1, 2, ..., 100] => Expected output: 100\n    Explanation: With attacks every second and needing 10000 damage, k must be at least 100 to cover all attacks.\n\n    Edge Case 3: n = 2, h = 10^18, a = [1, 10^9] => Expected output: 10^18\n    Explanation: With two widely spaced attacks and needing a very large amount of damage, k must be very large.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the required damage and attack timings.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given the attack timings. The solution must efficiently handle up to 1000 test cases with large values for h and attack timings.\nrequirement pool:\n- Calculate minimum k value for each test case\n- Optimize algorithm for large input sizes\n- Ensure output format is correct\n- Handle edge cases such as minimum and maximum values\n- Provide detailed comments and documentation\nWe will implement a binary search algorithm to efficiently determine the minimum value of k for each test case. The binary search will be used to find the smallest k such that the total damage is at least h. This approach is chosen due to its logarithmic time complexity, which is suitable for handling large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison that lasts for k seconds, dealing 1 damage per second. If a new attack occurs while the poison is active, it resets the poison duration.\n\n    'minimum possible value of k'\n    Explanation: The task is to find the smallest duration k for which the total damage dealt by the poison is at least h, the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all poisoned seconds meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. For each test case, initialize low and high bounds for binary search on k.\n    2. Perform binary search:\n        - Calculate mid-point k.\n        - Simulate the damage calculation for this k using the attack times.\n        - If total damage >= h, adjust high bound; otherwise, adjust low bound.\n    3. Return the minimum k found.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large k value\n    Explanation: The dragon has extremely high hit points, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 2, a = [1, 1000000000]\n    Expected output: 1\n    Explanation: The attacks are far apart, but only 2 damage is needed, so k = 1 suffices as each attack deals 1 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 998, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "expand_one2two", "parent_index": 38}
