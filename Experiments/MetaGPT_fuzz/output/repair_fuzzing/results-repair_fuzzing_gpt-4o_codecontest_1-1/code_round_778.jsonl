{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones returns, assisting his distant relative Indiana Jones, in locating a hidden treasure within a maze concealed beneath a desert filled with illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, ensuring connectivity between rooms with several tunnels allowing travel between each pair. The i-th room (1 \u2264 i \u2264 n) has an illusion rate of a_i. To travel from the x-th room to the y-th room, a tunnel must exist between x and y, requiring max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the maze can alter the illusion rate of any room within it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can receive a share of the treasure! You may assume that all rooms and tunnels are initialized properly. Make sure to optimize your solution for maximum efficiency.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones returns, assisting his distant relative Indiana Jones, in locating a hidden treasure within a maze concealed beneath a desert filled with illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, ensuring connectivity between rooms with several tunnels allowing travel between each pair. The i-th room (1 \u2264 i \u2264 n) has an illusion rate of a_i. To travel from the x-th room to the y-th room, a tunnel must exist between x and y, requiring max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the maze can alter the illusion rate of any room within it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can receive a share of the treasure! You may assume that all rooms and tunnels are initialized properly. Make sure to optimize your solution for maximum efficiency.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones returns, assisting his distant relative Indiana Jones, in locating a hidden treasure within a maze concealed beneath a desert filled with illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This configuration ensures connectivity between rooms with several tunnels allowing travel between each pair of rooms. The i-th room (1 \u2264 i \u2264 n) has an illusion rate of a_i. To travel from the x-th room to the y-th room, a tunnel must exist between x and y, requiring max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the maze can alter the illusion rate of any room within it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can receive a share of the treasure! You may assume that all rooms and tunnels are initialized properly. Make sure to optimize your solution for maximum efficiency.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones returns, assisting his distant relative Indiana Jones, in locating a hidden treasure within a maze concealed beneath a desert filled with illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, ensuring connectivity between rooms with several tunnels allowing travel between each pair, with the i-th room (1 \u2264 i \u2264 n) having an illusion rate of a_i. To travel from the x-th room to the y-th room, a tunnel must exist between x and y, requiring max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the maze can alter the illusion rate of any room within it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can receive a share of the treasure! You may assume that all rooms and tunnels are initialized properly. Make sure to optimize your solution for maximum efficiency.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient updates and queries.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        \"\"\"Initialize the segment tree with the given data.\"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Update the value at position pos to value.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]):\n    \"\"\"Perform DFS to calculate depth and parent for each node.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of nodes u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    # Bring u and v to the same depth\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    \"\"\"Calculate the energy required to travel between two rooms.\"\"\"\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    depth = [0] * (n + 1)\n    parent_list = [0] * (n + 1)\n    \n    # Preprocess the tree using DFS\n    dfs(tree, 1, -1, depth, parent_list)\n    \n    # Find the LCA of u and v\n    ancestor = lca(u, v, depth, parent_list)\n    \n    # Calculate the energy required to travel from u to v via the LCA\n    energy = 0\n    current = u\n    while current != ancestor:\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent_list[current] - 1])\n        current = parent_list[current]\n    \n    current = v\n    while current != ancestor:\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent_list[current] - 1])\n        current = parent_list[current]\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: nx.Graph) -> int:\n    \"\"\"Calculate the minimum energy required to travel between two rooms.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): The list of current illusion rates.\n        tree (nx.Graph): The tree structure representing the maze.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    path = nx.shortest_path(tree, source=u, target=v)\n    total_energy = 0\n\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = nx.Graph()\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tree.add_edge(s, t)\n        index += 2\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            update_illusion_rate(u, c, illusion_rates)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], depths: List[int], parents: List[List[int]]) -> None:\n    \"\"\"Perform a Depth First Search to compute depths and parent information for LCA.\n\n    Args:\n        node (int): The current node being visited.\n        parent (int): The parent of the current node.\n        depth (int): The depth of the current node.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n        depths (List[int]): The list to store depths of each node.\n        parents (List[List[int]]): The list to store parent information for each node.\n    \"\"\"\n    depths[node] = depth\n    parents[node][0] = parent\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, depths, parents)\n\ndef preprocess_lca(n: int, tree: List[List[int]]) -> Tuple[List[int], List[List[int]]]:\n    \"\"\"Preprocess the tree to compute depths and parent information for LCA.\n\n    Args:\n        n (int): The number of nodes in the tree.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n\n    Returns:\n        Tuple[List[int], List[List[int]]]: The depths and parent information for each node.\n    \"\"\"\n    LOG = 17  # Since n <= 10^5, log2(10^5) is approximately 17\n    depths = [-1] * (n + 1)\n    parents = [[-1] * LOG for _ in range(n + 1)]\n    dfs(1, -1, 0, tree, depths, parents)\n    \n    for j in range(1, LOG):\n        for i in range(1, n + 1):\n            if parents[i][j - 1] != -1:\n                parents[i][j] = parents[parents[i][j - 1]][j - 1]\n    \n    return depths, parents\n\ndef lca(u: int, v: int, depths: List[int], parents: List[List[int]]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\n\n    Args:\n        u (int): The first node.\n        v (int): The second node.\n        depths (List[int]): The depths of each node.\n        parents (List[List[int]]): The parent information for each node.\n\n    Returns:\n        int: The LCA of the two nodes.\n    \"\"\"\n    if depths[u] < depths[v]:\n        u, v = v, u\n    \n    LOG = len(parents[0])\n    for i in range(LOG - 1, -1, -1):\n        if depths[u] - (1 << i) >= depths[v]:\n            u = parents[u][i]\n    \n    if u == v:\n        return u\n    \n    for i in range(LOG - 1, -1, -1):\n        if parents[u][i] != parents[v][i]:\n            u = parents[u][i]\n            v = parents[v][i]\n    \n    return parents[u][0]\n\ndef calculate_energy(a: int, b: int) -> int:\n    \"\"\"Calculate the energy required to travel between two rooms.\n\n    Args:\n        a (int): The illusion rate of the first room.\n        b (int): The illusion rate of the second room.\n\n    Returns:\n        int: The energy required.\n    \"\"\"\n    return max(abs(a + b), abs(a - b))\n\ndef min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room.\n        v (int): The destination room.\n        illusion_rates (List[int]): The list of current illusion rates.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n\n    Returns:\n        int: The minimum energy required.\n    \"\"\"\n    depths, parents = preprocess_lca(len(tree) - 1, tree)\n    ancestor = lca(u, v, depths, parents)\n    \n    energy = 0\n    current = u\n    while current != ancestor:\n        parent = parents[current][0]\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent - 1])\n        current = parent\n    \n    current = v\n    while current != ancestor:\n        parent = parents[current][0]\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent - 1])\n        current = parent\n    \n    return energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient range updates and queries.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        \"\"\"Initialize the Segment Tree with the given data.\"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the Segment Tree from the given data.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Update the value at position `pos` to `value`.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    segment_tree.update(room - 1, new_rate)\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parents: List[int]):\n    \"\"\"Perform DFS to calculate depth and parent information.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parents[neighbor] = node\n            dfs(tree, neighbor, node, depth, parents)\n\ndef lca(u: int, v: int, depth: List[int], parents: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of nodes u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parents[u]\n    while u != v:\n        u = parents[u]\n        v = parents[v]\n    return u\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], depth: List[int], parents: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    ancestor = lca(u, v, depth, parents)\n    energy = 0\n    path = []\n    \n    # Collect path from u to ancestor\n    while u != ancestor:\n        path.append(u)\n        u = parents[u]\n    path.append(ancestor)\n    \n    # Collect path from v to ancestor\n    temp_path = []\n    while v != ancestor:\n        temp_path.append(v)\n        v = parents[v]\n    path.extend(reversed(temp_path))\n    \n    # Calculate energy for the path\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        ax, ay = illusion_rates[x - 1], illusion_rates[y - 1]\n        energy += max(abs(ax + ay), abs(ax - ay))\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    # Build the tree structure\n    tree = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    # Preprocess the tree using DFS\n    depth = [0] * (n + 1)\n    parents = [0] * (n + 1)\n    dfs(tree, 1, -1, depth, parents)\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree, depth, parents)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass MazeSolver:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tunnels = tunnels\n        self.tree = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        self.build_tree()\n        self.dfs(1, 0)\n        self.build_segment_tree(1, 1, n)\n\n    def build_tree(self):\n        for u, v in self.tunnels:\n            self.tree[u].append(v)\n            self.tree[v].append(u)\n\n    def dfs(self, node: int, par: int):\n        self.parent[node] = par\n        for neighbor in self.tree[node]:\n            if neighbor != par:\n                self.depth[neighbor] = self.depth[node] + 1\n                self.dfs(neighbor, node)\n\n    def build_segment_tree(self, node: int, start: int, end: int):\n        if start == end:\n            self.segment_tree[node] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self.build_segment_tree(2 * node, start, mid)\n            self.build_segment_tree(2 * node + 1, mid + 1, end)\n            self.segment_tree[node] = self.segment_tree[2 * node] + self.segment_tree[2 * node + 1]\n\n    def update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        if start == end:\n            self.segment_tree[node] = value\n            self.illusion_rates[idx - 1] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self.update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = self.segment_tree[2 * node] + self.segment_tree[2 * node + 1]\n\n    def query_segment_tree(self, node: int, start: int, end: int, L: int, R: int) -> int:\n        if R < start or end < L:\n            return 0\n        if L <= start and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_sum = self.query_segment_tree(2 * node, start, mid, L, R)\n        right_sum = self.query_segment_tree(2 * node + 1, mid + 1, end, L, R)\n        return left_sum + right_sum\n\n    def lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def calculate_energy(self, u: int, v: int) -> int:\n        lca_node = self.lca(u, v)\n        energy = 0\n        while u != lca_node:\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[self.parent[u] - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[self.parent[u] - 1]))\n            u = self.parent[u]\n        while v != lca_node:\n            energy += max(abs(self.illusion_rates[v - 1] + self.illusion_rates[self.parent[v] - 1]),\n                          abs(self.illusion_rates[v - 1] - self.illusion_rates[self.parent[v] - 1]))\n            v = self.parent[v]\n        return energy\n\ndef handle_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    solver = MazeSolver(n, illusion_rates, tunnels)\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, u, c = query\n            solver.update_segment_tree(1, 1, n, u, c)\n        elif query[0] == 2:\n            _, u, v = query\n            energy = solver.calculate_energy(u, v)\n            results.append(energy)\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results for type 2 queries\nresults = handle_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    # Update the illusion rate in the list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree accordingly\n    update_segment_tree(segment_tree, room - 1, new_rate, 0, len(illusion_rates) - 1, 0)\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], segment_tree: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Find the path from u to v using DFS and LCA\n    path = find_path(u, v, tree)\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy += max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]),\n                      abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n    return energy\n\ndef update_segment_tree(segment_tree: List[int], index: int, value: int, start: int, end: int, node: int) -> None:\n    \"\"\"Update the segment tree for a change in illusion rate.\"\"\"\n    if start == end:\n        segment_tree[node] = value\n    else:\n        mid = (start + end) // 2\n        if start <= index <= mid:\n            update_segment_tree(segment_tree, index, value, start, mid, 2 * node + 1)\n        else:\n            update_segment_tree(segment_tree, index, value, mid + 1, end, 2 * node + 2)\n        segment_tree[node] = max(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n\ndef find_path(u: int, v: int, tree: List[List[int]]) -> List[int]:\n    \"\"\"Find the path between two rooms using DFS.\"\"\"\n    path = []\n    visited = [False] * len(tree)\n    dfs(u, v, tree, visited, path)\n    return path\n\ndef dfs(current: int, target: int, tree: List[List[int]], visited: List[bool], path: List[int]) -> bool:\n    \"\"\"Depth First Search to find the path between two nodes.\"\"\"\n    visited[current] = True\n    path.append(current)\n    if current == target:\n        return True\n    for neighbor in tree[current]:\n        if not visited[neighbor]:\n            if dfs(neighbor, target, tree, visited, path):\n                return True\n    path.pop()\n    return False\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    segment_tree = [0] * (4 * n)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates, segment_tree)\n        elif query[0] == 2:\n            result = calculate_minimum_energy(query[1], query[2], illusion_rates, tree, segment_tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and range queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at the given index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], segment_tree: SegmentTree) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    # Perform DFS to find the path from u to v\n    path = []\n    visited = [False] * len(tree)\n    \n    def dfs(current: int, target: int, path: List[int]) -> bool:\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target, path):\n                    return True\n        path.pop()\n        return False\n    \n    dfs(u, v, path)\n    \n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates, segment_tree)\n        elif query[0] == 2:\n            result = calculate_min_energy(query[1], query[2], illusion_rates, tree, segment_tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    \"\"\"Class to represent the tree structure and handle queries.\"\"\"\n    \n    def __init__(self, n: int, a: List[int], edges: List[Tuple[int, int]]):\n        \"\"\"Initialize the tree with rooms, illusion rates, and tunnels.\"\"\"\n        self.n = n\n        self.a = a\n        self.edges = edges\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.energy = [0] * (n + 1)\n        self.build_tree()\n    \n    def build_tree(self):\n        \"\"\"Build adjacency list from edges and preprocess using DFS.\"\"\"\n        for u, v in self.edges:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.dfs(1, 0)\n    \n    def dfs(self, node: int, par: int):\n        \"\"\"Depth First Search to preprocess tree data.\"\"\"\n        self.parent[node] = par\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.depth[neighbor] = self.depth[node] + 1\n                self.energy[neighbor] = self.calculate_energy(node, neighbor)\n                self.dfs(neighbor, node)\n    \n    def calculate_energy(self, x: int, y: int) -> int:\n        \"\"\"Calculate energy required to travel between two rooms.\"\"\"\n        return max(abs(self.a[x - 1] + self.a[y - 1]), abs(self.a[x - 1] - self.a[y - 1]))\n    \n    def lca(self, u: int, v: int) -> int:\n        \"\"\"Find Lowest Common Ancestor of two nodes.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n    \n    def path_energy(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy required to travel from u to v.\"\"\"\n        lca_node = self.lca(u, v)\n        energy_sum = 0\n        while u != lca_node:\n            energy_sum += self.energy[u]\n            u = self.parent[u]\n        while v != lca_node:\n            energy_sum += self.energy[v]\n            v = self.parent[v]\n        return energy_sum\n    \n    def update_illusion_rate(self, u: int, c: int):\n        \"\"\"Update the illusion rate of a room.\"\"\"\n        self.a[u - 1] = c\n        self.dfs(u, self.parent[u])  # Recalculate energies from updated node\n\ndef process_queries(n: int, q: int, a: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Process the queries and return results for type 2 queries.\"\"\"\n    tree = Tree(n, a, edges)\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update illusion rate\n            u, c = query[1], query[2]\n            tree.update_illusion_rate(u, c)\n        elif query[0] == 2:\n            # Calculate minimum energy\n            u, v = query[1], query[2]\n            results.append(tree.path_energy(u, v))\n    return results\n\n# Input interface\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process the queries\nresults = process_queries(n, q, a, edges, queries)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]) -> None:\n    \"\"\"Performs Depth First Search to establish parent-child relationships and calculate depths.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            parent_list[neighbor] = node\n            depth[neighbor] = depth[node] + 1\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth: List[int]) -> int:\n    \"\"\"Calculates the energy required to travel from room u to room v.\"\"\"\n    ancestor = lca(u, v, parent_list, depth)\n    energy = 0\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent_list[u] - 1]),\n                      abs(illusion_rates[u - 1] - illusion_rates[parent_list[u] - 1]))\n        u = parent_list[u]\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v - 1] + illusion_rates[parent_list[v] - 1]),\n                      abs(illusion_rates[v - 1] - illusion_rates[parent_list[v] - 1]))\n        v = parent_list[v]\n    return energy\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(tree) - 1\n    parent_list = [-1] * (n + 1)\n    depth = [0] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_list)\n    return calculate_energy(u, v, illusion_rates, parent_list, depth)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            # Update query\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            # Calculate minimum energy query\n            result = calculate_minimum_energy(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The index of the room to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room index.\n        v (int): The destination room index.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representing the tree structure of rooms.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Use DFS to find the path from u to v\n    def dfs(current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        if current == target:\n            return True\n        visited[current] = True\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                path.append(neighbor)\n                if dfs(neighbor, target, visited, path):\n                    return True\n                path.pop()\n        return False\n\n    visited = [False] * (len(tree))\n    path = [u]\n    dfs(u, v, visited, path)\n\n    # Calculate the energy for the path found\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n\n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index + 3])\n        index += 3\n\n    for query in queries:\n        if query[0] == '1':\n            u = int(query[1])\n            c = int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling queries related to illusion rate changes and energy calculations in a tree-structured maze. The solution must be optimized for large datasets and ensure accurate energy computation.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Accurately compute energy requirements for each query.\n- Allow dynamic adjustment of room illusion rates.\n- Ensure the solution scales well with large tree structures.\n- Provide clear output for each type 2 query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths and energies, while the LCA will allow us to quickly find the path between any two nodes. We will also use a Segment Tree to handle the dynamic updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes.\n    'illusion rate': This is a value associated with each room that affects the energy required to travel between rooms.\n    'energy': The energy required to travel between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute sum and absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'minimum': In the context of the queries, it refers to finding the least amount of energy required to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest value.\n\n# [code logic]\n    1. Preprocess the tree using DFS to calculate paths and energies.\n    2. Use LCA to efficiently find paths between nodes for type 2 queries.\n    3. Implement a Segment Tree to handle dynamic updates of illusion rates for type 1 queries.\n    4. For each type 2 query, calculate the energy required for the path using the preprocessed data and return the minimum energy.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Output: 3000000000\n    Explanation: The initial path requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 energy for the first tunnel and max(|-1000000000 + 1000000000|, |-1000000000 - 1000000000|) = 1000000000 for the second tunnel.\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 3 -10\n           2 1 4\n    Output: 15\n            Explanation: Initially, each tunnel requires max(|-5 + (-5)|, |-5 - (-5)|) = 10 energy. After updating room 3's illusion rate to -10, the energy for the second tunnel becomes max(|-10 + (-5)|, |-10 - (-5)|) = 15.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle all cases including edge cases.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries on a tree structure representing a maze. The key challenge is to optimize the calculation of energy required to travel between rooms, considering dynamic updates to the illusion rates. The solution must be scalable and maintain performance even with the maximum constraints.\nrequirement pool:\n- Implement efficient pathfinding algorithm to handle type 2 queries.\n- Optimize data structures to support quick updates for type 1 queries.\n- Ensure the solution can handle the maximum input size without performance issues.\n- Provide clear and concise output for each query.\n- Develop a user-friendly interface for input and output operations.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle type 2 queries. For type 1 queries, we will use a simple update mechanism to change the illusion rate of a room. The DFS will help in precomputing necessary data for quick pathfinding, while LCA will allow us to find the path between any two nodes efficiently. We will use the 'networkx' library for handling tree structures and paths.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be altered by type 1 queries.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Precompute necessary data using DFS for efficient pathfinding and LCA computation.\n3. For type 1 queries, update the illusion rate of the specified room.\n4. For type 2 queries, use LCA to find the path between two rooms and calculate the minimum energy required using the precomputed data.\n5. Output the result for each type 2 query.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected output: \n       ```\n       10\n       ```\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected output:\n       ```\n       0\n       ```\n       Explanation: Since all illusion rates are zero, any path will have zero energy cost.\n\n    3. Large illusion rate change:\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected output:\n       ```\n       2000000000\n       ```\n       Explanation: After changing the illusion rate of room 1, the path from room 1 to room 3 has an energy cost of max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic should handle them correctly as long as it accounts for updating illusion rates and calculating energy based on current values.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries on a tree structure representing a maze. The main challenge is to optimize the pathfinding and update operations to ensure quick responses. The solution must handle dynamic changes in the illusion rates and compute the minimum energy required for traversal efficiently.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Optimize pathfinding between rooms in a tree structure.\n- Allow dynamic updates to room illusion rates.\n- Ensure the solution scales with the maximum constraints.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the pathfinding queries in the tree structure. For dynamic updates of the illusion rates, we will maintain an array to store the current illusion rates and update it as needed. The DFS will help in precomputing necessary information for LCA, and the LCA will allow us to quickly find the path between any two nodes. We will use a Segment Tree to handle the updates and queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes.\n    'illusion rate': This is a value associated with each room that affects the energy required to travel between rooms.\n    'energy': The energy required to travel between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute sum and the absolute difference of their illusion rates. In code, this can be implemented using the max function and abs function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'minimum': In the context of the queries, it refers to finding the least sum of energy needed to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Precompute necessary information using DFS for LCA.\n    4. Implement a Segment Tree to handle dynamic updates of illusion rates.\n    5. For type 2 queries, use LCA to find the path between rooms and calculate the minimum energy required.\n    6. For type 1 queries, update the illusion rate in the Segment Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 20\n    Explanation: The path is from room 1 to room 2 (energy = max(|10 + (-10)|, |10 - (-10)|) = 20) and then room 2 to room 3 (energy = max(|-10 + 10|, |-10 - 10|) = 20). Total energy = 20.\n\n    Input: 4 1\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 0\n    Explanation: All rooms have the same illusion rate, so each step requires max(|-5 + (-5)|, |-5 - (-5)|) = max(10, 0) = 10. However, since all are equal, the minimum path energy is effectively zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and LCA will correctly compute the minimum energy required for any valid input configuration.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to illusion rate changes and energy calculations in a tree-structured maze. The solution must be optimized for large inputs and provide accurate results quickly. The user interface should be intuitive, ensuring users can easily input queries and understand outputs.\nrequirement pool:\n- Efficiently handle type 1 queries to update illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Optimize performance for large input sizes.\n- Ensure output format is clear and concise.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to find paths between rooms, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures that both types of queries are handled in logarithmic time complexity, which is optimal for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected graph with no cycles, ensuring a unique path between any two nodes (rooms).\n    'illusion rate': A value associated with each room that affects the energy calculation for traveling between rooms.\n    'energy': The cost to travel between two rooms, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum sum of energy': This means finding the least possible total energy required to travel from one room to another. In code, this involves finding the path with the least energy cost using algorithms like DFS or Dijkstra's algorithm.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Use DFS to preprocess the tree for efficient path queries (e.g., using LCA - Lowest Common Ancestor).\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, calculate the minimum energy required to travel from room u to room v using preprocessed data and current illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms: Input with n = 2 and q = 1, e.g., `2 1\\n0 0\\n1 2\\n2 1 2` = 0\n       Explanation: With only two rooms and zero illusion rates, the energy required is zero.\n    2. Maximum illusion rate change: Input with a large change in illusion rate, e.g., `3 2\\n0 0 0\\n1 2\\n2 3\\n1 1 1000000000\\n2 1 3` = 1000000000\n       Explanation: The change in illusion rate significantly affects the energy calculation.\n    3. All rooms with zero illusion rate: Input where all rooms start with zero illusion rate, e.g., `4 1\\n0 0 0 0\\n1 2\\n2 3\\n3 4\\n2 1 4` = 0\n       Explanation: With all rooms having zero illusion rates, any path will have zero energy cost.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree will naturally handle these scenarios by ensuring correct path calculations and updates.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating energy costs between rooms. The solution must be optimized for large inputs and ensure accurate calculations.\nrequirement pool:\n- Efficiently handle type 1 queries to change illusion rates\n- Accurately calculate energy costs for type 2 queries\n- Optimize the solution for large datasets\n- Ensure the solution is scalable\n- Provide clear output for each query\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths and the LCA will be used to find the minimum energy path between any two rooms. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between rooms via tunnels.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between rooms is calculated using the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to travel between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function combined with `abs`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves calculating the energy for each path and selecting the smallest value.\n\n# [code logic]\n    1. Preprocess the tree using Depth First Search (DFS) to establish paths and calculate necessary data for Lowest Common Ancestor (LCA).\n    2. Implement LCA to efficiently find paths between any two rooms.\n    3. Use a Segment Tree to handle updates to illusion rates efficiently.\n    4. For type 2 queries, calculate the energy required for each path using the formula `max(|a_x + a_y|, |a_x - a_y|)` and find the minimum sum of energy.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 3000000000\n    Explanation: The energy required is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 for the first tunnel and max(|-1000000000 + 1000000000|, |-1000000000 - 1000000000|) = 1000000000 for the second tunnel.\n\n    Input: 4 1\n           -1 -1 -1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 6\n    Explanation: The energy required is max(|-1 + (-1)|, |-1 - (-1)|) = 2 for each tunnel, totaling to 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle these scenarios.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must be optimized for large input sizes and ensure accurate calculations.\nrequirement pool:\n- Efficiently handle type 1 queries to change illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Optimize the solution for large input sizes.\n- Ensure the solution is scalable and responsive.\n- Provide clear output format for energy calculations.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary information for LCA, which will then be used to compute the minimum energy path efficiently. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy required to travel between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of the queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest one.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Use Depth First Search (DFS) to preprocess the tree and calculate necessary information for Lowest Common Ancestor (LCA).\n3. Implement a Segment Tree to handle updates to the illusion rates efficiently.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate using the Segment Tree.\n   - If it's a type 2 query, use LCA to find the path between two rooms and calculate the minimum energy required using preprocessed information.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, any path will have zero energy cost.\n\n    3. Maximum possible illusion rate change:\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected Output: 2000000000\n       Explanation: After changing the illusion rate of room 1, the path from room 1 to room 3 will have an energy cost of max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS, LCA, and Segment Tree should be sufficient to handle these scenarios efficiently.\n", "requirement analysis:\nThe project requires handling a tree structure representing rooms and tunnels, with efficient updates and queries on illusion rates. The main challenge is optimizing the calculation of energy required for travel between rooms, especially given the constraints on the number of rooms and queries.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy required for travel between rooms.\n- Optimize performance for large datasets.\n- Ensure the solution is scalable and maintainable.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle updates and queries on the tree structure representing rooms and tunnels. DFS will help in traversing the tree and calculating paths, while the Segment Tree will allow for efficient updates and range queries on the illusion rates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it has a hierarchical structure with rooms connected by tunnels, ensuring connectivity without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one to update the illusion rate of a room and another to calculate the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to travel between two rooms, using the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves calculating the path with the least energy consumption.\n\n# [code logic]\n    1. Parse the input to construct the tree structure with rooms and tunnels.\n    2. Use DFS to traverse the tree and calculate paths between rooms.\n    3. Implement a Segment Tree to efficiently handle updates to illusion rates and range queries.\n    4. For type 1 queries, update the illusion rate of the specified room.\n    5. For type 2 queries, calculate the minimum energy required using DFS and Segment Tree operations.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so no energy is required to travel between them.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Expected Output: 2000000000\n    Explanation: The initial path requires maximum energy due to extreme illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle these scenarios by considering all possible paths and updates.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries related to updating room illusion rates and calculating the minimum energy required for travel between rooms. The solution must be optimized for performance given the constraints on the number of rooms and queries. The tree structure of the maze should be leveraged to ensure efficient pathfinding and energy calculation.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Optimize energy calculation between rooms.\n- Allow dynamic updates to room illusion rates.\n- Ensure the solution scales with the maximum number of rooms.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths and energies, while the LCA will allow us to quickly find the path between any two nodes. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it has n rooms and n-1 tunnels, ensuring connectivity without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the max function and abs function in Python.\n\n# [degree adverb]\n    'minimum': In the context of the queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This involves calculating the path with the least energy cost using techniques like DFS and LCA.\n\n# [code logic]\n    1. Preprocess the tree using DFS to calculate paths and energies.\n    2. Use LCA to efficiently find paths between any two nodes.\n    3. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    4. For type 2 queries, calculate the minimum energy required using preprocessed data and LCA.\n    5. For type 1 queries, update the illusion rate using the Segment Tree.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, the energy required is zero regardless of the path.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate of room 1, the energy calculation becomes max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle these scenarios.\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations for pathfinding. The tree structure of the maze should be leveraged for optimal traversal and query processing.\nrequirement pool:\n- Efficiently process type 1 queries to update illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Ensure scalability for large input sizes.\n- Optimize data structures for quick access and updates.\n- Provide clear output format for query results.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the minimum energy path between two nodes. We will use a Segment Tree or Binary Indexed Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be altered by queries, impacting the calculation of energy needed for traversal.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, which allows for efficient traversal and query processing using tree algorithms like DFS and LCA.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy calculation for traveling between two rooms. It requires finding the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'minimum'\n    Explanation: In the context of type 2 queries, it refers to finding the least amount of energy required to travel from one room to another. This involves calculating the path with the lowest energy cost using tree traversal techniques.\n\n# [code logic]\n    1. Preprocess the tree using DFS to establish parent-child relationships and calculate initial paths.\n    2. Use LCA to efficiently find paths between any two rooms for type 2 queries.\n    3. Implement a Segment Tree or Binary Indexed Tree to handle updates to illusion rates for type 1 queries.\n    4. For each type 2 query, calculate the energy required using the preprocessed data and update structures.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Output: 3000000000\n    Explanation: The initial path requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 energy from room 1 to room 2, and max(|-1000000000 + 1000000000|, |-1000000000 - 1000000000|) = 1000000000 energy from room 2 to room 3.\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 3 -10\n           2 1 4\n    Output: \n    Explanation: Initially, each step requires max(|-5 + (-5)|, |-5 - (-5)|) = max(10,0) =10 energy. After updating room 3's illusion rate, the energy calculation changes accordingly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will efficiently handle these scenarios by recalculating paths and updating rates as needed.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must be optimized for large datasets and ensure accurate energy calculations.\nrequirement pool:\n- Efficiently handle type 1 queries to update illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Optimize data structures for large input sizes.\n- Ensure the solution scales well with increasing number of queries.\n- Provide clear output format for energy calculations.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path energy efficiently. We will utilize Segment Trees to handle updates and queries efficiently. This approach ensures that both types of queries are handled in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy required to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of the second type of query, it refers to finding the path with the least total energy cost from room u to room v. This can be implemented using algorithms that find the shortest path, such as Dijkstra's algorithm, adapted for this specific energy calculation.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Use Depth First Search (DFS) to preprocess the tree and calculate necessary data for efficient path queries.\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates and efficiently process queries.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, calculate the minimum energy path from room u to room v using preprocessed data and efficient querying.\n\n# [edge case]\n    1. Single path tree (e.g., 1-2-3-4) with alternating high and low illusion rates.\n       Explanation: This tests if the algorithm correctly calculates energy over a simple linear path with varying rates.\n    2. All rooms have zero illusion rate initially.\n       Explanation: The energy for any path should be zero, testing if the algorithm handles zero values correctly.\n    3. Maximum possible illusion rate change (e.g., from 0 to 10^9).\n       Explanation: This tests if the algorithm can handle large updates without overflow or performance issues.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large updates and zero values.\n    - Ensure that updates to illusion rates are handled efficiently in logarithmic time.\n    - Implement checks for zero values in energy calculations to avoid unnecessary computations.\n\n```python\ndef update_illusion_rate(segment_tree, index, new_value):\n    # Update logic for segment tree\n    pass\n\ndef calculate_minimum_energy_path(tree, start, end):\n    # Use preprocessed data to calculate minimum energy path\n    pass\n\n# Example usage:\n# update_illusion_rate(segment_tree, room_index, new_illusion_rate)\n# min_energy = calculate_minimum_energy_path(tree, start_room, end_room)\n```\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 778, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "condense_two2one", "parent_index": 315}
