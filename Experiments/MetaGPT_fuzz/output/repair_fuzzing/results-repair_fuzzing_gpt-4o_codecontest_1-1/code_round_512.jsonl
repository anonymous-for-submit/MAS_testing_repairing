{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect. This means that the current poison effect is canceled and a new one is applied.\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon, and the battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger, with each attack occurring at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start; the dagger itself does not deal damage but applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds and begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one). For example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage. Monocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to slay the dragon.\n            - attacks: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    def calculate_damage(k: int, attacks: List[int]) -> int:\n        \"\"\"Calculate the total damage dealt with a given poison duration k.\n\n        Args:\n            k: Duration of the poison effect.\n            attacks: List of attack times.\n\n        Returns:\n            Total damage dealt.\n        \"\"\"\n        total_damage = 0\n        n = len(attacks)\n        \n        for i in range(n):\n            if i == n - 1:\n                total_damage += k\n            else:\n                total_damage += min(k, attacks[i + 1] - attacks[i])\n        \n        return total_damage\n\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(mid, attacks) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    test_cases.append((n, h, attacks))\n\n# Output interface\nresults = minimum_poison_duration(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\"\"\"\n    \n    def calculate_damage(k: int, attack_times: List[int]) -> int:\n        \"\"\"Calculate the total damage dealt with a given poison duration k.\"\"\"\n        total_damage = 0\n        n = len(attack_times)\n        \n        for i in range(n - 1):\n            # Calculate the damage for each interval between attacks\n            total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        \n        # Add damage for the last attack\n        total_damage += k\n        \n        return total_damage\n    \n    results = []\n    \n    for n, h, attack_times in test_cases:\n        # Binary search to find the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(mid, attack_times) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, h, a))\n\n# Output interface\nresults = minimum_poison_duration(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, 10**18  # Set a large upper bound for k\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to inflict at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # Initial bounds for k\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attack_times = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Hit points of the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, 10**18  # high is set to a large number to ensure it covers all possible k values\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid  # Try smaller k\n            else:\n                low = mid + 1  # Need larger k\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        low, high = 1, 10**9  # Initialize binary search bounds\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement involves calculating the minimum duration of poison effect needed to deal sufficient damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for performance\n- Verify the output format for each test case\n- Document the solution approach and edge cases\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be applied on the range of possible k values, and for each k, we will simulate the damage dealt to the dragon by iterating over the attack times and calculating the total damage. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. It lasts for k seconds and deals 1 damage per second. If a new attack occurs, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Simulate the damage dealt with k = mid:\n            - Initialize total_damage = 0.\n            - Iterate over attack times and calculate damage intervals.\n            - Accumulate damage for each interval.\n        c. If total_damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (try larger k).\n    3. Return low as the minimum k that satisfies the condition.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value of k\n    Explanation: The dragon has a very high hit point requirement, necessitating a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 5\n    Explanation: The attacks are spaced far apart, requiring k to be at least 5 to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying scenarios by adjusting k based on the accumulated damage.\n", "requirement analysis:\nThe problem requires determining the minimum duration of a poison effect that ensures the dragon receives at least h damage. The solution must efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and requiring calculations with large numbers.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum poison duration\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for performance\n- Provide clear and concise output for each test case\n- Include comprehensive test cases to validate the solution\nWe will use a binary search approach to efficiently determine the minimum poison duration k. The key observation is that the damage dealt by the poison can be calculated by considering the intervals between attacks and the duration of the poison effect. By simulating the damage calculation for different values of k using binary search, we can find the smallest k that results in at least h damage.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the poison duration ends, the poison effect is reset.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the minimum value of k by repeatedly dividing the range of possible values in half and checking if the current value of k is sufficient to deal at least h damage.\n\n# [phrase showing quantity relationship]\n    'smallest possible value of k': We need to find the minimum duration of the poison effect that results in at least h damage.\n    Implementation: Use binary search to find the smallest k.\n\n# [degree adverb]\n    'at least': The damage dealt must be greater than or equal to h.\n    Implementation: Ensure that the calculated damage for a given k meets or exceeds h.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, retrieve n, h, and the list of attack times.\n2. Implement a function to calculate the total damage for a given k by iterating through attack times and summing up the effective poison durations.\n3. Use binary search to find the minimum k that results in at least h damage:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - Calculate mid-point k and check if it results in sufficient damage.\n   - Adjust bounds based on whether the current k is sufficient or not.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with attacks at consecutive seconds:\n    Input: 2 2\n           1 2\n    Expected output: 1\n    Explanation: With k=1, damage is dealt in seconds [1, 2], which is sufficient.\n\n    Test case with maximum h:\n    Input: 1 10^18\n           1\n    Expected output: 10^18\n    Explanation: Only one attack, so k must be equal to h to deal sufficient damage.\n\n    Test case with attacks spaced far apart:\n    Input: 3 5\n           1 1000 2000\n    Expected output: 5\n    Explanation: Each attack resets the poison effect, so k must be at least 5 to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently considers all possible values of k and finds the minimum that meets the requirement.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given the sequence of attack times. The solution must efficiently handle large input sizes and ensure the output format is consistent with the requirements.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure output format matches requirements\n- Optimize for large input constraints\n- Test solution against multiple test cases\n- Document the solution approach\nWe will implement a binary search algorithm to efficiently find the minimum value of k. The key observation is that the damage dealt by the poison can be calculated by considering the intervals between attacks and the duration of the poison effect. By using binary search, we can determine the smallest k that satisfies the damage requirement.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the poison effect from a previous attack has expired, the poison effect is reset.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the minimum value of k by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'smallest possible value of k': We need to find the minimum k such that the total damage is at least h.\n    Implementation: Use binary search to find the smallest k that satisfies the condition.\n\n# [degree adverb]\n    'at least': The damage dealt must be greater than or equal to h.\n    Implementation: Ensure that the calculated damage for a given k meets or exceeds h.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, get n, h, and the list of attack times.\n2. Implement a function to calculate the total damage for a given k.\n3. Use binary search to find the minimum k such that the total damage is at least h.\n4. For each test case, output the result.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient to deal at least 1 damage.\n\n    Test case with attacks spaced far apart:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: Each attack can deal 1 damage independently, so k = 1 is sufficient.\n\n    Test case with maximum h:\n    2 1000000000000000000\n    1 1000000000\n    Expected output: Large value (depends on implementation)\n    Explanation: Requires a large k to accumulate enough damage over few attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by finding the minimum k that satisfies the condition for all test cases.\n", "requirement analysis:\nThe requirements focus on determining the minimum value of k for Monocarp to deal sufficient damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring the output format is consistent with the examples provided.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure output format matches the example\n- Optimize for large input sizes\n- Provide clear documentation of the logic\n- Test thoroughly with edge cases\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. This approach is suitable for handling large input sizes and ensures the solution is scalable. We will use Python's built-in capabilities to manage large integers and perform calculations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the previous poison effect ends, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: The task is to find the smallest duration k for which the total damage dealt by the poison effect is at least h, the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This means we need to ensure that the sum of damage over all poisoned seconds meets or exceeds h.\n\n# [degree adverb]\n    'smallest possible value of k'\n    Explanation: We need to find the minimum k such that the total damage is at least h. This involves optimizing k to be as small as possible while still achieving the required damage.\n\n# [code logic]\n    1. Initialize binary search bounds for k, with low = 1 and high = h.\n    2. For each test case, perform binary search:\n        - Calculate mid = (low + high) // 2.\n        - Simulate the damage calculation with current mid as k.\n        - If total damage >= h, update high = mid.\n        - Otherwise, update low = mid + 1.\n    3. After binary search completes, low will be the minimum k that satisfies the condition.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and needing only 1 damage, k can be 1.\n    \n    Test case: 2 1\n    Explanation: With two attacks and needing only 1 damage, k can be 1 since each attack resets the poison effect.\n    \n    Test case: 100 10^18\n    Explanation: With maximum attacks and maximum damage needed, k will be large but should be calculated efficiently using binary search.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles all cases by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect needed to deal at least h damage to the dragon, considering the sequence of attacks. The solution must efficiently handle large numbers and multiple test cases.\nrequirement pool:\n- Calculate minimum poison duration for each test case\n- Optimize for large input sizes\n- Ensure accurate damage calculation\n- Provide clear output format\n- Handle edge cases effectively\nWe will use a binary search approach to efficiently find the minimum value of k that satisfies the condition of dealing at least h damage to the dragon. This approach is suitable given the constraints on the input size and the need for optimization. We will leverage Python's built-in capabilities for handling large integers and efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp stabs the dragon. It deals 1 damage for each of the next k seconds. If a new stab occurs before the previous poison effect ends, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: This can be checked by summing up the damage over the effective seconds and comparing it to h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: This can be achieved using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage for each segment.\n     - If the current attack time plus k exceeds the next attack time, adjust the damage calculation.\n   - If total damage is at least h, adjust the upper bound of binary search; otherwise, adjust the lower bound.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Attack times: 1\n    Minimum k = 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal any damage.\n\n    Test case: 2 2\n    Attack times: 1 3\n    Minimum k = 1\n    Explanation: Each attack deals 1 damage, so with two attacks, k = 1 is sufficient.\n\n    Test case: 3 10\n    Attack times: 1 2 3\n    Minimum k = 4\n    Explanation: With attacks at consecutive seconds, k must be at least 4 to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting bounds based on total damage calculations.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of poison effect needed to inflict at least h damage to the dragon, considering the sequence of attacks. The solution must efficiently handle large input sizes and provide accurate results for each test case.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum poison duration\n- Ensure solution handles large input constraints\n- Optimize performance for multiple test cases\n- Provide clear output format\n- Include detailed comments for code clarity\nWe will implement a binary search algorithm to efficiently determine the minimum poison duration (k) required to inflict at least h damage to the dragon. This approach is chosen due to its ability to handle large input sizes and constraints effectively. We will utilize Python's built-in capabilities for handling large integers and ensure the solution is optimized for performance across multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp stabs the dragon, dealing 1 damage for each of the next k seconds. If a new stab occurs before the current poison effect ends, the effect is reset, starting a new k-second duration.\n\n    'minimum value of k'\n    Explanation: The smallest duration for which the poison effect must last to ensure that the total damage dealt is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt to the dragon must be greater than or equal to h. This can be implemented by ensuring the sum of all damage over the battle duration meets or exceeds h.\n\n# [degree adverb]\n    'smallest possible value'\n    Explanation: We need to find the minimum k such that the total damage is at least h. This can be implemented using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Implement a binary search for k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage intervals.\n     - If the next attack occurs before the current poison effect ends, adjust the damage calculation.\n   - If total damage is at least h, adjust the upper bound of k.\n   - Otherwise, adjust the lower bound.\n5. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 2, h = 2, a = [1, 1000000000] = 2\n    Explanation: With two attacks far apart, each attack needs to deal at least 1 damage, so k = 1 is sufficient.\n\n    Case 3: n = 100, h = 10000, a = [1, 2, ..., 100] = 100\n    Explanation: With attacks every second and needing a large amount of damage, k must be large enough to accumulate sufficient damage over all attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total calculated damage.\n", "requirement analysis:\nThe game requires a strategic approach to determine the optimal poison duration (k) to defeat the dragon. The solution must efficiently calculate the minimum k for each test case, ensuring the dragon receives at least h damage. The algorithm should handle large input sizes and provide accurate results quickly.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Optimize the algorithm for performance\n- Ensure the game logic is clear and understandable\n- Provide feedback to the player on their strategy\n- Test the game across different devices for performance\nWe will implement a function to calculate the minimum poison duration (k) required to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the total damage dealt for different values of k. We will use binary search to efficiently find the minimum k, ensuring the solution is scalable and performs well even with large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for k seconds starting from the second of the attack. If another attack occurs before the current poison effect ends, the poison effect is reset to start from the new attack time.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Ensure that the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage interval and add to total_damage.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n5. Output low as the minimum k for each test case.\n\n# [edge case]\n    Test case 1: \n    Input: 1 1\n           1\n    Output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal the required damage.\n\n    Test case 2:\n    Input: 2 2\n           1 3\n    Output: 1\n    Explanation: Two attacks at seconds 1 and 3 with h = 2 can be satisfied with k = 1, as each attack deals exactly 1 damage.\n\n    Test case 3:\n    Input: 3 5\n           1 2 3\n    Output: 2\n    Explanation: With attacks at seconds 1, 2, and 3, k = 2 is needed to ensure at least 5 damage is dealt.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum duration k for which the poison effect must last to inflict at least h damage on the dragon. The solution must efficiently handle up to 1000 test cases with large values for n and h, ensuring that the algorithm is both time and space efficient.\nrequirement pool:\n- Develop an efficient algorithm to calculate the minimum k\n- Ensure the solution handles large input sizes effectively\n- Optimize the algorithm for edge cases\n- Provide clear documentation and comments in the code\n- Implement additional test cases for validation\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. This approach is suitable for handling large input sizes and ensures that the solution is both time and space efficient. We will use Python's built-in capabilities without additional frameworks, focusing on optimizing the logic for edge cases and large values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second.\n\n    'minimum value of k'\n    Explanation: The task is to find the smallest duration k for which the total damage dealt by the poison effect is at least h, the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This means we need to ensure that the sum of damage over all poisoned seconds meets or exceeds h.\n\n# [degree adverb]\n    'smallest possible value'\n    Explanation: We need to find the minimum k such that the condition of dealing at least h damage is satisfied. This involves optimizing k to be as small as possible while still achieving the required damage.\n\n# [code logic]\n    1. Implement a binary search to find the minimum k.\n    2. For each test case, initialize low and high bounds for k.\n    3. Calculate the total damage for a given k using the attack times.\n    4. Adjust the bounds based on whether the calculated damage meets or exceeds h.\n    5. Return the smallest k that satisfies the condition.\n\n# [edge case]\n    Test case with minimum attacks and maximum h:\n    1 10^18\n    1\n    Explanation: With only one attack, k must be equal to h to deal enough damage, so expected output is 10^18.\n\n    Test case with attacks spaced far apart:\n    2 5\n    1 1000000000\n    Explanation: The attacks are spaced far apart, requiring a large k to cover the gap, expected output is 5.\n\n    Test case with attacks close together:\n    3 3\n    1 2 3\n    Explanation: Attacks are close together, allowing a small k to suffice, expected output is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on calculated damage.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring that the poison effect is applied optimally based on the attack sequence.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Optimize the solution for large input sizes\n- Ensure the solution handles edge cases\n- Provide detailed documentation and comments\n- Create a user-friendly interface for input and output\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be used to find the smallest k such that the total damage dealt is at least h. This approach is chosen because it allows us to efficiently handle the large input sizes and constraints provided in the problem. We will simulate the damage calculation for each potential k value and adjust our search range based on whether the damage meets or exceeds h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for k seconds starting from the second of the attack. If another attack occurs before the poison effect ends, the effect is reset.\n\n    'minimum value of k'\n    Explanation: The smallest duration for which the poison effect must last to ensure that the total damage is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Check if the calculated damage for a given k is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the attack times.\n3. Initialize binary search bounds for k (e.g., low = 1, high = maximum possible k).\n4. Perform binary search:\n   - Calculate mid as the average of low and high.\n   - Simulate the total damage for k = mid:\n     - Initialize total_damage to 0.\n     - For each attack time, calculate the damage interval considering overlaps.\n     - Accumulate the damage.\n   - If total_damage >= h, update high to mid (try smaller k).\n   - Otherwise, update low to mid + 1 (need larger k).\n5. After binary search, low will be the minimum k that satisfies the condition.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case: 1 1\n               1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal any damage.\n\n    Test case: 2 2\n               1 2\n    Expected output: 1\n    Explanation: Two attacks at consecutive seconds can deal 2 damage with k = 1.\n\n    Test case: 3 5\n               1 3 5\n    Expected output: 2\n    Explanation: With attacks at seconds 1, 3, and 5, k = 2 is needed to cover all intervals without gaps.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on whether the accumulated damage meets or exceeds h.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage dealt to the dragon is at least h. The solution must efficiently handle up to 1000 test cases with large constraints on n, h, and a_i values.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k value.\n- Optimize the solution for large input sizes and constraints.\n- Ensure the solution is tested against a variety of test cases.\n- Provide clear documentation and comments within the code.\n- Consider edge cases and potential optimizations.\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by iterating over the attack times and checking the overlap of poison effects. By using binary search on k, we can find the smallest k that results in at least h damage. This approach is efficient and works well within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the previous poison effect ends, the poison effect is reset.\n\n    'binary search'\n    Explanation: Binary search is a method used to efficiently find the minimum value of k by narrowing down the possible values based on whether the current k can deal at least h damage.\n\n# [phrase showing quantity relationship]\n    'smallest possible value of k': We need to find the minimum k such that the total damage is at least h.\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition of dealing at least h damage.\n\n# [code logic]\n    1. Initialize variables for binary search: low = 1, high = maximum possible k (e.g., 10^9).\n    2. Perform binary search:\n        - Calculate mid = (low + high) // 2.\n        - Calculate total damage for current mid value of k.\n        - If total damage >= h, update high = mid.\n        - Otherwise, update low = mid + 1.\n    3. Return low as the minimum k that deals at least h damage.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and needing to deal 1 damage, k must be at least 1.\n    \n    Test case: 2 1\n    Explanation: With two attacks and needing to deal only 1 damage, k can be as small as 1 since each attack resets the poison effect.\n    \n    Test case: 100 10^18\n    Explanation: With maximum constraints, we need to ensure that our binary search efficiently finds the correct k without exceeding time limits.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these cases by checking if the current k can deal at least h damage.\n"], "scores": [], "pass_results": [true, true, false, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 512, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "expand_one2two", "parent_index": 328}
