{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation, where the array is partitioned into two stable parts using x = a_n, with the left part containing elements not greater than x (\u2264 x) and the right part containing elements strictly greater than x (> x), and then replaced with the concatenation of these parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation, where the array is partitioned into two stable parts using x = a_n, with the left part containing elements not greater than x (\u2264 x) and the right part containing elements strictly greater than x (> x), and then replaced with the concatenation of these parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n.\n\nLet's define the eversion operation. The array is partitioned into two stable parts using x = a_n. The left part contains elements not greater than x (\u2264 x) and the right part contains elements strictly greater than x (> x). The array is then replaced with the concatenation of these parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n.\n\nLet's define the eversion operation, where the array is partitioned into two stable parts using x = a_n, combining the left part with elements not greater than x (\u2264 x) and the right part with elements strictly greater than x (> x), and then replaced with the concatenation of these parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    until the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        eversion_count = 0\n        \n        while True:\n            x = a[-1]  # Last element of the array\n            left_part = [num for num in a if num <= x]\n            right_part = [num for num in a if num > x]\n            new_a = left_part + right_part\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        max_so_far = float('-inf')\n        eversion_count = 0\n        \n        # Iterate from the end to the start of the array\n        for num in reversed(case):\n            if num > max_so_far:\n                max_so_far = num\n                eversion_count += 1\n        \n        # Subtract 1 because the last increment does not result in a change\n        results.append(eversion_count - 1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing an array of integers.\n\n    Returns:\n        A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the result\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions\n        for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef eversion_count(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        current_array = case[:]\n        eversion_count = 0\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = eversion_count(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        max_so_far = float('-inf')\n        eversion_count = 0\n        \n        # Iterate from the end to the start of the array\n        for num in reversed(case):\n            if num > max_so_far:\n                max_so_far = num\n                eversion_count += 1\n        \n        # Subtract 1 because the last eversion doesn't change the array\n        results.append(eversion_count - 1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\ndef min_eversions(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        list: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        eversion_count = 0\n        while True:\n            pivot = a[-1]\n            left_part = [x for x in a if x <= pivot]\n            right_part = [x for x in a if x > pivot]\n            new_array = left_part + right_part\n\n            if new_array == a:\n                break\n\n            a = new_array\n            eversion_count += 1\n\n        results.append(eversion_count)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Initialize list to store test cases\n    test_cases = []\n    for _ in range(t):\n        # Read the length of the array\n        n = int(input())\n        # Read the array elements\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Call the function and store the result\n    results = min_eversions(t, test_cases)\n\n    # Output the results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        current_array = case[:]\n        eversion_count = 0\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    until the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        current_array = case[:]\n        eversion_count = 0\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to implement an algorithm that performs eversions on an array until it stabilizes. The key challenge is to efficiently handle large input sizes while ensuring the output format is adhered to. The algorithm should be optimized for performance and clarity.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the algorithm handles multiple test cases efficiently.\n- Optimize the code for performance with large datasets.\n- Provide clear and concise output for each test case.\n- Maintain readability and simplicity in the code implementation.\nWe will implement an algorithm that performs the eversion operation on an array until it stabilizes. The key is to efficiently partition the array based on the last element and count the number of eversions required for stabilization. We will use a simple loop to perform the eversions and check for stabilization by comparing the array before and after each eversion. The algorithm will handle multiple test cases efficiently by iterating over each test case and processing them independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': means elements in the left part are less than or equal to the last element.\n    'strictly greater than (> x)': means elements in the right part are greater than the last element.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, read the array and initialize a counter for eversions.\n    2. Perform the eversion operation by partitioning the array based on the last element.\n    3. Concatenate the two parts to form a new array.\n    4. Compare the new array with the previous one to check for stabilization.\n    5. If the array changes, increment the counter and repeat; otherwise, record the counter as the result for that test case.\n    6. Output the results for all test cases.\n\n# [edge case]\n    Test case with all identical elements: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are identical, no eversion changes the array, so it stabilizes immediately.\n\n    Test case with already sorted array: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes it.\n\n    Test case with descending order: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion will move one element to its correct position until the array is sorted.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking stabilization after each eversion inherently handles these cases.\n", "requirement analysis:\nThe requirement involves performing a series of operations on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of operations needed for stabilization. The solution must handle large arrays and multiple test cases while ensuring accurate results.\nrequirement pool:\n- Implement the eversion operation correctly\n- Optimize the algorithm for large datasets\n- Ensure the solution handles edge cases\n- Provide clear output format\n- Document the code for maintainability\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered. The number of eversions required is determined by counting how many times we encounter a new maximum element as we iterate backwards. This approach ensures that we efficiently determine the stabilization point of the array with minimal computational complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x, where the left part contains elements not greater than x and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to x.\n    'strictly greater than': means elements in the right part are greater than x.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Iterate over the array from the end to the start.\n    3. Keep track of the maximum element encountered during iteration.\n    4. Count how many times a new maximum element is encountered.\n    5. The counter will represent the number of eversions needed for stabilization.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition value, so no eversion is needed.\n    \n    Input: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by counting new maximums encountered during backward iteration.\n", "requirement analysis:\nThe requirement is to determine the minimum number of eversions needed for an array to stop changing. The solution must efficiently handle multiple test cases and large input sizes, ensuring the output format is consistent and correct.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles the maximum input size efficiently\n- Optimize the algorithm for performance\n- Provide clear documentation and comments in the code\n- Include edge case handling and testing\nWe will implement a function to perform the eversion operation on an array. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. We will repeat this process until the array stops changing. The solution will efficiently handle multiple test cases and large input sizes using Python's built-in list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, where the left part contains elements not greater than the last element, and the right part contains elements strictly greater than the last element. The array is then replaced with the concatenation of these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to the last element.\n    'strictly greater than': means elements in the right part are greater than the last element.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, read the array.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n        - Identify the last element of the array.\n        - Partition the array into two parts based on this element.\n        - Concatenate these parts to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it is different, increment the counter and repeat; otherwise, stop.\n    6. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so the expected output is 0.\n    \n    Test case with strictly increasing elements: [1, 2, 3, 4, 5] = 1\n    Explanation: After one eversion, all elements will be in the left part, and no further eversions will change the array.\n    \n    Test case with strictly decreasing elements: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion will move one element to the right part until only one element remains in the left part.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of eversions needed. The solution must handle multiple test cases and large input sizes within the given constraints.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm for performance with large input sizes.\n- Provide clear documentation and comments within the code.\n- Include test cases to validate the solution against edge cases.\nWe will implement a function to perform the eversion operation on an array until it stabilizes. The key is to partition the array based on the last element and count the number of eversions needed for the array to stop changing. We will use a simple loop to perform the eversions and check for stability. The solution will handle multiple test cases efficiently by iterating over each test case and applying the eversion logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': This means elements in the left part of the partition are less than or equal to x.\n    'strictly greater than (>)': This means elements in the right part of the partition are greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for eversions.\n3. Perform the eversion operation:\n   - Identify the last element of the array as x.\n   - Partition the array into two parts: elements \u2264 x and elements > x.\n   - Concatenate these parts to form a new array.\n4. Check if the new array is different from the previous one.\n5. If it is different, increment the counter and repeat the process.\n6. If it is not different, stop and record the counter value as k for that test case.\n7. Output k for each test case.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no change occurs after an eversion.\n", "requirement analysis:\nThe problem requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of eversions needed. The solution must handle large input sizes and multiple test cases within the given constraints.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the solution handles the maximum input size within time limits.\n- Optimize the algorithm to reduce computational complexity.\n- Provide detailed comments and documentation for clarity.\n- Include edge case handling and validation.\nWe will implement the eversion operation by iteratively partitioning the array based on the last element and concatenating the parts until the array stabilizes. The key is to efficiently determine when the array stops changing, which can be done by checking if the partitioning results in the same array as before. We will use Python's built-in list operations to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements \u2264 x\n    'strictly greater than': means elements > x\n\n# [degree adverb]\n    'minimum': means the smallest number of eversions needed for the array to stop changing\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n       - Identify the last element, x, of the array.\n       - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n       - Concatenate these parts to form a new array.\n    4. Check if the new array is the same as the previous one. If it is, stop; otherwise, increment the counter and repeat.\n    5. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Test case: [1, 2, 3, 4, 5] = 1\n    Explanation: The first eversion results in [1, 2, 3, 4], [5] \u2192 [1, 2, 3, 4, 5], which is already stable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no change occurs after an eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs eversions on an array until it stabilizes. The challenge lies in efficiently partitioning the array and determining the minimum number of eversions needed. The solution must handle up to 200,000 elements across multiple test cases, ensuring both performance and correctness.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles the maximum input size within time limits\n- Optimize the code for readability and maintainability\n- Provide detailed comments and documentation\n- Include edge case handling and testing\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The key is to efficiently partition the array based on the last element and count the number of eversions needed for stabilization. We will use a simple loop to perform the eversions and check for changes in the array. The solution will handle multiple test cases and ensure performance by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these parts.\n\n    'stabilizes'\n    Explanation: The array stops changing after a certain number of eversions, meaning further eversions do not alter the array.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': This means elements in the left part of the partition are less than or equal to the last element of the array.\n    'strictly greater than (> x)': This means elements in the right part of the partition are greater than the last element of the array.\n\n# [degree adverb] \n    'minimum number': This refers to finding the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array is not stable:\n   - Identify the last element x = a[-1].\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate these parts to form a new array.\n   - Increment k.\n4. Check if the new array is identical to the previous one. If so, stop; otherwise, continue.\n5. Output k for each test case.\n\n# [edge case] \n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion, all elements are in the left part since they are \u2264 x (x = 1), and no further changes occur.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes it.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if further eversions change the array.\n", "requirement analysis:\nThe task requires implementing an eversion operation on an array, where the array is partitioned based on the last element and rearranged. The goal is to determine the minimum number of eversions needed for the array to stabilize. The solution must handle multiple test cases efficiently, with a focus on performance given the constraints on input size.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles up to 200,000 elements efficiently\n- Provide clear and concise output for each test case\n- Optimize the algorithm for performance\n- Document the code for maintainability\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered. The number of eversions required is equal to the number of times we encounter a new maximum element. This approach ensures that we efficiently determine the minimum number of eversions needed for the array to stabilize, leveraging the properties of the eversion operation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element of the array, x. Elements not greater than x form the left part, and elements greater than x form the right part. The array is then reformed by concatenating these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': This means elements that are less than or equal to x.\n    'strictly greater than (> x)': This means elements that are greater than x.\n\n# [degree adverb] \n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. Initialize a counter for eversions.\n2. Iterate over the array from the end to the start.\n3. Keep track of the maximum element encountered so far.\n4. Each time a new maximum is encountered, increment the eversion counter.\n5. The counter will represent the minimum number of eversions needed for stabilization.\n\n# [edge case] \n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are the same, so no eversion is needed as the array is already stable.\n    \n    Test case: [5, 4, 3, 2, 1] = 4\n    Explanation: Each element is a new maximum when iterating from the end, requiring an eversion for each element.\n    \n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting new maximums encountered from the end of the array inherently handles these cases.\n", "requirement analysis:\nThe requirements focus on efficiently performing eversions on arrays until they stabilize. The key challenge is ensuring the algorithm can handle the maximum constraints while providing accurate results. The output format must be strictly followed to ensure compatibility with test cases.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles up to 100 test cases efficiently\n- Optimize the algorithm for performance\n- Provide clear documentation for the eversion process\n- Enhance output readability\nWe will implement the eversion operation using a simple loop to partition the array based on the last element and concatenate the parts. We will use a while loop to perform eversions until the array stops changing. The algorithm will efficiently handle multiple test cases by iterating over each test case and applying the eversion logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts using the last element as a pivot. Elements not greater than the pivot go to the left, and elements greater than the pivot go to the right. The array is then reformed by concatenating these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': Elements that are less than or equal to the pivot are placed in the left part of the partition.\n    'strictly greater than (>)': Elements that are greater than the pivot are placed in the right part of the partition.\n\n# [degree adverb]\n    'minimum number': We need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for eversions.\n3. Perform the eversion operation:\n   - Use the last element as the pivot.\n   - Partition the array into two parts: elements \u2264 pivot and elements > pivot.\n   - Concatenate these parts to form a new array.\n4. Check if the array has changed after the eversion. If not, break the loop.\n5. Increment the counter for each eversion performed.\n6. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion will change the array. The expected output is 0.\n\n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible pivot, so no eversion will change the array. The expected output is 0.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion will change it. The expected output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of checking if the array has changed after each eversion will naturally handle these cases by breaking out of the loop when no change is detected.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the minimum number of eversions needed. The solution must handle multiple test cases and large input sizes while providing clear output.\nrequirement pool:\n- Implement the eversion algorithm to handle large inputs efficiently.\n- Ensure the output format is clear and follows the specified requirements.\n- Optimize the code for performance and readability.\n- Test the solution with various edge cases to ensure robustness.\n- Document the code to explain the logic and approach used.\nWe will implement an algorithm that performs the eversion operation on an array until it stabilizes. The key is to efficiently partition the array into two parts based on the last element and count the number of eversions needed for the array to stop changing. We will use a simple loop to perform the eversions and check for stability. The algorithm will handle multiple test cases and large input sizes by iterating over each test case and applying the eversion logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, combining elements not greater than the last element with those strictly greater, and concatenating them. The goal is to perform this operation until the array stops changing.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements \u2264 x\n    'strictly greater than': means elements > x\n\n# [degree adverb] \n    'minimum': means the smallest number of eversions needed for the array to stabilize\n\n# [code logic]\n    1. For each test case, read the array.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n       - Identify the last element of the array as x.\n       - Partition the array into two parts: one with elements \u2264 x and another with elements > x.\n       - Concatenate these parts to form a new array.\n    4. Check if the new array is the same as the previous one. If it is, stop; otherwise, increment the counter and repeat.\n    5. Output the counter as the result for each test case.\n\n# [edge case] \n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Input: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion changes the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no eversion changes the array.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of eversions needed for stabilization. The solution must handle multiple test cases and large input sizes, ensuring performance and clarity in output.\nrequirement pool:\n- Implement the eversion algorithm to handle large arrays efficiently.\n- Ensure the output format is clear and matches the specified requirements.\n- Optimize the code for performance to handle the maximum input size.\n- Provide detailed comments and documentation for code clarity.\n- Include edge case handling for arrays with identical elements.\nWe will implement a function that performs eversions on an array until it stabilizes. The function will partition the array into two parts based on the last element and concatenate them. We will use a loop to perform eversions until the array stops changing. The approach will efficiently handle large input sizes by minimizing unnecessary operations and using list comprehensions for partitioning.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, where the left part contains elements not greater than the last element, and the right part contains elements strictly greater than the last element. The array is then replaced with the concatenation of these parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to the last element.\n    'strictly greater than': means elements in the right part are greater than the last element.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. Initialize a counter for the number of eversions.\n    2. Use a loop to perform eversions until the array stops changing:\n        - Partition the array into two parts based on the last element.\n        - Concatenate these parts to form a new array.\n        - Check if the new array is different from the previous one.\n        - If it is different, increment the counter and continue; otherwise, break the loop.\n    3. Return the counter as the result.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array. The expected output is 0.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array. The expected output is 0.\n    \n    Input: [1, 2, 3, 4, 5] = 1\n    Explanation: The first eversion will partition as [1, 2, 3, 4], [5] and result in [1, 2, 3, 4, 5]. The array stops changing after one eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no change occurs after eversions.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 18, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "condense_two2one", "parent_index": 18}
