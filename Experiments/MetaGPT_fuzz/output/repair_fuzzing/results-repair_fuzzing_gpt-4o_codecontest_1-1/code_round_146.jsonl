{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n, connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y, using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n, connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y, using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n, connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. This illusion rate is an important factor in determining the energy cost. In order to move from room x to room y, a tunnel must connect x and y, using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert. The layout of the maze is structured as a tree with n rooms labeled from 1 to n, connected by n - 1 tunnels to enable travel between any pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y, using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter grave robbers, the labyrinth can alter the illusion rate of its rooms. Chanek and Indiana will pose q queries. Queries are of two sorts:   * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).   * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n). Assist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient updates and queries.\"\"\"\n    \n    def __init__(self, data):\n        \"\"\"Initialize the Segment Tree with the given data.\"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data):\n        \"\"\"Build the Segment Tree from the initial data.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos, value):\n        \"\"\"Update the value at position pos to the new value.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left, right):\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\n\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    \"\"\"Update the illusion rate of a room.\"\"\"\n    segment_tree.update(room - 1, new_rate)\n    illusion_rates[room - 1] = new_rate\n\n\ndef calculate_min_energy(u: int, v: int) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    # Perform DFS to find the path from u to v\n    path = []\n    visited = [False] * n\n    def dfs(current, target):\n        if current == target:\n            return True\n        visited[current] = True\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                path.append(neighbor)\n                if dfs(neighbor, target):\n                    return True\n                path.pop()\n        return False\n\n    path.append(u - 1)\n    dfs(u - 1, v - 1)\n\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        a_x, a_y = illusion_rates[x], illusion_rates[y]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return energy\n\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [input().strip() for _ in range(q)]\n\n# Construct the tree using adjacency lists\nadjacency_list = [[] for _ in range(n)]\nfor s, t in tunnels:\n    adjacency_list[s - 1].append(t - 1)\n    adjacency_list[t - 1].append(s - 1)\n\n# Initialize the Segment Tree\nsegment_tree = SegmentTree(illusion_rates)\n\n# Output interface\nfor query in queries:\n    parts = query.split()\n    if parts[0] == '1':\n        update_illusion_rate(int(parts[1]), int(parts[2]))\n    elif parts[0] == '2':\n        result = calculate_min_energy(int(parts[1]), int(parts[2]))\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    # Update the illusion rate in the list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree for efficient range queries\n    update_segment_tree(segment_tree, room - 1, new_rate)\n\ndef min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], lca: List[List[int]], depth: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Find the Lowest Common Ancestor (LCA) of u and v\n    ancestor = find_lca(u, v, lca, depth)\n    # Calculate the energy required to travel from u to ancestor and ancestor to v\n    energy_u_to_ancestor = calculate_energy_path(u, ancestor, illusion_rates, tree)\n    energy_ancestor_to_v = calculate_energy_path(ancestor, v, illusion_rates, tree)\n    # Return the total energy required\n    return energy_u_to_ancestor + energy_ancestor_to_v\n\ndef update_segment_tree(segment_tree: List[int], index: int, value: int) -> None:\n    \"\"\"Update the segment tree with a new value at a specific index.\"\"\"\n    # Implementation of segment tree update logic\n    n = len(segment_tree) // 2\n    index += n\n    segment_tree[index] = value\n    while index > 1:\n        index //= 2\n        segment_tree[index] = max(segment_tree[2 * index], segment_tree[2 * index + 1])\n\ndef find_lca(u: int, v: int, lca: List[List[int]], depth: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    # Bring u and v to the same depth\n    diff = depth[u] - depth[v]\n    for i in range(len(lca)):\n        if diff & (1 << i):\n            u = lca[u][i]\n    if u == v:\n        return u\n    for i in reversed(range(len(lca))):\n        if lca[u][i] != lca[v][i]:\n            u = lca[u][i]\n            v = lca[v][i]\n    return lca[u][0]\n\ndef calculate_energy_path(start: int, end: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the energy required to travel from start to end.\"\"\"\n    # Use DFS to calculate the energy path\n    stack = [(start, -1)]\n    energy = 0\n    while stack:\n        node, parent = stack.pop()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                energy += max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]),\n                              abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n                stack.append((neighbor, node))\n    return energy\n\ndef preprocess_tree(n: int, tree: List[List[int]]) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"Preprocess the tree to prepare for LCA queries.\"\"\"\n    depth = [-1] * (n + 1)\n    lca = [[-1] * (n + 1) for _ in range(n + 1)]\n    def dfs(node: int, parent: int, d: int):\n        depth[node] = d\n        lca[node][0] = parent\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, d + 1)\n    dfs(1, -1, 0)\n    for j in range(1, n + 1):\n        for i in range(1, n + 1):\n            if lca[i][j - 1] != -1:\n                lca[i][j] = lca[lca[i][j - 1]][j - 1]\n    return lca, depth\n\ndef build_segment_tree(illusion_rates: List[int]) -> List[int]:\n    \"\"\"Build a segment tree from the initial illusion rates.\"\"\"\n    n = len(illusion_rates)\n    segment_tree = [0] * (2 * n)\n    for i in range(n):\n        segment_tree[n + i] = illusion_rates[i]\n    for i in range(n - 1, 0, -1):\n        segment_tree[i] = max(segment_tree[2 * i], segment_tree[2 * i + 1])\n    return segment_tree\n\ndef main():\n    # Read input values\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    # Preprocess the tree for LCA and other necessary data\n    lca, depth = preprocess_tree(n, tree)\n\n    # Build the segment tree for efficient updates\n    segment_tree = build_segment_tree(illusion_rates)\n\n    # Process each query\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            # Update query\n            update_illusion_rate(query[1], query[2], illusion_rates, segment_tree)\n        elif query[0] == 2:\n            # Min energy query\n            result = min_energy(query[1], query[2], illusion_rates, tree, lca, depth)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Updates the illusion rate of the u-th room to c.\"\"\"\n    illusion_rates[u - 1] = c\n\ndef find_min_energy_path(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int], u: int, v: int) -> int:\n    \"\"\"Finds the minimum energy required to travel from room u to room v.\"\"\"\n    # Precompute necessary information using DFS for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    visited = [False] * n\n    adj_list = [[] for _ in range(n)]\n    \n    for s, t in edges:\n        adj_list[s - 1].append(t - 1)\n        adj_list[t - 1].append(s - 1)\n    \n    def dfs(node: int, par: int, dep: int):\n        visited[node] = True\n        parent[node] = par\n        depth[node] = dep\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, dep + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(x: int, y: int) -> int:\n        if depth[x] < depth[y]:\n            x, y = y, x\n        while depth[x] > depth[y]:\n            x = parent[x]\n        while x != y:\n            x = parent[x]\n            y = parent[y]\n        return x\n    \n    def calculate_energy(x: int, y: int) -> int:\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Find path from u to v using LCA\n    u -= 1\n    v -= 1\n    ancestor = lca(u, v)\n    energy_sum = 0\n    \n    # Calculate energy from u to ancestor\n    current = u\n    while current != ancestor:\n        energy_sum += calculate_energy(current, parent[current])\n        current = parent[current]\n    \n    # Calculate energy from v to ancestor\n    current = v\n    while current != ancestor:\n        energy_sum += calculate_energy(current, parent[current])\n        current = parent[current]\n    \n    return energy_sum\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = find_min_energy_path(n, edges, illusion_rates, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], node: int, parent: int, illusion_rates: List[int], energy_costs: List[int]) -> None:\n    \"\"\"Perform DFS to calculate energy costs for paths.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            energy_costs[neighbor] = energy_costs[node] + max(\n                abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]),\n                abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1])\n            )\n            dfs(tree, neighbor, node, illusion_rates, energy_costs)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    energy_costs = [0] * (len(tree))\n    dfs(tree, u, -1, illusion_rates, energy_costs)\n    return energy_costs[v]\n\ndef main():\n    \"\"\"Main function to process input and execute queries.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(200000)\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Perform BFS to find the path from u to v\n    queue = deque([(u, 0)])  # (current_room, current_energy)\n    visited = set()\n    visited.add(u)\n\n    while queue:\n        current_room, current_energy = queue.popleft()\n\n        if current_room == v:\n            return current_energy\n\n        for neighbor in tree[current_room]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                energy_cost = max(\n                    abs(illusion_rates[current_room - 1] + illusion_rates[neighbor - 1]),\n                    abs(illusion_rates[current_room - 1] - illusion_rates[neighbor - 1])\n                )\n                queue.append((neighbor, current_energy + energy_cost))\n\n    return -1  # Should not reach here if the input is valid\n\ndef main():\n    # Read input\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    queries = [input().split() for _ in range(q)]\n\n    # Process queries\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room.\n        v (int): The destination room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Preprocess the tree for LCA and energy calculation\n    n = len(illusion_rates)\n    parent = [-1] * (n + 1)\n    depth = [0] * (n + 1)\n    euler = []\n    first_occurrence = [-1] * (n + 1)\n    log = [0] * (2 * n)\n    sparse_table = []\n\n    def dfs(node: int, par: int, dep: int):\n        \"\"\"Perform DFS to populate parent, depth, and euler tour.\"\"\"\n        parent[node] = par\n        depth[node] = dep\n        first_occurrence[node] = len(euler)\n        euler.append(node)\n        for neighbor in tree[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n                euler.append(node)\n\n    def build_sparse_table():\n        \"\"\"Build a sparse table for LCA queries.\"\"\"\n        m = len(euler)\n        for i in range(m):\n            log[i] = log[i // 2] + 1 if i > 0 else 0\n        sparse_table = [[0] * (log[m] + 1) for _ in range(m)]\n        for i in range(m):\n            sparse_table[i][0] = euler[i]\n        j = 1\n        while (1 << j) <= m:\n            i = 0\n            while (i + (1 << j) - 1) < m:\n                if depth[sparse_table[i][j - 1]] < depth[sparse_table[i + (1 << (j - 1))][j - 1]]:\n                    sparse_table[i][j] = sparse_table[i][j - 1]\n                else:\n                    sparse_table[i][j] = sparse_table[i + (1 << (j - 1))][j - 1]\n                i += 1\n            j += 1\n        return sparse_table\n\n    def lca(u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor of u and v.\"\"\"\n        if first_occurrence[u] > first_occurrence[v]:\n            u, v = v, u\n        l = first_occurrence[u]\n        r = first_occurrence[v]\n        j = log[r - l + 1]\n        if depth[sparse_table[l][j]] < depth[sparse_table[r - (1 << j) + 1][j]]:\n            return sparse_table[l][j]\n        else:\n            return sparse_table[r - (1 << j) + 1][j]\n\n    def calculate_energy_path(u: int, v: int) -> int:\n        \"\"\"Calculate the energy cost of the path from u to v.\"\"\"\n        ancestor = lca(u, v)\n        path = []\n        while u != ancestor:\n            path.append(u)\n            u = parent[u]\n        path.append(ancestor)\n        temp = []\n        while v != ancestor:\n            temp.append(v)\n            v = parent[v]\n        path.extend(reversed(temp))\n        energy = 0\n        for i in range(1, len(path)):\n            x, y = path[i - 1], path[i]\n            energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]),\n                          abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n        return energy\n\n    # Initialize DFS and Sparse Table\n    dfs(1, -1, 0)\n    sparse_table = build_sparse_table()\n\n    # Calculate the minimum energy for the path\n    return calculate_energy_path(u, v)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        self.build_tree(tunnels)\n        self.dfs(1, 0)\n        self.build_segment_tree(1, 1, n)\n\n    def build_tree(self, tunnels: List[Tuple[int, int]]):\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n\n    def dfs(self, node: int, par: int):\n        self.parent[node] = par\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.depth[neighbor] = self.depth[node] + 1\n                self.dfs(neighbor, node)\n\n    def build_segment_tree(self, node: int, start: int, end: int):\n        if start == end:\n            self.segment_tree[node] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self.build_segment_tree(2 * node, start, mid)\n            self.build_segment_tree(2 * node + 1, mid + 1, end)\n            self.segment_tree[node] = self.segment_tree[2 * node] + self.segment_tree[2 * node + 1]\n\n    def update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        if start == end:\n            self.segment_tree[node] = value\n            self.illusion_rates[idx - 1] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self.update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = self.segment_tree[2 * node] + self.segment_tree[2 * node + 1]\n\n    def query_segment_tree(self, node: int, start: int, end: int, L: int, R: int) -> int:\n        if R < start or end < L:\n            return 0\n        if L <= start and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_sum = self.query_segment_tree(2 * node, start, mid, L, R)\n        right_sum = self.query_segment_tree(2 * node + 1, mid + 1, end, L, R)\n        return left_sum + right_sum\n\n    def lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def calculate_energy(self, u: int, v: int) -> int:\n        lca_node = self.lca(u, v)\n        energy = 0\n        while u != lca_node:\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[self.parent[u] - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[self.parent[u] - 1]))\n            u = self.parent[u]\n        while v != lca_node:\n            energy += max(abs(self.illusion_rates[v - 1] + self.illusion_rates[self.parent[v] - 1]),\n                          abs(self.illusion_rates[v - 1] - self.illusion_rates[self.parent[v] - 1]))\n            v = self.parent[v]\n        return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    tree = Tree(n, illusion_rates, tunnels)\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, u, c = query\n            tree.update_segment_tree(1, 1, n, u, c)\n        elif query[0] == 2:\n            _, u, v = query\n            energy = tree.calculate_energy(u, v)\n            results.append(energy)\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process the queries and get results\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.lca_preprocessed = False\n        self.lca_ancestor = [[-1] * (n + 1) for _ in range(20)]\n        self.segment_tree = [0] * (4 * n)\n        self.build_segment_tree(1, 1, n)\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.tree[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def preprocess_lca(self):\n        for i in range(1, self.n + 1):\n            self.lca_ancestor[0][i] = self.parent[i]\n        for j in range(1, 20):\n            for i in range(1, self.n + 1):\n                if self.lca_ancestor[j - 1][i] != -1:\n                    self.lca_ancestor[j][i] = self.lca_ancestor[j - 1][self.lca_ancestor[j - 1][i]]\n        self.lca_preprocessed = True\n\n    def find_lca(self, u: int, v: int) -> int:\n        if not self.lca_preprocessed:\n            self.preprocess_lca()\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.lca_ancestor[i][u]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.lca_ancestor[i][u] != self.lca_ancestor[i][v]:\n                u = self.lca_ancestor[i][u]\n                v = self.lca_ancestor[i][v]\n        return self.parent[u]\n\n    def build_segment_tree(self, node: int, start: int, end: int):\n        if start == end:\n            self.segment_tree[node] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self.build_segment_tree(2 * node, start, mid)\n            self.build_segment_tree(2 * node + 1, mid + 1, end)\n            self.segment_tree[node] = self.segment_tree[2 * node] + self.segment_tree[2 * node + 1]\n\n    def update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        if start == end:\n            self.illusion_rates[idx - 1] = value\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self.update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = self.segment_tree[2 * node] + self.segment_tree[2 * node + 1]\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.update_segment_tree(1, 1, self.n, room, new_rate)\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        lca = self.find_lca(u, v)\n        energy = 0\n        energy += self.calculate_energy_path(u, lca)\n        energy += self.calculate_energy_path(v, lca)\n        return energy\n\n    def calculate_energy_path(self, u: int, ancestor: int) -> int:\n        energy = 0\n        while u != ancestor:\n            par = self.parent[u]\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[par - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[par - 1]))\n            u = par\n        return energy\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    maze.update_illusion_rate(room, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    return maze.calculate_min_energy(u, v)\n\n# Input and Output Interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntree = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    s, t = map(int, input().split())\n    tree[s].append(t)\n    tree[t].append(s)\n\nmaze = Maze(n, illusion_rates, tree)\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        # Update query\n        update_illusion_rate(query[1], query[2], illusion_rates)\n    elif query[0] == 2:\n        # Calculate energy query\n        result = calculate_min_energy(query[1], query[2], illusion_rates, tree)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    if u == v:\n        return 0\n\n    # Perform DFS to find the path from u to v\n    path = []\n    visited = [False] * len(tree)\n    \n    def dfs(current: int, target: int, path: List[int]) -> bool:\n        \"\"\"Depth First Search to find path from current to target.\"\"\"\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target, path):\n                    return True\n        path.pop()\n        return False\n\n    dfs(u, v, path)\n\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to process input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], edges: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.lca_preprocessed = False\n        self.lca_ancestor = [[-1] * (n + 1) for _ in range(20)]  # Assuming log2(n) < 20\n        self.build_tree(edges)\n        self.preprocess_lca()\n\n    def build_tree(self, edges: List[Tuple[int, int]]):\n        for u, v in edges:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n\n    def dfs(self, node: int, par: int, dep: int):\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def preprocess_lca(self):\n        self.dfs(1, -1, 0)  # Assuming 1 is the root\n        for i in range(1, self.n + 1):\n            self.lca_ancestor[0][i] = self.parent[i]\n        for j in range(1, 20):\n            for i in range(1, self.n + 1):\n                if self.lca_ancestor[j - 1][i] != -1:\n                    self.lca_ancestor[j][i] = self.lca_ancestor[j - 1][self.lca_ancestor[j - 1][i]]\n        self.lca_preprocessed = True\n\n    def find_lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.lca_ancestor[i][u]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.lca_ancestor[i][u] != self.lca_ancestor[i][v]:\n                u = self.lca_ancestor[i][u]\n                v = self.lca_ancestor[i][v]\n        return self.parent[u]\n\n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        self.illusion_rates[room - 1] = new_rate\n\n    def min_energy_path(self, room_u: int, room_v: int) -> int:\n        lca = self.find_lca(room_u, room_v)\n        path = self.get_path(room_u, lca) + self.get_path(room_v, lca)[::-1][1:]\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u, v = path[i], path[i + 1]\n            energy = max(abs(self.illusion_rates[u - 1] + self.illusion_rates[v - 1]),\n                         abs(self.illusion_rates[u - 1] - self.illusion_rates[v - 1]))\n            total_energy += energy\n        return total_energy\n\n    def get_path(self, start: int, end: int) -> List[int]:\n        path = []\n        while start != end:\n            path.append(start)\n            start = self.parent[start]\n        path.append(end)\n        return path\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    edges = []\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    \n    maze = Maze(n, illusion_rates, edges)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            maze.update_illusion_rate(u, c)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = maze.min_energy_path(u, v)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe program must efficiently handle up to 100,000 queries and rooms, ensuring quick updates and calculations. The tree structure of the maze allows for traversal using depth-first search or similar algorithms to calculate energy requirements. The illusion rate updates must be handled in constant time, and the energy calculation should be optimized for minimal computational overhead.\nrequirement pool:\n- Implement efficient query processing for both update and energy calculation queries.\n- Ensure accurate calculation of energy requirements using the given formula.\n- Design a user-friendly interface for input and output handling.\n- Optimize the program for handling large input sizes efficiently.\n- Provide clear documentation and examples for users to understand the input/output format.\nWe will use a combination of Depth-First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will allow us to update the illusion rates in O(log n) time and query the minimum energy path efficiently. This approach is suitable given the constraints of up to 100,000 rooms and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing travel between any pair of rooms. This implies a hierarchical structure with no cycles.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms. The illusion rate can be updated, affecting subsequent energy calculations.\n\n    'energy calculation'\n    Explanation: The energy required to move between rooms x and y is calculated using max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of rooms x and y, respectively.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates the calculation of energy required to move between two rooms. It involves finding the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms.\n\n# [degree adverb]\n    'smallest': In the context of queries, it refers to finding the minimum sum of energy required to access the secret treasure from one room to another.\n\n# [code logic]\n    1. Parse the input to retrieve the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement a Segment Tree to manage updates and queries efficiently.\n    4. For type 1 queries, update the illusion rate of the specified room in the Segment Tree.\n    5. For type 2 queries, use DFS to traverse from the starting room to the target room, calculating the energy required using the Segment Tree for current illusion rates.\n    6. Output the minimum energy sum for each type 2 query.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2000000000\n    Explanation: The maximum possible illusion rate difference is used in energy calculation.\n\n    Input: 4 3\n           -1 -1 -1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 6\n    Explanation: Moving through rooms with identical negative illusion rates results in consistent energy calculations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will naturally handle these scenarios by calculating energy based on current illusion rates and tree structure.\n", "requirement analysis:\nThe program needs to efficiently handle updates to the illusion rates and calculate the minimum energy required for traversal between rooms. Given the constraints, the solution must be optimized for large input sizes and ensure quick query processing.\nrequirement pool:\n- Efficient query processing for both update and energy calculation\n- Accurate calculation of energy requirements\n- Handle large input sizes without performance degradation\n- Robust handling of edge cases in maze traversal\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths and the LCA will be used to find the shortest path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is structured as a tree.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented as `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb] \n    'smallest': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to read the number of rooms (n), number of queries (q), and the initial illusion rates.\n2. Construct the tree using adjacency lists from the given tunnels.\n3. Preprocess the tree using DFS to prepare for LCA queries.\n4. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n5. For each query:\n   - If it's an update query (type 1), update the illusion rate in the data structure.\n   - If it's a path query (type 2), use LCA to find the path from u to v and calculate the minimum energy required using the preprocessed data.\n\n# [edge case] \n    1. Single path from start to end: If there is only one direct path between u and v, calculate energy directly.\n       Example: 2 1 2 = 14\n       Explanation: Direct path from room 1 to room 2 with initial rates.\n\n    2. Update query with no effect: An update that doesn't change the illusion rate should not affect subsequent queries.\n       Example: 1 1 10 (if initial rate was already 10)\n       Explanation: No change in energy calculation for subsequent queries.\n\n    3. All rooms have zero illusion rate: If all rooms have an illusion rate of zero, energy for any path should be zero.\n       Example: 2 1 3 = 0\n       Explanation: All calculations result in zero energy due to zero illusion rates.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently and ensure that queries are processed in logarithmic time.\n    - Implement a Segment Tree or Fenwick Tree for efficient updates and queries on illusion rates.\n    - Ensure that LCA preprocessing is done correctly to handle path queries efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle both types of queries, especially the pathfinding query which requires calculating the minimum energy path in a dynamically changing tree structure. The solution must be optimized for both time and space to handle the upper limits of input size.\nrequirement pool:\n- Efficiently process type 2 queries to find the minimum energy path.\n- Implement a fast update mechanism for type 1 queries.\n- Optimize the solution to handle the maximum input size within time limits.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear documentation and examples for users.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the pathfinding queries. For the update queries, we will use a simple array update since the illusion rates are stored in an array. The DFS will help in precomputing necessary information for LCA, which will allow us to quickly find the path between any two nodes in the tree. This approach ensures that both types of queries are handled in logarithmic time complexity, making it suitable for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and is used in calculations for determining the energy needed to traverse tunnels.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing for a unique path between any two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves taking the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'smallest energy sum'\n    Explanation: This refers to finding the minimum total energy required to travel from one room to another. In code, this involves calculating the energy for each segment of the path and summing them up to find the minimum total.\n\n# [code logic]\n    - Use DFS to traverse the tree and precompute necessary information for LCA.\n    - Implement LCA to efficiently find paths between any two nodes.\n    - For type 1 queries, update the illusion rate in the array.\n    - For type 2 queries, calculate the energy required using precomputed paths and illusion rates.\n\n# [edge case]\n    2 1 1 = 0\n    Explanation: When querying from a room to itself, no movement is needed, so the energy required is 0.\n\n    1 1 0 = No output\n    Explanation: Updating a room's illusion rate does not produce an output; it simply modifies internal state.\n\n    2 n n = 0\n    Explanation: Similar to querying from a room to itself, querying from the last room to itself requires no energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for querying from a room to itself by returning 0 energy.\n", "requirement analysis:\nThe requirements focus on efficiently processing updates and queries in a tree-structured maze. The main challenge is to handle large input sizes and ensure that energy calculations are accurate and fast. The program must be able to dynamically update room illusion rates and compute the minimum energy path between any two rooms.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy path between rooms quickly.\n- Ensure the program can handle the maximum constraints of input size.\n- Provide clear and concise output for each query.\n- Optimize for performance to handle real-time updates and queries.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy path efficiently. We will utilize adjacency lists to represent the tree structure and segment trees to handle updates and queries efficiently. This approach ensures that we can handle large input sizes within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a numerical value associated with each room that affects the energy cost required to move between rooms. It is used in the calculation of energy as max(|a_x + a_y|, |a_x - a_y|).\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing travel between any pair of rooms. This implies a hierarchical structure with no cycles.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy cost to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'smallest energy sum'\n    Explanation: This refers to finding the minimum total energy required to travel from one room to another. In code, this involves calculating the energy for each path and selecting the path with the lowest total energy.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement DFS to preprocess the tree and calculate paths.\n3. Use segment trees or similar data structures to efficiently handle updates to illusion rates and queries for minimum energy paths.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, calculate the minimum energy required to travel from room u to room v using preprocessed data.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy cost between them is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 3000000000\n    Explanation: The path from room 1 to room 3 involves high illusion rates, resulting in large energy costs.\n\n    Input: 4 3\n           -1 -1 -1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 6\n    Explanation: The path from room 1 to room 4 involves consistent illusion rates, resulting in predictable energy costs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and segment trees should be sufficient to handle these scenarios efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze. The main challenge is to handle updates to the illusion rates and calculate the minimum energy required for traversal between rooms. The solution must be optimized for large input sizes, ensuring quick response times for both types of queries.\nrequirement pool:\n- Efficiently handle type 1 queries to update room illusion rates.\n- Efficiently handle type 2 queries to calculate minimum energy required for traversal.\n- Optimize the solution to handle the maximum constraints of n and q.\n- Ensure the solution is robust and handles edge cases effectively.\n- Provide clear and concise output for each query.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy required for traversal between rooms. We will utilize adjacency lists to represent the tree structure and efficiently update the illusion rates using a dictionary. For type 2 queries, we will use a pathfinding algorithm to calculate the minimum energy cost between two rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a numerical value associated with each room that affects the energy cost required to move between rooms. It is used in the calculation of energy as max(|a_x + a_y|, |a_x - a_y|).\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between any pair of rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy cost between two rooms. It requires taking the maximum of the absolute values of the sum and difference of the illusion rates of two rooms.\n\n# [degree adverb]\n    'smallest energy sum'\n    Explanation: This refers to finding the minimum total energy required to travel from one room to another, considering all possible paths.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Implement DFS to preprocess the tree and calculate paths.\n    3. Use a dictionary to efficiently update illusion rates for type 1 queries.\n    4. For type 2 queries, use a pathfinding algorithm (e.g., Dijkstra's) to calculate the minimum energy cost between two rooms.\n    5. Output the result for each type 2 query.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy cost is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n           2 1 3\n    Expected Output: 2000000000, 2000000000\n    Explanation: The large values test the handling of maximum integer values and updates.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        Ensure that the algorithm efficiently handles large integer values and updates.\n        Implement checks for zero illusion rates to avoid unnecessary calculations.\n        (other code)\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to room illusion rates and calculating the minimum energy required for traversal. The solution must handle large input sizes and provide quick updates to ensure optimal pathfinding.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Scalable solution for large mazes\n- Fast updates to room illusion rates\n- Accurate energy cost calculation\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the minimum energy path between two nodes. We will use the Euler Tour technique to flatten the tree and Binary Lifting for efficient LCA queries. This approach ensures that both update and query operations are handled in logarithmic time, making it scalable for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    A tree is a connected acyclic graph. In this context, it means that the maze is structured in such a way that there is exactly one path between any two rooms.\n\n    'illusion rate'\n    This is a property of each room that affects the energy cost to move between rooms. It is used in the calculation of energy required to traverse tunnels.\n\n    'energy cost'\n    The energy required to move from one room to another, calculated using the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's `max` and `abs` functions: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'smallest': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Preprocess the tree using Depth First Search (DFS) to prepare for Lowest Common Ancestor (LCA) queries.\n4. Implement Binary Lifting technique for efficient LCA queries.\n5. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), use LCA to find the path between rooms u and v, calculate the energy cost for this path, and return the minimum energy sum.\n\n# [edge case]\n    1. Query with u = v: The expected output is 0 because no movement is needed.\n       Explanation: Since starting and ending rooms are the same, no energy is required.\n       \n    2. All rooms have zero illusion rate: The expected output for any path query is 0.\n       Explanation: With zero illusion rates, all energy calculations result in zero.\n\n    3. Maximum possible illusion rate change: Test with an update query that changes an illusion rate to 10^9 or -10^9.\n       Explanation: Ensure that the program handles large numbers without overflow or errors.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of calculating energy costs and updating illusion rates. The original logic already considers cases where no movement is needed or where illusion rates are zero.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze. The main challenge is to handle updates to the illusion rates and calculate the minimum energy required for traversal. The solution must be optimized for large input sizes, given the constraints on n and q.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Support for updating illusion rates in real-time\n- Optimization for large datasets\n- User-friendly interface for input and output\n- Scalability to handle future expansions of the maze\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will allow us to quickly find the path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'smallest'\n    Explanation: For type 2 queries, we need to find the smallest energy sum required to access the secret treasure from one room to another. This involves finding the path with the minimum energy cost.\n\n# [code logic]\n    1. Preprocess the tree using DFS to calculate paths and prepare for LCA queries.\n    2. Use LCA to efficiently find paths between any two nodes for type 2 queries.\n    3. Implement a Segment Tree to handle updates to illusion rates for type 1 queries.\n    4. For each type 2 query, calculate the energy required using the preprocessed data and update results accordingly.\n\n# [edge case] \n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 -10\n           2 1 3\n    Output: 20\n            20\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = 20 energy. After updating room 2's illusion rate, the energy remains unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will handle these cases efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating room illusion rates and calculating the minimum energy required for movement between rooms. The solution must handle large input sizes and ensure quick response times while maintaining accuracy.\nrequirement pool:\n- Efficient query processing for both update and calculation queries\n- Accurate calculation of energy requirements between rooms\n- Ability to handle large input sizes without performance degradation\n- Robust error handling for invalid inputs\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the shortest path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently. This approach ensures that both update and query operations are handled in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze structure where rooms are nodes and tunnels are edges.\n\n    'illusion rate'\n    Explanation: This is a property of each room that affects the energy required to move between rooms. It can be updated and affects the calculation of energy.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each movement between two rooms, the energy required is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'smallest': In the context of the query, it refers to finding the minimum sum of energy required to travel from one room to another. This involves finding the shortest path in terms of energy cost.\n\n# [code logic]\n1. Preprocess the tree using DFS to establish parent-child relationships and calculate initial paths.\n2. Use LCA (Lowest Common Ancestor) to efficiently find paths between any two nodes.\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n4. For each type 2 query, calculate the minimum energy required using preprocessed data and LCA.\n5. For each type 1 query, update the illusion rate in the data structure.\n\n# [edge case]\n    1. Single path from start to end: If there's only one direct path between u and v, the energy is simply max(|a_u + a_v|, |a_u - a_v|).\n       Explanation: This is straightforward as there's no alternative path.\n       \n    2. All rooms have zero illusion rate: The energy for any path will be zero since max(|0 + 0|, |0 - 0|) = 0.\n       Explanation: This tests if the code correctly handles zero values in calculations.\n       \n    3. Maximum possible illusion rate change: Update a room's illusion rate to its maximum value (10^9) and check if calculations handle large numbers without overflow.\n       Explanation: Ensures that the code can handle extreme values and still produce correct results.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of using DFS, LCA, and Segment Tree for updates and queries. The original logic should be robust enough to handle these scenarios given proper implementation of data structures and algorithms.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating room illusion rates and calculating the minimum energy required for movement between rooms. The solution must handle large inputs and ensure accurate calculations while providing a user-friendly interface.\nrequirement pool:\n- Efficient query processing for both update and calculation queries.\n- Accurate calculation of energy requirements between rooms.\n- User-friendly interface for input and output.\n- Ability to handle large inputs without performance degradation.\n- Clear documentation and instructions for users.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between any two rooms efficiently. We will utilize adjacency lists to represent the tree structure and segment trees to handle updates and queries efficiently. The segment tree will allow us to update the illusion rates and calculate the minimum energy required for movement between rooms in logarithmic time.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest': In the context of the query, it refers to finding the minimum sum of energy required to travel from one room to another. This can be implemented by calculating all possible paths and selecting the one with the least energy cost.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Preprocess the tree using Depth First Search (DFS) to calculate paths and store necessary information for efficient queries.\n3. Implement a segment tree or similar data structure to handle updates to illusion rates and efficiently compute path energies.\n4. For each query:\n   - If it's an update query (type 1), update the illusion rate in the segment tree.\n   - If it's a path query (type 2), calculate the minimum energy required using preprocessed data and segment tree.\n\n# [edge case]\n    1. Query with u = v (e.g., 2 1 1) = 0\n       Explanation: If the start and end rooms are the same, no movement is needed, so the energy cost is 0.\n    2. All rooms have the same illusion rate (e.g., all a_i = 0) = 0 for any path\n       Explanation: If all illusion rates are zero, any path will have zero energy cost since max(|0 + 0|, |0 - 0|) = 0.\n    3. Maximum possible illusion rate change (e.g., update a room's rate from -10^9 to 10^9) = Correctly update and calculate new path costs\n       Explanation: Ensure that updates handle large changes in illusion rates without overflow or errors.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to updates and queries efficiently.\n    - Implement checks for u = v in type 2 queries to immediately return 0.\n    - Ensure that updates in the segment tree handle large values correctly.\n    - Use efficient data structures like segment trees or binary indexed trees to manage updates and queries within time limits.\n", "requirement analysis:\nThe program must efficiently handle updates to the illusion rates and calculate the minimum energy path between rooms. Given the constraints, it should be optimized for large input sizes and ensure quick query processing.\nrequirement pool:\n- Efficient query processing for type 2 queries\n- Quick update mechanism for type 1 queries\n- Scalability to handle up to 100,000 rooms and queries\n- Accurate energy calculation based on room illusion rates\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths and the LCA will be used to find the minimum energy path between two rooms. We will use adjacency lists to represent the tree and segment trees to handle updates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and is used in calculations for energy consumption.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing for a unique path between any two rooms.\n\n    'queries'\n    Explanation: There are two types of queries: updating the illusion rate of a room and finding the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves taking the maximum of the absolute values of the sum and difference of their illusion rates.\n\n# [degree adverb]\n    'smallest'\n    Explanation: In the context of type 2 queries, it refers to finding the minimum sum of energy needed to move from one room to another.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Preprocess the tree using DFS to calculate necessary paths and prepare for LCA queries.\n    3. Implement a segment tree or similar data structure to efficiently handle updates to illusion rates.\n    4. For type 1 queries, update the illusion rate in the segment tree.\n    5. For type 2 queries, use LCA to find the path between two rooms and calculate the energy using the preprocessed data.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 2 -1000000000\n           2 1 3\n    Expected Output: 3000000000, 2000000000\n    Explanation: The large values test the handling of maximum integer values and updates.\n\n# [extra code for edge case]\n    We need extra code to handle large integer values efficiently, ensuring no overflow occurs during calculations. This can be managed by using Python's inherent support for large integers and careful handling of arithmetic operations.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 146, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "rephrase_one", "parent_index": 95}
