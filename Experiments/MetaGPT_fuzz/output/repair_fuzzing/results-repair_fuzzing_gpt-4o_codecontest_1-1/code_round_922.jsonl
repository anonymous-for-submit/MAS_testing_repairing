{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. The towers are in a straight line and each has a specific height denoted by a_i. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume the array of heights is non-empty.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. The towers are in a straight line and each has a specific height denoted by a_i. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume the array of heights is non-empty.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. The towers are in a straight line and each has a specific height denoted by a_i. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). This allows you to move a block from tower i to tower j. This operation decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume the array of heights is non-empty.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Assume the array of heights is non-empty.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Sort the heights to easily find the min and max\n        heights.sort()\n        # Calculate the initial ugliness\n        initial_ugliness = heights[-1] - heights[0]\n        \n        # If the initial ugliness is 0, no redistribution is needed\n        if initial_ugliness == 0:\n            results.append(0)\n            continue\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Calculate the target height if all blocks were evenly distributed\n        target_height = total_blocks // n\n        \n        # Calculate the remainder blocks that cannot be evenly distributed\n        remainder_blocks = total_blocks % n\n        \n        # The minimum possible ugliness is 1 if there are remainder blocks, otherwise 0\n        min_ugliness = 1 if remainder_blocks > 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Output interface\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate the initial ugliness\n        max_height = max(heights)\n        min_height = min(heights)\n        initial_ugliness = max_height - min_height\n        \n        # Since we can redistribute blocks, the minimum possible ugliness is 0 or 1\n        # If all towers can be made equal, ugliness is 0\n        # Otherwise, the minimum possible ugliness is 1\n        if initial_ugliness == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Sort the heights to easily redistribute blocks\n        heights.sort()\n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Calculate the target height for all towers\n        target_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # The minimum ugliness is determined by the remainder\n        # If remainder is 0, all towers can be made equal\n        # If remainder is not 0, the difference will be 1\n        if remainder == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Output interface\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Sort the heights to easily find the minimum and maximum\n        heights.sort()\n        # The minimum ugliness is the difference between the max and min heights\n        # after redistribution, which is 0 if all heights can be made equal\n        min_height = heights[0]\n        max_height = heights[-1]\n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        # Calculate the number of towers\n        n = len(heights)\n        # Calculate the average height\n        average_height = total_blocks // n\n        # Calculate the remainder blocks after equal distribution\n        remainder_blocks = total_blocks % n\n        # If remainder_blocks is 0, all towers can be made exactly equal\n        if remainder_blocks == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1, because we can make all but one tower equal\n            results.append(1)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Output interface\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # If there is a remainder, the minimum possible ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n\n        # Calculate the minimum possible ugliness\n        # If remainder is 0, all towers can be equalized perfectly\n        # If remainder is not 0, the minimum ugliness will be 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Call the function\n    results = minimize_ugliness(t, test_cases)\n\n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing heights of buildings.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate the initial ugliness\n        max_height = max(heights)\n        min_height = min(heights)\n        initial_ugliness = max_height - min_height\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        num_buildings = len(heights)\n        \n        # Calculate the target height for equal distribution\n        target_height = total_blocks // num_buildings\n        \n        # Calculate the minimum possible ugliness\n        # If all buildings can be made equal, the ugliness is 0\n        # Otherwise, the ugliness is 1 (since we can only make heights nearly equal)\n        if total_blocks % num_buildings == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate total blocks and average height\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        average_height = total_blocks // num_towers\n        \n        # Calculate the minimum possible ugliness\n        # Redistribute blocks to make heights as close to average as possible\n        # Calculate the difference between max and min heights after redistribution\n        min_height = average_height\n        max_height = average_height + (1 if total_blocks % num_towers != 0 else 0)\n        \n        # The minimum possible ugliness is the difference between max and min heights\n        min_ugliness = max_height - min_height\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the buildings.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Sort the heights to easily find the minimum and maximum\n        heights.sort()\n        # The minimum possible ugliness is the difference between the max and min heights\n        # after redistribution, which can be minimized to 0 or 1\n        min_height = heights[0]\n        max_height = heights[-1]\n        # If the difference is 0 or 1, it is already minimized\n        if max_height - min_height <= 1:\n            results.append(0)\n        else:\n            # Otherwise, the minimum possible ugliness is 1\n            results.append(1)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing a list of tower heights.\n\n    Returns:\n        List[int]: A list of minimum possible ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate the maximum and minimum heights\n        max_height = max(heights)\n        min_height = min(heights)\n        \n        # The minimum possible ugliness is the difference between max and min heights\n        # after redistributing blocks to equalize the heights as much as possible.\n        # In this problem, we can always redistribute to make the difference 0 or 1.\n        if max_height - min_height <= 1:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on minimizing the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 towers each, ensuring the output is accurate and follows the specified format.\nrequirement pool:\n- Implement the algorithm to minimize ugliness efficiently.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide clear documentation for input and output formats.\n- Optimize the code for performance with large datasets.\n- Enhance user experience with intuitive input handling.\nWe will implement a function to calculate the minimum possible ugliness by redistributing blocks between towers. The approach involves sorting the heights and calculating the difference between the maximum and minimum heights after potential redistribution. We will use Python's built-in functions for sorting and min/max operations to ensure efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb]\n    'minimum': This indicates that we need to achieve the smallest possible value for ugliness.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Sort the list of building heights.\n3. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n4. Since we can redistribute blocks, the goal is to make all heights equal if possible, which would result in an ugliness of 0.\n5. If making all heights equal is not possible due to constraints, find the smallest possible difference by redistributing blocks optimally.\n6. Return the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: [1, 1] = 0\n    Explanation: With only two towers of equal height, no redistribution is needed, and ugliness is already 0.\n\n    Case 2: [1, 10000000] = 0\n    Explanation: With two towers, you can move blocks from the taller to the shorter until they are equal, resulting in an ugliness of 0.\n\n    Case 3: [1, 1, 1, 10000000] = 0\n    Explanation: You can redistribute blocks from the tallest tower to the others until all are equal, resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks until all heights are equal or as close as possible will handle these cases effectively.\n", "requirement analysis:\nThe task requires developing an algorithm to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution must efficiently handle up to 1000 test cases, each with up to 100 buildings, and provide the minimum possible ugliness for each test case.\nrequirement pool:\n- Develop an algorithm to calculate the minimum ugliness.\n- Ensure the solution can handle up to 1000 test cases efficiently.\n- Optimize the algorithm for large input sizes.\n- Provide clear documentation and examples for users.\n- Implement additional features for user interaction.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to make all towers as equal in height as possible, which can be achieved by calculating the difference between the maximum and minimum heights in the input list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means that we need to find the smallest difference between the maximum and minimum heights after redistributing blocks.\n\n# [degree adverb] \n    'minimum': means that we need to achieve the smallest possible value for ugliness.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n    3. Redistribute blocks to minimize the difference between the tallest and shortest buildings.\n    4. The optimal strategy is to make all towers as equal in height as possible.\n    5. Return the minimum possible ugliness for each test case.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: 3, [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all towers are already of equal height, the ugliness is 0.\n\n    Case 2: Towers can be made equal with a single operation.\n    Input: 4, [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By moving one block from tower 1 to tower 3, all towers become equal in height.\n\n    Case 3: Towers cannot be made completely equal.\n    Input: 5, [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistributing blocks optimally, the minimum possible ugliness is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the difference between max and min heights will handle these cases effectively.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks between towers. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 100 buildings. The heights can be as large as 10^7, necessitating an efficient algorithm to ensure scalability and performance.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear and formatted output for each test case.\n- Optimize the code for scalability across multiple test cases.\n- Include error handling for invalid inputs.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistributing blocks to make the heights as equal as possible. The approach involves calculating the difference between the maximum and minimum heights in the list of building heights for each test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means finding the smallest difference between the maximum and minimum heights after redistributing blocks.\n\n# [degree adverb] \n    'minimum': means achieving the smallest possible value for ugliness.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n    3. Redistribute blocks to minimize this difference:\n        - Sort the heights.\n        - Redistribute blocks from the tallest to the shortest until the difference is minimized.\n    4. Return the minimized ugliness for each test case.\n\n# [edge case] \n    Case 1: Input: 2, Heights: [1, 1] = Output: 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: Input: 3, Heights: [1, 1, 10] = Output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers until all are equal.\n\n    Case 3: Input: 4, Heights: [1, 2, 3, 4] = Output: 0\n    Explanation: Redistribute blocks to make all towers have equal height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks until all heights are equal will naturally handle these cases.\n", "requirement analysis:\nThe problem requires calculating the minimum possible ugliness of building heights after redistributing blocks between towers. The solution must efficiently handle up to 1000 test cases with building heights up to 10^7, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the code for performance and readability.\n- Validate the output format against multiple test cases.\n- Document the code for maintainability and future updates.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to make the heights as equal as possible, which can be achieved by redistributing blocks such that the difference between the maximum and minimum heights is minimized. This can be done by sorting the heights and calculating the difference between the maximum and minimum values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest towers.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Sort the list of heights.\n3. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n4. Redistribute blocks to make the heights as equal as possible:\n   - While there are differences between the tallest and shortest towers, move blocks from the tallest to the shortest.\n5. Recalculate the ugliness after redistribution.\n6. Return the minimum ugliness for each test case.\n\n# [edge case] \n    Case 1: [10, 10, 10] = 0\n    Explanation: All towers are already of equal height, so the ugliness is 0.\n\n    Case 2: [1, 1, 1, 10000000] = 0\n    Explanation: By redistributing blocks from the tallest tower to others, all towers can be made equal.\n\n    Case 3: [1, 1, 1, 1, 10000000] = 0\n    Explanation: Similar to Case 2, redistribute blocks to make all towers equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of redistributing blocks until all towers are as equal as possible will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of building heights after redistributing blocks between towers. The solution must handle up to 1000 test cases efficiently, with each test case having up to 100 buildings. The primary challenge is to ensure the solution is both time-efficient and accurate, given the constraints on the number of operations and the size of the input values.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and formatted output for each test case.\n- Optimize the algorithm for speed and accuracy.\n- Include comments and documentation for code clarity.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to make the heights as equal as possible, which can be achieved by redistributing blocks to minimize the difference between the maximum and minimum heights. We will use Python's built-in functions to efficiently find the maximum and minimum values in the list of heights.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest towers.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Calculate the total number of blocks by summing up all heights.\n3. Determine the average height by dividing the total number of blocks by the number of buildings.\n4. Calculate the remainder when dividing the total number of blocks by the number of buildings.\n5. The minimum possible ugliness is 1 if there is a remainder (since not all towers can be made exactly equal), otherwise it is 0.\n\n# [edge case] \n    Case 1: [1, 1] = 0\n    Explanation: Both towers are already equal, so no redistribution is needed, resulting in an ugliness of 0.\n\n    Case 2: [1, 10000000] = 1\n    Explanation: The large difference can be reduced to a minimum ugliness of 1 by redistributing blocks.\n\n    Case 3: [5, 5, 5, 5, 5] = 0\n    Explanation: All towers are already equal, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the average and checking for a remainder will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks between towers. The solution must handle up to 1000 test cases efficiently, with each test case containing up to 100 buildings. The heights can be as large as 10^7, necessitating an efficient algorithm to ensure quick processing.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large height values.\n- Provide clear output format for each test case.\n- Include error handling for invalid inputs.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The approach involves sorting the heights and calculating the difference between the maximum and minimum heights after potential redistribution. This can be efficiently achieved using Python's built-in sorting and min/max functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation where you can move a block from one tower to another, effectively decreasing the height of one tower and increasing the height of another.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) that can be achieved by redistributing blocks between towers.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest towers after redistributing blocks.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Calculate the total number of blocks across all towers.\n3. Determine the average height by dividing the total number of blocks by the number of towers.\n4. Calculate the minimum possible ugliness by considering the distribution of blocks around this average height.\n5. Return the difference between the maximum and minimum heights after redistribution.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already equal in height.\n\n    Case 2: Towers with heights that can be equalized perfectly.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By redistributing blocks, all towers can be made equal in height.\n\n    Case 3: Towers with heights that cannot be perfectly equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the closest possible equal heights result in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve an average height inherently handles these cases.\n", "requirement analysis:\nThe problem requires calculating the minimum possible ugliness of building heights after redistributing blocks between towers. The solution should efficiently handle up to 1000 test cases with building heights up to 10^7. The algorithm must ensure that the difference between the tallest and shortest buildings is minimized, and the output format must be consistent with the given examples.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness\n- Optimize the solution for large input sizes\n- Ensure the solution handles edge cases\n- Provide clear documentation and comments in the code\n- Test the solution with various test cases for robustness\nWe will implement a function to calculate the minimum possible ugliness by redistributing blocks between towers. The approach involves finding the maximum and minimum heights and calculating their difference, which represents the ugliness. The goal is to minimize this difference by redistributing blocks. We will use Python's built-in functions to efficiently handle the input and output operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest possible value of max(a) - min(a) after redistributing blocks between towers.\n\n# [degree adverb]\n    'tallest', 'shortest'\n    Explanation: 'Tallest' refers to the building with the maximum height, and 'shortest' refers to the building with the minimum height. We need to minimize the difference between these two.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Calculate the initial ugliness as max(height) - min(height).\n    3. Redistribute blocks to minimize the difference between the tallest and shortest buildings.\n    4. The goal is to make all buildings have equal or nearly equal heights.\n    5. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All buildings have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all buildings are already of equal height, the ugliness is 0.\n\n    Case 2: Heights can be made equal with redistribution.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By redistributing blocks, all buildings can be made of equal height.\n\n    Case 3: Heights cannot be made completely equal.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the minimum possible ugliness is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize max(a) - min(a) will handle these cases effectively.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of building heights after redistributing blocks between towers. The solution should efficiently handle up to 1000 test cases, with each test case containing up to 100 building heights. The algorithm must minimize the difference between the tallest and shortest buildings.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness\n- Ensure the solution handles edge cases and large inputs efficiently\n- Optimize the code for performance and readability\n- Provide detailed comments and documentation\n- Develop test cases to validate the solution\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to make the heights as equal as possible, which can be achieved by calculating the difference between the maximum and minimum heights in the input list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: The difference between the maximum and minimum heights of the towers. In code, this can be implemented as `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible value of ugliness after redistributing blocks. In code, this involves finding the smallest possible value of `max(a) - min(a)` after redistribution.\n\n# [code logic]\n    1. For each test case, read the number of towers and their respective heights.\n    2. Calculate the total number of blocks.\n    3. Determine the average height by dividing the total number of blocks by the number of towers.\n    4. Redistribute blocks to make all tower heights as close to the average height as possible.\n    5. Calculate the minimum possible ugliness as `max(a) - min(a)` after redistribution.\n    6. Output the result for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all towers are already equal in height, no redistribution is needed, and ugliness is 0.\n\n    Case 2: Towers can be made equal with one redistribution.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By redistributing one block from the tallest tower to the shortest, all towers can be made equal.\n\n    Case 3: Towers cannot be made completely equal.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After optimal redistribution, the minimum possible ugliness is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize `max(a) - min(a)` will handle these cases effectively.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks between towers. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles large input sizes efficiently.\n- Develop a user-friendly interface for input and output.\n- Optimize the code for scalability across multiple test cases.\n- Provide detailed documentation for the solution.\nWe will implement a function to calculate the minimum possible ugliness by redistributing blocks between towers. The approach involves sorting the heights and calculating the difference between the maximum and minimum heights after redistribution. This can be efficiently achieved using Python's built-in sorting and list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means that we need to find the smallest difference between the tallest and shortest buildings after redistributing blocks.\n\n# [degree adverb] \n    'minimum': means that we need to achieve the smallest possible value for ugliness.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Sort the list of heights.\n    3. Calculate the difference between the maximum and minimum heights.\n    4. Redistribute blocks to minimize this difference.\n    5. Return the minimum possible ugliness for each test case.\n\n# [edge case] \n    Case 1: Input: 2, Heights: [1, 1] = Output: 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: Input: 3, Heights: [1, 1, 10] = Output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers to make all heights equal.\n    \n    Case 3: Input: 4, Heights: [1, 2, 3, 4] = Output: 0\n    Explanation: Redistribute blocks to make all towers have equal height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and redistributing blocks will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to minimize the ugliness of the block towers by redistributing blocks between towers. The solution should efficiently handle up to 1000 test cases, each with up to 100 towers, and tower heights up to 10^7. The algorithm should focus on reducing the difference between the tallest and shortest towers to the minimum possible value.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness\n- Ensure the solution handles edge cases effectively\n- Optimize for performance with large inputs\n- Provide clear documentation and examples\n- Develop a user-friendly interface for input and output\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to equalize the heights as much as possible, which can be achieved by calculating the difference between the maximum and minimum heights in the input list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the context of this problem, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the initial maximum and minimum heights.\n3. The minimum possible ugliness is determined by redistributing blocks to equalize the heights as much as possible.\n4. The minimum ugliness is achieved when the difference between the maximum and minimum heights is minimized.\n5. Output the minimum possible ugliness for each test case.\n\n# [edge case] \n    Case 1: [1, 1, 1] = 0\n    Explanation: All towers are already of equal height, so the ugliness is 0.\n\n    Case 2: [1, 10000000] = 0\n    Explanation: With enough operations, we can redistribute blocks to make both towers have equal height, resulting in an ugliness of 0.\n\n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: By redistributing blocks, we can make all towers have equal height, resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating max(a) - min(a) after redistribution will handle these cases effectively.\n"], "scores": [], "pass_results": [false, false, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 922, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "add_1_sentence_at_end", "parent_index": 277}
