{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a with a size of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the smallest number k such that the array ceases to change after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a with a size of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the smallest number k such that the array ceases to change after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a with a size of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation. In other words, the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the smallest number k such that the array ceases to change after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a with a size of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x); the order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the smallest number k such that the array ceases to change after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_stabilization_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Finds the number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of test cases, each containing a list of integers representing the array.\n\n    Returns:\n        A list of integers where each integer represents the number of eversions required for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = find_stabilization_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Find the minimum number of eversions after which the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        eversion_count = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = find_minimum_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Find the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        max_element = case[-1]\n        k = 0\n        current_max = max_element\n        \n        # Iterate from the end to the beginning of the array\n        for i in range(n - 2, -1, -1):\n            if case[i] > current_max:\n                k += 1\n                current_max = case[i]\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the results\n    results = find_minimum_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Find the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        k = 0\n        current_array = case[:]\n        \n        while True:\n            x = current_array[-1]\n            left = [element for element in current_array if element <= x]\n            right = [element for element in current_array if element > x]\n            new_array = left + right\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = find_minimum_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef eversion_count(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of eversions after which the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = eversion_count(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef eversion_count(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions required for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        k = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Process test cases and get results\n    results = eversion_count(t, test_cases)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Find the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions needed for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        max_seen = case[-1]\n        eversion_count = 0\n        \n        # Iterate from the end to the beginning of the array\n        for i in range(n - 2, -1, -1):\n            if case[i] > max_seen:\n                eversion_count += 1\n                max_seen = case[i]\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = find_minimum_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef eversion_count(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        k = 0\n        current_array = case[:]\n        \n        while True:\n            x = current_array[-1]\n            left = [element for element in current_array if element <= x]\n            right = [element for element in current_array if element > x]\n            new_array = left + right\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\nnumber_of_test_cases = int(input())\ntest_cases = []\nfor _ in range(number_of_test_cases):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Output interface\nresults = eversion_count(number_of_test_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Find the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        current_array = case[:]\n        eversion_count = 0\n        \n        while True:\n            last_element = current_array[-1]\n            left_section = [x for x in current_array if x <= last_element]\n            right_section = [x for x in current_array if x > last_element]\n            new_array = left_section + right_section\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = find_minimum_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_minimum_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Finds the minimum number of eversions required for each test case\n    such that the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each test case is a list of integers.\n\n    Returns:\n        List[int]: List of integers where each integer is the number of eversions\n                   after which the array stops changing for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        last_element = a[-1]\n        eversion_count = 0\n        max_right = float('-inf')\n        \n        # Traverse the array from the end to the start\n        for i in range(n - 1, -1, -1):\n            if a[i] > last_element:\n                # If we find an element greater than the last element, it belongs to the right section\n                if a[i] > max_right:\n                    # If this is the largest element in the right section so far, increment eversion count\n                    eversion_count += 1\n                    max_right = a[i]\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = find_minimum_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires implementing an efficient algorithm to perform stable partitioning of an array based on the last element, repeatedly, until the array stops changing. The solution must handle multiple test cases and large input sizes efficiently.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the algorithm handles up to 200,000 elements.\n- Provide clear and concise output for each test case.\n- Maintain stability in the partitioning process.\n- Optimize for readability and maintainability.\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The key is to efficiently partition the array based on the last element and count the number of eversions needed for stabilization. We will use a simple loop to perform the partitioning and check for changes in the array. The algorithm will be efficient enough to handle the maximum constraints by leveraging Python's list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stabilization'\n    Explanation: Stabilization refers to the point at which further eversions do not change the array, meaning the array has reached a state where partitioning based on the last element no longer alters its order.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb] \n    'smallest number k': This refers to finding the minimum number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array is not stable:\n   - Perform an eversion operation:\n     - Identify x as the last element of the array.\n     - Partition the array into left (elements \u2264 x) and right (elements > x).\n     - Concatenate left and right to form a new array.\n   - Increment k.\n4. Check if the new array is identical to the previous one. If so, stop; otherwise, continue.\n5. Output k for each test case.\n\n# [edge case] \n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Case 2: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion will move one element to the right section until only one element remains in the left section.\n\n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of checking if the array has changed after each eversion will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of operations required for the array to stabilize. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear and concise output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that performs the eversion operation on the array as described. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. This process will be repeated until the array no longer changes. The solution will efficiently handle multiple test cases and large input sizes by minimizing unnecessary operations and using efficient data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'smallest': We need to find the minimum number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, read the array size n and the array a.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n        - Identify the last element x of the array.\n        - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n        - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is different from the previous one. If it is, increment the counter and repeat the process.\n    5. Stop when the array no longer changes and output the counter value.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array. The expected output is 0.\n\n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array. The expected output is 0.\n\n    Test case: [1, 2, 3, 4, 5] = 1\n    Explanation: After one eversion, the array becomes [1, 2, 3, 4, 5], which does not change further. The expected output is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no change occurs after an eversion.\n", "requirement analysis:\nThe requirements focus on implementing an eversion operation on an array and determining the number of operations needed for the array to stabilize. The solution must efficiently handle multiple test cases and large input sizes, ensuring performance optimization and accurate output.\nrequirement pool:\n- Implement the eversion operation correctly\n- Optimize the algorithm for large input sizes\n- Ensure accurate output for each test case\n- Handle edge cases gracefully\n- Provide clear documentation for the algorithm\nWe will implement the eversion operation by iterating over the array from the end to the beginning. The key observation is that the array stops changing when the largest element is at the end of the array. We will count how many elements need to be moved to the end to achieve this state. This approach ensures that we efficiently handle large input sizes by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves dividing the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then reformed by concatenating the left and right sections.\n\n    'smallest number k'\n    Explanation: This refers to the minimum number of eversions required for the array to reach a state where further eversions do not change it.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This means elements in the left section are less than or equal to x.\n    'strictly greater than x (> x)': This means elements in the right section are greater than x.\n\n# [degree adverb]\n    'smallest': This indicates finding the minimum number of eversions needed for the array to stabilize.\n\n# [code logic]\n1. For each test case, start with the given array.\n2. Initialize a counter for eversions, k = 0.\n3. Iterate from the end of the array to the beginning:\n   - Track the maximum element encountered so far.\n   - If an element is greater than this maximum, increment k and update the maximum.\n4. The value of k after processing the array is the answer for that test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 4\n    Explanation: Each element needs to be moved to the end one by one until the array is sorted in non-decreasing order.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by counting necessary eversions based on the maximum element encountered during iteration.\n", "requirement analysis:\nThe problem requires determining the number of eversions needed for an array to stabilize. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring that the partitioning operation is performed correctly and the output is accurate.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation.\n- Include edge case handling and validation.\nWe will implement a function that performs the eversion operation on the array. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. We will repeat this process until the array stops changing. The solution will efficiently handle multiple test cases by processing each test case independently and using a loop to determine the number of eversions required for stabilization.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stabilization'\n    Explanation: Stabilization occurs when further eversions do not change the array, meaning the array has reached a state where partitioning based on the last element results in no change.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This means elements in the left section are less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This means elements in the right section are greater than the last element of the array.\n\n# [degree adverb]\n    'smallest number k': This refers to the minimum number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array changes:\n   - Perform an eversion operation:\n     - Set x as the last element of the array.\n     - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n     - Concatenate left and right to form a new array.\n   - Increment k.\n4. Stop when the array no longer changes and output k.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: Similar to test case 1, all elements are equal, so no eversion is needed.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic inherently handles cases where no eversion is needed because it checks if the array changes after each eversion.\n", "requirement analysis:\nThe requirements focus on implementing an eversion operation on an array and determining the number of operations needed for the array to stabilize. The solution must handle multiple test cases efficiently and provide correct output for each case. The algorithm should be optimized for performance given the constraints on input size.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles large inputs efficiently\n- Optimize the algorithm for performance\n- Format the output correctly for each test case\n- Handle edge cases effectively\nWe will implement the eversion operation using a simple loop to partition the array into left and right sections based on the last element. The process will be repeated until the array stops changing. We will use Python's built-in list operations to efficiently handle the partitioning and concatenation. Given the constraints, the solution will be optimized to handle up to 200,000 elements across multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stable partition'\n    Explanation: The order of elements in each section remains the same as before the operation, meaning the partition is stable.\n\n# [phrase showing quantity relationship]\n    'not more than': means elements that are less than or equal to x (\u2264 x).\n    'strictly greater than': means elements that are greater than x (> x).\n\n# [degree adverb] \n    'smallest': means we need to find the minimum number of eversions after which the array stops changing.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array changes:\n   - Set x as the last element of the array.\n   - Partition the array into left (elements \u2264 x) and right (elements > x) sections.\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. Stop when the array no longer changes and output k.\n\n# [edge case] \n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion moves one element to the right section until only one element remains in the left section.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes it.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe task requires implementing a function that performs a stable partitioning operation on an array until it no longer changes. The challenge is to determine the minimum number of operations needed for the array to stabilize. The solution must handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the solution handles up to 100 test cases efficiently\n- Optimize the solution for large input sizes\n- Maintain code readability and simplicity\n- Include comments and documentation for clarity\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. We will use a loop to perform eversions until the array no longer changes, and count the number of eversions required. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stabilizes'\n    Explanation: The array is said to stabilize when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not more than': means elements in the left section are less than or equal to x.\n    'strictly greater than': means elements in the right section are greater than x.\n\n# [degree adverb] \n    'smallest': means we need to find the minimum number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array changes:\n   - Set x as the last element of the array.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. When the array no longer changes, output k.\n\n# [edge case] \n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion will move one element to the right section until only one element remains in the left section.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe problem requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of operations needed for the array to stabilize. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation for the code.\n- Include test cases to verify the correctness of the solution.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The key observation is that the array stabilizes when the maximum element is at the end of the array. We will iterate from the end of the array to the beginning, counting how many elements are greater than the current maximum seen so far. This count will give us the number of eversions needed for the array to stabilize. This approach ensures that we efficiently handle the maximum input size.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. Elements less than or equal to x form the left section, and elements greater than x form the right section. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'smallest': We need to find the minimum number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Iterate from the end of the array to the beginning.\n    3. Track the maximum element seen so far.\n    4. Count elements greater than this maximum.\n    5. The count gives the number of eversions needed for stabilization.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and already in a stable state, so no eversion is needed.\n    \n    Input: [10, 9, 8, 7, 6] = 4\n    Explanation: Each element is greater than the next, requiring multiple eversions until stabilization.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles these scenarios by counting necessary eversions based on the maximum element seen so far.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of operations needed for the array to stabilize. The solution must handle multiple test cases efficiently, with constraints on the size of the array and the number of test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements\n- Ensure the solution handles up to 100 test cases efficiently\n- Optimize the algorithm for large input sizes up to 2 \u22c5 10^5\n- Provide clear and correct output for each test case\n- Maintain code readability and simplicity\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. We will use a loop to perform eversions until the array no longer changes, and count the number of eversions required. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced with the concatenation of these two sections.\n\n    'stabilizes'\n    Explanation: The array is said to stabilize when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not more than': means elements in the left section are less than or equal to x.\n    'strictly greater than': means elements in the right section are greater than x.\n\n# [degree adverb] \n    'smallest': means we need to find the minimum number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array changes:\n   - Set x as the last element of the array.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. When the array no longer changes, output k.\n\n# [edge case] \n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion, the array becomes [1, 5, 4, 3, 2], which is stable after one more eversion.\n\n    Test case 3: [1] = 0\n    Explanation: A single-element array is already stable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after each eversion.\n", "requirement analysis:\nThe requirements focus on processing arrays through a defined eversion operation until they stabilize. The solution must handle multiple test cases efficiently, ensuring that the sum of elements does not exceed the given limit. The output should be the smallest number of eversions needed for stabilization.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles multiple test cases efficiently\n- Optimize the code for large input sizes\n- Provide accurate and consistent output\n- Document the code for clarity and maintenance\nWe will implement the eversion operation by iterating over the array and partitioning it into two sections based on the last element. We will continue this process until the array stops changing. The key challenge is to efficiently determine when the array stabilizes, which can be achieved by checking if the array remains the same after an eversion. We will use a simple loop to perform eversions and a condition to check for stabilization. The solution will handle multiple test cases by iterating over each test case and applying the eversion logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'smallest': We need to find the minimum number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, read the array size n and the array a.\n    2. Initialize a counter for eversions.\n    3. Perform the eversion operation:\n       - Identify the last element x of the array.\n       - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n       - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is identical to the previous array. If it is, stop; otherwise, increment the eversion counter and repeat.\n    5. Output the number of eversions for each test case.\n\n# [edge case]\n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Case 3: [1, 2, 3, 4, 5] = 1\n    Explanation: After one eversion with x = 5, the array does not change further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array remains unchanged after an eversion.\n", "requirement analysis:\nThe requirement involves performing a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of operations needed for the array to stabilize. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm to minimize computational complexity.\n- Provide clear documentation and examples for understanding the process.\n- Enhance user experience with concise output formatting.\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. We will count the number of eversions required for the array to stop changing. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This means elements in the left section are less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This means elements in the right section are greater than the last element of the array.\n\n# [degree adverb]\n    'smallest': We need to find the minimum number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, read the array size n and the array a.\n    2. Initialize a counter for eversions.\n    3. Perform the eversion operation:\n        - Identify the last element x of the array.\n        - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n        - Concatenate left and right sections to form a new array.\n    4. Check if the new array is identical to the previous array. If it is, stop; otherwise, increment the counter and repeat.\n    5. Output the counter as the number of eversions after which the array stops changing.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array; hence, k = 0.\n    \n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array; hence, k = 0.\n    \n    Test case: [1, 2, 3, 4, 5] = 1\n    Explanation: The first eversion results in [1, 2, 3, 4], [5] \u2192 [1, 2, 3, 4, 5], which is identical to the original array; hence, k = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after each eversion.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 896, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "rephrase_one", "parent_index": 380}
