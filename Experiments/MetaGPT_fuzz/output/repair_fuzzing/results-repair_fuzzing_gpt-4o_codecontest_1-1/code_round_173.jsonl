{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider whether redistributing the blocks evenly can minimize this ugliness.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider whether redistributing the blocks evenly can minimize this ugliness.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i. You are part of a building crew. You want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider whether redistributing the blocks evenly can minimize this ugliness.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible by choosing two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and moving a block from tower i to tower j in a single day, which essentially decreases a_i by 1 and increases a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings, and this is formally defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Consider whether redistributing the blocks evenly can minimize this ugliness.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // num_towers\n        remainder = total_blocks % num_towers\n        \n        # Determine the minimum possible ugliness\n        if remainder == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        heights = list(map(int, input().strip().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate average height\n        average_height = total_blocks / num_towers\n        \n        # Determine floor and ceiling of average height\n        floor_height = int(average_height)\n        ceiling_height = floor_height if average_height == floor_height else floor_height + 1\n        \n        # Calculate minimum possible ugliness\n        min_ugliness = ceiling_height - floor_height\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Calculate results\n    results = minimum_ugliness(t, test_cases)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport math\n\ndef minimum_ugliness(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of towers and their heights.\n\n    Returns:\n        list: List of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks / n\n        floor_height = math.floor(average_height)\n        ceil_height = math.ceil(average_height)\n\n        # Calculate the number of towers that can have floor_height and ceil_height\n        floor_count = sum(1 for h in heights if h <= floor_height)\n        ceil_count = n - floor_count\n\n        # Calculate the minimum ugliness\n        min_ugliness = ceil_height - floor_height if ceil_count > 0 else 0\n        results.append(min_ugliness)\n\n    return results\n\n# Input interface\nnum_test_cases = int(input())\ntest_cases = []\nfor _ in range(num_test_cases):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    test_cases.append((n, heights))\n\n# Call the function and print results\nresults = minimum_ugliness(num_test_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing a list of tower heights.\n\n    Returns:\n        List[int]: A list of minimum possible ugliness values for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Calculate the average height each tower should have\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all towers can be perfectly balanced\n        # If remainder is not 0, the difference will be 1\n        min_ugliness = 1 if remainder != 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the number of towers that should have the average height\n        remainder = total_blocks % n\n        # Minimum ugliness is determined by the difference between the tallest and shortest possible heights\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport math\n\ndef minimum_ugliness(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of towers and their heights.\n\n    Returns:\n        list: List of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks / n\n        floor_height = math.floor(average_height)\n        ceil_height = math.ceil(average_height)\n\n        # Calculate how many towers can have the floor height and how many can have the ceil height\n        num_floor = n * ceil_height - total_blocks\n        num_ceil = n - num_floor\n\n        # Calculate the minimum ugliness\n        min_ugliness = ceil_height - floor_height if num_floor > 0 and num_ceil > 0 else 0\n        results.append(min_ugliness)\n\n    return results\n\n# Input interface\nnum_test_cases = int(input())\ntest_cases = []\nfor _ in range(num_test_cases):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    test_cases.append((n, heights))\n\n# Function call\nresults = minimum_ugliness(num_test_cases, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n\n        # Sort the heights to facilitate redistribution\n        heights.sort()\n\n        # Calculate the minimum ugliness\n        # We need to distribute the remainder blocks to make the heights as even as possible\n        # The first `remainder` towers will have `average_height + 1` blocks\n        # The rest will have `average_height` blocks\n        min_height = average_height\n        max_height = average_height + (1 if remainder > 0 else 0)\n\n        # Calculate the ugliness\n        ugliness = max_height - min_height\n        results.append(ugliness)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        # Sort the heights to facilitate redistribution\n        heights.sort()\n        \n        # Calculate the initial ugliness\n        initial_ugliness = heights[-1] - heights[0]\n        \n        # Since we can redistribute blocks, the minimum possible ugliness\n        # is determined by the difference between the maximum and minimum\n        # heights after redistribution.\n        # In a sorted list, the minimum possible ugliness is always 1 or 0.\n        # If the difference between the max and min is 0 or 1, we cannot reduce it further.\n        # Otherwise, we can always make it 1 by redistributing blocks.\n        if initial_ugliness <= 1:\n            results.append(initial_ugliness)\n        else:\n            results.append(1)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Output interface\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing a list of tower heights.\n\n    Returns:\n        A list of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate average height\n        average_height = total_blocks / num_towers\n        \n        # Calculate floor and ceiling of average height\n        floor_height = int(average_height)\n        ceiling_height = floor_height if average_height == floor_height else floor_height + 1\n        \n        # Calculate the number of towers that should have floor_height and ceiling_height\n        num_floor_height = num_towers * ceiling_height - total_blocks\n        num_ceiling_height = num_towers - num_floor_height\n        \n        # Calculate the minimum ugliness\n        min_ugliness = ceiling_height - floor_height if num_floor_height > 0 and num_ceiling_height > 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    test_cases.append(heights)\n\n# Output interface\nresults = minimum_ugliness(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate average height\n        average_height = total_blocks // num_towers\n        \n        # Determine if the total blocks are perfectly divisible by the number of towers\n        if total_blocks % num_towers == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires redistributing blocks among towers to minimize the height difference between the tallest and shortest towers. The solution should efficiently handle up to 1000 test cases with up to 100 towers each, where tower heights can be as large as 10^7. The key is to determine if the blocks can be evenly distributed or if a minimal difference remains.\nrequirement pool:\n- Implement an efficient algorithm to calculate minimum ugliness.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide detailed comments and documentation for the algorithm.\n- Optimize the algorithm for speed and memory usage.\n- Include edge case handling and validation.\nWe will implement a function that calculates the minimum possible ugliness by redistributing the blocks among the towers. The key idea is to find the average height and determine the minimum difference between the tallest and shortest towers after redistribution. We will use basic arithmetic operations to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing the blocks evenly'\n    Explanation: This means moving blocks between towers to make their heights as equal as possible, thereby minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to achieving the smallest possible value of max(a) - min(a) after redistributing the blocks. In code, this can be implemented by calculating the difference between the maximum and minimum heights after redistribution.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that we need to find the smallest possible value of ugliness. In code, this involves redistributing blocks to make tower heights as equal as possible.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks across all towers.\n2. Compute the average height by dividing the total number of blocks by the number of towers.\n3. Determine the minimum possible ugliness by considering the remainder when dividing total blocks by number of towers.\n4. If the remainder is zero, all towers can be made equal, resulting in an ugliness of 0.\n5. If there is a remainder, some towers will be one block taller than others, resulting in an ugliness of 1.\n\n# [edge case]\n    Test case 1: 2\n                 1 1\n    Expected output: 0\n    Explanation: Both towers are already equal in height, so the ugliness is 0.\n\n    Test case 2: 3\n                 1 1 2\n    Expected output: 0\n    Explanation: By moving one block from the third tower to either of the first two, all towers can be made equal in height.\n\n    Test case 3: 4\n                 1 1 1 4\n    Expected output: 1\n    Explanation: After redistributing blocks, three towers can have a height of 2 and one tower will have a height of 3, resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the average and considering the remainder will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 towers each, ensuring scalability and clarity in output.\nrequirement pool:\n- Implement algorithm to minimize ugliness efficiently.\n- Ensure solution scalability for large number of test cases.\n- Provide clear and concise output format.\n- Optimize code for readability and maintainability.\n- Include comments and documentation for understanding.\nWe will implement a function to calculate the minimum possible ugliness by redistributing blocks among towers. The key observation is that the minimum ugliness is determined by the difference between the ceiling and floor of the average height of the towers. We will use Python's built-in functions to efficiently compute this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks evenly'\n    Explanation: This means moving blocks between towers to make their heights as equal as possible, thereby minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to achieving the smallest difference between the tallest and shortest towers after redistributing blocks. In code, this can be implemented by calculating the difference between the maximum and minimum heights after redistribution.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest value achievable for the ugliness, which is the difference between the maximum and minimum tower heights after redistribution. In code, this involves finding the minimum value of max(a) - min(a) after possible redistributions.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks across all towers.\n2. Compute the average height by dividing the total number of blocks by the number of towers.\n3. Determine the floor and ceiling of this average height.\n4. Calculate the minimum possible ugliness as the difference between these two values.\n5. Output this minimum ugliness for each test case.\n\n# [edge case]\n    Test case 1: 2\n                 1 1\n    Expected output: 0\n    Explanation: Both towers are already of equal height, so no redistribution is needed, resulting in an ugliness of 0.\n\n    Test case 2: 3\n                 1 1 10\n    Expected output: 0\n    Explanation: Redistribute blocks to make all towers of height 4, resulting in an ugliness of 0.\n\n    Test case 3: 4\n                 1 1 1 10\n    Expected output: 1\n    Explanation: Redistribute blocks to make three towers of height 3 and one tower of height 4, resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks based on average height will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle multiple test cases and large numbers, ensuring accurate results.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles multiple test cases efficiently.\n- Optimize for large input sizes.\n- Provide clear and accurate output format.\n- Enhance user experience with intuitive input handling.\nWe will implement a function that calculates the minimum possible ugliness by redistributing the blocks among the towers. The key observation is that the minimum ugliness is determined by the difference between the ceiling and floor of the average height of the towers. We will use the math library to efficiently compute the ceiling and floor values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing the blocks evenly'\n    Explanation: This means adjusting the heights of the towers such that the difference between the tallest and shortest is minimized, ideally making all towers have similar heights.\n\n# [phrase showing quantity relationship]\n    'difference between the tallest and shortest buildings'\n    Explanation: This refers to the subtraction of the minimum height from the maximum height in the list of tower heights. In code, this can be implemented as `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of ugliness that can be achieved by redistributing blocks. In code, this involves calculating the smallest possible value of `max(a) - min(a)` after redistribution.\n\n# [code logic]\n    1. For each test case, calculate the total number of blocks.\n    2. Compute the average height by dividing the total number of blocks by the number of towers.\n    3. Use ceiling and floor functions to determine the possible heights that can minimize ugliness.\n    4. Calculate the minimum possible ugliness using these values.\n    5. Return the result for each test case.\n\n# [edge case]\n    Case 1: All towers have equal height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all towers are already equal, no redistribution is needed, and ugliness is 0.\n\n    Case 2: Towers with heights that can be evenly distributed.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: Blocks can be redistributed to make all towers have equal height, resulting in ugliness of 0.\n\n    Case 3: Towers with heights that cannot be perfectly equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the closest possible equal heights result in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks based on average height will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle multiple test cases and large input sizes, ensuring the minimum possible ugliness is achieved.\nrequirement pool:\n- Implement algorithm to minimize ugliness efficiently.\n- Ensure solution scalability for large datasets.\n- Provide clear output format for multiple test cases.\n- Handle edge cases effectively.\n- Optimize for performance and speed.\nWe will implement a function to calculate the minimum possible ugliness by redistributing blocks among towers. The approach involves calculating the total number of blocks and determining the average height each tower should have. We will then calculate the maximum and minimum possible heights after redistribution to find the minimum ugliness. This approach ensures efficiency and scalability for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks evenly'\n    Explanation: This means adjusting the heights of the towers such that the difference between the tallest and shortest is minimized, ideally making all towers have the same or nearly the same height.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This refers to achieving the smallest possible value for max(a) - min(a) after redistributing blocks. In code, this means finding a way to balance the heights of the towers as evenly as possible.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The smallest value that can be achieved for the ugliness. In code, this involves calculating the average height and determining how close we can get all towers to this average.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks across all towers.\n2. Determine the average height each tower should have by dividing the total number of blocks by the number of towers.\n3. Calculate the maximum and minimum possible heights after redistribution.\n4. The minimum ugliness is determined by the difference between these maximum and minimum heights.\n5. Return this minimum ugliness for each test case.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already equal.\n\n    Case 2: Towers can be perfectly balanced.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: Redistribution can make all towers equal in height.\n\n    Case 3: Towers cannot be perfectly balanced.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: Redistribution can only minimize the difference to 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating total blocks and redistributing them to achieve minimum ugliness inherently handles these cases.\n", "requirement analysis:\nThe task requires redistributing blocks among towers to minimize the height difference between the tallest and shortest towers. The solution should efficiently handle up to 1000 test cases, each with up to 100 buildings, and building heights up to 10^7. The goal is to achieve the minimum possible ugliness, defined as the difference between the maximum and minimum heights after redistribution.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear input and output handling for multiple test cases.\n- Optimize the algorithm for performance with large numbers.\n- Include comments and documentation for code clarity.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks among towers. The approach involves calculating the total number of blocks and determining the average height each tower should have. We will then calculate the minimum ugliness by finding the difference between the maximum and minimum possible heights after redistribution. This can be efficiently achieved using basic arithmetic operations without the need for complex algorithms, ensuring the solution handles the maximum constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks evenly'\n    Explanation: This means adjusting the heights of the towers such that the difference between the tallest and shortest is minimized, ideally making them as equal as possible.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This refers to the subtraction of the minimum height from the maximum height among the towers. In code, this can be implemented as `max(heights) - min(heights)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible value for ugliness. In code, this involves redistributing blocks to minimize `max(a) - min(a)`.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the total number of blocks across all towers.\n3. Determine the average height each tower should have by dividing the total blocks by the number of towers.\n4. Calculate the minimum possible ugliness by considering the difference between the maximum and minimum possible heights after redistribution.\n5. Output the minimum ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: 3\n           3\n           10 10 10\n    Expected Output: 0\n    Explanation: No redistribution needed as all towers are already equal.\n\n    Case 2: Towers can be made equal with simple redistribution.\n    Input: 4\n           4\n           3 2 1 2\n    Expected Output: 0\n    Explanation: Redistribute blocks to make all towers of height 2.\n\n    Case 3: Towers cannot be made completely equal.\n    Input: 5\n           5\n           1 2 3 1 5\n    Expected Output: 1\n    Explanation: After redistribution, the closest equal heights are [2, 2, 3, 2, 3], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks based on average height and calculating max-min difference will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 towers each, ensuring scalability and clarity in output.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear output format for user understanding.\n- Optimize for performance in edge cases.\n- Include comprehensive test coverage.\nWe will calculate the total number of blocks and determine the average height each tower should have to minimize the ugliness. The minimum possible ugliness is determined by the difference between the maximum and minimum possible heights after redistributing the blocks as evenly as possible. This can be achieved by calculating the ceiling and floor of the average height and checking the difference.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing the blocks evenly'\n    Explanation: This means adjusting the heights of the towers such that the difference between the tallest and shortest is minimized, ideally making all towers have similar heights.\n\n# [phrase showing quantity relationship]\n    'difference between the tallest and shortest'\n    Explanation: This refers to the subtraction of the minimum height from the maximum height in the list of tower heights. In code, this can be implemented using `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum possible ugliness'\n    Explanation: This means achieving the smallest possible value for the difference between the tallest and shortest buildings after redistributing blocks. In code, this involves finding a way to make `max(a) - min(a)` as small as possible.\n\n# [code logic]\n1. Calculate the total number of blocks across all towers.\n2. Determine the average height each tower should have by dividing the total number of blocks by the number of towers.\n3. Calculate both the floor and ceiling of this average height.\n4. Redistribute blocks to make most towers have heights close to these calculated average values.\n5. Compute the difference between the maximum and minimum heights after redistribution to find the minimum possible ugliness.\n\n# [edge case]\n    Input: 2\n           2\n           1 1\n    Output: 0\n    Explanation: Both towers already have equal heights, so no redistribution is needed, and ugliness is 0.\n\n    Input: 3\n           3\n           1 1 10\n    Output: 0\n    Explanation: Redistribute blocks from tower 3 to towers 1 and 2 until all towers have equal heights.\n\n    Input: 4\n           4\n           1 1 1 10\n    Output: 1\n    Explanation: After redistribution, it is impossible to make all towers have exactly equal heights due to integer constraints, but we can minimize ugliness to 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks evenly will naturally handle these scenarios by aiming to minimize the difference between max and min heights.\n", "requirement analysis:\nThe task requires developing an algorithm to minimize the height difference between the tallest and shortest buildings by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 buildings each, where each building's height can be as large as 10^7. The goal is to achieve the minimum possible ugliness, defined as the difference between the maximum and minimum heights after redistribution.\nrequirement pool:\n- Develop an algorithm to calculate minimum ugliness\n- Ensure the algorithm handles maximum constraints efficiently\n- Provide clear and concise output for each test case\n- Optimize the algorithm for performance\n- Include detailed comments and documentation\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key idea is to find the difference between the maximum and minimum heights after redistributing blocks to make the heights as even as possible. This can be achieved by sorting the heights and calculating the difference between the maximum and minimum values after potential redistribution.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks evenly'\n    Explanation: This means moving blocks between towers to make their heights as equal as possible, thereby minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This refers to the difference between the maximum and minimum heights of the towers. In code, this can be implemented as `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible value of ugliness, which is the smallest difference between the tallest and shortest buildings. This can be implemented by redistributing blocks to make heights as even as possible.\n\n# [code logic]\n    1. For each test case, read the number of towers and their respective heights.\n    2. Sort the list of heights.\n    3. Calculate the total number of blocks and determine the average height.\n    4. Redistribute blocks to make heights as close to the average as possible.\n    5. Calculate the difference between the maximum and minimum heights after redistribution.\n    6. Return this difference as the minimum possible ugliness.\n\n# [edge case]\n    Case 1: Input: 2 towers with equal height, e.g., [5, 5] = 0\n    Explanation: Since both towers have equal height, no redistribution is needed, and ugliness is already minimized to 0.\n\n    Case 2: Input: Towers with heights that can be evenly redistributed, e.g., [3, 3, 3] = 0\n    Explanation: All towers have equal height, so no redistribution is needed, and ugliness is minimized to 0.\n\n    Case 3: Input: Towers with one significantly taller tower, e.g., [1, 1, 10] = 0\n    Explanation: Blocks can be redistributed from the tallest tower to others to achieve equal heights, minimizing ugliness to 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks evenly will naturally handle these cases by ensuring all towers have equal or nearly equal heights.\n", "requirement analysis:\nThe task requires redistributing blocks between towers to minimize the height difference, defined as ugliness. The solution should efficiently handle multiple test cases and large input sizes, ensuring the minimum possible ugliness is achieved.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Optimize for large input sizes\n- Ensure accurate output format\n- Handle edge cases effectively\n- Improve user experience with clear instructions\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key is to find the difference between the maximum and minimum heights after redistributing blocks as evenly as possible. We will use a simple approach by sorting the heights and calculating the difference between the maximum and minimum heights after potential redistribution.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, which is calculated as max(a) - min(a).\n\n    'redistributing blocks evenly'\n    Explanation: This means moving blocks from taller towers to shorter ones to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This refers to achieving the smallest possible value of max(a) - min(a) after redistributing blocks. In code, this involves iterating through possible redistributions to find the configuration with the smallest height difference.\n\n# [degree adverb] \n    'minimum': \n    Explanation: This indicates that the goal is to reduce the ugliness to the smallest possible value. In code, this involves finding the configuration with the smallest max(a) - min(a).\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Sort the list of building heights.\n3. Calculate the initial ugliness as max(a) - min(a).\n4. Consider redistributing blocks to minimize this difference:\n   - Move blocks from taller towers to shorter ones.\n   - Calculate potential new ugliness after each redistribution.\n5. Return the minimum ugliness found for each test case.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already of equal height.\n\n    Case 2: Towers are already in a balanced state after minimal redistribution.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By moving one block from tower 1 to tower 3, all towers can be made equal in height.\n\n    Case 3: Towers with a large initial height difference.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistributing blocks optimally, the minimum possible ugliness is achieved with a difference of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and redistributing blocks will naturally handle these scenarios by minimizing the height difference.\n", "requirement analysis:\nThe problem requires determining the minimum possible difference between the tallest and shortest towers after redistributing blocks. The key is to understand that redistributing blocks to achieve an even distribution minimizes the ugliness. The solution should efficiently handle up to 1000 test cases with each having up to 100 towers.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles maximum constraints efficiently.\n- Optimize the code for readability and maintainability.\n- Include edge case handling in the solution.\n- Provide detailed comments and documentation for the code.\nWe will iterate through each test case, calculate the total number of blocks, and determine the average height each tower should have to minimize the ugliness. The minimum possible ugliness is determined by the difference between the maximum and minimum possible heights after redistributing the blocks as evenly as possible. This can be achieved by calculating the ceiling and floor of the average height and checking the difference between them.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n    'redistributing the blocks evenly'\n    Explanation: This means adjusting the heights of the towers such that they are as close to each other as possible, ideally making all towers have the same height.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This refers to the subtraction of the minimum height from the maximum height in the list of tower heights. In code, this can be implemented using `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement asks for the smallest possible value of ugliness after redistributing blocks. This can be implemented by trying to make all tower heights as equal as possible.\n\n# [code logic]\n    1. For each test case, calculate the total number of blocks across all towers.\n    2. Determine the average height each tower should have by dividing the total number of blocks by the number of towers.\n    3. Calculate the floor and ceiling of this average height.\n    4. Redistribute blocks to make tower heights as close to this average as possible.\n    5. Calculate the ugliness as the difference between the maximum and minimum heights after redistribution.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected output: 0\n    Explanation: Since all towers are already equal, no redistribution is needed, and ugliness is 0.\n\n    Case 2: Towers can be made equal with redistribution.\n    Input: [3, 2, 1, 2]\n    Expected output: 0\n    Explanation: Redistributing blocks can make all towers have a height of 2, resulting in ugliness of 0.\n\n    Case 3: Towers cannot be made completely equal.\n    Input: [1, 2, 3, 1, 5]\n    Expected output: 1\n    Explanation: After redistribution, the closest we can get is [2, 2, 3, 2, 3], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks evenly and calculating max(a) - min(a) will handle these cases correctly.\n", "requirement analysis:\nThe main requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 buildings each, where each building height can be as large as 10^7.\nrequirement pool:\n- Implement the algorithm to minimize ugliness by redistributing blocks.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear input and output handling for multiple test cases.\n- Optimize the algorithm for performance with large inputs.\n- Include detailed comments and documentation for maintainability.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks among towers. The approach involves calculating the total number of blocks and determining the average height each tower should have. The minimum ugliness is then the difference between the maximum and minimum possible heights after redistribution. We will use basic Python operations and avoid complex data structures to ensure efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks evenly'\n    Explanation: This refers to the process of moving blocks between towers to make their heights as equal as possible, thereby minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) that can be achieved by redistributing blocks.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The smallest possible value of ugliness after redistributing blocks.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks across all towers.\n2. Determine the average height each tower should have by dividing the total number of blocks by the number of towers.\n3. Calculate the minimum possible ugliness by considering the difference between the maximum and minimum heights after redistribution.\n4. If the total number of blocks is perfectly divisible by the number of towers, the minimum ugliness is 0; otherwise, it is 1.\n\n# [edge case] \n    Test case 1: [1, 1, 1] = 0\n    Explanation: All towers are already of equal height, so no redistribution is needed, and ugliness is 0.\n\n    Test case 2: [1, 1, 1, 4] = 1\n    Explanation: Redistribute one block from the tallest tower to one of the shortest towers to achieve heights [2, 2, 1, 2], resulting in an ugliness of 1.\n\n    Test case 3: [10^7, 10^7, 10^7] = 0\n    Explanation: All towers are already of equal height, so no redistribution is needed, and ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating total blocks and redistributing them evenly will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 173, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "add_1_sentence_at_end", "parent_index": 40}
