{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of people that are friends with one another. The people of Baltia want to organize a successful party, which is a gathering of exactly 5 people, but they have very strict rules on what a party is and when the party is successful. The party is considered to be successful if either all the people at the party are friends with each other. This means that they can all talk to each other without having to worry about talking to someone they are not friends with, or none of the people at the party are friends with each other, which allows everyone to just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Remember to consider edge cases where friendships might form interconnected groups.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of people that are friends with one another. The people of Baltia want to organize a successful party, which is a gathering of exactly 5 people, but they have very strict rules on what a party is and when the party is successful. The party is considered to be successful if either all the people at the party are friends with each other. This means that they can all talk to each other without having to worry about talking to someone they are not friends with, or none of the people at the party are friends with each other, which allows everyone to just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Remember to consider edge cases where friendships might form interconnected groups.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of people that are friends with one another. The people of Baltia want to organize a successful party, which is a gathering of exactly 5 people, but they have very strict rules on what a party is and when the party is successful. The party is considered to be successful if either all the people at the party are friends with each other. This means that they can all talk to each other. They do not have to worry about talking to someone they are not friends with, or none of the people at the party are friends with each other, which allows everyone to just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Remember to consider edge cases where friendships might form interconnected groups.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of people that are friends with one another. The people of Baltia want to organize a successful party, which is a gathering of exactly 5 people, but they have very strict rules on what a party is and when it's successful if either all the people at the party are friends with each other. This means that they can all talk to each other without having to worry about talking to someone they are not friends with, or none of the people at the party are friends with each other, which allows everyone to just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Remember to consider edge cases where friendships might form interconnected groups.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of exactly 5 people where either all are friends or none are friends.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph from the friendships\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    A successful party is defined as a group of 5 people where either all are\n    friends with each other (a clique) or none are friends with each other\n    (an independent set).\n\n    Args:\n        N: The number of people in Baltia.\n        M: The number of friendships.\n        friendships: A list of tuples representing pairs of friends.\n\n    Returns:\n        A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by checking the complement graph for cliques.\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nN, M = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Call the function\nresult = find_successful_party(N, M, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of exactly 5 people where either all are friends or none are friends.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of exactly 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people in Baltia.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for nodes in nx.find_cliques(graph):\n        if len(nodes) == 5:\n            return nodes\n\n    # Check for an independent set of size 5\n    # An independent set can be found by checking complement graph for a clique\n    complement_graph = nx.complement(graph)\n    for nodes in nx.find_cliques(complement_graph):\n        if len(nodes) == 5:\n            return nodes\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of exactly 5 people in Baltia.\n\n    Args:\n        n (int): Number of people in Baltia.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of nodes with no edges between them\n    # We can find independent sets by checking complement graph cliques\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of exactly 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people in Baltia.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for cliques of size 5\n    for subset in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(subset, 2)):\n            return list(subset)\n\n    # Check for independent sets of size 5\n    for subset in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(subset, 2)):\n            return list(subset)\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Function call\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    from itertools import combinations\n\n    for combination in combinations(range(1, n + 1), 5):\n        if is_clique(combination) or is_independent_set(combination):\n            return list(combination)\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of exactly 5 people either all friends or none friends.\n\n    Args:\n        n (int): Number of people in Baltia.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check for cliques of size 5\n    for person in range(1, n + 1):\n        # Attempt to build a clique starting from this person\n        potential_clique = [person]\n        for friend in adjacency_list[person]:\n            if len(potential_clique) < 5:\n                potential_clique.append(friend)\n        if len(potential_clique) == 5 and is_clique(potential_clique):\n            return potential_clique\n\n    # Check for independent sets of size 5\n    for person in range(1, n + 1):\n        # Attempt to build an independent set starting from this person\n        potential_independent_set = [person]\n        for other in range(1, n + 1):\n            if other != person and other not in adjacency_list[person]:\n                potential_independent_set.append(other)\n            if len(potential_independent_set) == 5:\n                break\n        if len(potential_independent_set) == 5 and is_independent_set(potential_independent_set):\n            return potential_independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of exactly 5 people where either all are friends or none are friends.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by checking the complement graph for cliques.\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe requirement is to determine if a group of 5 people can form a successful party based on their friendship connections. The solution must efficiently handle up to 200,000 people and friendships, ensuring that either all or none of the selected group are friends. The challenge lies in efficiently checking these conditions within the given constraints.\nrequirement pool:\n- Efficiently check if a group of 5 people can form a successful party.\n- Handle large input sizes up to 200,000 people and friendships.\n- Provide clear and correct output for all test cases.\n- Consider edge cases where friendships form interconnected groups.\n- Optimize for both time and space complexity.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and use the NetworkX library to efficiently check for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). NetworkX provides efficient algorithms for finding cliques and independent sets, which will help us handle large input sizes within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'friendship'\n    Explanation: Friendship is represented as pairs of people who can communicate directly with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group selected for the party contains exactly 5 people.\n\n# [degree adverb]\n    'successful': The party is successful if it meets the criteria of either all being friends or none being friends.\n    Implementation: Check for cliques of size 5 or independent sets of size 5 in the graph.\n\n# [code logic]\n    - Represent the friendships as an undirected graph using NetworkX.\n    - Check for cliques of size 5 using NetworkX's clique finding algorithms.\n    - Check for independent sets of size 5 using NetworkX's algorithms for finding independent sets.\n    - If a clique or independent set of size 5 is found, print the members. Otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no group of exactly 5 can be completely independent.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using NetworkX's algorithms will naturally handle these scenarios by checking for cliques and independent sets.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle large inputs and edge cases where friendships form interconnected groups.\nrequirement pool:\n- Develop an algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints efficiently.\n- Optimize the algorithm for speed and memory usage.\n- Provide clear and concise output as per the problem statement.\n- Consider edge cases and validate with multiple test scenarios.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We will utilize the NetworkX library for efficient graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'friendship'\n    Explanation: Friendship is represented as pairs of people who are friends, forming edges in a graph.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': means the party must consist of precisely 5 individuals.\n    Explanation: The requirement specifies that the party must have exactly 5 people, which is a fixed quantity.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using NetworkX.\n2. Check for cliques of size 5 in the graph.\n3. Check for independent sets of size 5 in the graph.\n4. If either a clique or an independent set of size 5 is found, print the members.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, all people form an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 forms a clique.\n\n    Input: 10 0\n    Output: Any combination of 5 people\n    Explanation: With no friendships, any group of 5 forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on strict friendship rules. The solution must efficiently handle large inputs and provide clear output. Edge cases involving interconnected groups must be considered.\nrequirement pool:\n- Implement an algorithm to check if a group of 5 people can form a successful party.\n- Ensure the solution handles up to 200,000 people and friendships efficiently.\n- Consider edge cases where friendships form interconnected groups.\n- Provide clear output format as specified in the requirements.\n- Optimize the solution for performance and scalability.\nWe will use graph theory to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these subgraphs using combinatorial techniques and efficient graph traversal methods.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent. In this context, it means none of the 5 people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 people.\n    Implementation: Ensure the selection of 5 people from the graph.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5:\n        - Iterate through combinations of 5 people and check if all pairs within the combination are friends.\n    3. Check for an independent set of size 5:\n        - Iterate through combinations of 5 people and check if no pairs within the combination are friends.\n    4. If either condition is met, print the combination; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 3\n    Output: -1\n    Explanation: Not enough friendships or lack of independence to form a successful party.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship connections. The solution must efficiently handle large datasets and provide clear output. Edge cases, such as interconnected friendship groups, must be considered.\nrequirement pool:\n- Efficiently check for successful party conditions.\n- Handle large input sizes up to 200,000 people and friendships.\n- Provide clear output indicating party possibility.\n- Consider edge cases with interconnected friendship groups.\n- Optimize for speed and memory usage.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. NetworkX, a Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks, will be used to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n\n    'independent set'\n    Explanation: An independent set is a set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using adjacency lists.\n2. Check for a clique of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if every pair within the group is friends.\n3. Check for an independent set of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if no pair within the group is friends.\n4. If either a clique or an independent set is found, print the group of 5 people.\n5. If no such group is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 10 0\n    Output: Any combination of 5 people\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The solution must efficiently handle up to 200,000 people and friendships, suggesting the use of graph algorithms that can manage large datasets.\nrequirement pool:\n- Implement a function to check for cliques of size 5.\n- Implement a function to check for independent sets of size 5.\n- Optimize the solution to handle the upper constraint limits efficiently.\n- Ensure the solution is robust against edge cases.\n- Provide clear and concise output formatting.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and use algorithms to detect cliques and independent sets of size 5. The NetworkX library will be used for efficient graph operations, as it provides functions to find cliques and analyze graph properties. We will first check for cliques of size 5, and if none are found, we will check for independent sets of size 5.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of vertices in a graph such that every two distinct vertices are adjacent. In this context, it means all 5 people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set is a subset of vertices in a graph, no two of which are adjacent. In this context, it means none of the 5 people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This indicates that the party must consist of precisely 5 people.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using NetworkX.\n    2. Check for cliques of size 5 using NetworkX's `find_cliques` function.\n    3. If no cliques of size 5 are found, check for independent sets of size 5.\n    4. If either a clique or an independent set of size 5 is found, print the 5 people involved.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any selection of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any selection of 5 people forms a clique.\n\n    Input: 7 3\n    Output: -1\n    Explanation: With sparse friendships, neither a clique nor an independent set of size 5 can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints of up to 200,000 people and friendships.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles edge cases with interconnected friendship groups.\n- Optimize the algorithm for performance with large datasets.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful party configurations if possible.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these sets using graph traversal techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n\n    'independent set'\n    Explanation: An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for cliques of size 5 by examining subsets of the graph.\n    3. Check for independent sets of size 5 by examining subsets of the graph.\n    4. If either a clique or an independent set is found, print the 5 people involved.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 3\n    Output: -1\n    Explanation: The number of friendships is too low to form a clique, and the number of people is too high to form an independent set without overlapping friendships.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n        - Implement checks for cliques and independent sets using graph traversal techniques.\n        - Use combinations to efficiently check subsets of size 5 for the required conditions.\n", "requirement analysis:\nThe requirement is to determine if a group of 5 people can be selected such that they are either all friends with each other or none are friends with each other. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Implement an algorithm to check for a clique of 5 friends.\n- Implement an algorithm to check for 5 people with no friendships among them.\n- Optimize the solution to handle the upper limits of N and M efficiently.\n- Ensure the solution handles edge cases, such as interconnected groups.\n- Provide clear and concise output as per the format requirements.\nWe will use a graph-based approach to solve this problem. The task is to find either a clique of 5 people (where everyone is friends with each other) or an independent set of 5 people (where no one is friends with each other). Given the constraints, we need an efficient algorithm. We can use adjacency lists to represent friendships and then check for cliques and independent sets using combinations and graph traversal techniques. NetworkX, a Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks, can be used to simplify some of these operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of people where every pair of people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set is a subset of people where no pair of people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of 5 people by examining combinations of 5 people and verifying if all pairs are friends.\n    3. Check for an independent set of 5 people by examining combinations of 5 people and verifying if no pairs are friends.\n    4. If either a clique or an independent set is found, print the 5 people involved.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is friends, no independent set of 5 can exist.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a group of N people such that either all 5 are friends with each other or none are friends with each other. The constraints are large, with up to 200,000 people and friendships, so the solution must be efficient. The problem can be approached by modeling it as a graph problem, where people are nodes and friendships are edges. The task is to find a clique of size 5 or an independent set of size 5.\nrequirement pool:\n- Implement an efficient algorithm to find a clique or independent set of size 5.\n- Ensure the solution handles edge cases with interconnected groups.\n- Optimize the solution for large inputs.\n- Provide clear and concise output as per the format.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem. The task is to find either a clique of size 5 or an independent set of size 5. A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. An independent set is a subset of vertices such that no two vertices in the set are adjacent. Given the constraints, we will use efficient graph traversal techniques and possibly leverage libraries like NetworkX for graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people at the party are friends with each other.\n\n    'independent set'\n    Explanation: An independent set is a subset of vertices in a graph, no two of which are adjacent. Here, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    \n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to construct a graph where nodes represent people and edges represent friendships.\n2. Check for a clique of size 5:\n   - Use a combination of depth-first search (DFS) or breadth-first search (BFS) to explore potential cliques.\n   - For each node, check if it can form a clique with 4 other nodes.\n3. Check for an independent set of size 5:\n   - Use graph traversal to find sets of 5 nodes with no edges between them.\n4. If either a clique or an independent set is found, print the nodes. Otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships (complete graph), any group of 5 people forms a clique.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship criteria. The solution must efficiently handle large input sizes and provide clear output. Edge cases, such as interconnected friendship groups, must be considered.\nrequirement pool:\n- Implement an algorithm to find cliques of 5 friends.\n- Implement an algorithm to find sets of 5 people with no friendships.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output format.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We will use adjacency lists to represent the graph and employ efficient algorithms to search for these specific subgraphs. Given the constraints, we need to ensure our solution is optimized for large input sizes, potentially using techniques like depth-first search (DFS) and backtracking to explore possible combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution found involves exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using adjacency lists.\n2. Check for cliques of size 5:\n   - Use a combination of depth-first search (DFS) and backtracking to explore potential cliques.\n   - For each person, attempt to build a clique by checking if they and four others are all mutual friends.\n3. Check for independent sets of size 5:\n   - Use a similar approach to find a set of 5 people where no two are friends.\n4. If either a clique or an independent set is found, print the 5 people involved.\n5. If no such group is found, print -1.\n\n# [edge case]\n    Edge Case 1: N = 5, M = 0\n    Expected Output: Any combination of the 5 people, e.g., 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Edge Case 2: N = 6, M = 15\n    Expected Output: Any combination of 5 people, e.g., 1 2 3 4 5\n    Explanation: With maximum friendships (a complete graph), any group of 5 people forms a clique.\n\n    Edge Case 3: N = 10, M = 0\n    Expected Output: Any combination of the first 5 people, e.g., 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints of up to 200,000 people and friendships.\nrequirement pool:\n- Implement an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles edge cases and large inputs within constraints.\n- Optimize the solution for performance and memory usage.\n- Provide clear and formatted output as specified.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We will utilize the NetworkX library to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'friendship'\n    Explanation: Friendship is represented as pairs of people who can communicate directly with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group considered for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': The party is successful if it meets the criteria of either all members being friends or none being friends.\n    Implementation: Check for cliques (all members are friends) or independent sets (no members are friends) of size 5.\n\n# [code logic]\n    - Model the friendships using an undirected graph.\n    - Check for cliques of size 5 using graph theory methods.\n    - Check for independent sets of size 5 using graph theory methods.\n    - If either condition is met, print the 5 people involved; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 3\n    Output: -1\n    Explanation: Not enough friendships or lack of structure to form a clique or independent set of size 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, true, false, false, false, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 237, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "condense_two2one", "parent_index": 165}
