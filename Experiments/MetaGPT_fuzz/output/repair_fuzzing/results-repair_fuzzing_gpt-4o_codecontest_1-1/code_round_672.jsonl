{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Explain how your approach minimizes the ugliness effectively. Consider edge cases and constraints in your solution to ensure it is robust.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Explain how your approach minimizes the ugliness effectively. Consider edge cases and constraints in your solution to ensure it is robust.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1. Meanwhile, it increases a_j by 1 which results in the transfer of block height.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Explain how your approach minimizes the ugliness effectively. Consider edge cases and constraints in your solution to ensure it is robust.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j, which essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings, formally defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Explain how your approach minimizes the ugliness effectively, considering edge cases and constraints in your solution to ensure it is robust.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // num_towers\n        \n        # Calculate the remainder to distribute\n        remainder = total_blocks % num_towers\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all towers can be made exactly equal\n        # If remainder is not 0, the difference will be 1\n        min_ugliness = 1 if remainder != 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Output interface\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: A list of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // num_towers\n        remainder = total_blocks % num_towers\n        \n        # If there is a remainder, the minimum ugliness is 1, otherwise it's 0\n        if remainder == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Output interface\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: A list of minimum possible ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Check if the total number of blocks is divisible by the number of towers\n        if total_blocks % n == 0:\n            results.append(0)  # All towers can be made equal\n        else:\n            results.append(1)  # The difference between the tallest and shortest towers can be minimized to 1\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Output interface\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // num_towers\n        \n        # Check if the total number of blocks is divisible by the number of towers\n        if total_blocks % num_towers == 0:\n            # If divisible, ugliness can be 0\n            results.append(0)\n        else:\n            # If not divisible, the best we can achieve is an ugliness of 1\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Check if the total number of blocks is divisible by the number of towers\n        if total_blocks % num_towers == 0:\n            results.append(0)  # Ugliness can be reduced to 0\n        else:\n            results.append(1)  # Ugliness can only be reduced to 1\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing a list of tower heights.\n\n    Returns:\n        A list of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        average_height = total_blocks // num_towers\n        \n        # Calculate the number of blocks needed to reach the average height\n        excess_blocks = total_blocks % num_towers\n        \n        # Sort the heights to facilitate redistribution\n        heights.sort()\n        \n        # Calculate the minimum ugliness\n        min_ugliness = heights[-1] - heights[0]\n        \n        # Redistribute blocks to minimize ugliness\n        for i in range(num_towers):\n            if i < num_towers - excess_blocks:\n                heights[i] = average_height\n            else:\n                heights[i] = average_height + 1\n        \n        # Calculate the ugliness after redistribution\n        min_ugliness = max(heights) - min(heights)\n        \n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    test_cases.append(heights)\n\n# Output interface\nresults = minimize_ugliness(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing a list of building heights.\n\n    Returns:\n        A list of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        # Sort the heights to easily access the tallest and shortest towers\n        heights.sort()\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        \n        # Calculate the number of buildings\n        n = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // n\n        \n        # Calculate the remainder blocks after distributing evenly\n        remainder_blocks = total_blocks % n\n        \n        # The minimum possible ugliness is determined by the remainder blocks\n        # If remainder_blocks is 0, all towers can be made equal, ugliness is 0\n        # Otherwise, the ugliness is 1 because we can't distribute blocks evenly\n        min_ugliness = 1 if remainder_blocks > 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    test_cases.append(heights)\n\n# Output interface\nresult = minimize_ugliness(t, test_cases)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: A list of minimum possible ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        \n        # Calculate the minimum possible ugliness\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        \n        # Sort the heights to facilitate redistribution\n        heights.sort()\n        \n        # Redistribute blocks to minimize ugliness\n        excess_blocks = total_blocks % n\n        min_height = average_height\n        max_height = average_height + (1 if excess_blocks > 0 else 0)\n        \n        # Calculate the minimum possible ugliness\n        min_ugliness = max_height - min_height\n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: A list of minimum possible ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Check if the total number of blocks is divisible by the number of towers\n        if total_blocks % n == 0:\n            results.append(0)  # All towers can be made equal\n        else:\n            results.append(1)  # The best we can do is a difference of 1\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution must handle multiple test cases efficiently and consider edge cases such as already equal heights or large height values.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Optimize for large input sizes and edge cases.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed documentation for the algorithm.\n- Include test cases to validate the solution.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The approach involves calculating the total number of blocks and distributing them evenly across all towers to minimize the height difference. This can be achieved by finding the average height and adjusting the towers accordingly. We will use basic list operations and arithmetic calculations to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This involves moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing blocks. In code, this involves iterating through possible distributions to achieve the smallest difference.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible value of ugliness, which means reducing max(a) - min(a) as much as possible.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks across all towers.\n2. Compute the average height by dividing the total number of blocks by the number of towers.\n3. Distribute blocks to make all towers as close to the average height as possible.\n4. Calculate the new max and min heights after redistribution.\n5. Return the difference between the new max and min heights as the minimum possible ugliness.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already equal.\n\n    Case 2: Towers have heights that can be perfectly balanced.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By redistributing blocks, all towers can be made equal in height.\n\n    Case 3: Towers have a large disparity in height.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the closest possible balance results in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve an average height inherently handles these cases.\n", "requirement analysis:\nThe problem requires minimizing the difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 buildings each, where each building height can be as large as 10^7. The key is to balance the heights by moving blocks from taller to shorter towers until the difference is minimized.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Ensure the solution handles edge cases effectively\n- Optimize the algorithm for performance\n- Provide clear and correct output format\n- Document the solution approach and edge case handling\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest towers to the shortest towers until the difference between the tallest and shortest is minimized. This approach is efficient given the constraints and ensures that the solution handles edge cases effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'difference between the tallest and shortest'\n    Explanation: This refers to the subtraction of the minimum height from the maximum height in the list of tower heights. In code, this can be implemented as `max(heights) - min(heights)`.\n\n# [degree adverb]\n    'minimum possible ugliness'\n    Explanation: This means achieving the smallest possible value for the difference between the tallest and shortest buildings. In code, this involves redistributing blocks until the difference is minimized.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the total number of blocks across all towers.\n3. Determine the average height by dividing the total number of blocks by the number of towers.\n4. Calculate the remainder when dividing the total number of blocks by the number of towers.\n5. The minimum possible ugliness is 1 if there is a remainder (since not all towers can be perfectly equal), otherwise it is 0.\n\n# [edge case]\n    Case 1: [1, 1, 1] = 0\n    Explanation: All towers are already of equal height, so no redistribution is needed, and ugliness is 0.\n\n    Case 2: [1, 1, 2] = 0\n    Explanation: One block can be moved from the tallest tower to one of the shorter towers to make all heights equal.\n\n    Case 3: [1, 1, 3] = 1\n    Explanation: After redistributing blocks, it is not possible to make all towers equal due to an odd number of total blocks, resulting in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating average height and checking for remainder inherently handles these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution must efficiently handle multiple test cases and large input sizes, ensuring robustness and clarity in output.\nrequirement pool:\n- Implement an efficient algorithm to minimize ugliness\n- Ensure solution handles edge cases and constraints\n- Optimize for large input sizes and multiple test cases\n- Provide clear and concise output format\n- Document the approach and edge case handling\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest towers to the shortest towers. The key observation is that the minimum possible ugliness is either 0 or 1. If the total number of blocks is divisible by the number of towers, we can make all towers equal, achieving an ugliness of 0. Otherwise, the best we can do is to make the difference between the tallest and shortest towers 1, achieving an ugliness of 1. This approach is efficient and handles the constraints well.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving blocks from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing blocks. In code, this involves checking if the total number of blocks is divisible by the number of towers to achieve an ugliness of 0, otherwise 1.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The smallest possible value of ugliness that can be achieved through redistribution.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks.\n2. Check if the total number of blocks is divisible by the number of towers:\n   - If yes, all towers can be made equal, and the minimum ugliness is 0.\n   - If no, the minimum ugliness is 1 because we can make all but one tower equal.\n3. Output the minimum ugliness for each test case.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both towers are already equal, so the ugliness is 0.\n\n    Case 2: n = 3, heights = [1, 1, 2] = 1\n    Explanation: The total number of blocks is not divisible by 3, so the minimum ugliness is 1.\n\n    Case 3: n = 4, heights = [4, 4, 4, 4] = 0\n    Explanation: All towers are already equal, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking divisibility and adjusting accordingly handles all cases effectively.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 100 towers with heights up to 10^7, ensuring robustness across all test cases.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles edge cases effectively.\n- Optimize for large input sizes.\n- Provide clear documentation for maintainability.\n- Develop a user-friendly interface for input and output.\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest towers to the shortest ones. The key observation is that the minimum possible ugliness is either 0 or 1. If the total number of blocks is divisible by the number of towers, we can make all towers equal, resulting in an ugliness of 0. Otherwise, the best we can achieve is to have the tallest and shortest towers differ by 1, resulting in an ugliness of 1. This approach efficiently handles the constraints and edge cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: The smallest value of max(a) - min(a) that can be achieved through redistribution of blocks.\n\n# [degree adverb]\n    'tallest'\n    Explanation: Refers to the building with the maximum height in the list.\n    \n    'shortest'\n    Explanation: Refers to the building with the minimum height in the list.\n\n# [code logic]\n1. Calculate the total number of blocks across all towers.\n2. Check if the total number of blocks is divisible by the number of towers:\n   - If divisible, redistribute blocks to make all towers equal, resulting in ugliness of 0.\n   - If not divisible, redistribute blocks to make the tallest and shortest towers differ by 1, resulting in ugliness of 1.\n3. Iterate through each test case and apply the above logic to determine the minimum possible ugliness.\n\n# [edge case]\n    Case 1: Input = [3, 10, 10, 10], Output = 0\n    Explanation: All towers are already equal, so no redistribution is needed.\n\n    Case 2: Input = [4, 3, 2, 1, 2], Output = 0\n    Explanation: Redistribute blocks to make all towers equal, resulting in ugliness of 0.\n\n    Case 3: Input = [5, 1, 2, 3, 1, 5], Output = 1\n    Explanation: Redistribute blocks to minimize height difference to 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles all cases by checking divisibility and redistributing blocks accordingly.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 1000 test cases, each with up to 100 towers. The approach should consider edge cases such as already equal heights and large height differences.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Consider edge cases where towers are already equal.\n- Optimize the solution for large height differences.\n- Provide clear documentation and output format.\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest towers to the shortest ones. The key observation is that the minimum possible ugliness is either 0 or 1. If the total number of blocks is divisible by the number of towers, we can make all towers equal, achieving an ugliness of 0. Otherwise, the best we can do is to make the difference between the tallest and shortest towers 1, resulting in an ugliness of 1. This approach efficiently handles up to 1000 test cases with up to 100 towers each.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving blocks from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) that can be achieved through redistribution.\n\n    'divisible by the number of towers'\n    Explanation: If the total number of blocks is divisible by the number of towers, it implies that all towers can be made equal in height.\n\n# [degree adverb]\n    'tallest'\n    Explanation: Refers to the building with the maximum height in the list.\n    \n    'shortest'\n    Explanation: Refers to the building with the minimum height in the list.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks.\n2. Check if the total number of blocks is divisible by the number of towers:\n   - If yes, set ugliness to 0 because all towers can be made equal.\n   - If no, set ugliness to 1 because the best achievable difference is 1.\n3. Output the calculated ugliness for each test case.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 10000000] = 1\n    Explanation: The total number of blocks is not divisible by 2, so the minimum possible ugliness is 1.\n    \n    Case 2: n = 100, heights = [1]*99 + [100] = 1\n    Explanation: The total number of blocks is not divisible by 100, so the minimum possible ugliness is 1.\n    \n    Case 3: n = 3, heights = [3, 3, 3] = 0\n    Explanation: All towers are already equal, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers whether the total number of blocks is divisible by the number of towers to determine if ugliness can be reduced to 0 or must remain at 1.\n", "requirement analysis:\nThe problem requires minimizing the difference between the tallest and shortest towers by redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 buildings each, where each building can have a height up to 10^7. The key is to balance the heights by moving blocks from taller to shorter towers until the difference is minimized.\nrequirement pool:\n- Implement an efficient algorithm to minimize ugliness\n- Ensure the solution handles edge cases correctly\n- Optimize the algorithm for large inputs\n- Provide clear documentation and comments in the code\n- Include test cases to validate the solution\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest towers to the shortest towers until the height difference is minimized. The key is to calculate the average height and adjust the towers to be as close to this average as possible. This approach ensures that the difference between the tallest and shortest towers is minimized efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving blocks from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This refers to the difference between the maximum and minimum heights of the towers. In code, this can be implemented using max(a) - min(a).\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible value for ugliness, which is the height difference between the tallest and shortest towers. In code, this involves redistributing blocks until the difference is minimized.\n\n# [code logic]\n    1. For each test case, calculate the total number of blocks across all towers.\n    2. Compute the average height by dividing the total number of blocks by the number of towers.\n    3. Redistribute blocks to make each tower's height as close to the average as possible.\n    4. Calculate the ugliness as max(a) - min(a) after redistribution.\n    5. Return the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: The ugliness is already 0 since all towers have the same height.\n\n    Case 2: Towers with heights that can be evenly distributed.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: After redistribution, all towers can have a height of 2, resulting in an ugliness of 0.\n\n    Case 3: Towers with heights that cannot be perfectly equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the closest possible equal heights are [2, 2, 3, 2, 3], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks based on average height will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires minimizing the difference between the tallest and shortest towers by redistributing blocks. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, where building heights can be very large. The approach should ensure that the minimum possible ugliness is achieved, considering all possible redistributions.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Ensure the solution handles edge cases effectively\n- Optimize the algorithm for performance\n- Provide clear and correct output format\n- Document the approach and edge case handling\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest tower to the shortest tower until the difference between the tallest and shortest tower is minimized. This approach is efficient given the constraints, as it directly targets the reduction of the height difference. We will iterate over each test case, calculate the initial ugliness, and perform operations to balance the heights until the minimum possible ugliness is achieved.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another, effectively decreasing the height of one tower and increasing the height of another.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means achieving the smallest possible value for max(a) - min(a) after redistributing blocks. In code, this involves iteratively adjusting the heights to minimize the difference.\n\n# [degree adverb]\n    'tallest'\n    Explanation: Refers to the building with the maximum height in the list.\n    'shortest'\n    Explanation: Refers to the building with the minimum height in the list.\n    These can be implemented in code using max() and min() functions respectively.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Calculate the initial ugliness as max(a) - min(a).\n3. While max(a) - min(a) is greater than 0:\n   - Identify the tallest and shortest towers.\n   - Move a block from the tallest to the shortest tower.\n   - Recalculate max(a) and min(a).\n4. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: [10, 10, 10] = 0\n    Explanation: All towers are already of equal height, so no operations are needed, and ugliness is 0.\n\n    Case 2: [1, 1, 1, 10000000] = 0\n    Explanation: By redistributing blocks from the tallest tower to others, all towers can be made equal.\n\n    Case 3: [1, 1, 1, 1, 10000000] = 1\n    Explanation: After redistributing blocks, it is impossible to make all towers equal due to an odd number of total blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks until max(a) - min(a) is minimized will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution must efficiently handle up to 1000 test cases with up to 100 towers each, ensuring robustness and accuracy.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Ensure the solution handles edge cases effectively\n- Optimize for performance with large inputs\n- Provide clear documentation and output format\n- Enhance user experience with intuitive design\nWe will use a greedy approach to minimize the ugliness by redistributing blocks between towers. The key idea is to balance the heights by moving blocks from the tallest tower to the shortest tower until the difference is minimized. This approach is efficient and robust for the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another to balance the heights and minimize the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) that can be achieved by redistributing blocks between towers.\n\n# [degree adverb] \n    'tallest'\n    Explanation: Refers to the building with the maximum height in the list.\n    \n    'shortest'\n    Explanation: Refers to the building with the minimum height in the list.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Calculate the total number of blocks by summing up all heights.\n3. Compute the average height by dividing the total number of blocks by the number of buildings.\n4. Determine the minimum possible ugliness by checking if all buildings can be made to have heights close to this average.\n5. If the total number of blocks is divisible by the number of buildings, the minimum ugliness is 0; otherwise, it is 1.\n6. Output the minimum possible ugliness for each test case.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000] = 0\n    Explanation: The total number of blocks is 10000001, which can be evenly distributed between two towers, resulting in an ugliness of 0.\n\n    Case 2: n = 3, heights = [1, 1, 1] = 0\n    Explanation: All towers already have equal height, so the ugliness is already minimized at 0.\n\n    Case 3: n = 4, heights = [1, 1, 1, 4] = 1\n    Explanation: The total number of blocks is 7, which cannot be evenly distributed among four towers, resulting in a minimum possible ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking divisibility by n will handle these cases effectively.\n", "requirement analysis:\nThe problem requires minimizing the difference between the tallest and shortest buildings by redistributing blocks. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, where each building height can be as large as 10^7. The approach should consider edge cases such as already equal heights and large disparities in heights.\nrequirement pool:\n- Implement an efficient algorithm to minimize building ugliness.\n- Ensure the solution handles edge cases effectively.\n- Optimize the algorithm for performance with large inputs.\n- Provide clear and correct output for each test case.\n- Document the approach and edge case handling.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The approach involves calculating the average height and redistributing blocks to minimize the difference between the tallest and shortest towers. This can be achieved by sorting the heights and adjusting them towards the average. The solution will handle edge cases such as already equal heights and large disparities efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest towers.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the total number of blocks and determine the average height by dividing the total blocks by the number of towers.\n3. Sort the tower heights.\n4. Redistribute blocks by moving excess blocks from taller towers to shorter ones, aiming to make all towers as close to the average height as possible.\n5. Calculate the new max and min heights after redistribution.\n6. The minimum possible ugliness is the difference between these new max and min heights.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already equal.\n\n    Case 2: Towers with alternating heights.\n    Input: [1, 3, 1, 3]\n    Expected Output: 0\n    Explanation: Redistribute blocks from taller towers to shorter ones to equalize all heights.\n\n    Case 3: One tower significantly taller than others.\n    Input: [1, 1, 1, 10]\n    Expected Output: 0\n    Explanation: Redistribute blocks from the tallest tower to others until all are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks towards an average height inherently handles these cases by ensuring all towers can be made equal or as close as possible to each other.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution must handle multiple test cases efficiently and consider constraints such as the number of towers and their heights.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Optimize for large inputs and edge cases\n- Ensure clear output format for test cases\n- Provide detailed explanation of the approach\n- Consider user experience in terms of input and output clarity\nWe will use a greedy approach to minimize the ugliness by redistributing blocks from the tallest towers to the shortest ones. The key observation is that the minimum possible ugliness is either 0 or 1. If the total number of blocks is divisible by the number of towers, we can make all towers equal, achieving an ugliness of 0. Otherwise, the best we can do is to make the difference between the tallest and shortest towers 1, achieving an ugliness of 1. This approach is efficient and handles edge cases well.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving blocks from one tower to another to minimize the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means finding the smallest value of max(a) - min(a) after redistributing blocks.\n    'divisible by the number of towers': This implies checking if the total number of blocks can be evenly distributed among all towers.\n\n# [degree adverb]\n    'minimum': This indicates that we need to achieve the smallest possible ugliness value.\n\n# [code logic]\n1. For each test case, calculate the total number of blocks across all towers.\n2. Check if the total number of blocks is divisible by the number of towers:\n   - If yes, set the minimum possible ugliness to 0 because all towers can be made equal.\n   - If no, set the minimum possible ugliness to 1 because the best distribution will have a difference of 1 between the tallest and shortest towers.\n3. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both towers are already equal, so the ugliness is 0.\n\n    Case 2: n = 3, heights = [1, 1, 2] = 1\n    Explanation: The total number of blocks is not divisible by 3, so the minimum ugliness is 1.\n\n    Case 3: n = 4, heights = [4, 4, 4, 4] = 0\n    Explanation: All towers are already equal, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking divisibility and setting ugliness to either 0 or 1 covers all scenarios effectively.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 672, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "add_1_sentence_at_end", "parent_index": 409}
