{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, and they have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, and they have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, and they have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other. This means they can communicate freely without any issues or disruptions. Alternatively, no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party with very strict regulations on what constitutes success. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people for a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check all combinations of 5 individuals\n    for combination in combinations(range(1, n + 1), 5):\n        # Check if the combination forms a clique\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n        \n        # Check if the combination forms an independent set\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no valid combination is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of 5 people either all friends or none friends.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals for a successful party or -1 if impossible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of nodes with no edges between them\n    nodes = list(graph.nodes)\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            for k in range(j + 1, len(nodes)):\n                for l in range(k + 1, len(nodes)):\n                    for m in range(l + 1, len(nodes)):\n                        subset = [nodes[i], nodes[j], nodes[k], nodes[l], nodes[m]]\n                        if graph.subgraph(subset).number_of_edges() == 0:\n                            return subset\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 individuals based on friendship conditions.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    # An independent set can be found by checking complement graph for a clique\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither condition is met, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on the given friendships.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party can be formed, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] not in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    people = list(range(1, n + 1))\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    for o in range(l + 1, n):\n                        group = [people[i], people[j], people[k], people[l], people[o]]\n                        if is_clique(group) or is_independent_set(group):\n                            return group\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Union\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship conditions.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people if a successful party can be organized, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # If no clique of size 5 is found, check for independent sets of size 5\n    # by using the complement of the graph\n    G_complement = nx.complement(G)\n    for independent_set in nx.find_cliques(G_complement):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif isinstance(result, list):\n    print(' '.join(map(str, result)))\nelse:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of exactly 5 people where either all are friends or none are friends.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Initialize adjacency list for friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the adjacency list\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n    \n    # Check for independent set of size 5\n    def find_independent_set():\n        for i in range(1, n + 1):\n            # Try to form an independent set starting from person i\n            independent_set = [i]\n            for j in range(1, n + 1):\n                if j != i and all(j not in adjacency_list[k] for k in independent_set):\n                    independent_set.append(j)\n                if len(independent_set) == 5:\n                    return independent_set\n        return -1\n    \n    # Check for clique of size 5\n    def find_clique():\n        for i in range(1, n + 1):\n            # Try to form a clique starting from person i\n            clique = [i]\n            for j in adjacency_list[i]:\n                if all(j in adjacency_list[k] for k in clique):\n                    clique.append(j)\n                if len(clique) == 5:\n                    return clique\n        return -1\n    \n    # Try to find either a clique or an independent set\n    result = find_clique()\n    if result == -1:\n        result = find_independent_set()\n    \n    return result\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration based on friendships.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 individuals for a successful party or -1 if impossible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither condition is met, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of exactly 5 people.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if impossible.\n    \"\"\"\n    # Create a graph from the friendship pairs\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the adjacency list with the given friendships\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n    \n    # Iterate over all combinations of 5 people\n    for combo in combinations(range(1, n + 1), 5):\n        # Check if the combination forms a complete subgraph (clique)\n        if all(v in adjacency_list[u] for u, v in combinations(combo, 2)):\n            return list(combo)\n        \n        # Check if the combination forms an independent set\n        if all(v not in adjacency_list[u] for u, v in combinations(combo, 2)):\n            return list(combo)\n    \n    # If no valid combination is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on the given friendships.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for person in range(1, n + 1):\n        if len(adjacency_list[person]) >= 4:\n            # Check if the friends of this person form a clique\n            friends = list(adjacency_list[person])\n            for combo in combinations(friends, 4):\n                if all(friend in adjacency_list[combo[0]] for friend in combo[1:]):\n                    return [person] + list(combo)\n\n    # Check for an independent set of size 5\n    for combo in combinations(range(1, n + 1), 5):\n        if all(combo[j] not in adjacency_list[combo[i]] for i in range(5) for j in range(i + 1, 5)):\n            return list(combo)\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves analyzing the friendship graph to find cliques or independent sets of size 5.\nrequirement pool:\n- Implement an efficient graph traversal algorithm to find cliques or independent sets.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize for time complexity given the constraints of N and M.\n- Provide clear error handling and output formatting.\n- Test the solution against multiple scenarios to ensure robustness.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique or an independent set of size 5 in a graph. We will represent the friendships as an undirected graph and use adjacency lists for efficient traversal. We will check for cliques by examining combinations of 5 nodes and verifying if they are fully connected or completely disconnected. Given the constraints, we will optimize the solution to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique' and 'independent set'\n    Explanation: A clique in a graph is a subset of vertices such that every two distinct vertices are adjacent. An independent set is a subset of vertices such that no two vertices are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': means the party must consist of exactly 5 individuals.\n    'no pair': means none of the selected individuals should be friends with each other for the independent set condition.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using adjacency lists.\n    2. Iterate through combinations of 5 nodes to check if they form a clique or an independent set.\n    3. For a clique, ensure all pairs within the combination are friends.\n    4. For an independent set, ensure no pairs within the combination are friends.\n    5. If a valid combination is found, print the 5 numbers; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 individuals is a friendship, no group of 5 can be completely disconnected.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations of nodes for cliques or independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can either all be friends or none be friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The solution must efficiently handle up to 200,000 nodes and edges, suggesting the need for optimized graph algorithms.\nrequirement pool:\n- Implement an efficient algorithm to find cliques of size 5.\n- Implement an efficient algorithm to find independent sets of size 5.\n- Optimize the solution to handle the upper constraint limits.\n- Ensure the solution provides correct output for all edge cases.\n- Provide a user-friendly interface for input and output.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to represent the graph and check for cliques and independent sets of size 5. NetworkX provides efficient methods for finding cliques, which can be leveraged to find fully connected subgraphs. For independent sets, we can check combinations of nodes to ensure no edges exist between them.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include precisely 5 people, no more, no less.\n    'no pair of people': Indicates that for a successful party with no friendships, there should be zero connections among the 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using the NetworkX library.\n2. Check for cliques of size 5 in the graph, which represent fully connected subgraphs (all attendees are friends).\n3. Check for independent sets of size 5, which represent subgraphs with no edges (no attendees are friends).\n4. If either a clique or an independent set of size 5 is found, print the nodes involved.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, it's impossible to have a group of 5 where no one is friends.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: Again, with no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship pairs. The solution must efficiently handle large datasets and provide clear output indicating either a successful party configuration or impossibility.\nrequirement pool:\n- Efficiently process large numbers of people and friendships\n- Determine if a successful party configuration is possible\n- Provide clear output format\n- Handle edge cases with minimal friendships\n- Optimize for multiple successful party configurations\nWe will use a graph-based approach to solve this problem. The individuals can be represented as nodes and friendships as edges in an undirected graph. We need to check for two conditions: a complete subgraph of 5 nodes (clique) or an independent set of 5 nodes. We will use the NetworkX library to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in Baltia is defined as a gathering of exactly 5 individuals where either all attendees are friends with each other (forming a complete subgraph or clique) or none of the attendees are friends (forming an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of nodes in a graph such that every two distinct nodes are adjacent. In this context, it means all 5 individuals are friends with each other.\n\n    'independent set'\n    Explanation: An independent set is a subset of nodes in a graph such that no two nodes are adjacent. In this context, it means none of the 5 individuals are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of precisely 5 individuals.\n    Implementation: Ensure the selected subset of individuals always contains 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent individuals and friendships as nodes and edges in an undirected graph.\n    2. Check for the existence of a clique of size 5 using graph traversal techniques.\n    3. Check for the existence of an independent set of size 5 using graph traversal techniques.\n    4. If either condition is met, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any selection of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs among 6 individuals are friends, it's impossible to form an independent set of size 5.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any selection of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to determine if a successful party can be organized.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for performance with large inputs.\n- Provide clear and concise output as per the problem statement.\n- Document the code for maintainability and future improvements.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these subgraphs using efficient graph traversal techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must include exactly 5 individuals.\n    'no pair': No two individuals at the party should be friends for the independent set condition.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5:\n        - Iterate through each person and their friends to find a subset of 5 people where each person is friends with all others.\n    3. Check for an independent set of size 5:\n        - Iterate through each person and ensure none of them are friends with each other.\n    4. If either condition is met, print the 5 individuals. Otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can be formed.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers both the clique and independent set conditions efficiently.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship pairs. The solution must efficiently handle large datasets and provide quick and accurate results. The challenge lies in checking all possible combinations of attendees to meet the success criteria.\nrequirement pool:\n- Develop algorithm to check all attendees are friends or none are friends.\n- Optimize solution for large datasets.\n- Provide clear output format as specified.\n- Ensure no duplicate friendship pairs are processed.\n- Handle edge cases where no party is possible.\nWe will use graph theory to solve this problem. The problem can be approached by checking for cliques of size 5 or independent sets of size 5 in the graph. We will use the NetworkX library to efficiently handle graph operations and check for these conditions. NetworkX provides functions to find cliques and can be used to check for independent sets by complementing the graph.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': A clique in a graph is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means a group of 5 people where everyone is friends with each other.\n    \n    'independent sets': An independent set in a graph is a subset of vertices such that no two vertices in the subset are adjacent. Here, it means a group of 5 people where no one is friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of exactly 5 people, no more, no less. In code, this can be implemented by checking the size of the selected group of people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of people (N) and the number of friendships (M).\n2. Create a graph using the NetworkX library.\n3. Add edges to the graph based on the given friendships.\n4. Check for cliques of size 5 using NetworkX's clique finding functions.\n5. If a clique of size 5 is found, print the members of the clique.\n6. If no clique is found, create the complement of the graph.\n7. Check for cliques of size 5 in the complement graph (which corresponds to independent sets in the original graph).\n8. If an independent set of size 5 is found, print the members.\n9. If neither a clique nor an independent set of size 5 is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no independent set can exist, and if there are more than 5 people, no clique of exactly 5 can be formed.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for checking cliques and independent sets inherently handles these scenarios by considering all possible combinations and their relationships.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that either all are friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles the maximum constraints of N and M.\n- Optimize the solution for edge cases with minimal friendships.\n- Provide clear and formatted output as specified.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we need an approach that can handle up to 200,000 nodes and edges efficiently. We will use a combination of depth-first search (DFS) and combinatorial checks to find the required subset of people.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other or none of them are friends.\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure the selected subset of people contains exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5:\n        - Use combinatorial checks to find a subset of 5 people where all are friends.\n    3. Check for an independent set of size 5:\n        - Use DFS or BFS to find a subset of 5 people where none are friends.\n    4. If either condition is met, print the subset; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship connections. The solution must efficiently handle large datasets and provide a clear output indicating either a successful party configuration or impossibility.\nrequirement pool:\n- Develop algorithm to check all attendees are friends or none are friends.\n- Ensure solution handles maximum constraints efficiently.\n- Provide multiple successful party configurations if possible.\n- Optimize for speed and memory usage.\n- Include detailed error handling and user feedback.\nWe will use graph theory to solve this problem. The problem can be approached by checking for cliques of size 5 (where all attendees are friends) or independent sets of size 5 (where no attendees are friends). We will utilize the NetworkX library to efficiently manage and analyze the graph structure.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all attendees are friends with each other.\n    \n    'independent sets': An independent set in a graph is a set of vertices such that no two vertices in the set are adjacent. Here, it means no pair of people at the party are friends.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must include exactly 5 persons, not more or less.\n    \n    'no pairs': This means that none of the pairs of people at the party should be friends for the independent set condition.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as a graph using NetworkX.\n    2. Check for cliques of size 5 in the graph.\n    3. Check for independent sets of size 5 in the graph.\n    4. If either condition is met, print the 5 individuals involved.\n    5. If neither condition is met, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining if a group of 5 people can form a successful party based on friendship criteria. The solution must efficiently handle large inputs and provide clear output indicating either a successful party configuration or impossibility.\nrequirement pool:\n- Implement algorithm to check all attendees are friends or none are friends.\n- Ensure solution handles maximum constraints efficiently.\n- Provide clear output format as specified.\n- Optimize for multiple successful party configurations.\n- Consider edge cases with minimum friendships.\nWe will use graph theory to solve this problem. The key is to check for cliques of size 5 or independent sets of size 5. We can use the NetworkX library to efficiently manage and analyze the graph of friendships. The approach involves creating a graph from the input data and then checking for cliques and independent sets of size 5.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all attendees are friends with each other.\n    \n    'independent sets': An independent set in a graph is a set of vertices such that no two vertices in the set are adjacent. In this context, it means no pair of people at the party are friends.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of exactly 5 individuals.\n    \n    'no pairs are repeated': Each friendship pair is unique and not repeated in the input.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to create a graph representation of friendships using NetworkX.\n    2. Check for cliques of size 5 in the graph.\n    3. Check for independent sets of size 5 in the graph.\n    4. If either a clique or an independent set of size 5 is found, print the members of that set.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist, and if no clique of size 5 is found, return -1.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M. The solution must handle edge cases where no such subset exists.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles the maximum constraints of N and M.\n- Optimize the solution for speed and memory usage.\n- Provide clear and formatted output as specified.\n- Consider edge cases and provide appropriate outputs.\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking combinations of 5 people to see if they form a complete subgraph (clique) or an independent set. Given the constraints, we will use efficient graph traversal techniques to ensure scalability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other (forming a complete subgraph or clique) or none of the attendees are friends with each other (forming an independent set).\n\n    'graph theory'\n    Explanation: The friendships can be represented as an undirected graph where nodes represent individuals and edges represent friendships. The task is to find a subset of 5 nodes that either form a complete subgraph or an independent set.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 individuals.\n    Implementation: Ensure that any subset of people considered for the party has exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using adjacency lists.\n2. Iterate over all possible combinations of 5 people from the N individuals.\n3. For each combination, check if it forms a complete subgraph (clique) by verifying that every pair of individuals in the combination are friends.\n4. Alternatively, check if the combination forms an independent set by verifying that no pair of individuals in the combination are friends.\n5. If a valid combination is found, print the 5 individuals. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no group of 5 can be an independent set, and since there are only 6 people, a clique of size 5 cannot exist.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 people for either a complete subgraph or an independent set will naturally handle these cases.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves graph theory concepts, specifically cliques and independent sets. The solution must efficiently handle up to 200,000 people and friendships, necessitating an algorithm with a time complexity that can manage large datasets.\nrequirement pool:\n- Develop an algorithm to find a successful party configuration.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and formatted output as specified.\n- Consider edge cases such as no friendships or all possible friendships.\n- Optimize for readability and maintainability of the code.\nWe will use graph theory concepts to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for either a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use adjacency lists to represent the graph and employ efficient algorithms to search for these structures. The solution will be optimized to handle the maximum constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all attendees are friends with each other (forming a clique) or none of the attendees are friends (forming an independent set).\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 individuals are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent. In this context, it means none of the 5 individuals are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of precisely 5 individuals.\n    Implementation: Ensure the selection of 5 individuals for the party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using adjacency lists.\n2. Check for a clique of size 5:\n   - Iterate through each person and check if they have at least 4 friends.\n   - For each person with at least 4 friends, check if their friends form a clique.\n3. Check for an independent set of size 5:\n   - Iterate through combinations of 5 people and check if none are friends.\n4. If either a clique or an independent set is found, print the 5 individuals.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any combination of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs among 6 people are friends, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any combination of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which covers all possible scenarios.\n"], "scores": [], "pass_results": [false, false, false, true, true, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 624, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "parent_index": 384}
