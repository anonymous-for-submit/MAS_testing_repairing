{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage. However, it applies a poison effect on the dragon, which is very important for dealing damage. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage. However, it applies a poison effect on the dragon, which is very important for dealing damage. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage. However, it applies a poison effect on the dragon, which is very important for dealing damage. This poison effect deals 1 damage during each of the next k seconds. This means that the damage is inflicted over k seconds that follow an attack. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon, and the battle with the dragon lasts 100^{500} seconds; during this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage. However, it applies a poison effect on the dragon, which is very important for dealing damage; this poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger, but if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to be dealt.\n            - attacks: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # k cannot be more than h in the worst case\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        low, high = 1, 10**18\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_poison_duration(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, 10**9  # Maximum possible k based on constraints\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Try larger k\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration needed to deal sufficient damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if is_sufficient_damage(mid, n, h, attacks):\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n\n    return results\n\ndef is_sufficient_damage(k: int, n: int, h: int, attacks: List[int]) -> bool:\n    \"\"\"Check if the given k results in sufficient damage.\n\n    Args:\n        k (int): Duration of poison effect.\n        n (int): Number of attacks.\n        h (int): Required damage.\n        attacks (List[int]): List of attack times.\n\n    Returns:\n        bool: True if the damage is sufficient, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration needed to defeat the dragon for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Hit points of the dragon.\n            - attack_times: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    result = minimum_poison_duration(t, test_cases)\n    for res in result:\n        print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration needed to defeat the dragon for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_timings (List[int]): List of attack timings.\n\n    Returns:\n        List[int]: List of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_timings in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_timings[i + 1] - attack_timings[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_timings = list(map(int, input().split()))\n        test_cases.append((n, h, attack_timings))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search range for k\n        left, right = 1, 10**18\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search range based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        # Append the minimum k that satisfies the condition\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given a sequence of attack times. The solution must efficiently handle large input sizes and constraints.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large numbers efficiently\n- Optimize the code for performance\n- Provide clear output format as specified\n- Test the solution against edge cases\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be used to find the smallest k such that the total damage dealt is at least h. This approach is efficient given the constraints, as it reduces the problem to a logarithmic number of checks, each of which can be computed in linear time relative to the number of attacks.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds and is reapplied with each attack, canceling any previous poison effects.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration of the poison effect that ensures the total damage is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: We need to calculate the total damage for different values of k and check if it meets or exceeds h.\n\n# [degree adverb]\n    'smallest': We are looking for the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, get the number of attacks, required damage, and attack times.\n2. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k in the binary search, calculate the total damage:\n     - Iterate through attack times and calculate damage intervals.\n     - Sum up the damage dealt in these intervals.\n   - Adjust binary search bounds based on whether the total damage meets or exceeds h.\n3. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with attacks at consecutive seconds:\n    Input: 2 2\n           1 2\n    Expected output: 1\n    Explanation: With k=1, damage is dealt in seconds [1, 2], which is sufficient.\n\n    Test case with large h:\n    Input: 1 1000000000000000000\n           1\n    Expected output: 1000000000000000000\n    Explanation: Only one attack, so k must be equal to h to deal enough damage.\n\n    Test case with maximum n:\n    Input: 100 100\n           1 2 3 ... 100\n    Expected output: 1\n    Explanation: With k=1, each attack deals damage in its own second, totaling 100 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on total damage calculations.\n", "requirement analysis:\nThe problem requires calculating the minimum duration k for which the poison effect must last to deal at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases, each with up to 100 attacks. The challenge lies in optimizing the calculation to handle large values of h and ensuring the solution is both correct and efficient.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k.\n- Optimize the solution for large input sizes and edge cases.\n- Ensure the code is well-documented and maintainable.\n- Test the solution against a variety of test cases for accuracy.\n- Consider potential future extensions or variations of the problem.\nWe will implement a binary search algorithm to efficiently find the minimum value of k. The key challenge is to ensure that the poison effect is maximized by considering the sequence of attacks and updating the poison effect correctly. We will use Python's built-in capabilities to handle large integers and optimize the solution for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage for each of the next k seconds, starting from the second of the attack. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k such that the total damage dealt by the poison effect is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt by the poison effect must be greater than or equal to h.\n    Implementation: This can be checked by summing up the damage over the effective seconds and comparing it to h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: This can be achieved using a binary search over possible values of k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Implement a binary search for k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for this mid value of k.\n     - If total damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n4. Output the value of low as it represents the minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Case 2: n = 2, h = 10, a = [1, 1000000000] => Expected output: 10\n    Explanation: The attacks are far apart, so k must be at least 10 to deal enough damage with just one attack.\n\n    Case 3: n = 3, h = 3, a = [1, 2, 3] => Expected output: 1\n    Explanation: Each attack can deal damage immediately, so k = 1 is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage dealt to the dragon meets or exceeds its hit points (h). The solution must efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and requiring damage calculations over potentially large time spans.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case\n- Ensure the solution handles large values of h efficiently\n- Optimize the algorithm for performance with large input sizes\n- Validate the output format against the requirements\n- Include edge case testing in the solution\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by considering the intervals between attacks. By using binary search on k, we can find the smallest k that results in total damage greater than or equal to h. This approach is efficient and handles large input sizes well.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for the next k seconds. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k for which the total damage dealt by the poison effect is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt by the poison effect must be greater than or equal to h.\n    'smallest possible value of k': We need to find the minimum k such that the total damage is at least h.\n\n# [degree adverb]\n    'smallest': We are looking for the minimum value of k that satisfies the condition.\n\n# [code logic]\n1. For each test case, read n, h, and the list of attack times.\n2. Use binary search to find the minimum k:\n   - Set low = 1 and high = h (since k cannot be more than h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for this mid value of k:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage interval considering the next attack time or end of battle.\n       - Accumulate the damage intervals.\n     - If total_damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n3. After binary search, low will be the minimum k that satisfies the condition.\n4. Output low for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Case 2: n = 2, h = 10, a = [1, 1000000000] => Expected output: 10\n    Explanation: The attacks are far apart, so k must be at least 10 to accumulate enough damage from the first attack alone.\n\n    Case 3: n = 3, h = 3, a = [1, 2, 3] => Expected output: 1\n    Explanation: Each attack can deal damage immediately, so k = 1 is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the cumulative damage calculation.\n", "requirement analysis:\nThe problem requires calculating the minimum duration k for which the poison effect must last to deal at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large input sizes, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Validate the output format against multiple test cases\n- Document the solution approach and edge case handling\nWe will use a binary search approach to efficiently find the minimum value of k. The key observation is that the damage dealt by the poison can be calculated by iterating over the attack times and summing the effective damage periods. By using binary search on k, we can determine the smallest k that results in at least h damage. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage per second for k seconds starting from the attack second. If another attack occurs before the poison effect ends, the effect is reset.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k for which the total damage dealt by the poison effect is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    'smallest possible value of k': We need to find the minimum k that satisfies the condition.\n\n# [degree adverb]\n    'smallest': We are looking for the minimum value of k that allows Monocarp to deal at least h damage.\n\n# [code logic]\n1. For each test case, initialize low and high values for binary search. Low starts at 1, and high can be a large number, such as 10^18.\n2. Perform binary search:\n   - Calculate mid as (low + high) // 2.\n   - Calculate the total damage for this mid value of k by iterating over attack times and summing up the effective damage periods.\n   - If the total damage is at least h, set high to mid.\n   - Otherwise, set low to mid + 1.\n3. Once binary search completes, low will be the minimum k that results in at least h damage.\n4. Output the result for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal any damage. The expected output is 1.\n\n    Test case: 2 2\n    Explanation: With two attacks at different times and h = 2, k must be at least 1 to ensure each attack deals damage. The expected output is 1.\n\n    Test case: 3 1000000000\n    Explanation: With three attacks and a very high h, k must be large enough to cover the gap between attacks. The expected output will depend on the specific attack times.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles different scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of the poison effect (k) such that the total damage dealt is at least h. The solution must efficiently handle up to 1000 test cases with large constraints on the number of attacks and damage required.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide detailed comments and documentation.\n- Implement additional test cases for validation.\nWe will use a binary search approach to efficiently find the minimum value of k. The idea is to simulate the damage dealt by the poison effect for different values of k and check if it meets the required damage h. This approach is efficient given the constraints, as it reduces the problem to a logarithmic search space.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism through which damage is dealt to the dragon. It lasts for k seconds after each attack, and the goal is to find the minimum k that results in at least h damage.\n\n    'binary search'\n    Explanation: A method to efficiently find the minimum value of k by narrowing down the possible values through iterative comparison.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage dealt must be greater than or equal to h.\n    Implementation: Check if the accumulated damage for a given k meets or exceeds h.\n\n# [degree adverb]\n    'smallest possible value': means finding the minimum k that satisfies the condition.\n    Implementation: Use binary search to find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k.\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Simulate the poison effect for k = mid and calculate total damage.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (try larger k).\n    3. Return low as the minimum k that satisfies the condition.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100] => Expected output: Large k\n    Explanation: The dragon has extremely high hit points, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 2, a = [1, 1000000000] => Expected output: 1\n    Explanation: The attacks are far apart, so k = 1 is sufficient to deal damage in both attack windows.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the search space based on damage calculations.\n", "requirement analysis:\nThe game requires calculating the minimum poison duration needed to deal sufficient damage to the dragon. The challenge lies in optimizing the poison effect application based on the sequence of attacks. The solution must efficiently handle large input sizes and provide accurate results for multiple test cases.\nrequirement pool:\n- Implement the core algorithm to calculate minimum poison duration\n- Optimize performance for handling large input sizes\n- Ensure accurate results across multiple test cases\n- Provide user feedback on damage dealt\n- Enhance user interface for better engagement\nWe will implement a function to calculate the minimum poison duration needed to deal sufficient damage to the dragon. The function will iterate over the attack times and calculate the damage dealt by considering the overlap of poison effects. We will use binary search to efficiently find the minimum value of k that satisfies the damage requirement. This approach ensures optimal performance even for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism through which damage is dealt to the dragon. It lasts for k seconds after each attack, and if a new attack occurs during this period, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage dealt must be greater than or equal to h.\n    'smallest possible value of k': means finding the minimum k that satisfies the condition.\n\n# [degree adverb] \n    'smallest': means we need to find the minimum duration of poison effect that meets the requirement.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n (number of attacks) and h (required damage).\n    3. Read the attack times into a list.\n    4. Use binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - Calculate mid-point k and simulate the damage calculation.\n        - If the damage is sufficient, adjust high bound; otherwise, adjust low bound.\n    5. Output the minimum k for each test case.\n\n# [edge case] \n    Case 1: Single attack with h = 1\n    Input: 1 1\n           1\n    Expected output: 1\n    Explanation: With one attack, k must be at least 1 to deal any damage.\n\n    Case 2: Multiple attacks with large gaps\n    Input: 3 3\n           1 10 20\n    Expected output: 3\n    Explanation: Each attack needs a separate poison effect duration to accumulate enough damage.\n\n    Case 3: Attacks at consecutive seconds\n    Input: 5 5\n           1 2 3 4 5\n    Expected output: 1\n    Explanation: With consecutive attacks, k = 1 is sufficient as each attack resets the poison effect.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on damage calculations.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum duration of poison effect needed to defeat a dragon given a sequence of attack times. The solution must efficiently handle large numbers and multiple test cases, ensuring accurate damage calculation and output.\nrequirement pool:\n- Calculate minimum poison duration for each test case.\n- Optimize algorithm for handling large input sizes.\n- Ensure output format is clear and concise.\n- Handle edge cases where attack times are very close.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to calculate the minimum poison duration needed to defeat the dragon. The function will iterate over the attack times and calculate the total damage dealt for different poison durations using a binary search approach to optimize performance for large input sizes. We will use Python's built-in capabilities to handle large integers and ensure the solution is efficient for multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the damage mechanism that deals 1 damage per second for k seconds after each attack. If a new attack occurs before the current poison effect ends, the poison effect is reset to last for another k seconds from the new attack time.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage dealt is at least equal to the dragon's hit points, h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Ensure that the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k such that the total damage is at least h.\n    Implementation: Use a binary search to efficiently find this minimum k.\n\n# [code logic]\n1. For each test case, read n (number of attacks) and h (hit points of the dragon).\n2. Read the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (e.g., h).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage contributed by that attack considering overlapping effects.\n     - If total_damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n4. Output low as the minimum k for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n    \n    Test case: 2 2\n    Explanation: With two attacks at different times and needing only 2 damage, k = 1 is sufficient since each attack contributes 1 damage.\n\n    Test case: 3 1000000000000000000\n    Explanation: With three attacks and needing a very large amount of damage, k will need to be very large to accumulate enough damage over time.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these cases by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum duration of poison effect needed to defeat the dragon, considering multiple attack timings and ensuring the solution is efficient for large input sizes.\nrequirement pool:\n- Calculate minimum poison duration for each test case.\n- Ensure solution handles large numbers efficiently.\n- Provide clear output format as specified.\n- Optimize algorithm for performance.\n- Consider edge cases in attack timings.\nWe will implement a function to calculate the minimum poison duration needed to defeat the dragon. The function will iterate over the attack timings and calculate the total damage dealt for different values of k using a binary search approach to optimize performance. This will ensure the solution handles large numbers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the key mechanism for dealing damage to the dragon. It lasts for k seconds and is reapplied with each attack, canceling any previous poison effects.\n\n    'minimum value of k'\n    Explanation: The goal is to find the smallest duration of the poison effect that will deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt by the poison effect must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all attack intervals meets or exceeds h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize variables to store the number of test cases and results.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Use binary search to find the minimum k:\n        - Set low and high bounds for k.\n        - Calculate mid-point k and simulate damage calculation.\n        - If total damage with current k is sufficient, adjust high bound.\n        - Otherwise, adjust low bound.\n    4. Store the result for each test case and print all results.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: Large value close to h/n\n    Explanation: With maximum attacks and maximum required damage, k must be large enough to accumulate sufficient damage over all attacks.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 3\n    Explanation: The poison effect must last long enough to cover gaps between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently considers all possible values of k and finds the minimum that satisfies the condition.\n", "requirement analysis:\nThe requirement involves calculating the minimum poison duration k needed to deal at least h damage to the dragon. The solution must efficiently handle large numbers and multiple test cases, ensuring the output format is consistent.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for edge cases\n- Verify the output format for consistency\n- Document the solution approach and logic\nWe will implement a binary search algorithm to efficiently find the minimum value of k. The key challenge is to ensure the algorithm handles large input sizes and edge cases effectively. We will use Python's built-in capabilities to manage large integers and optimize the search process.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds after each attack, and if a new attack occurs during this period, the poison effect is reset.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect lasts that is sufficient to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest possible value'\n    Explanation: We need to find the minimum k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize a binary search range for k, starting from 1 to a large number (e.g., 10^18).\n    2. For each test case, calculate the total damage for a given k using the attack times.\n    3. Use binary search to adjust k based on whether the total damage is sufficient.\n    4. Return the minimum k found for each test case.\n\n# [edge case]\n    Test case with minimum attacks and damage:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case with maximum attacks and minimum damage:\n    100 1\n    1 2 3 ... 100\n    Expected output: 1\n    Explanation: With many attacks but only needing 1 damage, k=1 is sufficient.\n\n    Test case with large h and sparse attacks:\n    2 10^18\n    1 10^9\n    Expected output: Large k value\n    Explanation: Sparse attacks require a large k to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage dealt to the dragon is at least h. The solution must efficiently handle up to 1000 test cases with large input sizes, ensuring that the logic accounts for overlapping poison effects and optimizes the calculation of total damage.\nrequirement pool:\n- Implement the main logic to calculate the minimum k for each test case\n- Optimize the solution to handle large values of n and h efficiently\n- Ensure the solution is robust against edge cases\n- Provide detailed comments and documentation for the code\n- Implement additional test cases to validate the solution\nWe will use a binary search approach to efficiently determine the minimum value of k. The key challenge is to handle overlapping poison effects and ensure the solution is optimized for large values of n and h. We will iterate over the attack times and calculate the total damage for a given k, adjusting k using binary search until the damage is at least h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is dealt to the dragon. It lasts for k seconds and is reapplied with each attack, potentially overlapping with previous effects.\n\n    'minimum value of k'\n    Explanation: The smallest duration for which the poison effect must last to ensure the total damage is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Compute total damage for k = mid by iterating over attack times and summing up the poison effects.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. Return low as the minimum k that satisfies the condition.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k can be 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/n\n    Explanation: With maximum attacks and maximum damage needed, k must be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 5\n    Explanation: The attacks are far apart, so k must be at least 5 to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying values of n and h efficiently.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 609, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "expand_one2two", "parent_index": 343}
