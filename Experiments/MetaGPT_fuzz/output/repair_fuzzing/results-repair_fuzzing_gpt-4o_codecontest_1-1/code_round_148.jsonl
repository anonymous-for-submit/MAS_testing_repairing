{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp wants the problemset to be challenging. The problems should also be diverse to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp wants the problemset to be challenging. The problems should also be diverse to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp wants the problemset to be challenging. The problems should also be diverse. This diversity is important to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp wants the problemset to be challenging and diverse to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_triplets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid triplets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problem tuples (topic, difficulty).\n\n    Returns:\n        A list of integers representing the number of valid triplets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total number of ways to select any three problems\n        total_triplets = comb(n, 3)\n\n        # Calculate invalid combinations where all three problems share the same topic or difficulty\n        invalid_triplets = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_triplets += comb(count, 3)\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_triplets += comb(count, 3)\n\n        # Calculate valid triplets\n        valid_triplets = total_triplets - invalid_triplets\n        results.append(valid_triplets)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_triplets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid sets of three problems for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = {}\n        difficulty_count = {}\n\n        for topic, difficulty in problems:\n            if topic not in topic_count:\n                topic_count[topic] = 0\n            if difficulty not in difficulty_count:\n                difficulty_count[difficulty] = 0\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Subtract invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid selections of three problems for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        A list of integers representing the number of valid selections for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where two problems have the same topic or difficulty\n        invalid_combinations = 0\n\n        # Invalid combinations due to same topic\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Invalid combinations due to same difficulty\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_selections(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples with topic and difficulty.\n\n    Returns:\n        List[int]: List of results, each representing the number of valid combinations for a test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        pair_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and topic-difficulty pair\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            pair_count[(topic, difficulty)] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Subtract invalid combinations where two problems share the same topic or difficulty\n        invalid_combinations = 0\n\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Add back the over-subtracted combinations where all three problems share the same topic and difficulty\n        for count in pair_count.values():\n            if count >= 3:\n                invalid_combinations -= count * (count - 1) * (count - 2) // 6\n\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_combinations(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three diverse training problems.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): Each test case contains the number of problems and a list of tuples,\n            where each tuple contains the topic and difficulty of a problem.\n\n    Returns:\n        List[int]: A list of integers where each integer represents the number of valid combinations for a test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Subtract combinations where two other problems have the same topic or difficulty\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Count the number of ways to select three diverse problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing topic and difficulty.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Create dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not diverse\n        invalid_combinations = 0\n\n        # Count invalid combinations due to same topic\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Count invalid combinations due to same difficulty\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the total number of combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where two problems share the same topic or difficulty\n        invalid_combinations = 0\n\n        # Subtract combinations where two problems share the same topic\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract combinations where two problems share the same difficulty\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the total number of ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Subtract invalid combinations where two problems share the same topic or difficulty\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Calculate invalid combinations for this specific problem\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing topic and difficulty.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid problem sets.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        problem_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and topic-difficulty pair\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            problem_count[(topic, difficulty)] += 1\n\n        # Calculate the number of valid combinations\n        valid_combinations = 0\n        for topic, difficulty in problems:\n            # Total combinations minus invalid combinations\n            valid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid sets of three problems for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers where each integer represents the number of valid sets of three problems\n        for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Subtract invalid combinations\n        invalid_combinations = 0\n\n        # Subtract combinations where all three problems have the same topic\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract combinations where all three problems have the same difficulty\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Add back combinations where all three problems have the same topic and difficulty\n        # These were subtracted twice in the above steps\n        for topic, difficulty in problems:\n            if topic_count[topic] > 1 and difficulty_count[difficulty] > 1:\n                invalid_combinations -= (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The constraints are high, with up to 50000 test cases and a total of 200000 problems across all test cases. The solution must be efficient in terms of time complexity to handle the upper limits of the input size.\nrequirement pool:\n- Efficiently compute the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide a clear and concise output format as specified.\n- Validate input to ensure no two problems have the same topic and difficulty.\n- Optimize the algorithm for better performance if possible.\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of ways to form a valid triplet by considering the combinations of problems with the same topic or difficulty. This approach leverages combinatorial counting and efficient data structures to handle the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': refers to a collection of problems that Monocarp wants to organize.\n    'challenging' and 'diverse': imply that the problems should vary in difficulty and topic to provide a comprehensive learning experience.\n    'ways to select three training problems': means finding combinations of three problems that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'number of testcases': indicates the total number of scenarios to evaluate.\n    'number of problems': refers to the count of problems available in each testcase.\n    'sum of n over all testcases doesn't exceed 2 \u22c5 10^5': ensures that the total number of problems across all testcases is within a manageable limit for computation.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of testcases, t.\n2. For each testcase, do the following:\n   - Read the number of problems, n.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the total number of ways to select any three problems using combinatorial counting (n choose 3).\n   - Subtract invalid combinations where all three problems share the same topic or difficulty.\n3. Output the result for each testcase.\n\n# [edge case]\n    Testcase with minimum n (n=3):\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one way to select all three problems since n=3.\n\n    Testcase with maximum n for a single testcase:\n    Input:\n    1\n    200000\n    (200000 lines with unique topic-difficulty pairs)\n    Output: \n    (calculated based on combinatorial logic)\n    Explanation: The output will be based on the combination logic applied to a large dataset.\n\n    Testcase with all problems having unique topics and difficulties:\n    Input:\n    1\n    4\n    1 2\n    2 3\n    3 4\n    4 5\n    Output:\n    4\n    Explanation: All combinations of three problems are valid since no two problems share the same topic or difficulty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and dictionary-based counting will handle these cases effectively.\n", "requirement analysis:\nThe requirements focus on creating a challenging and diverse problem set for students. The solution must efficiently handle up to 50000 test cases and ensure the sum of n does not exceed 2 \u22c5 10^5. The output must accurately reflect the number of ways to select three problems meeting the criteria.\nrequirement pool:\n- Efficiently handle large input sizes and constraints\n- Ensure diversity and challenge in problem selection\n- Provide accurate output for all test cases\n- Optimize computation to meet performance requirements\n- Ensure user-friendly input and output format\nWe will use combinatorial mathematics to efficiently calculate the number of ways to select three problems from the given set. The constraints allow us to use combinations to determine the number of valid selections. We will utilize Python's itertools library to handle combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects belonging to a finite set in accordance with certain constraints, such as those of graph theory.\n\n    'diverse problems'\n    Explanation: This implies that the problems should cover a range of topics and difficulties, ensuring a variety of challenges.\n\n# [phrase showing quantity relationship]\n    'number of testcases (1 \u2264 t \u2264 50000)': This indicates the range of test cases that need to be handled.\n    'number of problems (3 \u2264 n \u2264 2 \u22c5 10^5)': This specifies the range for the number of problems in each test case.\n    'topic and difficulty (1 \u2264 a_i, b_i \u2264 n)': This indicates that both topic and difficulty values are within the range of the number of problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case, do the following:\n   - Parse the number of problems, `n`.\n   - Create a list to store tuples of (topic, difficulty) for each problem.\n   - Use combinations from itertools to generate all possible sets of three problems.\n   - For each combination, check if it meets the diversity requirement (e.g., different topics or difficulties).\n   - Count and store the number of valid combinations for each test case.\n3. Output the count for each test case.\n\n# [edge case] \n    Case 1: t = 1, n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one combination is possible with three problems.\n\n    Case 2: t = 1, n = 4, problems = [(1, 2), (2, 3), (3, 4), (4, 5)]\n    Expected output: 4\n    Explanation: All combinations of three problems are valid as they all have different topics and difficulties.\n\n    Case 3: t = 1, n = 5, problems = [(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)]\n    Expected output: 10\n    Explanation: All combinations are valid except those that repeat topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinations inherently handles all possible selections and checks for diversity constraints.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The input size can be large, so the solution must be efficient. The output should be the number of valid selections for each test case.\nrequirement pool:\n- Efficiently compute the number of valid problem selections for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear documentation and comments in the code for maintainability.\n- Optimize the algorithm to reduce computational complexity.\n- Include edge case handling for minimum and maximum input values.\nWe will use a combination of combinatorial mathematics and efficient data structures to count the number of valid selections of three problems. The key is to ensure that the selection criteria are met while optimizing for large input sizes. We will utilize Python's built-in data structures such as dictionaries to efficiently track and count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'challenging' and 'diverse'\n    Explanation: The requirement implies that the selection of problems should be both challenging and diverse, which means selecting problems with different topics and difficulties.\n\n# [phrase showing quantity relationship]\n    'three': Refers to selecting exactly three problems from the list.\n    'number of ways': Refers to counting all possible combinations that meet the criteria.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases, t.\n    2. For each test case, read the number of problems, n.\n    3. For each problem, store the topic and difficulty in a list.\n    4. Use combinatorial mathematics to calculate the number of ways to select three problems such that they meet the criteria of being challenging and diverse.\n    5. Use dictionaries to count occurrences of each topic and difficulty.\n    6. Calculate valid combinations by ensuring no two problems have the same topic and difficulty simultaneously.\n    7. Output the number of valid combinations for each test case.\n\n# [edge case] \n    Case 1: \n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one way to select three problems with different topics and difficulties.\n\n    Case 2: \n    Input: \n    1\n    3\n    1 2\n    2 3\n    3 1\n    Output: \n    1\n    Explanation: Only one way to select three problems with different topics and difficulties.\n\n    Case 3: \n    Input: \n    1\n    4\n    1 2\n    2 3\n    3 4\n    4 1\n    Output: \n    4\n    Explanation: Four ways to select three problems with different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations while ensuring no two problems have the same topic and difficulty simultaneously will handle these cases.\n", "requirement analysis:\nThe requirements focus on creating a challenging and diverse problem set for students. The input constraints are significant, requiring efficient handling of large datasets. The output must be precise, reflecting the number of valid combinations of problems that meet the criteria. The solution should be optimized for performance given the constraints.\nrequirement pool:\n- Efficiently handle up to 50000 test cases with large n values\n- Ensure no two problems have the same topic and difficulty\n- Provide accurate output for the number of valid problem combinations\n- Optimize algorithm for performance given input constraints\n- Enhance user experience with clear and concise output\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. The key is to count the number of valid combinations of three problems that meet the criteria. We will utilize dictionaries to efficiently count occurrences of topics and difficulties, and then apply combinatorial logic to determine the number of valid sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'diverse': means that the problems should cover different topics and difficulties to ensure a variety of learning experiences.\n    'challenging': implies that the problems should have varying levels of difficulty to test the students' skills.\n\n# [phrase showing quantity relationship]\n    'three': indicates that we need to select exactly three problems from the list.\n    'number of ways': refers to the different combinations possible to select three problems that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topics and difficulties.\n    3. Use dictionaries to count occurrences of each topic and difficulty.\n    4. Apply combinatorial logic to calculate the number of valid sets of three problems.\n    5. Ensure that no two problems have the same topic and difficulty simultaneously.\n    6. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one combination is possible with three problems, as each has a unique topic and difficulty.\n\n    Input: \n    1\n    4\n    1 2\n    2 3\n    3 4\n    4 5\n    Output: \n    4\n    Explanation: All combinations of three problems are valid since they all have unique topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations inherently handles these scenarios by ensuring unique topic and difficulty pairs.\n", "requirement analysis:\nThe requirements focus on creating a challenging and diverse problem set to aid effective learning. The solution must efficiently handle large input sizes, ensuring performance optimization. The output format must strictly adhere to the given specifications.\nrequirement pool:\n- Efficiently handle large input sizes up to 2 \u22c5 10^5 problems\n- Ensure diversity in problem topics and difficulty\n- Optimize the algorithm for performance\n- Strictly follow the input-output format\n- Provide clear documentation for understanding the solution\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of ways to form a triplet by selecting two other problems with different topics or difficulties. This approach ensures that we efficiently handle large input sizes by leveraging counting and combinatorial logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'diverse'\n    Explanation: In the context of the problem, diversity refers to selecting problems with different topics or difficulties to ensure a varied problem set.\n\n    'ways to select three training problems'\n    Explanation: This refers to the combinations of three problems that can be chosen from the given set, adhering to the diversity requirement.\n\n# [phrase showing quantity relationship]\n    'three': This indicates that we need to select exactly three problems from the list.\n    'number of ways': This refers to the different combinations or permutations possible for selecting the problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case:\n   - Read the number of problems, `n`.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the total number of ways to choose any three problems from `n` using combinatorial logic (n choose 3).\n   - For each problem, calculate the number of invalid combinations where two other problems have the same topic or difficulty.\n   - Subtract these invalid combinations from the total to get the valid combinations.\n3. Output the result for each test case.\n\n# [edge case]\n    Case 1: \n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) is possible since all topics and difficulties are unique.\n\n    Case 2:\n    Input: 1\n           4\n           1 2\n           1 3\n           2 2\n           2 3\n    Output: 4\n    Explanation: The valid combinations are (1, 2, 3), (1, 2, 4), (1, 3, 4), and (2, 3, 4).\n\n    Case 3:\n    Input: 1\n           5\n           1 1\n           1 2\n           2 1\n           2 2\n           3 3\n    Output: 6\n    Explanation: The valid combinations are (1, 2, 5), (1, 3, 5), (1, 4, 5), (2, 3, 5), (2, 4, 5), and (3, 4, 5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting and subtracting invalid combinations will handle these cases correctly.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and diverse, which is crucial for effective learning. The solution must efficiently handle large input sizes, ensuring performance optimization.\nrequirement pool:\n- Implement an algorithm to select three diverse and challenging problems\n- Ensure the solution handles up to 50000 test cases efficiently\n- Optimize the algorithm for large input sizes\n- Validate the uniqueness of topic and difficulty for each problem\n- Provide clear output format as specified\nWe will implement a function to count the number of ways to select three problems such that they are diverse in terms of topic and difficulty. We will use combinations and hash maps to efficiently count the occurrences of topics and difficulties, ensuring the solution handles large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'diverse'\n    Explanation: In the context of the problem, 'diverse' means selecting problems such that they have different topics and difficulties. This ensures a variety of challenges for students.\n\n# [phrase showing quantity relationship]\n    'three': We need to select exactly three problems.\n    'number of ways': We need to count all possible combinations that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topics and difficulties.\n    3. Use hash maps to count occurrences of each topic and difficulty.\n    4. Calculate combinations of three problems ensuring diversity in topics and difficulties.\n    5. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (problems 1, 2, and 3) is possible with different topics and difficulties.\n\n    Input: 1\n           4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No combination of three problems can be formed with diverse topics and difficulties.\n\n    Input: 1\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems are possible with different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations with diverse topics and difficulties will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on creating a challenging and diverse problem set for students. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring no two problems have the same topic and difficulty simultaneously. The output should accurately reflect the number of ways to select three training problems that meet the specified criteria.\nrequirement pool:\n- Efficiently handle large input sizes up to 200000 problems.\n- Ensure no two problems have the same topic and difficulty.\n- Provide accurate output for the number of valid problem selections.\n- Optimize computation to meet performance constraints.\n- Enhance user understanding with clear output formatting.\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, we will calculate the number of valid combinations of three problems by iterating over the problems and using the counts to determine how many other problems can be paired with each problem to form a valid set of three.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'challenging and diverse'\n    Explanation: The requirement is to select problems that are varied in terms of topic and difficulty, ensuring a mix that provides a learning challenge.\n\n# [phrase showing quantity relationship]\n    'number of ways': This refers to calculating the total possible combinations of three problems that meet the criteria.\n    'three training problems': This indicates that we need to select exactly three problems from the list.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topic and difficulty.\n    3. Use dictionaries to count occurrences of each topic and difficulty.\n    4. Iterate over the list of problems to calculate valid combinations of three problems using the counts from the dictionaries.\n    5. Ensure no two problems have the same topic and difficulty simultaneously.\n    6. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Case 1: When n = 3, and all problems have unique topics and difficulties.\n    Example: \n    Input:\n    1\n    3\n    1 2\n    2 3\n    3 1\n    Expected Output: 1\n    Explanation: Only one combination is possible with three unique problems.\n\n    Case 2: When n = 4, and two problems share the same topic but different difficulties.\n    Example:\n    Input:\n    1\n    4\n    1 2\n    1 3\n    2 4\n    3 5\n    Expected Output: 4\n    Explanation: Multiple combinations are possible, but no two problems can have the same topic and difficulty.\n\n    Case 3: When n = 5, and all topics and difficulties are unique.\n    Example:\n    Input:\n    1\n    5\n    1 2\n    2 3\n    3 4\n    4 5\n    5 6\n    Expected Output: 10\n    Explanation: All combinations of three problems are valid.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations based on unique topics and difficulties will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on creating a challenging and diverse problemset for students. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring no two problems have the same topic and difficulty simultaneously. The output should accurately reflect the number of ways to select three training problems meeting the specified criteria.\nrequirement pool:\n- Efficiently handle large input sizes up to 200000 problems\n- Ensure no two problems have the same topic and difficulty\n- Provide accurate output for the number of valid problem sets\n- Optimize performance for quick computation\n- Enhance user experience with clear instructions and output\nWe will implement a function to count the number of ways to select three problems such that no two problems have the same topic and difficulty. We will use dictionaries to count occurrences of topics and difficulties, and then calculate the number of valid combinations using combinatorial logic. This approach ensures efficient handling of large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': refers to the collection of problems Monocarp has, each with a unique topic and difficulty.\n    'challenging and diverse': implies the need for variety in topics and difficulties to enhance learning.\n\n# [phrase showing quantity relationship]\n    'three': indicates the need to select exactly three problems.\n    'no two problems have the same topic and difficulty': means each selected problem must have a unique combination of topic and difficulty.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topics and difficulties.\n    3. Use dictionaries to count occurrences of each topic and difficulty.\n    4. Calculate the number of valid combinations using combinatorial logic, ensuring no two problems have the same topic and difficulty.\n    5. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (problems 1, 2, and 3) is possible since all topics and difficulties are unique.\n\n    Input: 1\n           4\n           1 2\n           2 3\n           3 4\n           4 1\n    Output: 4\n    Explanation: All combinations of three problems are valid as no two problems share the same topic and difficulty.\n\n    Input: 1\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems are valid as no two problems share the same topic and difficulty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations based on unique topics and difficulties will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to compute the number of ways to select three problems from a given set such that they meet specific criteria. The solution must efficiently handle up to 50000 test cases and a total of 200000 problems across all test cases. The constraints ensure no duplicate topic-difficulty pairs, allowing for straightforward computation.\nrequirement pool:\n- Efficiently compute the number of valid problem sets for each testcase.\n- Ensure the solution handles maximum input sizes within time limits.\n- Provide clear and formatted output for each testcase.\n- Validate input constraints to prevent errors.\n- Optimize the algorithm for better performance.\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of valid combinations by considering the other problems that share the same topic or difficulty. This approach ensures that we efficiently handle the constraints and large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': refers to a collection of problems that Monocarp wants to use for training.\n    'topic and difficulty': each problem is characterized by a unique combination of these two attributes.\n\n# [phrase showing quantity relationship]\n    'number of testcases': indicates the total number of test scenarios to evaluate.\n    'number of problems': specifies how many problems are available in each test case.\n    'sum of n over all testcases': ensures that the total number of problems across all test cases does not exceed a certain limit.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topic and difficulty.\n3. Use dictionaries to count occurrences of each topic and difficulty.\n4. For each problem, calculate the number of valid combinations by considering other problems with the same topic or difficulty.\n5. Sum up the valid combinations for each test case and print the result.\n\n# [edge case]\n    Test case with minimum values:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    = 0\n    Explanation: No three problems can be selected as each has a unique topic and difficulty.\n\n    Test case with maximum n:\n    1\n    200000\n    (200000 lines with unique topic-difficulty pairs)\n    = Large number (depends on specific input)\n    Explanation: The function should handle large inputs efficiently without exceeding time limits.\n\n    Test case with all problems having the same topic or difficulty:\n    1\n    4\n    1 2\n    1 3\n    1 4\n    1 5\n    = 4\n    Explanation: All problems share the same topic, allowing multiple combinations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using dictionaries to count occurrences and calculate combinations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires selecting three problems from a set such that they meet specific criteria. The constraints involve handling up to 50,000 test cases and a total of 200,000 problems across all test cases. The solution must efficiently compute the number of valid problem sets for each test case, ensuring no two problems have the same topic and difficulty simultaneously.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure no two problems have the same topic and difficulty.\n- Provide a clear and concise output format.\n- Optimize the algorithm for performance.\n- Include comprehensive test cases to validate the solution.\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. The key challenge is to efficiently count the number of valid sets of three problems that meet the criteria without exceeding time limits given the constraints. We will leverage Python's collections library to manage and count occurrences of topics and difficulties efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects belonging to a finite set in accordance with certain constraints, such as those of graph theory.\n\n    'efficient data structures'\n    Explanation: This refers to using data structures that allow for quick access and manipulation of data, such as dictionaries or sets, which are crucial for handling large inputs efficiently.\n\n# [phrase showing quantity relationship]\n    'number of ways': This indicates that we need to calculate the total possible combinations of problems that meet the criteria.\n    Implementation: Use combinatorial functions to calculate combinations, such as `itertools.combinations`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topics and difficulties.\n    3. Use a dictionary to count occurrences of each topic and difficulty.\n    4. Calculate the number of valid combinations of three problems using combinatorial mathematics.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) is possible since all topics and difficulties are unique.\n\n    Input: 1\n           4\n           1 2\n           2 3\n           3 4\n           4 5\n    Output: 4\n    Explanation: All combinations of three problems are valid since all topics and difficulties are unique.\n\n    Input: 1\n           5\n           1 1\n           1 2\n           1 3\n           2 2\n           3 3\n    Output: 10\n    Explanation: Multiple combinations are possible due to repeated topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial mathematics will naturally handle these cases by considering all possible combinations.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 148, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "parent_index": 70}
