{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew wanting to make the buildings look as nice as possible. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j, which essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume that the number of operations you can perform is unlimited.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew wanting to make the buildings look as nice as possible. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j, which essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume that the number of operations you can perform is unlimited.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew wanting to make the buildings look as nice as possible. Each day, you have the option to modify the heights of two different towers. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j, which essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume that the number of operations you can perform is unlimited.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew wanting to make the buildings look as nice as possible; in a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j, which essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a).\n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Assume that the number of operations you can perform is unlimited.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n\n        # Calculate the minimum possible ugliness\n        # If remainder is 0, all towers can be equalized to average_height\n        # If remainder is not 0, the minimum ugliness will be 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        \n        # Calculate the number of towers that should have the floor and ceil of average height\n        floor_height = average_height\n        ceil_height = average_height if total_blocks % n == 0 else average_height + 1\n        \n        # Calculate the number of towers that should have floor_height and ceil_height\n        num_floor_height = n - (total_blocks % n)\n        num_ceil_height = total_blocks % n\n        \n        # Calculate the minimum ugliness\n        min_ugliness = ceil_height - floor_height\n        \n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate the minimum and maximum heights\n        min_height = min(heights)\n        max_height = max(heights)\n        \n        # Calculate the minimum possible ugliness\n        # If all heights are already equal, ugliness is 0\n        if min_height == max_height:\n            results.append(0)\n        else:\n            # With unlimited operations, we can make all towers equal\n            # The minimum possible ugliness is 1 if there are at least two different heights\n            results.append(1)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimize_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        # Calculate the number of towers\n        num_towers = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // num_towers\n        \n        # Calculate the remainder blocks after distributing evenly\n        remainder_blocks = total_blocks % num_towers\n        \n        # The minimum ugliness is determined by the remainder blocks\n        # If remainder_blocks is 0, all towers can be made equal, ugliness is 0\n        # If remainder_blocks is not 0, the difference will be 1\n        min_ugliness = 1 if remainder_blocks > 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimize_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_height = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate the remainder when total height is divided by number of towers\n        remainder = total_height % num_towers\n        \n        # If remainder is zero, minimum ugliness is zero; otherwise, it is one\n        min_ugliness = 0 if remainder == 0 else 1\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of lists, where each inner list contains the heights of towers for a test case.\n\n    Returns:\n        A list of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate the initial ugliness\n        max_height = max(heights)\n        min_height = min(heights)\n        initial_ugliness = max_height - min_height\n        \n        # Since we can redistribute blocks indefinitely, the minimum ugliness is determined by the difference\n        # between the maximum and minimum heights after redistribution.\n        # The minimum possible ugliness is either 0 or 1, depending on the parity of the sum of heights.\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # If the total number of blocks is divisible by the number of towers, we can make all towers equal\n        if total_blocks % num_towers == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the buildings.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // n\n        \n        # Calculate the remainder to determine how many buildings need to be one block taller\n        remainder = total_blocks % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made exactly the average height\n        # If remainder is not 0, some buildings will be one block taller than the average\n        min_ugliness = 1 if remainder != 0 else 0\n        \n        results.append(min_ugliness)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Call the function and print the results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Calculate the maximum and minimum heights\n        max_height = max(heights)\n        min_height = min(heights)\n        # The minimum possible ugliness is the difference between max and min heights\n        ugliness = max_height - min_height\n        results.append(ugliness)\n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())  # Read number of towers (not used directly)\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing heights of buildings.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        max_height = max(heights)\n        min_height = min(heights)\n        ugliness = max_height - min_height\n        results.append(ugliness)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Determine if the total number of blocks is divisible by the number of towers\n        if total_blocks % num_towers == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the minimum possible ugliness of building heights after unlimited operations. The key is to balance the heights by redistributing blocks between towers until the difference between the tallest and shortest is minimized.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the code for performance.\n- Provide detailed comments and documentation.\n- Enhance user interface for better readability.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers until the difference between the tallest and shortest is minimized. The approach involves calculating the average height and determining the maximum and minimum possible heights after redistribution. We will use Python's built-in functions for efficient computation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness': The ugliness of the buildings is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks': This involves moving blocks from one tower to another to minimize the height difference.\n\n# [phrase showing quantity relationship]\n    'height difference': This refers to the subtraction operation between the maximum and minimum heights of the towers.\n\n# [degree adverb]\n    'minimum': We need to achieve the smallest possible value for the ugliness, which is the height difference.\n\n# [code logic]\n    1. For each test case, read the number of towers and their respective heights.\n    2. Calculate the total number of blocks and determine the average height.\n    3. Redistribute blocks to make all towers as close to the average height as possible.\n    4. Calculate the minimum possible ugliness by finding the difference between the tallest and shortest towers after redistribution.\n    5. Return the minimum ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: The ugliness is already 0 since all towers are of equal height.\n\n    Case 2: Towers with heights that can be evenly distributed.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By redistributing blocks, all towers can have equal height, resulting in an ugliness of 0.\n\n    Case 3: Towers with heights that cannot be perfectly equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the closest possible equal heights result in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks until the height difference is minimized will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks. The solution should efficiently handle multiple test cases and large input sizes, ensuring the output is accurate and easy to interpret.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness\n- Optimize for large input sizes\n- Ensure output format is clear and concise\n- Handle edge cases effectively\n- Provide scalability for future enhancements\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistributing blocks to make the heights as equal as possible. We will use Python's built-in functions to efficiently find the maximum and minimum values in the list of tower heights.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another, which decreases the height of one tower and increases the height of another.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks. In code, this involves iterating over possible redistributions to minimize the difference.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest value that can be achieved for the ugliness after redistributing blocks. In code, this involves finding the smallest possible value of max(a) - min(a).\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the total number of blocks across all towers.\n3. Determine the average height by dividing the total number of blocks by the number of towers.\n4. Calculate the minimum possible ugliness by considering the distribution of blocks around this average height.\n5. The minimum ugliness is achieved when the heights are as close to the average as possible, which is either floor(average) or ceil(average).\n6. Return the difference between the maximum and minimum heights after redistribution.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already equal.\n\n    Case 2: Towers with heights that can be made equal with one move.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By moving one block from tower 1 to tower 3, all towers can have equal height.\n\n    Case 3: Towers with a large difference in height.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistributing blocks optimally, the minimum possible ugliness is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve heights as close to the average as possible will handle these cases effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum possible ugliness of building heights after redistributing blocks. The key is to balance the heights as much as possible, which can be achieved by redistributing blocks from taller to shorter towers until the difference between the tallest and shortest is minimized.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness\n- Optimize the algorithm for large input sizes\n- Ensure the solution is easy to understand and maintain\n- Test the algorithm with edge cases\n- Document the solution approach and edge cases\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution, which can be achieved by balancing the heights as much as possible. We will use Python's built-in functions to efficiently find the maximum and minimum values in the list of heights.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks. In code, this involves iterating through possible redistributions to achieve the smallest height difference.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that we need to find the smallest possible value of ugliness, which is the smallest difference between the maximum and minimum tower heights after redistribution.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the initial maximum and minimum heights.\n3. If all heights are already equal, the ugliness is 0.\n4. Otherwise, redistribute blocks to balance the heights as much as possible:\n   - Sort the list of heights.\n   - Calculate the potential new maximum and minimum heights after redistribution.\n   - The minimum possible ugliness is determined by balancing the heights such that max(a) - min(a) is minimized.\n5. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: [1, 1, 1] = 0\n    Explanation: All towers are already of equal height, so no redistribution is needed, and ugliness is 0.\n\n    Case 2: [1, 10000000] = 0\n    Explanation: With unlimited operations, we can redistribute blocks to make both towers equal in height, resulting in an ugliness of 0.\n\n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: We can redistribute blocks to make all towers equal in height (e.g., [3, 3, 3, 3, 3]), resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to balance heights will naturally handle these cases.\n", "requirement analysis:\nThe task requires a solution that can efficiently redistribute blocks between towers to minimize the height difference. The solution should handle multiple test cases and large input sizes, ensuring the output format is consistent and clear.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize for large height values up to 10^7.\n- Provide clear and formatted output for each test case.\n- Include error handling for invalid inputs.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is achieved when the difference between the tallest and shortest tower is minimized, which can be done by redistributing blocks to equalize the heights as much as possible. We will use Python's built-in functions to efficiently find the maximum and minimum heights and calculate the difference.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: The difference between the maximum and minimum heights of the towers. In code, this can be implemented using `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible value of ugliness that can be achieved after redistributing blocks. In code, this involves iteratively redistributing blocks until the height difference is minimized.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the initial ugliness as the difference between the tallest and shortest tower.\n3. While the tallest tower is greater than the shortest tower, redistribute blocks from the tallest to the shortest tower.\n4. Update the heights and recalculate the ugliness.\n5. Repeat until no further redistribution can reduce the ugliness.\n6. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: Input = [1, 1, 1], Expected Output = 0\n    Explanation: All towers have the same height, so the ugliness is already minimized at 0.\n\n    Case 2: Input = [1, 10], Expected Output = 0\n    Explanation: Blocks can be redistributed from the taller tower to the shorter one until both have equal height.\n\n    Case 3: Input = [1, 1, 10], Expected Output = 0\n    Explanation: Blocks can be redistributed from the tallest tower to the shorter ones until all have equal height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks until heights are equal will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest towers by redistributing blocks between them. The solution should efficiently handle multiple test cases and provide the minimum possible ugliness for each case.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the code for large input sizes.\n- Provide clear documentation and comments within the code.\n- Develop a user-friendly interface for input and output.\nWe will calculate the minimum possible ugliness by redistributing the blocks such that the difference between the maximum and minimum heights is minimized. The key observation is that the minimum ugliness is achieved when the difference between the maximum and minimum heights is at most 1. This can be done by calculating the average height and checking the remainder when the total height is divided by the number of towers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: The smallest value of max(a) - min(a) that can be achieved by redistributing blocks.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest achievable value for the ugliness after redistributing blocks.\n\n# [code logic]\n    1. For each test case, read the number of towers and their heights.\n    2. Calculate the total height of all towers.\n    3. Compute the average height by dividing the total height by the number of towers.\n    4. Determine the remainder when the total height is divided by the number of towers.\n    5. If the remainder is zero, the minimum ugliness is zero; otherwise, it is one.\n    6. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [5, 5, 5, 5]\n    Expected Output: 0\n    Explanation: Since all towers are already equal in height, no redistribution is needed, and ugliness is zero.\n\n    Case 2: Towers have heights that can be evenly distributed.\n    Input: [3, 3, 3, 3, 3]\n    Expected Output: 0\n    Explanation: The total height is divisible by the number of towers, allowing for equal distribution.\n\n    Case 3: Towers have heights that cannot be evenly distributed.\n    Input: [1, 2, 3]\n    Expected Output: 1\n    Explanation: The total height is not divisible by the number of towers, resulting in a minimum ugliness of one.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers these scenarios by checking the remainder when dividing the total height by the number of towers.\n", "requirement analysis:\nThe problem requires determining the minimum possible ugliness of a series of block towers after any number of operations. The key is to balance the heights by redistributing blocks between towers, which can be done optimally by ensuring the difference between the maximum and minimum heights is minimized. The solution must efficiently handle up to 1000 test cases with up to 100 towers each, where each tower can have a height up to 10^7.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Optimize the solution for large input sizes.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear documentation and comments in the code.\n- Test the solution with a variety of test cases.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is achieved when the difference between the maximum and minimum heights is minimized, which can be done by redistributing blocks to equalize the heights as much as possible. We will use Python's built-in functions to efficiently find the maximum and minimum values and calculate the difference.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This refers to the subtraction of the minimum height from the maximum height in the list of tower heights. In code, this can be implemented as `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement asks for the smallest possible value of ugliness after redistributing blocks. In code, this means finding the smallest possible value of `max(a) - min(a)` after any number of operations.\n\n# [code logic]\n    1. For each test case, read the number of towers and their respective heights.\n    2. Calculate the initial ugliness as `max(a) - min(a)`.\n    3. Redistribute blocks between towers to minimize the height difference.\n    4. The goal is to make all tower heights as equal as possible.\n    5. Return the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all towers are already equal in height, no operations are needed, and ugliness is 0.\n\n    Case 2: Towers have heights that can be equalized with a single operation.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By moving one block from the tallest tower to the shortest, all towers can be made equal.\n\n    Case 3: Towers have heights that cannot be completely equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistributing blocks optimally, the minimum possible ugliness is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize `max(a) - min(a)` will handle these cases effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum possible ugliness of building heights after unlimited operations. The key is to balance the heights by redistributing blocks between towers until the difference between the tallest and shortest is minimized.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles edge cases efficiently.\n- Optimize the algorithm for large input sizes.\n- Provide clear documentation and comments in the code.\n- Develop a user-friendly interface for input and output.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistributing blocks to make the heights as equal as possible. The algorithm will find the maximum and minimum heights and calculate their difference, which is the minimum ugliness achievable.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the operation of moving a block from one tower to another, which decreases the height of one tower and increases the height of another.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n1. For each test case, read the number of buildings and their respective heights.\n2. Calculate the total number of blocks by summing up all the heights.\n3. Determine the average height by dividing the total number of blocks by the number of buildings.\n4. Calculate the minimum possible ugliness by considering that the heights can be made as equal as possible, which is determined by the difference between the maximum and minimum heights after redistribution.\n5. Output the minimum possible ugliness for each test case.\n\n# [edge case] \n    Case 1: All buildings have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all buildings are already of equal height.\n\n    Case 2: Only two buildings with different heights.\n    Input: [1, 10000000]\n    Expected Output: 0\n    Explanation: Blocks can be moved from the taller building to the shorter one until both are equal.\n\n    Case 3: Buildings with alternating heights.\n    Input: [1, 3, 1, 3, 1]\n    Expected Output: 0\n    Explanation: Blocks can be redistributed to make all buildings have a height of 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to equalize heights inherently handles these cases.\n", "requirement analysis:\nThe task requires determining the minimum possible ugliness of building heights after unlimited operations of transferring blocks between towers. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, where building heights can be as large as 10^7.\nrequirement pool:\n- Implement the algorithm to calculate minimum ugliness.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide detailed comments and documentation for the code.\n- Optimize the algorithm for faster execution time.\n- Create a user-friendly interface for input and output.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks to equalize the heights of the towers as much as possible. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. Since the number of operations is unlimited, the minimum ugliness is simply the difference between the maximum and minimum heights in the input list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'unlimited operations'\n    Explanation: This means you can perform as many operations as needed to achieve the minimum possible ugliness.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This refers to the difference between the maximum and minimum heights of the towers. In code, this can be implemented using `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible value for ugliness, which is the smallest difference between the tallest and shortest buildings. In code, this means redistributing blocks until the heights are as equal as possible.\n\n# [code logic]\n    1. For each test case, read the number of towers and their respective heights.\n    2. Calculate the maximum and minimum heights of the towers.\n    3. The minimum possible ugliness is simply the difference between these maximum and minimum heights.\n    4. Output this difference for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all towers are already of equal height, the ugliness is 0.\n\n    Case 2: Towers have heights that can be equalized with a single operation.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: By moving one block from tower 1 to tower 3, all towers can be made of equal height.\n\n    Case 3: Towers have heights that cannot be completely equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistributing blocks optimally, the smallest possible difference between max and min heights is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating `max(a) - min(a)` after redistribution will handle all cases correctly.\n", "requirement analysis:\nThe problem requires determining the minimum possible difference between the tallest and shortest building heights after redistributing blocks. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, where each building height can be as large as 10^7. The key is to balance the heights by redistributing blocks optimally.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles edge cases, such as all buildings having the same height.\n- Optimize the solution for performance with large inputs.\n- Provide clear and concise output formatting.\n- Include comments and documentation for code clarity.\nWe will iterate through each test case, and for each case, calculate the minimum possible ugliness by finding the difference between the maximum and minimum heights of the buildings. Since the number of operations is unlimited, the minimum ugliness is simply the difference between the maximum and minimum heights after redistributing blocks optimally.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'unlimited operations'\n    Explanation: This means you can perform as many operations as needed to achieve the minimum possible ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means that we need to find the smallest difference between the tallest and shortest buildings after redistributing blocks.\n\n# [degree adverb] \n    'minimum': means that we need to achieve the smallest possible value for ugliness.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Calculate the maximum and minimum heights of the buildings.\n    3. The minimum possible ugliness is the difference between these maximum and minimum heights.\n    4. Output this value for each test case.\n\n# [edge case] \n    Case 1: All buildings have the same height.\n    Input: [5, 5, 5, 5]\n    Expected output: 0\n    Explanation: Since all buildings have the same height, the ugliness is already 0.\n\n    Case 2: Two buildings with maximum and minimum heights.\n    Input: [1, 10]\n    Expected output: 0\n    Explanation: You can move blocks from the taller building to the shorter one until both have equal height.\n\n    Case 3: Heights are already in a balanced state.\n    Input: [3, 3, 3, 3]\n    Expected output: 0\n    Explanation: The buildings are already balanced, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating max(a) - min(a) will handle these cases correctly.\n", "requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks between towers. The solution should efficiently handle multiple test cases and provide accurate results for each. The operations are unlimited, allowing for complete redistribution to achieve minimal ugliness.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the code for performance and clarity.\n- Provide detailed documentation for user understanding.\n- Enhance user interface for better experience.\nWe will implement a function that calculates the minimum possible ugliness by redistributing the blocks among the towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. Since the number of operations is unlimited, we can always redistribute the blocks such that the difference between the maximum and minimum heights is minimized. The minimum possible ugliness is either 0 or 1, depending on whether the total number of blocks is divisible by the number of towers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: The smallest value of max(a) - min(a) that can be achieved through redistribution. This can be implemented by checking if the total number of blocks is divisible by the number of towers.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest achievable value for the ugliness after redistribution. This is implemented by redistributing blocks until the height difference is minimized.\n\n# [code logic]\n    1. For each test case, calculate the total number of blocks.\n    2. Determine if the total number of blocks is divisible by the number of towers.\n    3. If divisible, the minimum ugliness is 0; otherwise, it is 1.\n    4. Return the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n\n    Case 2: n = 3, heights = [1, 1, 2] = 0\n    Explanation: Redistribute one block from the third tower to either of the first two towers to achieve equal heights.\n\n    Case 3: n = 4, heights = [1, 1, 1, 4] = 1\n    Explanation: Redistribute blocks to achieve heights [2, 2, 2, 1], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking divisibility and redistributing blocks will handle these cases effectively.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 229, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "condense_two2one", "parent_index": 130}
