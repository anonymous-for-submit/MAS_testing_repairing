{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's define k as the arithmetic average of these elements, which is found by dividing the total sum of elements by their count. This means you calculate the sum of all the elements and then divide it by n to find the mean k. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's define k as the arithmetic average of these elements, which is found by dividing the total sum of elements by their count. This means you calculate the sum of all the elements and then divide it by n to find the mean k. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has got an array a consisting of n integers. Let's define k as the arithmetic average of these elements, which is found by dividing the total sum of elements by their count. You need to sum all the elements first. Then divide it by n to find the mean k. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has got an array a consisting of n integers. Let's define k as the arithmetic average of these elements by dividing the total sum of elements by their count, meaning you calculate the sum of all the elements and then divide it by n to find the mean k. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\ndef count_valid_pairs(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of elements\n                           and the array of integers.\n\n    Returns:\n        list: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        required_sum = mean_k * (n - 2)\n\n        # Use a hashmap to store the frequency of each element\n        frequency = {}\n        for num in a:\n            if num in frequency:\n                frequency[num] += 1\n            else:\n                frequency[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            # Calculate the target sum for the pair\n            target_sum = total_sum - a[i] - required_sum\n\n            # Check if the target sum can be achieved with another element\n            if target_sum in frequency:\n                # If the target element is the same as the current element\n                if target_sum == a[i]:\n                    # We need at least two occurrences of this element\n                    valid_pairs += frequency[target_sum] - 1\n                else:\n                    valid_pairs += frequency[target_sum]\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing these elements keeps the mean of the remaining elements unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing\n            a tuple with the number of elements and the array of integers.\n\n    Returns:\n        List[int]: List of integers representing the count of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        total_sum = sum(a)\n        original_mean = total_sum / n\n\n        # To maintain the mean after removing two elements, the sum of the two elements\n        # to be removed should be equal to 2 * original_mean.\n        target_sum = 2 * original_mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            current_element = a[i]\n            required_pair_element = target_sum - current_element\n\n            # Decrease the count of the current element in the map\n            count_map[current_element] -= 1\n\n            # Check if the required pair element exists in the map\n            if required_pair_element in count_map and count_map[required_pair_element] > 0:\n                valid_pairs += count_map[required_pair_element]\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices that can be removed\n    while maintaining the same arithmetic mean.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing\n                                      the number of elements followed by the elements themselves.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Calculate the required sum of two elements to be removed\n        required_sum = 2 * mean\n        \n        # Use a hashmap to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        valid_pairs = 0\n        \n        # Iterate through each element to find valid pairs\n        for num in a:\n            # Calculate the complement that would form the required sum\n            complement = required_sum - num\n            \n            # Check if the complement exists in the hashmap\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n                \n                # If complement is the same as num, we counted the pair (num, num) twice\n                if complement == num:\n                    valid_pairs -= 1\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append([n] + a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n\n        # Calculate twice the mean for comparison\n        twice_mean = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map: Dict[int, int] = {}\n        for num in case:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate through the array to find valid pairs\n        for num in case:\n            # Calculate the required complement\n            complement = twice_mean - num\n\n            # Check if the complement exists in the map\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n            # Adjust the count for the current number to avoid counting itself\n            count_map[num] -= 1\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    \n    # Call the function and print results\n    results = count_valid_pairs(t, cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of pairs of positions [i, j] such that if the elements on these positions are deleted,\n    the arithmetic mean of the remaining elements is equal to the original mean.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the number of elements and the array.\n\n    Returns:\n        List[int]: List of results for each test case, indicating the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # Calculate the target sum for the remaining elements\n        target_sum = mean * (n - 2)\n\n        # Use a hashmap to count occurrences of elements\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element and find pairs\n        for i in range(n):\n            element_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                element_count[a[j]] -= 1\n\n                # Check if the sum of the remaining elements equals the target sum\n                if total_sum - a[i] - a[j] == target_sum:\n                    valid_pairs += 1\n\n                element_count[a[j]] += 1\n            element_count[a[i]] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append([n] + a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    if the elements on these positions are deleted, the mean of the remaining\n    elements is equal to the mean of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n\n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (a[i], a[j]) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) = mean\n        # Simplifying gives: a[i] + a[j] = 2 * mean\n\n        target_sum = 2 * mean\n        count_map = defaultdict(int)\n        valid_pairs = 0\n\n        for number in case:\n            # Check if there exists a number that can pair with the current number\n            # to form the target_sum\n            complement = target_sum - number\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n            # Count occurrences of each number\n            count_map[number] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Calculate the target sum for the remaining elements after removing two elements\n        target_sum = (n - 2) * mean\n        \n        # Use a hashmap to store the frequency of each element\n        freq_map: Dict[int, int] = {}\n        for num in a:\n            if num in freq_map:\n                freq_map[num] += 1\n            else:\n                freq_map[num] = 1\n        \n        valid_pairs_count = 0\n        \n        # Iterate over each element\n        for i in range(n):\n            # Calculate the required sum for the other element\n            required_sum = target_sum - (total_sum - a[i])\n            \n            # Check if the complement exists in the hashmap\n            if required_sum in freq_map:\n                valid_pairs_count += freq_map[required_sum]\n                \n                # If the required element is the same as the current element, decrement the count\n                if required_sum == a[i]:\n                    valid_pairs_count -= 1\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs_count // 2)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing the elements at these positions keeps the mean of the remaining elements unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        target_sum = (n - 2) * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        valid_pairs = 0\n        \n        # Iterate through each pair (i, j)\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements if a[i] and a[j] are removed\n                remaining_sum = total_sum - a[i] - a[j]\n                \n                # Check if the remaining sum equals the target sum\n                if remaining_sum == target_sum:\n                    valid_pairs += 1\n        \n        results.append(valid_pairs)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean_k = total_sum / n\n\n        # Calculate the required sum of the remaining elements to maintain the mean\n        required_sum = mean_k * (n - 2)\n\n        # Use a hashmap to store the frequency of each element\n        frequency_map: Dict[int, int] = {}\n        for num in case:\n            if num in frequency_map:\n                frequency_map[num] += 1\n            else:\n                frequency_map[num] = 1\n\n        valid_pairs_count = 0\n\n        # Iterate through each element and check for valid pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the two elements to be removed\n                sum_of_two = case[i] + case[j]\n\n                # Check if removing these two elements keeps the mean unchanged\n                if total_sum - sum_of_two == required_sum:\n                    valid_pairs_count += 1\n\n        results.append(valid_pairs_count)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices (i, j) such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # To find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count_map: Dict[int, int] = {}\n        valid_pairs = 0\n\n        for number in a:\n            complement = target_sum - number\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n            \n            if number in count_map:\n                count_map[number] += 1\n            else:\n                count_map[number] = 1\n\n        results.append(valid_pairs)\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of averages and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Ensure solution handles maximum constraints\n- Optimize for time complexity\n- Provide clear documentation and comments\n- Include edge case handling\nWe will calculate the total sum of the array and the mean k. For each element, we will check if there exists another element such that removing these two elements keeps the mean unchanged. This can be efficiently done using a hashmap to store the frequency of elements and checking the condition for each pair.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by dividing the sum of all elements by the number of elements. In this problem, it is denoted as k.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'equal to'\n    Explanation: The mean of the remaining elements after removing two should be equal to the original mean k. This implies that the sum of the remaining elements divided by (n-2) should equal the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and compute the mean k.\n2. For each element, calculate the required sum of the remaining elements to maintain the mean.\n3. Use a hashmap to store frequencies of elements.\n4. For each element, check if there exists another element such that removing these two elements keeps the mean unchanged.\n5. Count valid pairs and ensure each pair is counted only once.\n\n# [edge case] \n    Input: 3\n           3\n           1 1 1\n    Output: 1\n    Explanation: Only one pair (1, 2) can be removed to keep the mean unchanged since all elements are equal.\n\n    Input: 4\n           5\n           10 10 10 10 10\n    Output: 10\n    Explanation: Any pair of elements can be removed since all are equal.\n\n    Input: 3\n           3\n           0 0 0\n    Output: 1\n    Explanation: Only one pair (1, 2) can be removed to keep the mean unchanged since all elements are zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and checking conditions will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices [i, j] such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 200,000 elements across all test cases, ensuring performance and accuracy.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Provide clear documentation and comments in the code.\n- Implement additional test cases for validation.\nWe will iterate over each test case, calculate the total sum of the array, and then use a hashmap to count occurrences of each element. For each element, we will calculate the required pair element that would maintain the mean when both are removed. This approach ensures that we efficiently find valid pairs without checking every possible pair explicitly, optimizing for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average': This refers to the mean of the elements in the array, calculated by dividing the sum of all elements by the number of elements.\n    'delete exactly two elements': The task is to find pairs of elements whose removal does not change the mean of the remaining elements.\n    'pairs of positions [i, j] (i < j)': We need to find pairs of indices such that removing these elements keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'equal to': The mean of the remaining elements after removing two should be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, calculate the total sum of the array and the original mean.\n2. Use a hashmap to count occurrences of each element in the array.\n3. For each element, calculate the required pair element that would maintain the mean when both are removed.\n4. Check if this required pair element exists in the hashmap and count valid pairs.\n5. Return the total count of valid pairs for each test case.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct and do not satisfy the condition.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where no valid pairs exist by returning a count of zero.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices that can be removed from an array while maintaining the same arithmetic mean. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Efficiently calculate valid pairs of indices for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and formatted output for each test case.\n- Optimize the algorithm for better performance.\n- Include comments and documentation for code clarity.\nWe will use a mathematical approach to determine the number of valid pairs of indices that can be removed while maintaining the same arithmetic mean. The key observation is that removing two elements should not affect the sum of the remaining elements. We will use a hashmap to efficiently count occurrences of required sums and iterate through the array to find valid pairs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by dividing the sum of all elements by the number of elements. In this problem, it is crucial to maintain the same mean after removing two elements.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements remains unchanged.\n\n# [phrase showing quantity relationship]\n    'dividing the total sum of elements by their count'\n    Explanation: This phrase describes how to calculate the arithmetic mean. In code, this is implemented as `sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the total sum of the array and the arithmetic mean.\n    2. Iterate through each element and calculate the required sum of two elements that can be removed to maintain the mean.\n    3. Use a hashmap to store occurrences of each element.\n    4. For each element, check if there exists another element such that their sum equals the required sum.\n    5. Count valid pairs and ensure i < j.\n\n# [edge case]\n    Input: 4, Array: [8, 8, 8, 8] = Output: 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n\n    Input: 3, Array: [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed without changing the mean.\n\n    Input: 5, Array: [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Pairs (1, 3) and (4, 5) can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and checking for valid pairs will handle these cases correctly.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array while maintaining the original mean. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient algorithm to find valid pairs\n- Ensure solution handles maximum constraints\n- Optimize for performance with large datasets\n- Provide clear output format\n- Include edge case handling\nWe will use a hashmap to count occurrences of each element in the array. The key observation is that for the mean to remain the same after removing two elements, the sum of the two removed elements must equal twice the mean of the array. This allows us to efficiently find pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by dividing the sum of all elements by the number of elements.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'dividing the total sum of elements by their count'\n    Explanation: This describes the calculation of the arithmetic mean, which is implemented in code as `mean = sum(array) / len(array)`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the arithmetic mean of the array.\n    2. For each pair of elements (i, j), check if their sum equals twice the mean.\n    3. Use a hashmap to count occurrences of each element to efficiently find pairs.\n    4. Iterate through the array and for each element, calculate the required complement to maintain the mean.\n    5. Count valid pairs using the hashmap.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 3\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3\n           3\n           1 2 3\n    Output: 0\n    Explanation: No pair can be removed to maintain the mean because removing any pair changes the sum significantly.\n\n    Input: 4\n           4\n           2 2 2 2\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a hashmap to count occurrences and checking pairs will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of averages and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement the main algorithm to find valid pairs\n- Optimize the solution for large input sizes\n- Ensure the solution handles edge cases correctly\n- Provide clear documentation and comments in the code\n- Develop a user-friendly interface for input and output\nWe will use a mathematical approach to determine the number of pairs that can be removed while maintaining the mean. The key observation is that the sum of the remaining elements must be equal to the sum of the original elements minus the sum of the two removed elements. We can use a hashmap to efficiently count occurrences of sums that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by dividing the sum of all elements by the number of elements.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array while maintaining the same arithmetic mean for the remaining elements.\n\n# [phrase showing quantity relationship]\n    'divide by n': This indicates the operation to calculate the mean by dividing the total sum of elements by their count.\n    Implementation: mean = sum(a) / n\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the total sum of the array and the mean.\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a hashmap to store and count occurrences of sums that satisfy the condition.\n    4. Iterate through possible pairs and count valid pairs using the hashmap.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3, [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean because the elements are too different.\n\n    Input: 5, [1, 4, 7, 3, 5] = 2\n    Explanation: Removing pairs (1, 3) or (4, 5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap efficiently handles all cases by checking sums that satisfy the condition.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle multiple test cases and large arrays, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Optimize for large datasets\n- Ensure accurate output format\n- Handle edge cases effectively\n- Provide user-friendly input handling\nWe will iterate over each test case, calculate the total sum of the array, and then use a hashmap to count occurrences of each element. For each element, we will check if there exists another element that can be paired with it to maintain the mean. This approach ensures that we efficiently find the number of valid pairs without checking every possible pair explicitly, optimizing for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by dividing the sum of all elements by the number of elements.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'divide': This refers to the operation of dividing the sum of elements by their count to find the mean.\n    Implementation: `mean = sum(array) / len(array)`\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, calculate the total sum of the array.\n    2. Calculate the mean of the array.\n    3. Use a hashmap to store occurrences of each element.\n    4. Iterate over each element and check if there exists another element that can be paired with it to maintain the mean.\n    5. Count valid pairs and return the result for each test case.\n\n# [edge case]\n    Input: 3\n           0 0 0\n    Output: 3\n    Explanation: Any pair of elements can be removed since all are zero, maintaining the mean.\n\n    Input: 4\n           1 1 1 1\n    Output: 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Input: 5\n           10 10 10 10 10\n    Output: 10\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles cases where all elements are equal or zero, as any pair can be removed without affecting the mean.\n", "requirement analysis:\nThe task requires calculating the number of pairs of positions [i, j] such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 10,000 test cases and arrays with a total of up to 200,000 elements.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Optimize for large input sizes\n- Ensure accurate output format\n- Handle edge cases like all elements being equal\n- Provide detailed error messages for invalid inputs\nWe will use a mathematical approach to determine the number of valid pairs. The key observation is that the sum of the remaining elements after removing two elements should be equal to the sum of the original array minus twice the mean. This can be efficiently calculated using a hashmap to store the frequency of each element and then iterating over possible pairs to check if they satisfy the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by dividing the sum of all elements by the number of elements.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two'\n    Explanation: This indicates that precisely two elements must be removed from the array. In code, this means iterating over pairs of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the total sum of the array and the mean (k).\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a hashmap to store frequencies and efficiently check conditions for valid pairs.\n    4. Iterate over possible pairs and count those that satisfy the condition.\n\n# [edge case]\n    Input: 4\n           4\n           8 8 8 8\n           Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3\n           50 20 10\n           Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: 5\n           1 4 7 3 5\n           Output: 2\n    Explanation: Removing positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and pair iteration will cover these scenarios efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of averages and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement the main algorithm to find valid pairs\n- Optimize the solution for large input sizes\n- Ensure the solution handles edge cases\n- Provide detailed error messages for invalid inputs\n- Enhance user interface for input and output\nWe will calculate the total sum of the array and the mean k. For each pair of elements, we will check if removing them keeps the mean of the remaining elements equal to k. This can be optimized by using a hashmap to count occurrences of each element and using the formula derived from the condition that the sum of the remaining elements should be equal to (n-2) * k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by summing all elements of the array and dividing by the number of elements.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two specific elements from the array such that the mean of the remaining elements remains unchanged.\n\n# [phrase showing quantity relationship]\n    'number of pairs of positions [i, j] (i < j)'\n    Explanation: This indicates that we need to find all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and determine the mean k.\n2. For each test case, iterate through possible pairs of elements to remove.\n3. Use a hashmap to track occurrences of each element.\n4. For each pair (i, j), check if removing these elements keeps the mean unchanged using the condition derived from the sum of remaining elements.\n5. Count and return the number of valid pairs for each test case.\n\n# [edge case] \n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged as all elements are distinct and do not satisfy the condition.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should account for all scenarios by checking each pair and using a hashmap for efficient counting.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of averages and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair checking algorithm\n- Optimize for large input sizes\n- Ensure accurate mean calculation\n- Handle edge cases with equal elements\n- Provide detailed error messages for invalid inputs\nWe will calculate the total sum of the array and the mean k. For each element, we will check if there exists another element such that removing these two elements keeps the mean unchanged. This can be efficiently done using a hashmap to store the frequency of each element and checking the condition derived from the mean equation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average'\n    Explanation: The arithmetic average, or mean, is calculated by summing all elements of the array and dividing by the number of elements. In this problem, it is denoted as k.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and determine the mean k.\n2. For each element, calculate the required sum of the remaining elements to maintain the mean.\n3. Use a hashmap to store the frequency of each element.\n4. Iterate through each element and check if there exists another element such that removing these two elements keeps the mean unchanged.\n5. Count all valid pairs (i, j) where i < j.\n\n# [edge case] \n    Case 1: n = 3, a = [1, 1, 1] = 3\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Case 2: n = 4, a = [0, 0, 0, 0] = 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Case 3: n = 5, a = [10^9, 10^9, 10^9, 10^9, 10^9] = 10\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to track frequencies and checking conditions derived from the mean equation will handle these cases effectively.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the arithmetic mean of the remaining elements. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Efficiently calculate the number of valid pairs for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and formatted output as specified in the requirements.\n- Optimize the algorithm to reduce time complexity.\n- Include comments and documentation for code clarity.\nWe will use a mathematical approach to determine the number of valid pairs. The key observation is that removing two elements should not change the mean, which implies that the sum of the removed elements should be equal to twice the mean. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'arithmetic average' (mean)\n    Explanation: The arithmetic average or mean is calculated by dividing the sum of all elements by the number of elements. In this problem, it is denoted as k.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two'\n    Explanation: This indicates that precisely two elements must be removed, no more, no less. In code, this means iterating over pairs of indices.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean k.\n2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n3. This condition translates to checking if the sum of the removed elements equals twice the mean.\n4. Use a hashmap to count occurrences of each element to efficiently find pairs that satisfy the condition.\n5. Iterate over each element and calculate the required complement to form a valid pair.\n6. Count valid pairs using the hashmap.\n\n# [edge case]\n    Case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged as all elements are distinct and do not satisfy the condition.\n\n    Case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing pairs (1, 7) or (3, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a hashmap to count pairs will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 743, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 458}
