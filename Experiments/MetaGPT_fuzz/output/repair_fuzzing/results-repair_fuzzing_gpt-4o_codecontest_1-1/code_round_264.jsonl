{"name": "1598_E. Staircases", "description": "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "tags": ["brute force", "combinatorics", "data structures", "dfs and similar", "dp", "implementation", "math"], "difficulty": 11, "id": 1598, "sample_io": [{"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n"]}, {"input": "1000 1000 2\n239 634\n239 634\n", "output": ["1332632508\n1333333000\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n1\n0\n"]}], "test_list": [{"input": "1 1 1\n1 1\n", "output": ["0\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n238\n233\n222\n207\n186\n180\n162\n140\n151\n144\n137\n144\n137\n111\n109\n91\n82\n77\n87\n78\n76\n83\n81\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 2\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n12\n8\n13\n23\n19\n15\n"]}, {"input": "1 1 2\n1 1\n1 1\n", "output": ["0\n1\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n86\n81\n91\n82\n80\n86\n84\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 1\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n3\n6\n2\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n77\n68\n66\n72\n70\n"]}, {"input": "3 4 10\n1 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n31\n45\n25\n17\n15\n12\n14\n16\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n17\n14\n12\n15\n17\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n16\n14\n"]}, {"input": "1000 1000 2\n252 634\n239 634\n", "output": ["1332594366\n1331893874\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n74\n69\n79\n70\n68\n74\n72\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n9\n6\n5\n4\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n78\n76\n64\n77\n74\n80\n71\n69\n75\n73\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n14\n12\n8\n13\n23\n31\n27\n"]}, {"input": "1000 1000 2\n59 634\n239 634\n", "output": ["1333160628\n1332460136\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n162\n140\n135\n124\n111\n104\n117\n114\n94\n92\n80\n77\n85\n101\n92\n90\n96\n94\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n90\n76\n64\n77\n74\n80\n69\n67\n71\n69\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n78\n70\n56\n62\n56\n"]}, {"input": "1000 1000 2\n239 634\n418 634\n", "output": ["1332632508\n1331406830\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n74\n65\n63\n69\n67\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n75\n72\n"]}, {"input": "3 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n"]}, {"input": "1000 1000 2\n59 323\n239 634\n", "output": ["1333014458\n1332313966\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n142\n137\n126\n116\n109\n103\n99\n91\n77\n65\n78\n73\n79\n68\n66\n70\n69\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n52\n54\n49\n47\n41\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n66\n63\n"]}, {"input": "2 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "1000 1000 2\n59 323\n239 999\n", "output": ["1333014458\n1333011116\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n83\n72\n70\n74\n73\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n75\n73\n67\n70\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n124\n113\n123\n119\n111\n97\n85\n98\n88\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n194\n183\n154\n151\n138\n130\n121\n129\n126\n119\n118\n106\n100\n95\n105\n92\n90\n76\n79\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n77\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n109\n101\n96\n106\n93\n95\n81\n84\n"]}, {"input": "6 3 4\n1 2\n1 3\n2 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n63\n61\n"]}, {"input": "2 1 2\n1 1\n1 1\n", "output": ["1\n3\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n27\n23\n31\n21\n25\n18\n15\n13\n"]}, {"input": "1000 1000 2\n341 634\n239 634\n", "output": ["1332333240\n1331632748\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n116\n109\n112\n109\n83\n81\n69\n78\n73\n83\n74\n72\n77\n75\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n17\n15\n12\n14\n16\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n179\n163\n157\n135\n130\n119\n112\n108\n103\n100\n80\n78\n64\n73\n70\n76\n67\n65\n71\n69\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n35\n31\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 4\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n43\n33\n26\n24\n"]}, {"input": "1000 1000 2\n252 634\n239 877\n", "output": ["1332594366\n1332358004\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n112\n100\n97\n92\n102\n93\n91\n97\n87\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n234\n229\n218\n195\n188\n186\n164\n144\n133\n126\n119\n114\n111\n91\n89\n71\n62\n59\n65\n56\n54\n60\n58\n"]}, {"input": "3 3 10\n1 2\n2 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n11\n14\n18\n14\n25\n35\n25\n21\n"]}, {"input": "1000 1000 2\n59 634\n239 35\n", "output": ["1333160628\n1332948862\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n107\n98\n96\n102\n100\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n98\n86\n99\n96\n90\n68\n64\n68\n66\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n23\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n10\n5\n2\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n78\n75\n"]}, {"input": "1000 1000 2\n59 323\n448 634\n", "output": ["1333014458\n1331700760\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 1\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n170\n165\n150\n122\n115\n109\n105\n97\n83\n71\n84\n79\n85\n74\n72\n76\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n74\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n5 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n83\n81\n72\n75\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n127\n113\n101\n114\n104\n92\n81\n79\n83\n82\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n102\n105\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n21\n17\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n208\n197\n174\n159\n153\n131\n126\n113\n110\n121\n124\n121\n95\n93\n81\n90\n85\n95\n86\n84\n89\n87\n"]}, {"input": "3 4 10\n1 4\n2 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n29\n25\n19\n11\n9\n8\n5\n6\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n1 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n197\n181\n175\n152\n157\n139\n132\n128\n123\n120\n97\n93\n79\n93\n90\n96\n81\n79\n73\n71\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n21\n17\n"]}, {"input": "1000 1000 2\n142 634\n239 877\n", "output": ["1332917106\n1332680744\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 5\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n110\n98\n95\n90\n100\n93\n91\n98\n88\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n180\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n56\n"]}, {"input": "1000 1000 2\n59 634\n239 24\n", "output": ["1333160628\n1333015896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n127\n115\n109\n117\n133\n122\n120\n127\n119\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 2\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n119\n107\n120\n117\n111\n81\n77\n81\n78\n"]}, {"input": "3 3 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["26\n18\n15\n14\n"]}, {"input": "2 3 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["12\n18\n12\n7\n10\n18\n10\n7\n"]}, {"input": "3 3 4\n1 3\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n5 2\n2 3\n3 1\n", "output": ["31\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n223\n212\n195\n169\n163\n128\n125\n114\n107\n101\n108\n105\n98\n97\n83\n80\n75\n85\n72\n70\n72\n69\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n120\n108\n105\n116\n106\n94\n88\n86\n93\n92\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n2 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n127\n130\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n180\n164\n158\n135\n132\n114\n107\n103\n98\n95\n87\n85\n71\n76\n73\n79\n66\n64\n58\n56\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n60\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n137\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n34\n26\n23\n"]}, {"input": "6 3 4\n1 1\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n75\n71\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n132\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 4\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 4\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n113\n112\n92\n90\n70\n61\n56\n61\n52\n50\n56\n58\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n126\n133\n136\n"]}, {"input": "3 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n4 2\n7 2\n2 3\n3 0\n", "output": ["39\n33\n43\n53\n"]}, {"input": "6 3 4\n1 1\n2 3\n1 2\n2 3\n1 3\n1 5\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n71\n68\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n5 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n118\n111\n83\n90\n110\n107\n95\n89\n94\n100\n85\n87\n94\n97\n"]}, {"input": "3 6 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 4\n2 2\n5 2\n2 3\n3 1\n", "output": ["79\n59\n56\n50\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n197\n"]}, {"input": "2 5 1\n1 4\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["26\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n179\n181\n"]}, {"input": "12 3 4\n2 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["177\n173\n170\n174\n"]}, {"input": "2 5 1\n1 2\n1 6\n2 1\n1 3\n4 1\n3 2\n0 3\n0 4\n1 3\n3 1\n", "output": ["25\n"]}, {"input": "1 2 1\n1 1\n", "output": ["1\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n244\n239\n225\n210\n189\n183\n165\n143\n154\n145\n138\n147\n140\n114\n112\n94\n85\n82\n74\n65\n63\n70\n68\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n28\n39\n29\n23\n17\n22\n20\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n116\n123\n120\n100\n98\n86\n95\n90\n100\n91\n89\n95\n93\n"]}, {"input": "3 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n30\n39\n22\n14\n12\n9\n11\n9\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n2 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n272\n251\n209\n205\n194\n171\n164\n159\n137\n132\n121\n114\n107\n102\n100\n80\n78\n66\n75\n72\n78\n69\n67\n73\n71\n"]}, {"input": "3 4 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n29\n27\n41\n21\n17\n13\n10\n14\n15\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n20\n22\n25\n29\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n2 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n10\n19\n9\n13\n11\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 2\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n18\n14\n12\n9\n6\n4\n"]}, {"input": "1000 1000 2\n494 634\n239 634\n", "output": ["1331884338\n1331183846\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n111\n99\n96\n91\n101\n86\n84\n91\n89\n"]}, {"input": "3 4 6\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n98\n78\n74\n62\n82\n79\n85\n76\n74\n80\n78\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n106\n99\n112\n109\n101\n99\n87\n84\n92\n108\n95\n93\n87\n85\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n96\n88\n74\n80\n96\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n96\n93\n79\n78\n66\n75\n72\n75\n66\n64\n70\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n170\n160\n128\n123\n116\n109\n102\n109\n102\n88\n87\n81\n76\n71\n81\n72\n74\n80\n77\n"]}, {"input": "3 3 3\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n57\n"]}, {"input": "1000 1000 2\n59 323\n239 587\n", "output": ["1333014458\n1332224196\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n78\n82\n71\n69\n73\n72\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 7\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n112\n110\n98\n91\n86\n96\n81\n79\n72\n75\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n1 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n144\n137\n136\n129\n109\n104\n114\n101\n103\n89\n92\n"]}, {"input": "3 4 10\n1 1\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n33\n22\n20\n28\n20\n26\n19\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 3\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n132\n125\n118\n115\n89\n87\n75\n84\n79\n87\n78\n76\n83\n81\n"]}, {"input": "1000 1000 2\n252 412\n239 877\n", "output": ["1332147258\n1331910896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n80\n72\n80\n71\n69\n75\n70\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n15\n10\n14\n11\n7\n"]}, {"input": "1000 1000 2\n59 722\n239 35\n", "output": ["1333201988\n1332990222\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n75\n73\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n2 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 1\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["25\n23\n31\n22\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 6\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n282\n259\n227\n220\n209\n187\n174\n166\n134\n130\n123\n116\n107\n114\n111\n97\n96\n84\n78\n73\n83\n74\n72\n81\n78\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n565\n560\n549\n532\n517\n511\n476\n473\n462\n455\n448\n455\n452\n445\n444\n420\n417\n404\n470\n457\n447\n449\n446\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 3\n1 3\n1 3\n3 3\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n77\n79\n77\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n85\n83\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["79\n77\n71\n73\n"]}, {"input": "6 3 4\n2 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 2\n2 3\n3 1\n", "output": ["69\n65\n63\n61\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n27\n25\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 10\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n278\n230\n223\n212\n189\n163\n157\n135\n130\n117\n114\n121\n124\n121\n95\n93\n79\n88\n83\n93\n84\n82\n87\n85\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n37\n32\n28\n31\n20\n18\n"]}, {"input": "1000 1000 2\n63 634\n239 24\n", "output": ["1333148892\n1333004160\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n137\n125\n120\n128\n144\n129\n127\n134\n126\n"]}, {"input": "3 3 4\n1 3\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["31\n23\n19\n20\n"]}, {"input": "3 3 4\n1 2\n1 2\n1 2\n1 3\n1 3\n3 3\n4 2\n5 2\n2 3\n3 1\n", "output": ["25\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n222\n217\n200\n169\n163\n128\n125\n114\n109\n99\n104\n101\n94\n93\n79\n76\n73\n78\n65\n63\n65\n62\n"]}, {"input": "2 4 1\n2 4\n1 6\n2 1\n1 2\n4 3\n3 2\n1 3\n0 4\n1 3\n3 1\n", "output": ["20\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 3\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n264\n216\n231\n220\n197\n158\n152\n145\n140\n129\n132\n121\n131\n127\n108\n96\n90\n101\n91\n87\n81\n79\n86\n85\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["132\n126\n138\n120\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 7\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n56\n54\n66\n68\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n143\n137\n145\n161\n131\n127\n134\n142\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n25\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n3 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n223\n213\n202\n179\n161\n153\n137\n126\n115\n108\n105\n100\n96\n76\n74\n66\n59\n56\n62\n53\n51\n57\n59\n"]}, {"input": "2 4 1\n1 2\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["17\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n185\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n29\n43\n33\n43\n33\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 8\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n346\n323\n306\n290\n246\n212\n206\n195\n172\n157\n151\n129\n124\n113\n106\n104\n111\n108\n88\n86\n82\n91\n86\n96\n87\n89\n95\n93\n"]}, {"input": "6 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["144\n128\n120\n130\n110\n78\n76\n71\n73\n65\n"]}, {"input": "3 8 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["115\n100\n98\n113\n90\n86\n79\n74\n81\n82\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n1 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n21\n19\n21\n25\n"]}, {"input": "1000 1000 2\n494 749\n239 634\n", "output": ["1332338588\n1331638096\n"]}, {"input": "5 10 15\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n1 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n106\n86\n82\n70\n90\n87\n93\n84\n82\n88\n86\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 4\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n104\n97\n84\n81\n78\n76\n64\n61\n69\n79\n68\n66\n63\n61\n"]}, {"input": "3 4 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["39\n33\n43\n33\n25\n15\n10\n15\n23\n21\n"]}, {"input": "3 3 4\n1 2\n1 3\n2 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n0 1\n", "output": ["25\n23\n12\n14\n"]}, {"input": "5 7 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["243\n216\n187\n192\n243\n227\n209\n162\n168\n184\n"]}, {"input": "5 10 30\n5 3\n5 8\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n372\n354\n328\n313\n297\n268\n234\n229\n218\n180\n165\n159\n124\n119\n112\n104\n97\n92\n89\n75\n74\n70\n79\n76\n79\n70\n72\n86\n83\n"]}, {"input": "3 4 4\n1 4\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["49\n41\n31\n35\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n5 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n69\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 4\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n119\n109\n98\n92\n88\n79\n77\n65\n78\n74\n78\n69\n67\n70\n69\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 4\n2 3\n3 1\n", "output": ["132\n126\n138\n148\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n3 3\n1 3\n1 3\n2 2\n3 2\n2 3\n2 1\n", "output": ["79\n77\n85\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 10\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n78\n70\n78\n69\n67\n73\n68\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n18\n11\n8\n6\n4\n"]}, {"input": "5 10 28\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 10\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n611\n606\n595\n548\n527\n521\n486\n480\n469\n462\n458\n465\n458\n451\n450\n420\n417\n404\n470\n457\n447\n450\n447\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 9\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n89\n87\n"]}, {"input": "6 3 4\n1 3\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["85\n89\n79\n75\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 1\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n15\n13\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 4\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n24\n20\n17\n21\n26\n37\n35\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n5 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n228\n213\n206\n171\n166\n151\n119\n112\n144\n151\n174\n170\n158\n153\n161\n177\n154\n152\n137\n128\n"]}, {"input": "6 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["536\n474\n446\n413\n358\n342\n336\n280\n267\n262\n245\n214\n208\n173\n170\n159\n154\n144\n149\n146\n139\n138\n116\n113\n108\n121\n108\n102\n104\n101\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 3\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n136\n130\n138\n144\n114\n102\n109\n114\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 2\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n14\n11\n14\n17\n"]}, {"input": "6 3 4\n1 1\n1 3\n2 2\n2 3\n1 3\n1 8\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n75\n62\n60\n"]}, {"input": "12 3 3\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n3 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "2 4 1\n1 4\n1 6\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 0\n", "output": ["25\n23\n31\n23\n"]}], "task_id": "codecontest/62", "prompt": "You are given a matrix, consisting of n rows and m columns, where the rows are numbered top to bottom and the columns are numbered left to right. Each cell of the matrix can be either free or locked. Let's call a path in the matrix a staircase if it starts and ends in the free cell, visits only free cells, and has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. In particular, a path, consisting of a single cell, is considered to be a staircase. Here are some examples of staircases: <image> Initially all the cells of the matrix are free. You have to process q queries, each of them flipping the state of a single cell\u2014so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free. Print the number of different staircases after each query; two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "repair_prompt": ["You are given a matrix, consisting of n rows and m columns, where the rows are numbered top to bottom and the columns are numbered left to right. Each cell of the matrix can be either free or locked. Let's call a path in the matrix a staircase if it starts and ends in the free cell, visits only free cells, and has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. In particular, a path, consisting of a single cell, is considered to be a staircase. Here are some examples of staircases: <image> Initially all the cells of the matrix are free. You have to process q queries, each of them flipping the state of a single cell\u2014so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free. Print the number of different staircases after each query; two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a matrix, consisting of n rows and m columns, where the rows are numbered top to bottom and the columns are numbered left to right. Each cell of the matrix can be either free or locked. Let's call a path in the matrix a staircase if it starts and ends in the free cell, visits only free cells, and has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one. Then the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one. Then the fourth cell is 1 to the bottom from the third one, and so on. In particular, a path, consisting of a single cell, is considered to be a staircase. Here are some examples of staircases: <image> Initially all the cells of the matrix are free. You have to process q queries, each of them flipping the state of a single cell\u2014so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free. Print the number of different staircases after each query; two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a matrix, consisting of n rows and m columns, where the rows are numbered top to bottom and the columns are numbered left to right, and each cell of the matrix can be either free or locked. Let's call a path in the matrix a staircase if it starts and ends in the free cell, visits only free cells, and has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. In particular, a path, consisting of a single cell, is considered to be a staircase, and here are some examples of staircases: <image> Initially all the cells of the matrix are free. You have to process q queries, each of them flipping the state of a single cell\u2014so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free. Print the number of different staircases after each query; two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\ndef count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Process queries to count the number of unique staircases in a matrix.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list[tuple[int, int]]): List of queries, each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        list[int]: List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Initialize a set to keep track of unique staircases\n    staircases = set()\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = not matrix[x][y]\n    \n    # Function to check if a cell is free\n    def is_free(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m and matrix[x][y]\n    \n    # Function to explore staircases using DFS\n    def explore_staircase(x: int, y: int, path: list[tuple[int, int]], direction: int):\n        if not is_free(x, y):\n            return\n        \n        path.append((x, y))\n        \n        # If the path is a valid staircase, add it to the set\n        if len(path) > 1:\n            staircases.add(tuple(path))\n        \n        # Explore next cell based on direction\n        if direction == 0:  # Right then Down\n            explore_staircase(x, y + 1, path.copy(), 1)\n            explore_staircase(x + 1, y, path.copy(), 0)\n        else:  # Down then Right\n            explore_staircase(x + 1, y, path.copy(), 0)\n            explore_staircase(x, y + 1, path.copy(), 1)\n    \n    # Function to count staircases after each query\n    def count_staircases_after_query():\n        staircases.clear()\n        for i in range(n):\n            for j in range(m):\n                if is_free(i, j):\n                    explore_staircase(i, j, [], 0)\n                    explore_staircase(i, j, [], 1)\n        return len(staircases)\n    \n    # Process each query and count staircases\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)  # Convert to 0-based index\n        results.append(count_staircases_after_query())\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Process queries to toggle cell states and count unique staircases.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list[tuple[int, int]]): List of queries to toggle cell states.\n\n    Returns:\n        list[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True represents free, False represents locked)\n    matrix = np.ones((n, m), dtype=bool)\n    \n    # Initialize a list to store the number of staircases after each query\n    staircase_counts = []\n\n    def is_staircase_path(x: int, y: int, direction: int) -> bool:\n        \"\"\"Check if a path starting at (x, y) is a valid staircase path.\n\n        Args:\n            x (int): Starting row index.\n            y (int): Starting column index.\n            direction (int): Direction of the staircase (0 for right-bottom, 1 for bottom-right).\n\n        Returns:\n            bool: True if the path is a valid staircase, False otherwise.\n        \"\"\"\n        current_x, current_y = x, y\n        while 0 <= current_x < n and 0 <= current_y < m and matrix[current_x, current_y]:\n            if direction == 0:\n                if current_y + 1 < m and matrix[current_x, current_y + 1]:\n                    current_y += 1\n                    direction = 1\n                else:\n                    break\n            else:\n                if current_x + 1 < n and matrix[current_x + 1, current_y]:\n                    current_x += 1\n                    direction = 0\n                else:\n                    break\n        return current_x != x or current_y != y\n\n    def count_staircases_in_matrix() -> int:\n        \"\"\"Count the number of unique staircases in the current matrix configuration.\n\n        Returns:\n            int: Number of unique staircases.\n        \"\"\"\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i, j]:\n                    # Check both possible staircase directions\n                    if is_staircase_path(i, j, 0):\n                        count += 1\n                    if is_staircase_path(i, j, 1):\n                        count += 1\n        return count\n\n    # Process each query\n    for x, y in queries:\n        # Toggle the state of the specified cell\n        matrix[x - 1, y - 1] = not matrix[x - 1, y - 1]\n        \n        # Count the staircases after the toggle\n        staircase_count = count_staircases_in_matrix()\n        staircase_counts.append(staircase_count)\n\n    return staircase_counts\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query toggles the state of a cell.\n\n    Returns:\n        List[int]: List of counts of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells marked as free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = not matrix[x][y]\n\n    # Function to count unique staircases\n    def count_unique_staircases() -> int:\n        visited = set()\n        unique_staircases = set()\n\n        def dfs(x: int, y: int, path: List[Tuple[int, int]], direction: int):\n            if (x, y) in visited or not matrix[x][y]:\n                return\n            visited.add((x, y))\n            path.append((x, y))\n            unique_staircases.add(tuple(path))\n\n            # Zigzag pattern: right then down or down then right\n            if direction == 0:  # Right then down\n                if y + 1 < m:\n                    dfs(x, y + 1, path[:], 1)\n                if x + 1 < n:\n                    dfs(x + 1, y, path[:], 0)\n            else:  # Down then right\n                if x + 1 < n:\n                    dfs(x + 1, y, path[:], 1)\n                if y + 1 < m:\n                    dfs(x, y + 1, path[:], 0)\n\n            visited.remove((x, y))\n\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    dfs(i, j, [], 0)\n                    dfs(i, j, [], 1)\n\n        return len(unique_staircases)\n\n    results = []\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        x -= 1\n        y -= 1\n        \n        # Toggle the state of the specified cell\n        toggle_cell(x, y)\n        \n        # Recalculate the number of unique staircases\n        unique_staircases_count = count_unique_staircases()\n        \n        # Append the result for this query\n        results.append(unique_staircases_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Function call\n    results = count_staircases(n, m, queries)\n    \n    # Output interface\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = [['free' for _ in range(m)] for _ in range(n)]\n    \n    # Function to check if all cells are locked\n    def all_locked(matrix: List[List[str]]) -> bool:\n        return all(cell == 'locked' for row in matrix for cell in row)\n    \n    # Function to check if all cells are free\n    def all_free(matrix: List[List[str]]) -> bool:\n        return all(cell == 'free' for row in matrix for cell in row)\n    \n    # Function to calculate maximum staircases in a fully free matrix\n    def max_staircases(matrix: List[List[str]]) -> int:\n        # For a fully free matrix, calculate the number of staircases\n        return n * m  # Simplified calculation for demonstration\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = 'locked' if matrix[x][y] == 'free' else 'free'\n    \n    # Function to calculate staircases using DFS\n    def calculate_staircases() -> int:\n        visited = set()\n        \n        def dfs(x: int, y: int, direction: int) -> int:\n            if (x, y) in visited or matrix[x][y] == 'locked':\n                return 0\n            visited.add((x, y))\n            count = 1  # Count the current cell as a staircase\n            if direction == 0:  # Right then down\n                if y + 1 < m:\n                    count += dfs(x, y + 1, 1)\n                if x + 1 < n:\n                    count += dfs(x + 1, y, 0)\n            else:  # Down then right\n                if x + 1 < n:\n                    count += dfs(x + 1, y, 0)\n                if y + 1 < m:\n                    count += dfs(x, y + 1, 1)\n            return count\n        \n        total_staircases = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'free' and (i, j) not in visited:\n                    total_staircases += dfs(i, j, 0) + dfs(i, j, 1)\n        \n        return total_staircases\n    \n    results = []\n    \n    for x, y in queries:\n        # Adjust indices for 0-based indexing\n        x -= 1\n        y -= 1\n        \n        # Toggle the cell state\n        toggle_cell(x, y)\n        \n        # Handle edge cases\n        if n == 1 and m == 1:\n            results.append(1 if matrix[0][0] == 'free' else 0)\n        elif all_locked(matrix):\n            results.append(0)\n        elif all_free(matrix):\n            results.append(max_staircases(matrix))\n        else:\n            # Calculate staircases for the current matrix state\n            results.append(calculate_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Counts the number of different staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list[tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to flip.\n\n    Returns:\n        list[int]: List of integers representing the number of different staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = np.ones((n, m), dtype=bool)\n    \n    # Cache to store previously computed results for subproblems\n    cache = {}\n\n    def is_free(x: int, y: int) -> bool:\n        \"\"\"Check if a cell is free.\"\"\"\n        return 0 <= x < n and 0 <= y < m and matrix[x, y]\n\n    def count_staircases_from(x: int, y: int) -> int:\n        \"\"\"Count staircases starting from a given cell.\"\"\"\n        if not is_free(x, y):\n            return 0\n        if (x, y) in cache:\n            return cache[(x, y)]\n        \n        # Single cell is a staircase\n        count = 1\n        \n        # Check right-down pattern\n        if is_free(x, y + 1) and is_free(x + 1, y + 1):\n            count += count_staircases_from(x + 1, y + 1)\n        \n        # Check down-right pattern\n        if is_free(x + 1, y) and is_free(x + 1, y + 1):\n            count += count_staircases_from(x + 1, y + 1)\n        \n        cache[(x, y)] = count\n        return count\n\n    def total_staircases() -> int:\n        \"\"\"Calculate the total number of staircases in the current matrix.\"\"\"\n        cache.clear()\n        total = 0\n        for i in range(n):\n            for j in range(m):\n                if is_free(i, j):\n                    total += count_staircases_from(i, j)\n        return total\n\n    results = []\n    for x, y in queries:\n        # Flip the state of the cell (x, y)\n        matrix[x - 1, y - 1] = not matrix[x - 1, y - 1]\n        # Count staircases after the query\n        results.append(total_staircases())\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Count the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query toggles the state of a cell.\n\n    Returns:\n        List[int]: List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells marked as free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = not matrix[x][y]\n\n    # Function to count unique staircases\n    def count_unique_staircases() -> int:\n        unique_staircases = set()\n        \n        # Check each cell as a potential start of a staircase\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:  # If the cell is free\n                    # Try to build staircases starting from this cell\n                    build_staircase(i, j, unique_staircases)\n        \n        return len(unique_staircases)\n\n    # Function to build staircases from a given starting cell\n    def build_staircase(x: int, y: int, unique_staircases: set):\n        # Two possible patterns: right-down-right... and down-right-down...\n        path1 = []\n        path2 = []\n        \n        # Pattern 1: right-down-right...\n        i, j = x, y\n        while i < n and j < m and matrix[i][j]:\n            path1.append((i, j))\n            if len(path1) % 2 == 1:  # Move right\n                j += 1\n            else:  # Move down\n                i += 1\n        if path1:\n            unique_staircases.add(tuple(path1))\n        \n        # Pattern 2: down-right-down...\n        i, j = x, y\n        while i < n and j < m and matrix[i][j]:\n            path2.append((i, j))\n            if len(path2) % 2 == 1:  # Move down\n                i += 1\n            else:  # Move right\n                j += 1\n        if path2:\n            unique_staircases.add(tuple(path2))\n\n    results = []\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        toggle_cell(x - 1, y - 1)\n        # Recalculate the number of unique staircases\n        results.append(count_unique_staircases())\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Count the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True represents free, False represents locked)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = not matrix[x][y]\n\n    # Function to count unique staircases in the matrix\n    def count_unique_staircases() -> int:\n        unique_staircases = set()\n        \n        # Iterate through each cell in the matrix\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:  # If the cell is free\n                    # Check for staircases starting from this cell\n                    check_staircase(i, j, unique_staircases)\n        \n        return len(unique_staircases)\n\n    # Function to check and add staircases starting from a given cell\n    def check_staircase(start_x: int, start_y: int, staircases_set: set):\n        # Check both zigzag patterns\n        path1 = []\n        path2 = []\n        \n        x, y = start_x, start_y\n        while x < n and y < m and matrix[x][y]:\n            path1.append((x, y))\n            x += 1\n            if x < n and matrix[x][y]:\n                path1.append((x, y))\n                y += 1\n        \n        x, y = start_x, start_y\n        while x < n and y < m and matrix[x][y]:\n            path2.append((x, y))\n            y += 1\n            if y < m and matrix[x][y]:\n                path2.append((x, y))\n                x += 1\n        \n        # Add paths to the set if they are valid staircases\n        if path1:\n            staircases_set.add(tuple(path1))\n        if path2:\n            staircases_set.add(tuple(path2))\n\n    # Process each query and calculate the number of unique staircases\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)  # Adjust for 0-based index\n        results.append(count_unique_staircases())\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of different staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cell states.\n\n    Returns:\n        List[int]: Number of different staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Initialize the result list\n    results = []\n    \n    # Function to count staircases in the current matrix state\n    def count_current_staircases() -> int:\n        # Dynamic programming table to store staircase counts\n        dp_right = [[0] * m for _ in range(n)]\n        dp_bottom = [[0] * m for _ in range(n)]\n        \n        # Count single cell staircases\n        total_staircases = sum(sum(row) for row in matrix)\n        \n        # Fill the dynamic programming tables\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    # Count staircases ending at (i, j) with right-bottom pattern\n                    if j > 0 and i > 0:\n                        dp_right[i][j] = dp_bottom[i-1][j-1] + 1\n                    # Count staircases ending at (i, j) with bottom-right pattern\n                    if i > 0 and j > 0:\n                        dp_bottom[i][j] = dp_right[i-1][j-1] + 1\n                    \n                    # Add to total staircases\n                    total_staircases += dp_right[i][j] + dp_bottom[i][j]\n        \n        return total_staircases\n    \n    # Process each query\n    for x, y in queries:\n        # Toggle the state of the cell (x-1, y-1)\n        matrix[x-1][y-1] = not matrix[x-1][y-1]\n        \n        # Count staircases after the toggle\n        results.append(count_current_staircases())\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output results\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to flip the state of cells.\n\n    Returns:\n        List[int]: List of the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    def is_valid(x: int, y: int) -> bool:\n        \"\"\"Check if a cell is within the matrix bounds and free.\"\"\"\n        return 0 <= x < n and 0 <= y < m and matrix[x][y]\n\n    def dfs(x: int, y: int, visited: set) -> None:\n        \"\"\"Perform DFS to explore all possible paths from a given cell.\"\"\"\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        # Explore right-bottom and bottom-right paths\n        if is_valid(x, y + 1) and is_valid(x + 1, y + 1):\n            dfs(x + 1, y + 1, visited)\n        if is_valid(x + 1, y) and is_valid(x + 1, y + 1):\n            dfs(x + 1, y + 1, visited)\n\n    results = []\n    for x, y in queries:\n        # Flip the state of the cell\n        x -= 1  # Convert to 0-based index\n        y -= 1  # Convert to 0-based index\n        if matrix[x][y]:\n            matrix[x][y] = False\n            free_cells.discard((x, y))\n        else:\n            matrix[x][y] = True\n            free_cells.add((x, y))\n\n        # Count unique staircases\n        visited = set()\n        staircase_count = 0\n        for cell in free_cells:\n            if cell not in visited:\n                dfs(cell[0], cell[1], visited)\n                staircase_count += 1\n\n        results.append(staircase_count)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Count the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize matrix and set of free cells\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n\n    def toggle_cell(x: int, y: int) -> None:\n        \"\"\"Toggle the state of a cell in the matrix.\"\"\"\n        if (x, y) in free_cells:\n            free_cells.remove((x, y))\n        else:\n            free_cells.add((x, y))\n\n    def dfs(x: int, y: int, visited: set) -> None:\n        \"\"\"Perform DFS to explore paths and mark visited cells.\"\"\"\n        if (x, y) not in free_cells or (x, y) in visited:\n            return\n        visited.add((x, y))\n        if x + 1 < n:\n            dfs(x + 1, y, visited)\n        if y + 1 < m:\n            dfs(x, y + 1, visited)\n\n    def count_staircases() -> int:\n        \"\"\"Count the number of unique staircases using DFS.\"\"\"\n        visited = set()\n        staircase_count = 0\n        for x, y in free_cells:\n            if (x, y) not in visited:\n                dfs(x, y, visited)\n                staircase_count += 1\n        return staircase_count\n\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)\n        results.append(count_staircases())\n\n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    result = count_staircases(n, m, queries)\n    for res in result:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to efficiently process a series of queries on a matrix to determine the number of unique staircase paths. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy. The challenge lies in dynamically updating the staircase count as cells are toggled between free and locked states.\nrequirement pool:\n- Efficiently handle matrix queries to update staircase counts.\n- Accurately count unique staircase paths after each query.\n- Optimize performance for large matrices and numerous queries.\n- Provide clear output format as specified in requirements.\n- Implement user-friendly input handling.\nWe will use a matrix to represent the grid and a set to keep track of all unique staircases. For each query, we will toggle the state of the specified cell and update the set of staircases accordingly. The challenge is efficiently updating the staircase count after each query, which can be achieved by checking the impact of the toggle on existing staircases and potential new staircases. We will use a combination of depth-first search (DFS) and dynamic programming to efficiently count and update staircases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific structures: alternating right and down movements or alternating down and right movements.\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix, changing it from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    'different'\n    Explanation: Two staircases are considered different if there exists a cell that appears in one path and doesn't appear in the other path.\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to keep track of all unique staircases.\n    2. For each query, toggle the state of the specified cell.\n    3. Use depth-first search (DFS) to explore potential staircases starting from each free cell.\n    4. Use dynamic programming to efficiently count and update staircases by storing intermediate results.\n    5. After processing each query, count the number of unique staircases and store the result.\n\n# [edge case] \n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist, so the output for each query will be 0.\n\n    Edge Case 2: A matrix with only one free cell.\n    Explanation: The single free cell itself is considered a staircase, so the output for each query will be 1.\n\n    Edge Case 3: A matrix with alternating locked and free cells in a checkerboard pattern.\n    Explanation: The number of staircases will depend on the specific arrangement and queries, but it will be limited due to the locked cells preventing continuous paths.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if all cells are locked initially and return 0 for each query.\n        - Handle matrices with only one free cell by returning 1 for each query.\n        - Implement logic to efficiently count staircases in complex patterns like checkerboards using DFS and dynamic programming.\n", "requirement analysis:\nThe task requires efficiently processing a series of queries on a matrix to determine the number of unique staircases. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy. The challenge lies in dynamically updating the staircase count as cells are toggled between free and locked states.\nrequirement pool:\n- Implement efficient matrix query processing.\n- Develop accurate staircase counting logic.\n- Optimize for large matrix sizes and high query counts.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and immediate output for each query.\nWe will use a matrix to represent the grid and a set to track the unique staircases. For each query, we will toggle the state of the cell and update the staircase count by checking the possible staircase paths that include the toggled cell. This approach ensures that we efficiently update the count without recalculating from scratch. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid of n rows and m columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by checking adjacent cells in the specified direction.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix to represent the grid, with all cells initially set to free.\n2. Initialize a counter to track the number of unique staircases.\n3. For each query:\n   - Toggle the state of the specified cell.\n   - Check for new staircases that include the toggled cell by examining its neighbors in the zigzag pattern.\n   - Update the staircase count based on the changes.\n4. Output the staircase count after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with only one cell (1x1) and one query.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is toggled from free to locked, resulting in no free cells for a staircase.\n\n    Edge Case 2: A matrix with all cells initially locked.\n    Input: 2 2 1\n           1 1\n    Expected Output: 0\n    Explanation: Toggling one cell does not create any valid staircases as all other cells remain locked.\n\n    Edge Case 3: A matrix with maximum size (1000x1000) and a single query.\n    Input: 1000 1000 1\n           500 500\n    Expected Output: Depends on initial configuration but should handle efficiently.\n    Explanation: The performance should be tested for large matrices with minimal queries.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently, especially for large matrices.\n    - Implement efficient data structures to track free cells and potential staircases.\n    - Use numpy for matrix operations to handle large data efficiently.\n    - Consider edge cases where toggling does not affect existing staircases or creates new ones.\n", "requirement analysis:\nThe task requires processing a matrix with dynamic cell states and counting unique staircase paths after each query. The main challenge is efficiently updating and counting paths in response to each query, especially given the potential size of the matrix and number of queries.\nrequirement pool:\n- Implement efficient matrix query processing.\n- Develop accurate staircase path counting logic.\n- Optimize performance for large matrices and numerous queries.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and concise output for each query.\nWe will implement a function to process the matrix queries efficiently. The function will maintain the state of the matrix and count the number of unique staircases after each query. We will use a 2D list to represent the matrix and a set to track unique staircases. The function will update the matrix state and recalculate the number of staircases after each query. Given the constraints, we will focus on optimizing the path counting logic to handle large matrices and numerous queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix': A grid consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom': These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix cells accordingly (e.g., moving from (i, j) to (i, j+1) for right movement and (i+1, j) for bottom movement).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix with all cells marked as free.\n    2. For each query, toggle the state of the specified cell (free to locked or locked to free).\n    3. After each query, recalculate the number of unique staircases:\n        - Use a set to track unique paths.\n        - Implement logic to explore possible staircase paths starting from each free cell.\n        - Ensure paths follow the zigzag pattern described in the requirement.\n    4. Output the count of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist, so the output should be 0 after each query.\n    \n    Edge Case 2: A matrix with only one cell.\n    Explanation: The single cell is a staircase itself if it is free, so the output should be 1 if the cell is free and 0 if it is locked.\n    \n    Edge Case 3: A matrix with alternating free and locked cells in a checkerboard pattern.\n    Explanation: Depending on the query, staircases may be limited due to locked cells blocking paths.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently:\n        - Implement checks for single-cell matrices.\n        - Optimize path exploration logic to handle matrices with complex patterns like checkerboards.\n        - Ensure efficient toggling and recalculation of paths to handle large matrices and numerous queries.\n", "requirement analysis:\nThe task involves processing a matrix with dynamic updates and calculating the number of unique staircase paths after each update. The main challenge is efficiently handling large matrices and numerous queries while ensuring accurate path counting.\nrequirement pool:\n- Efficiently handle matrix updates and query processing.\n- Accurately count and differentiate staircase paths.\n- Optimize performance for large matrices and high query volumes.\n- Provide clear output for each query.\n- Implement a user-friendly interface for input and output.\nWe will use a matrix to represent the grid and a set to track the unique staircases. For each query, we will toggle the state of the specified cell and recalculate the number of unique staircases. The challenge is efficiently updating the count of staircases after each query, which can be achieved by only recalculating paths affected by the change. We will use a depth-first search (DFS) approach to explore possible staircases starting from each free cell.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid structure consisting of rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix, affecting the number of possible staircases.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each step moves either one cell to the right or one cell down.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to track unique staircases.\n    2. For each query, toggle the state of the specified cell.\n    3. Use DFS to explore possible staircases starting from each free cell.\n    4. Update the count of unique staircases after each query by recalculating paths affected by the change.\n    5. Print the number of different staircases after each query.\n\n# [edge case]\n    Edge Case 1: Matrix with all cells initially locked\n    Explanation: No staircases can exist, so the output for each query will be 0.\n\n    Edge Case 2: Matrix with all cells initially free\n    Explanation: The number of staircases will be maximized initially, and will decrease as cells are locked.\n\n    Edge Case 3: Single cell matrix\n    Explanation: The only staircase is the single cell itself, so toggling it will result in outputs alternating between 1 and 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            # Handle single cell matrix separately\n            print(1 if matrix[0][0] == 'free' else 0)\n        elif all_locked(matrix):\n            # Handle all cells locked case\n            print(0)\n        elif all_free(matrix):\n            # Handle all cells free case\n            print(max_staircases(matrix))\n        (other code)\n", "requirement analysis:\nThe requirements focus on processing matrix queries efficiently and accurately counting staircases. The solution must handle large matrices and multiple queries, ensuring performance optimization and correctness in staircase identification.\nrequirement pool:\n- Implement efficient matrix query processing.\n- Develop accurate staircase counting logic.\n- Optimize performance for large matrices.\n- Ensure scalability for up to 10^4 queries.\n- Provide clear input/output handling.\nWe will use a matrix representation to track the state of each cell (free or locked) and efficiently update it with each query. To count staircases, we will implement a function that checks possible staircase paths starting from each free cell. Given the constraints, we will optimize the solution using NumPy for efficient matrix operations and leverage caching techniques to avoid redundant calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure consisting of rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each step is either one cell to the right or one cell down from the previous cell.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix of size n x m with all cells marked as free.\n2. For each query, flip the state of the specified cell (x, y).\n3. After each query, count the number of different staircases:\n   - Iterate over each cell in the matrix.\n   - For each free cell, attempt to form a staircase starting from that cell using both possible patterns.\n   - Use caching to store previously computed results for subproblems to avoid redundant calculations.\n4. Output the number of different staircases after each query.\n\n# [edge case]\n    Edge Case 1: A 1x1 matrix with a single query flipping the only cell.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is flipped to locked, so no staircases can exist.\n\n    Edge Case 2: A 2x2 matrix with all cells initially free and multiple queries flipping the same cell back and forth.\n    Input: 2 2 4\n           1 1\n           1 1\n           1 1\n           1 1\n    Expected Output: 3, 0, 3, 0\n    Explanation: The first query locks one cell, reducing staircases. The second query unlocks it, restoring staircases.\n\n    Edge Case 3: A large matrix with no queries.\n    Input: 1000 1000 0\n    Expected Output: No output since there are no queries to process.\n    Explanation: The matrix remains unchanged with all cells free, but no queries mean no output is required.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no queries are provided or when all cells are locked.\n    \n```python\ndef handle_no_queries(n, m):\n    # If there are no queries, simply return without processing\n    return\n\ndef handle_all_locked(matrix):\n    # If all cells are locked, return zero staircases\n    return 0\n\n# Integrate these functions into the main logic where necessary\n```\n", "requirement analysis:\nThe requirement is to efficiently process a series of queries on a matrix to determine the number of unique staircase paths. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently process matrix queries to update cell states.\n- Accurately count unique staircase paths after each query.\n- Optimize the algorithm for large matrices and numerous queries.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and concise output for each query.\nWe will implement a function to efficiently process matrix queries and count unique staircase paths. The challenge is to handle large matrices and numerous queries efficiently. We will use a 2D list to represent the matrix and a set to track unique staircases. The function will toggle the state of a cell and recalculate the number of unique staircases after each query. We will optimize the path counting by only recalculating paths affected by the query.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix': A grid consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the matrix that starts and ends in a free cell, visiting only free cells, with specific movement patterns.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom': These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix with all cells marked as free.\n    2. For each query, toggle the state of the specified cell.\n    3. After each query, recalculate the number of unique staircases:\n        - Use a set to track unique paths.\n        - For each free cell, attempt to build a staircase path following the defined movement patterns.\n        - Add each valid path to the set.\n    4. Output the size of the set after each query, which represents the number of unique staircases.\n\n# [edge case]\n    Edge Case 1: A matrix with only one cell (1x1) and one query.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is toggled to locked, so no staircase can exist.\n\n    Edge Case 2: A matrix with all cells initially locked.\n    Input: 2 2 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Expected Output: 0, 0, 0, 0\n    Explanation: All cells are toggled to free one by one, but no staircase can be formed until all are free.\n\n    Edge Case 3: A large matrix with no queries.\n    Input: 1000 1000 0\n    Expected Output: (No output)\n    Explanation: No queries mean no changes to the matrix, hence no staircases are recalculated.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no staircases can be formed due to all cells being locked or insufficient queries:\n        - Check if all cells are locked after a query; if so, return 0 for that query.\n        - Handle cases with no queries by skipping staircase calculations entirely.\n", "requirement analysis:\nThe task requires processing a matrix with dynamic cell states and counting unique staircase paths after each query. The challenge lies in efficiently updating and counting paths as the matrix changes, especially given the constraints on matrix size and number of queries.\nrequirement pool:\n- Implement efficient matrix query processing.\n- Develop accurate staircase counting logic.\n- Optimize for large matrix sizes and numerous queries.\n- Ensure the solution is scalable and maintainable.\n- Provide clear output format as specified.\nWe will implement a function to efficiently process the matrix queries and count the number of unique staircases. The challenge is to dynamically update the matrix and recalculate the staircase count after each query. We will use a 2D list to represent the matrix and a set to track unique staircases. The function will iterate over each query, toggle the cell state, and update the staircase count accordingly. Given the constraints, the solution will be optimized for performance using efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each step is either one cell to the right or one cell down from the previous cell.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the matrix, with all cells initially set to free.\n2. Create a function to toggle the state of a cell based on the query.\n3. Implement a function to count unique staircases in the matrix:\n   - Iterate through each cell in the matrix.\n   - For each free cell, attempt to form a staircase path following both patterns.\n   - Use a set to track unique paths based on their cell coordinates.\n4. For each query, toggle the specified cell and recalculate the number of unique staircases.\n5. Output the number of unique staircases after each query.\n\n# [edge case]\n    1. A matrix with all cells initially locked (e.g., 2x2 matrix with all cells locked) = 0\n    Explanation: No staircases can be formed if all cells are locked.\n\n    2. A single-cell matrix (1x1) = 1\n    Explanation: A single free cell is considered a staircase by itself.\n\n    3. A matrix with alternating locked and free cells in a checkerboard pattern = Depends on specific queries\n    Explanation: The number of staircases will vary based on which cells are toggled by queries.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for edge cases where all cells are locked or when dealing with very small matrices.\n        - Ensure that the logic for counting staircases correctly handles matrices with minimal dimensions or specific patterns like checkerboards.\n", "requirement analysis:\nThe requirement is to efficiently process a series of queries on a matrix to determine the number of unique staircases after each query. The solution must handle large matrices and a high number of queries, ensuring performance optimization and accurate counting of staircases.\nrequirement pool:\n- Efficiently process matrix queries to flip cell states.\n- Accurately count the number of unique staircases after each query.\n- Optimize the algorithm for large matrices and high query counts.\n- Ensure the output format is clear and consistent with requirements.\n- Provide user-friendly input and output handling.\nWe will use a matrix representation to track the state of each cell (free or locked) and employ a dynamic programming approach to efficiently count staircases. The algorithm will update the count of staircases after each query by recalculating paths affected by the change in cell state. Libraries like NumPy can be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix': A grid-like structure consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the matrix that starts and ends in a free cell, visits only free cells, and follows specific movement patterns (right-bottom-right-bottom or bottom-right-bottom-right).\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the state of each cell (free or locked).\n    2. For each query, toggle the state of the specified cell.\n    3. Use dynamic programming to count staircases:\n        - For each free cell, check if it can be part of a staircase by following the defined movement patterns.\n        - Update the count of staircases based on changes in cell states.\n    4. After processing each query, output the number of different staircases.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist, so the output for each query will be 0.\n    \n    Edge Case 2: A matrix with only one row or one column.\n    Explanation: Staircases can only be single cells since movement patterns require both horizontal and vertical moves.\n    \n    Edge Case 3: A query that toggles a cell back to its original state immediately after toggling it.\n    Explanation: The number of staircases should return to its previous count before the toggle.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if all cells are locked initially and return 0 for all queries.\n        - Handle matrices with only one row or column by limiting staircase checks to single cells.\n        - Implement logic to revert staircase counts when a cell is toggled back to its original state.\n", "requirement analysis:\nThe task requires efficiently processing a series of queries on a matrix to determine the number of unique staircases. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient query processing for matrix updates.\n- Develop an algorithm to accurately count unique staircases.\n- Optimize the solution for large matrix sizes.\n- Ensure the solution is scalable with the number of queries.\n- Provide detailed output for each query result.\nWe will use a matrix to represent the grid and a set to track the free cells. For each query, we will update the state of the cell and recalculate the number of unique staircases using a depth-first search (DFS) approach. This will allow us to efficiently explore all possible paths and count the staircases. The use of DFS ensures that we can handle large matrices and a high number of queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array consisting of rows and columns. In this requirement, it represents a grid where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern either right-bottom-right-bottom or bottom-right-bottom-right.\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or move down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to track free cells.\n    2. For each query, update the state of the specified cell.\n    3. Use DFS to explore all possible paths starting from each free cell and count unique staircases.\n    4. After processing each query, output the number of unique staircases.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Expected Output: 0\n    Explanation: No staircases can exist if all cells are locked.\n\n    Edge Case 2: A matrix with only one free cell.\n    Expected Output: 1\n    Explanation: A single free cell is considered a staircase.\n\n    Edge Case 3: A matrix with alternating locked and free cells in a checkerboard pattern.\n    Expected Output: Depends on the specific arrangement and queries, but generally fewer staircases due to limited continuous free paths.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if all cells are locked:\n            return 0\n        if only one cell is free:\n            return 1\n        (other code for handling checkerboard pattern)\n", "requirement analysis:\nThe requirements focus on processing a series of queries that flip the state of cells in a matrix and counting the number of unique staircases after each query. The solution must efficiently handle large matrices and a high number of queries, ensuring accurate staircase differentiation. The output format must strictly follow the provided examples.\nrequirement pool:\n- Efficient query processing to update matrix state\n- Accurate counting of unique staircases\n- Scalability for large matrices and query sets\n- User-friendly input and output format\n- Clear documentation and instructions\nWe will use a matrix to represent the grid and a set to keep track of free cells. For each query, we will update the state of the cell and recalculate the number of unique staircases using a depth-first search (DFS) approach. This will allow us to efficiently explore all possible paths and count staircases. The use of DFS ensures that we can handle large matrices and a high number of queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each step is either one cell to the right or one cell down.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix to represent the grid and a set to track free cells.\n2. For each query, toggle the state of the specified cell.\n3. Use a depth-first search (DFS) to explore all possible paths starting from each free cell.\n4. Count the number of unique staircases by ensuring no two paths share the same set of cells.\n5. After processing each query, output the current count of unique staircases.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist, so the output should be 0 for all queries.\n\n    Edge Case 2: A single cell matrix (1x1).\n    Explanation: The only possible staircase is the single cell itself, so the output should toggle between 1 and 0 with each query.\n\n    Edge Case 3: A matrix with alternating locked and free cells in a checkerboard pattern.\n    Explanation: The number of staircases will depend on how queries affect connectivity, potentially resulting in complex patterns.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For a matrix with all cells initially locked, ensure that no staircases are counted.\n    - For a single cell matrix, handle toggling between 1 and 0 correctly.\n    - For complex patterns like checkerboards, ensure DFS correctly identifies and counts unique paths.\n\n```python\ndef process_queries(n, m, queries):\n    # Initialize matrix and set of free cells\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n\n    def toggle_cell(x, y):\n        if (x, y) in free_cells:\n            free_cells.remove((x, y))\n        else:\n            free_cells.add((x, y))\n\n    def count_staircases():\n        # Implement DFS to count unique staircases\n        # This is a placeholder for the actual DFS logic\n        return len(free_cells)  # Simplified example\n\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)\n        results.append(count_staircases())\n\n    return results\n```\n\nThis code provides a basic structure for handling queries and counting staircases. The actual DFS logic needs to be implemented to accurately count unique paths based on the problem's requirements.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 264, "examples": "\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "mutate_method": "condense_two2one", "parent_index": 129}
