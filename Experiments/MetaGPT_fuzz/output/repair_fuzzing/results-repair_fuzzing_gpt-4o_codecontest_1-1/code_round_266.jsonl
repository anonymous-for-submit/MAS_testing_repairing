{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's define a positive number as special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4, we have that number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's define a positive number as special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4, we have that number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's define a positive number as special if it can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4, we have that number 17 is special. This is definitely special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not a special number.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's define a positive number as special if it can be expressed as a sum of distinct non-negative powers of n; for example, for n = 4, we have that number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k >>= 1\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            k //= 2\n            power = (power * n) % MOD\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing (n, k) for each test case.\n\n    Returns:\n        List[int]: List of k-th special numbers modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1  # Start with n^0 which is 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MODULO\n            k //= n\n            power = (power * n) % MODULO\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed as a sum\n    of distinct non-negative powers of a given integer n. The k-th special number is\n    the k-th number in the sequence of special numbers when sorted in increasing order.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        test_cases.append((n, k))\n        index += 2\n    \n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1  # Start with n^0 which is 1\n        while k > 0:\n            if k & 1:  # Check if the least significant bit is set\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO  # Move to the next power of n\n            k >>= 1  # Shift k to the right to process the next bit\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"Find the k-th special number for a given base n.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of distinct non-negative powers of n. The k-th special number\n    is the k-th smallest number in this sequence.\n\n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n\n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n\n    return result\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    t = int(input().strip())\n    results = []\n\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        result = find_kth_special_number(n, k)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    MOD = 10**9 + 7\n    results = []\n\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        index = 0\n\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n            index += 1\n\n        results.append(special_number)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            k //= 2\n            power = (power * n) % MOD\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1  # Start with n^0\n        while k > 0:\n            if k & 1:  # Check if the least significant bit is set\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO  # Move to the next power of n\n            k >>= 1  # Shift k right by one bit\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires generating special numbers based on distinct non-negative powers of n. The solution must efficiently compute the k-th special number for large values of n and k, ensuring results are modulo 10^9+7. The algorithm should handle multiple test cases and provide accurate outputs quickly.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Ensure robust error handling\nWe will use a mathematical approach to generate special numbers by considering the binary representation of k. Each bit in the binary representation corresponds to a power of n, which allows us to efficiently compute the k-th special number. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure scalability and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding different powers of n, where each power is used at most once.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its binary representation.\n    3. For each bit in the binary representation, calculate the corresponding power of n.\n    4. Sum these powers to get the k-th special number.\n    5. Return the result modulo 10^9+7.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The first special number for n=3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by considering the binary representation of k and calculating the sum of powers accordingly.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases efficiently and output results modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a binary representation approach to efficiently compute the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and scales well with large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are within the specified modulo constraint.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding together different powers of n, where each power is non-negative (including zero). In code, this can be implemented by iterating over powers of n and checking combinations that sum up to the desired number.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or accessing the k-th special number, the sequence must be ordered.\n\n# [code logic]\n    1. Convert k to its base-n representation.\n    2. For each digit in the base-n representation, calculate the corresponding power of n and sum them up.\n    3. Apply modulo 10^9+7 to the result to ensure it fits within the constraints.\n    4. Repeat for each test case.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: For n=2, the second special number is 2, which corresponds to n^1.\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The first special number for n=3 is also 1, corresponding to n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by correctly computing the base-n representation and summing distinct powers.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, outputting results modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Optimize for performance with multiple test cases\n- Ensure output is modulo 10^9+7\n- Provide clear and concise output format\nWe will use a mathematical approach to generate the k-th special number by representing it as a sum of distinct non-negative powers of n. The key is to convert k into its binary representation and use the positions of '1's to determine the powers of n that need to be summed. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of a given number n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each power of n can be used at most once in the sum to form a special number. In code, this can be implemented by iterating over the binary representation of k and using the positions of '1's to determine which powers of n to include in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted in ascending order. This implies that the k-th special number is the k-th smallest number in this sequence.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Convert k into its binary representation.\n3. Initialize a variable to store the special number.\n4. Iterate over each bit in the binary representation of k:\n   - If the bit is '1', add the corresponding power of n to the special number.\n5. Compute the result modulo 10^9+7.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case 1: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Test case 2: (n=2, k=2) = 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Test case 3: (n=10^9, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of converting k into its binary representation and summing the corresponding powers of n inherently handles these cases.\n", "requirement analysis:\nThe task requires finding the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are output modulo 10^9+7.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and memory usage\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and perform modulo operations to ensure results fit within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding together different powers of n, where each power is used at most once. In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that the k-th special number is the k-th smallest in this sorted sequence.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its base-n representation.\n    3. Calculate the special number by summing the distinct powers of n indicated by the base-n representation.\n    4. Apply modulo 10^9+7 to the result to ensure it fits within constraints.\n    5. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Edge Case 3: n = 3, k = 10^9\n    Expected Output: (calculated value modulo 10^9+7)\n    Explanation: This tests the upper limit of k, ensuring the algorithm handles large values efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of converting k to base-n and summing distinct powers inherently handles these cases.\n", "requirement analysis:\nThe problem requires generating special numbers based on distinct non-negative powers of n. The solution must efficiently compute the k-th special number for large values of n and k, ensuring results are accurate and within the modulo constraint. The algorithm should handle multiple test cases and provide results quickly.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Ensure robust error handling\nWe will use a mathematical approach to generate special numbers by expressing them as sums of distinct non-negative powers of n. To efficiently compute the k-th special number, we will leverage the properties of binary representation and powers of n. The solution will handle large values of n and k by using modular arithmetic to ensure results are within the constraints. Python's built-in capabilities will be sufficient for this task, and we will use the modulo operation to manage large numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each power of n used in the sum is unique and non-repeating. For example, using powers like n^0, n^1, n^2, etc., without repetition.\n\n# [degree adverb] \n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use binary representation to determine which powers of n to include in the sum to form the k-th special number.\n3. Convert k to its binary form and use each bit to decide whether to include the corresponding power of n in the sum.\n4. Calculate the sum using powers of n where the corresponding bit in k's binary representation is 1.\n5. Use modular arithmetic (modulo 10^9+7) to ensure the result fits within the constraints.\n6. Output the result for each test case.\n\n# [edge case] \n    Edge Case 1: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Edge Case 2: (n=10^9, k=1) = 1\n    Explanation: Even for very large n, the first special number remains 1.\n\n    Edge Case 3: (n=2, k=10^9) = (result modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the calculation handles large numbers correctly using modular arithmetic.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by using binary representation and modular arithmetic.\n", "requirement analysis:\nThe task requires finding the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Optimize for multiple test cases\n- Provide clear and formatted output\nWe will use a mathematical approach to generate the k-th special number by leveraging the properties of binary representation and powers of n. The key idea is to treat k as a binary number and use its bits to determine which powers of n to sum. This approach is efficient and can handle large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each power of n can be used at most once in the sum to form a special number. In code, this can be implemented by iterating over the binary representation of k and using each bit to decide whether to include a corresponding power of n in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating the k-th special number, we need to ensure that we are considering the sequence in its natural order.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Initialize a variable to store the k-th special number.\n3. Convert k to its binary representation.\n4. Iterate over each bit in the binary representation of k:\n   - If the bit is set (i.e., 1), add the corresponding power of n to the special number.\n5. Compute the result modulo 10^9+7.\n6. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the upper limit of k and ensures that the code handles large values correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using binary representation and modular arithmetic inherently handles these cases efficiently.\n", "requirement analysis:\nThe problem requires calculating the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must efficiently handle large values of n and k, and return results modulo 10^9+7. The algorithm should be optimized for performance given the constraints.\nrequirement pool:\n- Efficiently compute the k-th special number using powers of n\n- Ensure the solution handles large inputs effectively\n- Provide accurate results within constraints\n- Optimize algorithm for performance\n- Implement modular arithmetic to handle large numbers\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. The k-th special number can be found by converting k to its base-n representation and interpreting it as a sum of powers of n. This approach is efficient and handles large values of n and k effectively. We will also use modular arithmetic to ensure the result is within the specified modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding different powers of n, where each power is used at most once. In code, this can be implemented by converting k to its base-n representation and using each digit as an indicator of whether a particular power of n is included in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when finding the k-th special number, we are considering the k-th smallest number in this sequence.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k to its base-n representation.\n3. Interpret this base-n representation as a sum of distinct powers of n.\n4. Compute the result modulo 10^9+7 to handle large numbers.\n5. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Edge Case 2: (n=10^9, k=1) = 1\n    Explanation: Even for very large n, the first special number is still 1.\n\n    Edge Case 3: (n=2, k=10^9) = (result modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the code handles large values correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its base-n representation inherently handles these cases, as it correctly computes the sum of distinct powers of n and applies the modulo operation.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n and k values across multiple test cases. The solution must efficiently handle large values and ensure results are modulo 10^9+7. The algorithm should be optimized for performance and accuracy.\nrequirement pool:\n- Efficient computation of special numbers\n- Handling large input values for n and k\n- Output results modulo 10^9+7\n- Ensure correct output format\n- Optimize algorithm for speed\nWe will use a mathematical approach to generate special numbers by expressing them as sums of distinct non-negative powers of n. To efficiently compute the k-th special number, we will leverage the properties of binary representation and powers of n. The algorithm will be optimized to handle large values of n and k by using bit manipulation and modular arithmetic to ensure results are within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n.\n\n    'modulo 10^9+7'\n    Explanation: Since the k-th special number may be too large, the result should be output modulo 10^9+7 to ensure it fits within standard integer limits.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding different powers of n, where each power is non-negative and distinct. In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers should be sorted in increasing order, meaning each subsequent number is greater than the previous one. This can be implemented by generating numbers in a sorted manner.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Generate special numbers using distinct non-negative powers of n.\n    3. Use binary representation to efficiently compute combinations of powers.\n    4. Sort the generated numbers in increasing order.\n    5. Retrieve the k-th special number from the sorted list.\n    6. Output the result modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 3, k = 10^9\n    Expected Output: (large number modulo 10^9+7)\n    Explanation: For large k, the output should be computed modulo 10^9+7 to fit within integer limits.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def find_special_number(n, k):\n            MOD = 10**9 + 7\n            special_numbers = []\n            i = 0\n            while len(special_numbers) < k:\n                num = sum(n**j for j in range(i+1))\n                special_numbers.append(num)\n                i += 1\n            special_numbers.sort()\n            return special_numbers[k-1] % MOD\n\n        (other code)\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are computed modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and memory usage\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. The k-th special number can be found by converting k to its base-n representation and interpreting it as a sum of powers of n. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n.\n\n    'modulo 10^9+7'\n    Explanation: The result should be computed modulo 10^9+7 to handle large numbers and prevent overflow.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding different powers of n, where each power is used at most once.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted in ascending order.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its base-n representation.\n    3. Interpret the base-n representation as a sum of distinct powers of n to find the k-th special number.\n    4. Compute the result modulo 10^9+7.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 1\n           2 1\n    Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Input: 1\n           2 2\n    Output: 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Input: 1\n           3 1\n    Output: 1\n    Explanation: The first special number for n=3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for converting k to its base-n representation and interpreting it as a sum of powers of n inherently handles these cases.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are computed modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support multiple test cases\n- Optimize for speed and memory usage\nWe will use a mathematical approach to generate the k-th special number by considering the binary representation of k and using powers of n. This approach leverages the fact that each special number can be represented as a sum of distinct powers of n, which corresponds to the binary digits of k. We will use Python's built-in capabilities to handle large integers and perform modulo operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of distinct non-negative powers'\n    Explanation: This means that each special number is formed by adding together different powers of n, where each power is used at most once. In code, this can be implemented by iterating over the binary representation of k and using it to determine which powers of n to include in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating the sequence, we need to ensure that we are considering the numbers in their natural order.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Convert k to its binary representation.\n3. Initialize a variable to store the special number.\n4. Iterate over each bit in the binary representation of k:\n   - If the bit is set (i.e., it is 1), add the corresponding power of n to the special number.\n5. Take the result modulo 10^9+7 to handle large numbers.\n6. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10, k = 1024\n    Expected Output: 1000000006\n    Explanation: The 1024th special number for n = 10 is very large, and when taken modulo 10^9+7, it results in 1000000006.\n\n    Edge Case 3: n = 3, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using binary representation and modulo operation will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, false, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 266, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "rephrase_one", "parent_index": 172}
