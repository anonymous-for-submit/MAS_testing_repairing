{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n. These rooms are connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently. This solution must handle potentially large inputs within the given constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n. These rooms are connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently. This solution must handle potentially large inputs within the given constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n. These rooms are connected by n - 1 tunnels. These tunnels are arranged in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently. This solution must handle potentially large inputs within the given constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert. The layout of the maze is structured as a tree with n rooms labeled from 1 to n, connected by n - 1 tunnels allowing travel between any pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i, and moving between rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy, where a tunnel must connect x and y and |z| represents the absolute value of z. To deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms, and Chanek and Indiana will pose q queries. Queries are of two sorts: * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n). Assist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently. This solution must handle potentially large inputs within the given constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of the u-th room to c.\"\"\"\n    illusion_rates[u - 1] = c\n\ndef dfs(tree: List[List[int]], current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n    \"\"\"Perform DFS to find a path from current room to target room.\"\"\"\n    if current == target:\n        path.append(current)\n        return True\n    visited[current] = True\n    path.append(current)\n    for neighbor in tree[current]:\n        if not visited[neighbor]:\n            if dfs(tree, neighbor, target, visited, path):\n                return True\n    path.pop()\n    return False\n\ndef calculate_energy(illusion_rates: List[int], path: List[int]) -> int:\n    \"\"\"Calculate the total energy required for the given path.\"\"\"\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n    return total_energy\n\ndef calculate_min_energy(illusion_rates: List[int], tree: List[List[int]], u: int, v: int) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    if u == v:\n        return 0\n    visited = [False] * len(tree)\n    path = []\n    dfs(tree, u, v, visited, path)\n    return calculate_energy(illusion_rates, path)\n\ndef main():\n    \"\"\"Main function to handle input parsing and query processing.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s_i = int(data[index])\n        index += 1\n        t_i = int(data[index])\n        index += 1\n        tree[s_i].append(t_i)\n        tree[t_i].append(s_i)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            update_illusion_rate(illusion_rates, u, c)\n        elif query_type == 2:\n            v = int(data[index])\n            index += 1\n            result = calculate_min_energy(illusion_rates, tree, u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_info: List[int], depth_info: List[int]) -> None:\n    \"\"\"Performs Depth First Search to precompute parent and depth information.\"\"\"\n    parent_info[node] = parent\n    depth_info[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_info, depth_info)\n\ndef lca(u: int, v: int, parent_info: List[int], depth_info: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth_info[u] < depth_info[v]:\n        u, v = v, u\n    while depth_info[u] > depth_info[v]:\n        u = parent_info[u]\n    while u != v:\n        u = parent_info[u]\n        v = parent_info[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_info: List[int], depth_info: List[int]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    ancestor = lca(u, v, parent_info, depth_info)\n    energy = 0\n    current = u\n    while current != ancestor:\n        parent = parent_info[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[parent - 1]), abs(illusion_rates[current - 1] - illusion_rates[parent - 1]))\n        current = parent\n    current = v\n    while current != ancestor:\n        parent = parent_info[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[parent - 1]), abs(illusion_rates[current - 1] - illusion_rates[parent - 1]))\n        current = parent\n    return energy\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Finds the minimum energy path between two rooms using precomputed LCA data.\"\"\"\n    n = len(tree) - 1\n    parent_info = [-1] * (n + 1)\n    depth_info = [0] * (n + 1)\n    dfs(1, -1, 0, tree, parent_info, depth_info)\n    return calculate_energy(u, v, illusion_rates, parent_info, depth_info)\n\ndef main():\n    \"\"\"Main function to process input and execute queries.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            # Update query\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            # Path query\n            result = min_energy_path(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room and modify the segment tree accordingly.\"\"\"\n    # Update the illusion rate in the list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree (details omitted for brevity)\n    # This would typically involve updating the segment tree nodes affected by this change\n\ndef query_min_energy(u: int, v: int, illusion_rates: List[int], segment_tree: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    if u == v:\n        return 0\n    \n    # Perform DFS to find the path from u to v\n    path = find_path(u, v, tree)\n    \n    # Calculate the total energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        energy = max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n        total_energy += energy\n    \n    return total_energy\n\ndef find_path(u: int, v: int, tree: List[List[int]]) -> List[int]:\n    \"\"\"Find the path from room u to room v using DFS.\"\"\"\n    visited = [False] * len(tree)\n    path = []\n    \n    def dfs(current: int):\n        if current == v:\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        path.pop()\n        return False\n    \n    dfs(u)\n    return path\n\ndef main():\n    # Read input values\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    # Initialize segment tree (details omitted)\n    segment_tree = [0] * (4 * n)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == 2:\n            _, u, v = query\n            result = query_min_energy(u, v, illusion_rates, segment_tree, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Perform DFS to populate parent and depth information.\"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if depth_list[u] < depth_list[v]:\n        u, v = v, u\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    \"\"\"Calculate the energy required to move between two rooms.\"\"\"\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    \n    # Preprocess the tree to get parent and depth information\n    dfs(1, -1, 0, tree, parent_list, depth_list)\n    \n    # Find the LCA of u and v\n    ancestor = lca(u, v, parent_list, depth_list)\n    \n    # Calculate the energy from u to ancestor and ancestor to v\n    total_energy = 0\n    current = u\n    while current != ancestor:\n        total_energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent_list[current] - 1])\n        current = parent_list[current]\n    \n    current = v\n    while current != ancestor:\n        total_energy += calculate_energy(illusion_rates[current - 1], illusion_rates[parent_list[current] - 1])\n        current = parent_list[current]\n    \n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]) -> None:\n    \"\"\"Performs DFS to calculate depth and parent for each node.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor of nodes u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    n = len(tree) - 1\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    \n    # Preprocess the tree using DFS\n    dfs(tree, 1, -1, depth, parent_list)\n    \n    # Find the path using LCA\n    ancestor = lca(u, v, depth, parent_list)\n    \n    # Calculate energy required\n    energy = 0\n    current = u\n    while current != ancestor:\n        next_room = parent_list[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    \n    current = v\n    while current != ancestor:\n        next_room = parent_list[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input parsing, tree construction, and query processing.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Updates the illusion rate of the specified room.\n\n    Args:\n        illusion_rates: A list of integers representing the illusion rates of each room.\n        u: The index of the room to update (1-based index).\n        c: The new illusion rate for the room.\n    \"\"\"\n    illusion_rates[u - 1] = c\n\ndef calculate_min_energy(n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], u: int, v: int) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\n\n    Args:\n        n: The number of rooms in the maze.\n        illusion_rates: A list of integers representing the illusion rates of each room.\n        tunnels: A list of tuples representing the connections between rooms.\n        u: The starting room (1-based index).\n        v: The destination room (1-based index).\n\n    Returns:\n        The minimum sum of energy required to move from room u to room v.\n    \"\"\"\n    # Build adjacency list for the tree structure\n    adjacency_list = [[] for _ in range(n)]\n    for s, t in tunnels:\n        adjacency_list[s - 1].append(t - 1)\n        adjacency_list[t - 1].append(s - 1)\n\n    # Perform DFS to find the path and calculate energy\n    def dfs(current: int, target: int, visited: List[bool]) -> int:\n        if current == target:\n            return 0\n        visited[current] = True\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                energy = max(abs(illusion_rates[current] + illusion_rates[neighbor]),\n                             abs(illusion_rates[current] - illusion_rates[neighbor]))\n                result = dfs(neighbor, target, visited)\n                if result != -1:\n                    return energy + result\n        return -1\n\n    visited = [False] * n\n    return dfs(u - 1, v - 1, visited)\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [input().split() for _ in range(q)]\n\n# Output interface\nfor query in queries:\n    if query[0] == '1':\n        u, c = int(query[1]), int(query[2])\n        update_illusion_rate(illusion_rates, u, c)\n    elif query[0] == '2':\n        u, v = int(query[1]), int(query[2])\n        result = calculate_min_energy(n, illusion_rates, tunnels, u, v)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], connections: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for s, t in connections:\n            self.adj_list[s].append(t)\n            self.adj_list[t].append(s)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.preprocess()\n\n    def preprocess(self):\n        \"\"\"Preprocess the tree to calculate parent and depth of each node.\"\"\"\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Depth First Search to set parent and depth for each node.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def update_illusion_rate(self, u: int, c: int):\n        \"\"\"Update the illusion rate of the u-th room.\"\"\"\n        self.illusion_rates[u - 1] = c\n\n    def calculate_energy(self, x: int, y: int) -> int:\n        \"\"\"Calculate the energy required to move between two connected rooms.\"\"\"\n        a_x = self.illusion_rates[x - 1]\n        a_y = self.illusion_rates[y - 1]\n        return max(abs(a_x + a_y), abs(a_x - a_y))\n\n    def min_energy(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n        # Find the path from u to v using parent information\n        path = []\n        while u != v:\n            if self.depth[u] > self.depth[v]:\n                path.append((u, self.parent[u]))\n                u = self.parent[u]\n            else:\n                path.append((v, self.parent[v]))\n                v = self.parent[v]\n        \n        # Calculate the total energy for the path\n        total_energy = 0\n        for x, y in path:\n            total_energy += self.calculate_energy(x, y)\n        \n        return total_energy\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    maze = Maze(len(illusion_rates), illusion_rates, [(i + 1, j + 1) for i, adj in enumerate(tree) for j in adj if i < j])\n    return maze.min_energy(u, v)\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntree = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    s, t = map(int, input().split())\n    tree[s].append(t)\n    tree[t].append(s)\n\nqueries = [input().split() for _ in range(q)]\n\n# Output interface\nmaze = Maze(n, illusion_rates, [(s, t) for s, t in zip(tree[1:], tree[2:])])\nfor query in queries:\n    if query[0] == '1':\n        u, c = int(query[1]), int(query[2])\n        maze.update_illusion_rate(u, c)\n    elif query[0] == '2':\n        u, v = int(query[1]), int(query[2])\n        result = maze.min_energy(u, v)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, euler: List[int], first: List[int], depth_list: List[int], tree: List[List[int]]) -> None:\n    \"\"\"Perform DFS to populate Euler tour and depth information.\"\"\"\n    first[node] = len(euler)\n    euler.append(node)\n    depth_list.append(depth)\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, euler, first, depth_list, tree)\n            euler.append(node)\n            depth_list.append(depth)\n\ndef build_segment_tree(arr: List[int], seg_tree: List[int], start: int, end: int, node: int) -> None:\n    \"\"\"Build a segment tree for range minimum query.\"\"\"\n    if start == end:\n        seg_tree[node] = start\n    else:\n        mid = (start + end) // 2\n        build_segment_tree(arr, seg_tree, start, mid, 2 * node + 1)\n        build_segment_tree(arr, seg_tree, mid + 1, end, 2 * node + 2)\n        left = seg_tree[2 * node + 1]\n        right = seg_tree[2 * node + 2]\n        seg_tree[node] = left if arr[left] < arr[right] else right\n\ndef range_minimum_query(seg_tree: List[int], arr: List[int], start: int, end: int, l: int, r: int, node: int) -> int:\n    \"\"\"Query the segment tree for the minimum value index in a range.\"\"\"\n    if l > end or r < start:\n        return -1\n    if l <= start and r >= end:\n        return seg_tree[node]\n    mid = (start + end) // 2\n    left = range_minimum_query(seg_tree, arr, start, mid, l, r, 2 * node + 1)\n    right = range_minimum_query(seg_tree, arr, mid + 1, end, l, r, 2 * node + 2)\n    if left == -1:\n        return right\n    if right == -1:\n        return left\n    return left if arr[left] < arr[right] else right\n\ndef find_lca(u: int, v: int, first: List[int], euler: List[int], depth_list: List[int], seg_tree: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if first[u] > first[v]:\n        u, v = v, u\n    lca_index = range_minimum_query(seg_tree, depth_list, 0, len(euler) - 1, first[u], first[v], 0)\n    return euler[lca_index]\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    if u == v:\n        return 0\n    \n    n = len(tree) - 1\n    euler = []\n    first = [-1] * (n + 1)\n    depth_list = []\n    \n    dfs(1, -1, 0, euler, first, depth_list, tree)\n    \n    seg_tree = [0] * (4 * len(euler))\n    build_segment_tree(depth_list, seg_tree, 0, len(euler) - 1, 0)\n    \n    lca = find_lca(u, v, first, euler, depth_list, seg_tree)\n    \n    path = []\n    current = u\n    while current != lca:\n        path.append(current)\n        for neighbor in tree[current]:\n            if first[neighbor] < first[current]:\n                current = neighbor\n                break\n    path.append(lca)\n    current = v\n    while current != lca:\n        path.append(current)\n        for neighbor in tree[current]:\n            if first[neighbor] < first[current]:\n                current = neighbor\n                break\n    \n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    # Perform a DFS to find the path from u to v\n    path = []\n    visited = [False] * len(tree)\n    \n    def dfs(current: int, target: int) -> bool:\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target):\n                    path.append(current)\n                    return True\n        return False\n    \n    dfs(u, v)\n    path.reverse()\n    \n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        a_x, a_y = illusion_rates[x - 1], illusion_rates[y - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n    \n    return total_energy\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    queries = [input().split() for _ in range(q)]\n\n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room: The room number whose illusion rate is to be updated.\n        new_rate: The new illusion rate for the room.\n        illusion_rates: The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u: The starting room number.\n        v: The destination room number.\n        illusion_rates: The list of current illusion rates for all rooms.\n        tree: The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        The minimum energy required to travel from room u to room v.\n    \"\"\"\n    def dfs(current: int, target: int, visited: List[bool], current_energy: int) -> int:\n        \"\"\"Perform DFS to find the minimum energy path from current to target.\n\n        Args:\n            current: The current room number in the DFS traversal.\n            target: The target room number to reach.\n            visited: A list indicating whether a room has been visited.\n            current_energy: The accumulated energy cost so far.\n\n        Returns:\n            The minimum energy required to reach the target from the current room.\n        \"\"\"\n        if current == target:\n            return current_energy\n\n        visited[current] = True\n        min_energy = float('inf')\n\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                energy_cost = max(\n                    abs(illusion_rates[current - 1] + illusion_rates[neighbor - 1]),\n                    abs(illusion_rates[current - 1] - illusion_rates[neighbor - 1])\n                )\n                min_energy = min(min_energy, dfs(neighbor, target, visited, current_energy + energy_cost))\n\n        visited[current] = False\n        return min_energy\n\n    visited = [False] * (len(tree))\n    return dfs(u, v, visited, 0)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. It should leverage data structures that optimize traversal and updates within the tree structure of the maze.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries.\n- Ensure accurate energy calculations between rooms.\n- Optimize data structures for quick traversal.\n- Handle large input sizes without performance degradation.\n- Provide clear output for each query.\nWe will use Depth First Search (DFS) to traverse the tree structure efficiently. For type 1 queries, we will update the illusion rate using a simple list update. For type 2 queries, we will precompute the path using DFS and calculate the energy using the given formula. We will use adjacency lists to represent the tree and optimize traversal using memoization.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, which allows traversal between any two rooms using a unique path.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'smallest': This indicates that for type 2 queries, we need to find the minimum energy sum required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Represent the tree using an adjacency list.\n3. For type 1 queries, update the illusion rate of the specified room.\n4. For type 2 queries, use DFS to find the path from room u to room v and calculate the total energy required using the given formula.\n5. Use memoization to store previously computed paths and energies to optimize repeated queries.\n\n# [edge case] \n    1. Query with u = v: The expected output is 0 because no movement is needed.\n    Explanation: If the start and end rooms are the same, no energy is required.\n\n    2. All rooms have zero illusion rate: The expected output for any path is 0.\n    Explanation: If all illusion rates are zero, then max(|0 + 0|, |0 - 0|) = 0 for any path.\n\n    3. Maximum possible illusion rate change: Test with maximum allowed change in illusion rate (10^9).\n    Explanation: This tests if the program can handle large numbers without overflow or performance issues.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where u = v.\n```python\ndef handle_query(u, v):\n    if u == v:\n        return 0\n    # Proceed with normal DFS and energy calculation\n```\nThis ensures that when u equals v, we immediately return 0 without unnecessary calculations.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and compute the minimum energy path in a tree structure. The solution must be optimized for large inputs and frequent queries, ensuring quick updates and path calculations.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Compute minimum energy path between any two rooms.\n- Optimize for large input sizes and frequent queries.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently compute the minimum energy path in the tree structure. For updates, we will use a simple array update since the illusion rate changes are direct. The DFS will help in precomputing necessary data for LCA, and LCA will allow us to quickly find the path between any two nodes. This approach is efficient for the given constraints of up to 100,000 nodes and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, consisting of n rooms and n-1 tunnels.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb]\n    'smallest': This indicates that for type 2 queries, we need to find the minimum energy sum required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given tunnels.\n3. Precompute necessary data for LCA using DFS, such as parent and depth information.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, use LCA to find the path between the two rooms and calculate the total energy required using the given formula.\n5. Output the result for each type 2 query.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1, with a single type 2 query.\n       Explanation: This tests the simplest case with only two rooms directly connected.\n    2. All illusion rates are zero: n = 5, q = 1, with a type 2 query.\n       Explanation: This tests if the code correctly handles zero illusion rates, where energy should be zero.\n    3. Maximum possible illusion rate change: n = 3, q = 2, with a type 1 query setting an illusion rate to 10^9.\n       Explanation: This tests if the code can handle large values without overflow or performance issues.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and LCA should handle them efficiently as long as we ensure that updates and calculations are performed correctly within constraints.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates and queries on a tree structure with potentially large input sizes. The solution must ensure that energy calculations are accurate and that updates to the illusion rates are reflected immediately in subsequent queries. The use of data structures that support fast updates and queries, such as segment trees or binary indexed trees, may be necessary.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Accurately calculate energy requirements between rooms.\n- Support real-time updates to room illusion rates.\n- Optimize for low memory usage.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) for tree traversal and a Segment Tree to efficiently handle updates and queries. The Segment Tree will allow us to update the illusion rates in O(log n) time and query the minimum energy path in O(log n) time. This approach is efficient given the constraints of up to 100,000 rooms and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost of moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'smallest': This indicates that we need to find the minimum energy sum required to reach the treasure. In code, this can be implemented by maintaining a minimum value during traversal or using data structures that efficiently support minimum queries.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement a Segment Tree or similar data structure to handle updates and queries efficiently.\n3. For type 1 queries, update the illusion rate of the specified room.\n4. For type 2 queries, use DFS or BFS to find the path from room u to room v and calculate the total energy required using the given formula.\n5. Output the result for each type 2 query.\n\n# [edge case] \n    1. Query with u = v (e.g., 2 1 1) = 0\n       Explanation: If the start and end rooms are the same, no movement is needed, so the energy required is 0.\n    \n    2. All rooms have an illusion rate of 0 (e.g., 2 1 2 with all a_i = 0) = 0\n       Explanation: If all illusion rates are zero, any movement between rooms will require zero energy.\n\n    3. Maximum possible illusion rate change (e.g., 1 1 10^9 followed by 2 1 n) = Calculated based on updated rates\n       Explanation: This tests the ability to handle large updates and ensure calculations are correct with maximum values.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - For query type 2 where u = v, directly return 0 without further calculations.\n        - Ensure that updates correctly modify the Segment Tree or data structure used for efficient querying.\n        - Handle large values by ensuring data types can accommodate maximum possible values (e.g., using long integers in Python).\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the constraints on illusion rates require careful handling to avoid overflow or inaccuracies.\nrequirement pool:\n- Efficiently process type 2 queries to calculate minimum energy.\n- Implement quick updates for type 1 queries to change illusion rates.\n- Ensure the solution handles large inputs within time constraints.\n- Optimize data structures for fast query processing.\n- Provide clear output format for energy calculations.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the shortest path between any two nodes. We will use a Segment Tree or Binary Indexed Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A data structure where each node has zero or more children and exactly one parent, except for the root node which has no parent. In this context, it represents the maze layout.\n    \n    'illusion rate': A numerical value associated with each room that affects the energy required to move between rooms.\n    \n    'energy': The cost calculated using the formula max(|a_x + a_y|, |a_x - a_y|) to move between two connected rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented as `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'smallest': Refers to finding the minimum energy sum required to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Preprocess the tree using DFS to prepare for LCA queries.\n3. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), use LCA to find the path between the two rooms and calculate the total energy required using the given formula.\n4. Use a data structure like a Segment Tree or Binary Indexed Tree to efficiently handle updates and queries.\n\n# [edge case]\n    1. Single path from start to end: If there's only one direct path between two rooms, calculate energy directly.\n       Example: 2 1 2 = 39\n       Explanation: Direct calculation as shown in the example.\n       \n    2. Update query with no effect: An update that doesn't change the illusion rate should not affect subsequent queries.\n       Example: Update room 1 from 10 to 10, then query 2 1 2 should still return 39.\n       Explanation: Since there's no change in illusion rate, energy calculation remains the same.\n\n    3. Query on same room: Querying energy from a room to itself should return 0.\n       Example: 2 3 3 = 0\n       Explanation: No movement is needed, hence no energy is required.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of calculating paths and updates. The original logic already considers direct paths, unchanged updates, and self-queries.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of queries requires a responsive system.\nrequirement pool:\n- Efficiently process type 2 queries to calculate minimum energy.\n- Implement quick updates for type 1 queries to change illusion rates.\n- Ensure scalability to handle maximum input constraints.\n- Optimize data structures for fast query processing.\n- Provide clear output format for query results.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the shortest path between any two nodes. We will also use a Segment Tree or Fenwick Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and is used in calculations for energy consumption.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing travel between any pair of rooms.\n\n    'queries'\n    Explanation: There are two types of queries: updating the illusion rate of a room and finding the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves taking the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms.\n\n# [degree adverb]\n    'smallest'\n    Explanation: In the context of queries, it refers to finding the minimum sum of energy needed to move from one room to another.\n\n# [code logic]\n    - Preprocess the tree using DFS to establish paths and calculate necessary data for LCA.\n    - Implement LCA to efficiently find paths between any two nodes.\n    - Use a Segment Tree or Fenwick Tree to handle updates to illusion rates efficiently.\n    - For type 2 queries, calculate the energy required using the preprocessed data and updated illusion rates.\n\n# [edge case]\n    2 1 1 = 0\n    Explanation: If the start and end rooms are the same, no movement is required, so the energy is 0.\n\n    2 1 n = <calculated energy>\n    Explanation: This tests the longest possible path in the tree, ensuring that calculations handle maximum path lengths correctly.\n\n    1 u c (where c = 0) followed by 2 u v = <calculated energy>\n    Explanation: Tests updating a room's illusion rate to zero and then calculating energy, ensuring updates are correctly applied.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment/Fenwick Tree should handle these cases efficiently.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal and query processing using algorithms like DFS or BFS. The solution should focus on minimizing computational complexity and optimizing data structures for fast access and updates.\nrequirement pool:\n- Efficient query processing for large inputs\n- Accurate energy calculation between rooms\n- Quick update of room illusion rates\n- Optimized data structures for fast access\n- User-friendly interface for seamless experience\nWe will use Depth First Search (DFS) to efficiently traverse the tree structure of the maze for query processing. For updating the illusion rates, a simple list update will suffice. For calculating the minimum energy required, we will use a DFS-based approach to find the path and calculate the energy using the given formula. The use of DFS ensures that we can handle large inputs efficiently. We will also use adjacency lists to represent the tree structure for quick access and updates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it has n rooms and n-1 tunnels, allowing traversal between any pair of rooms. This implies a connected acyclic graph.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms. The energy is calculated using the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves taking the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest'\n    Explanation: Refers to finding the minimum sum of energy required to access the secret treasure from one room to another. This involves calculating the path with the least energy cost using DFS traversal.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Represent the tree structure using adjacency lists for efficient traversal.\n    3. Implement DFS to traverse the tree and calculate the energy required for type 2 queries.\n    4. For type 1 queries, update the illusion rate of the specified room.\n    5. For type 2 queries, use DFS to find the path from room u to room v and calculate the total energy using the given formula.\n\n# [edge case]\n    Case 1: Single path with no branches\n    Input: \n    ```\n    3 2\n    5 10 -5\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: \n    ```\n    20\n    ```\n    Explanation: The path is straightforward from room 1 to room 3 via room 2.\n\n    Case 2: All rooms have zero illusion rate\n    Input:\n    ```\n    4 1\n    0 0 0 0\n    1 2\n    2 3\n    3 4\n    2 1 4\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, no energy is required.\n\n    Case 3: Update query changes path cost significantly\n    Input:\n    ```\n    3 3\n    5 -5 10\n    1 2\n    2 3\n    2 1 3\n    1 2 -10\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    20\n    25\n    ```\n    Explanation: The update changes the illusion rate of room 2, affecting the energy calculation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and adjacency lists will naturally handle these scenarios efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating illusion rates and calculating energy requirements between rooms in a maze structured as a tree. The solution must handle large inputs and provide accurate results quickly.\nrequirement pool:\n- Efficient query processing for large inputs\n- Accurate calculation of energy requirements\n- User-friendly interface for input and output\n- Quick response times for user queries\n- Scalability to handle increasing number of rooms and queries\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy required for each query efficiently. We will utilize adjacency lists to represent the tree structure and segment trees to handle updates and queries efficiently. This approach ensures that we can handle large inputs within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is structured as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms. The illusion rate can be updated through queries.\n\n    'energy calculation'\n    Explanation: The energy required to move between two connected rooms x and y is calculated as max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of rooms x and y, respectively.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to read the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct an adjacency list to represent the tree structure of the maze.\n3. Implement a DFS to preprocess the tree and calculate initial energy values between connected rooms.\n4. Use a segment tree or similar data structure to efficiently handle updates to illusion rates and queries for minimum energy.\n5. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), calculate the minimum energy required to travel from room u to room v using preprocessed data and return the result.\n\n# [edge case]\n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: With only two rooms having zero illusion rates, the energy required is zero.\n\n    2. Input: 3 1\n             1000000000 -1000000000 0\n             1 2\n             2 3\n             2 1 3\n       Output: 2000000000\n       Explanation: The maximum possible energy is required due to extreme illusion rates.\n\n    3. Input: 4 2\n             1 -1 1 -1\n             1 2\n             2 3\n             3 4\n             2 1 4\n             1 3 -1\n       Output: 4\n       Explanation: Initially, moving from room 1 to room 4 requires energy of max(|1-(-1)|, |1+(-1)|) + max(|-1-1|, |-1+1|) = 4.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently using a segment tree or similar data structure to ensure that updates and queries are processed within time constraints.\n    \n```python\nclass Maze:\n    def __init__(self, n, illusion_rates, connections):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for s, t in connections:\n            self.adj_list[s].append(t)\n            self.adj_list[t].append(s)\n        # Additional data structures for efficient query handling\n\n    def update_illusion_rate(self, u, c):\n        self.illusion_rates[u] = c\n        # Update segment tree or other structures\n\n    def min_energy(self, u, v):\n        # Calculate minimum energy using preprocessed data\n        pass\n\n# Example usage:\n# maze = Maze(n, illusion_rates, connections)\n# maze.update_illusion_rate(u, c)\n# result = maze.min_energy(u, v)\n```\nThis code structure provides a foundation for implementing efficient updates and queries in the maze problem.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates and queries on a tree structure with potentially large input sizes. The solution must ensure quick updates to the illusion rates and fast computation of the minimum energy required for traversal. The algorithm should be optimized for both time and space complexity to handle the upper limits of the constraints.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries.\n- Optimize energy calculation between rooms.\n- Ensure the solution handles the maximum constraints smoothly.\n- Provide clear and concise output for each query.\n- Implement additional features for user interaction.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and queries. The DFS will help in traversing the tree and calculating the energy required between rooms, while LCA will assist in quickly finding the path between any two rooms. We will use the Euler Tour technique to preprocess the tree for LCA queries, and Segment Tree for efficient updates and queries on the illusion rates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, consisting of n rooms and n-1 tunnels.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two connected rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented as:\n    ```python\n    energy = max(abs(a_x + a_y), abs(a_x - a_y))\n    ```\n\n# [degree adverb]\n    'smallest': In the context of the queries, it refers to finding the minimum sum of energy required to travel from one room to another. This involves calculating the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given tunnels.\n3. Preprocess the tree using DFS to prepare for LCA queries.\n4. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n5. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), use LCA to find the path between the two rooms and calculate the total energy required using the preprocessed data.\n\n# [edge case]\n    1. Single path from start to end: If there's only one direct path between u and v, calculate energy directly.\n       Example: For a tree with rooms connected linearly, e.g., 1-2-3-4, querying from 1 to 4 should consider all intermediate rooms.\n    2. Update query with no effect: If an update query changes an illusion rate to its current value, it should not affect subsequent path queries.\n       Example: Updating room 1's illusion rate from 10 to 10 should not change any path calculations.\n    3. Path query with same start and end: If u and v are the same in a type 2 query, the energy required should be 0.\n       Example: Querying from room 3 to room 3 should return 0.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to path queries where u equals v.\n    ```python\n    if u == v:\n        return 0\n    ```\n    This ensures that if the start and end room are the same, no energy is required.\n", "requirement analysis:\nThe project requires handling a tree structure of rooms with dynamic updates to room properties and efficient pathfinding. The main challenge is to ensure that the solution can handle the upper limits of input size while maintaining performance. The solution should focus on optimizing data structures and algorithms to manage updates and queries effectively.\nrequirement pool:\n- Efficiently handle up to 100,000 rooms and queries.\n- Implement a fast algorithm for calculating minimum energy paths.\n- Allow real-time updates to room illusion rates.\n- Ensure the solution is scalable and performs well under maximum constraints.\n- Provide clear and concise output for each query.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy required for each query efficiently. We will utilize a Segment Tree to handle updates to the illusion rates quickly. This approach ensures that both queries and updates are processed in logarithmic time, which is suitable for handling large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, consisting of n rooms and n-1 tunnels.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms connected by a tunnel is calculated using max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb] \n    'smallest': In the context of the query type 2, it refers to finding the minimum sum of energy needed to reach the secret treasure from a starting room. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists to represent tunnels between rooms.\n    3. Implement DFS to preprocess paths and calculate initial energy requirements.\n    4. Use a Segment Tree to efficiently handle updates to illusion rates.\n    5. For type 1 queries, update the illusion rate of the specified room using the Segment Tree.\n    6. For type 2 queries, calculate the minimum energy required using preprocessed data and update results based on current illusion rates.\n\n# [edge case] \n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, moving between any rooms requires zero energy.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After updating room 1's illusion rate, moving from room 1 to room 3 requires max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle these scenarios within the constraints provided.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze. The main challenge is to handle large input sizes and ensure quick updates and calculations. The solution should be optimized for both time and space complexity, considering the constraints provided.\nrequirement pool:\n- Efficiently handle up to 100,000 rooms and queries.\n- Accurately calculate the minimum energy required for room transitions.\n- Implement real-time updates for illusion rates.\n- Ensure the solution is scalable and maintains performance.\n- Provide a user-friendly interface for input and output.\nWe will use Depth First Search (DFS) to efficiently traverse the tree structure of the maze. For handling updates and queries, we will utilize adjacency lists for representing the tree and a dictionary for storing the illusion rates. This approach allows us to efficiently update the illusion rates and calculate the minimum energy required for transitions between rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, consisting of n rooms and n-1 tunnels.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest': In the context of the queries, it refers to finding the minimum energy sum required to travel from one room to another. This can be implemented by calculating the total energy for all possible paths and selecting the minimum.\n\n# [code logic]\n1. Parse the input to extract the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Represent the maze as an adjacency list to facilitate traversal.\n3. Use a dictionary to store and update the illusion rates of each room.\n4. Implement DFS to traverse the tree and calculate the energy required for each path.\n5. For type 1 queries, update the illusion rate of the specified room.\n6. For type 2 queries, calculate and return the minimum energy required to travel from room u to room v using DFS.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: 2 1\n              5 -5\n              1 2\n              2 1 2\n       Expected Output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All rooms have zero illusion rate:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, moving between any rooms requires zero energy.\n\n    3. Update query changes illusion rate to zero:\n       Input: 3 2\n              5 -5 10\n              1 2\n              2 3\n              1 1 0\n              2 1 3\n       Expected Output: 15\n       Explanation: After updating room 1's illusion rate to zero, moving from room 1 to room 3 requires max(|0 + (-5)|, |0 - (-5)|) + max(|-5 + 10|, |-5 - 10|) = 5 + 15 = 20.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and adjacency lists will naturally handle these scenarios by recalculating energies based on updated illusion rates and tree traversal paths.\n"], "scores": [], "pass_results": [false, true, true, false, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 438, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 224}
