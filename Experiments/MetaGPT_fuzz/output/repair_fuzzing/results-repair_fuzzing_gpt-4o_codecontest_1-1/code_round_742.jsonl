{"name": "1607_C. Minimum Extraction", "description": "Yelisey has an array a of n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei finds the minimal number m in the array. If there are several identical minima, Yelisey can choose any of them. \n  2. Then the selected minimal element is removed from the array. After that, m is subtracted from each remaining element. \n\n\n\nThus, after each operation, the length of the array is reduced by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "tags": ["brute force", "sortings"], "difficulty": 9, "id": 1607, "sample_io": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}], "test_list": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 0 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 19 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n12\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 6\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n7\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 1\n5\n3 2 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 12\n2\n2 4\n5\n3 3 -5 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n8\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -6 -1 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n5\n3\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -1 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-3\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 12\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n10\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 0 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n11\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-1 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n0 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n4\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -1 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-2 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["15\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n1\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n7\n2\n0 -1\n3\n-2 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["7\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -7 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n5\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 1\n5\n0 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n1\n2\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 1 0\n4\n2 10 1 7\n2\n2 6\n5\n3 4 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n1\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-3\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n4 3\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n3\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n1\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 15 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 8\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 16 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n8\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 2\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n8\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 4 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -4\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n4\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 0\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 -1 1\n2\n-1 1\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n0 18 1 9\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n9\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 0\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n1\n0\n"]}, {"input": "8\n1\n19\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["19\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-2 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n3 12 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-3\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-3\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 1 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 1\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n1\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n0 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n4 10 1 7\n2\n-1 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n5\n4\n2\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 14\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n0 4\n5\n0 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n0 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n6\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 8\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n4 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n1 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n5\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 -1\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["8\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 11 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n9\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n6 10 2 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-4\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-4\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -12 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n8\n2\n-2\n"]}, {"input": "8\n1\n1\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["1\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 6\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 12\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 0 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 0\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n1\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 0\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n1\n-2\n"]}], "task_id": "codecontest/100", "prompt": "Yelisey possesses an array a consisting of n integers.\n\nIf a has a length greater than one, then Yelisei can perform an operation named minimum extraction on it:\n\n  1. Initially, Yelisei identifies the smallest number m within the array. If there are multiple matching minima, Yelisey is able to select any one of them.\n  2. Next, the chosen minimum element is eliminated from the array. Subsequently, m is deducted from each remaining element.\n\nTherefore, after each operation, the size of the array decreases by 1.\n\nFor instance, if a = [1, 6, -4, -2, -4], then the smallest element is a_3 = -4, indicating that after this process, the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nBecause Yelisey prefers large numbers, he desires the elements in the array a to be as large as can be.\n\nFormally, he aims to maximize the smallest number in array a (i.e. he wants to make the minimum as large as possible). To achieve this goal, Yelisey is able to apply the minimum extraction operation to the array multiple times as needed (including zero times). Keep in mind that the operation cannot be utilized on an array with a length of 1.\n\nHelp him discover the greatest possible value that the smallest element of the array can reach after performing several (potentially zero) minimum extraction operations on the array. Evaluate the procedure and determine the plan to efficiently attain the desired maximum minimal value.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "repair_prompt": ["Yelisey possesses an array a consisting of n integers.\n\nIf a has a length greater than one, then Yelisei can perform an operation named minimum extraction on it:\n\n  1. Initially, Yelisei identifies the smallest number m within the array. If there are multiple matching minima, Yelisey is able to select any one of them.\n  2. Next, the chosen minimum element is eliminated from the array. Subsequently, m is deducted from each remaining element.\n\nTherefore, after each operation, the size of the array decreases by 1.\n\nFor instance, if a = [1, 6, -4, -2, -4], then the smallest element is a_3 = -4, indicating that after this process, the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nBecause Yelisey prefers large numbers, he desires the elements in the array a to be as large as can be.\n\nFormally, he aims to maximize the smallest number in array a (i.e. he wants to make the minimum as large as possible). To achieve this goal, Yelisey is able to apply the minimum extraction operation to the array multiple times as needed (including zero times). Keep in mind that the operation cannot be utilized on an array with a length of 1.\n\nHelp him discover the greatest possible value that the smallest element of the array can reach after performing several (potentially zero) minimum extraction operations on the array. Evaluate the procedure and determine the plan to efficiently attain the desired maximum minimal value.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "Yelisey possesses an array a consisting of n integers.\n\nIf a has a length greater than one, then Yelisei can perform an operation named minimum extraction on it:\n\n  1. Initially, Yelisey identifies the smallest number m within the array. If there are multiple matching minima, Yelisey is able to select any one of them.\n  2. Next, the chosen minimum element is eliminated from the array. This effectively reduces the size of the array by one. Subsequently, m is deducted from each remaining element.\n\nTherefore, after each operation, the size of the array decreases by 1.\n\nFor instance, if a = [1, 6, -4, -2, -4], then the smallest element is a_3 = -4, indicating that after this process, the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nBecause Yelisey prefers large numbers, he desires the elements in the array a to be as large as can be.\n\nFormally, he aims to maximize the smallest number in array a (i.e. he wants to make the minimum as large as possible). To achieve this goal, Yelisey is able to apply the minimum extraction operation to the array multiple times as needed (including zero times). Keep in mind that the operation cannot be utilized on an array with a length of 1.\n\nHelp him discover the greatest possible value that the smallest element of the array can reach after performing several (potentially zero) minimum extraction operations on the array. Evaluate the procedure and determine the plan to efficiently attain the desired maximum minimal value.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "Yelisey possesses an array a consisting of n integers. If a has a length greater than one, then Yelisei can perform an operation named minimum extraction on it: Initially, Yelisei identifies the smallest number m within the array. If there are multiple matching minima, Yelisey is able to select any one of them, and next, the chosen minimum element is eliminated from the array. Subsequently, m is deducted from each remaining element. Therefore, after each operation, the size of the array decreases by 1. For instance, if a = [1, 6, -4, -2, -4], then the smallest element is a_3 = -4, indicating that after this process, the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Because Yelisey prefers large numbers, he desires the elements in the array a to be as large as can be. Formally, he aims to maximize the smallest number in array a (i.e. he wants to make the minimum as large as possible). To achieve this goal, Yelisey is able to apply the minimum extraction operation to the array multiple times as needed (including zero times). Keep in mind that the operation cannot be utilized on an array with a length of 1. Help him discover the greatest possible value that the smallest element of the array can reach after performing several (potentially zero) minimum extraction operations on the array. Evaluate the procedure and determine the plan to efficiently attain the desired maximum minimal value.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        \n        # If the array length is 1, return the single element as no operations can be performed\n        if n == 1:\n            results.append(case[0])\n            continue\n        \n        # Sort the array\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_min_value = case[0]\n        \n        # Calculate the maximum possible minimum value by iterating through the sorted array\n        for i in range(1, n):\n            # Calculate the difference between consecutive elements\n            difference = case[i] - case[i - 1]\n            # Update the maximum possible minimum value\n            max_min_value = max(max_min_value, difference)\n        \n        results.append(max_min_value)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef max_possible_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value after performing minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        if n == 1:\n            # If there's only one element, return it as no operations can be performed.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to simulate the minimum extraction process.\n        case.sort()\n        \n        # Initialize the maximum possible minimum value.\n        max_min_value = case[0]\n        \n        # Calculate the differences between consecutive elements.\n        for i in range(1, n):\n            difference = case[i] - case[i - 1]\n            max_min_value = max(max_min_value, difference)\n        \n        # Append the result for the current test case.\n        results.append(max_min_value)\n    \n    return results\n\n# Input and output interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Get results\n    results = max_possible_minimum(t, test_cases)\n    \n    # Print results\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        \n        # If the array length is 1, return the single element as no operations can be performed.\n        if n == 1:\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate easy extraction of the minimum element.\n        case.sort()\n        \n        # Initialize the maximum possible minimum value.\n        max_min_value = case[0]\n        \n        # Iterate through the sorted array, applying the minimum extraction operation.\n        for i in range(1, n):\n            # Calculate the difference between the current element and the previous minimum.\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum value.\n            max_min_value = max(max_min_value, diff)\n        \n        # Append the result for the current test case.\n        results.append(max_min_value)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case after performing\n    the minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximal possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        \n        # If the array length is 1, return the single element as the result\n        if n == 1:\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate finding differences between consecutive elements\n        case.sort()\n        \n        # Calculate the maximum possible minimum value\n        max_possible_min = float('-inf')\n        for i in range(1, n):\n            max_possible_min = max(max_possible_min, case[i] - case[i - 1])\n        \n        # Append the result for the current test case\n        results.append(max_possible_min)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimal_value(test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        test_cases (List[List[int]]): A list of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: A list of integers representing the maximum possible minimum value for each test case.\n    \"\"\"\n    results = []\n    for array in test_cases:\n        n = len(array)\n        if n == 1:\n            # If the array has only one element, return it as no operations can be performed.\n            results.append(array[0])\n        else:\n            # Sort the array to facilitate the calculation of differences.\n            array.sort()\n            # Initialize the maximum possible minimum value.\n            max_min_value = array[0]\n            # Iterate through the sorted array and calculate differences between consecutive elements.\n            for i in range(1, n):\n                difference = array[i] - array[i - 1]\n                # Update the maximum possible minimum value based on these differences.\n                max_min_value = max(max_min_value, difference)\n            results.append(max_min_value)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n\n    results = maximize_minimal_value(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after performing\n    minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        \n        # If the array length is 1, return the single element as no operation can be performed\n        if n == 1:\n            results.append(case[0])\n            continue\n        \n        # Sort the array to easily identify and extract the minimum element\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_min_value = case[0]\n        \n        # Iterate through the sorted array, performing minimum extraction\n        for i in range(1, n):\n            # Calculate the difference between current and previous element\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum value\n            max_min_value = max(max_min_value, diff)\n        \n        # Append the result for the current test case\n        results.append(max_min_value)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        \n        # If the array has only one element, the result is the element itself\n        if n == 1:\n            results.append(a[0])\n            continue\n        \n        # Sort the array\n        a.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_possible_min = float('-inf')\n        \n        # Calculate differences between consecutive elements\n        for i in range(1, n):\n            difference = a[i] - a[i - 1]\n            max_possible_min = max(max_possible_min, difference)\n        \n        # Append the result for the current test case\n        results.append(max_possible_min)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        \n        # If the array has only one element, the result is the element itself\n        if n == 1:\n            results.append(case[0])\n            continue\n        \n        # Sort the array\n        case.sort()\n        \n        # Initialize max_min to a very small number\n        max_min = float('-inf')\n        \n        # Calculate the maximum possible minimum value\n        for i in range(1, n):\n            # Calculate the difference between consecutive elements\n            diff = case[i] - case[i - 1]\n            # Update max_min with the maximum difference encountered\n            max_min = max(max_min, diff)\n        \n        # Append the result for the current test case\n        results.append(max_min)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        \n        # If the array has only one element, return that element as the result\n        if n == 1:\n            results.append(a[0])\n            continue\n        \n        # Sort the array\n        a.sort()\n        \n        # Initialize max_min with the first element\n        max_min = a[0]\n        \n        # Calculate the maximum possible minimum value\n        for i in range(1, n):\n            # Calculate the difference between consecutive elements\n            difference = a[i] - a[i - 1]\n            # Update max_min with the maximum of its current value and the difference\n            max_min = max(max_min, difference)\n        \n        results.append(max_min)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after performing\n    minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        if len(case) == 1:\n            # If the array has only one element, return it as no operations can be performed.\n            results.append(case[0])\n            continue\n\n        # Convert the array into a min-heap.\n        heapq.heapify(case)\n        \n        # Initialize the maximum of minimums.\n        max_of_mins = float('-inf')\n\n        # Perform minimum extraction operations until one element remains.\n        while len(case) > 1:\n            # Extract the smallest element.\n            min_element = heapq.heappop(case)\n            \n            # Update the maximum of minimums.\n            max_of_mins = max(max_of_mins, min_element)\n            \n            # Subtract the extracted minimum from all remaining elements.\n            case = [x - min_element for x in case]\n            \n            # Re-heapify the array after modification.\n            heapq.heapify(case)\n\n        # The last remaining element is the maximum possible minimum.\n        max_of_mins = max(max_of_mins, case[0])\n        results.append(max_of_mins)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of an integer n followed by n integers\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Call the function and print results\nresults = maximize_minimum(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement involves processing multiple test cases where each test case consists of an array of integers. The goal is to maximize the smallest element in the array after performing a series of operations. The operations involve removing the smallest element and subtracting it from the remaining elements. The solution must efficiently handle up to 10,000 test cases and arrays with a total length of up to 200,000 elements.\nrequirement pool:\n- Efficiently handle up to 10,000 test cases\n- Accurately compute the maximal possible minimum for each test case\n- Optimize performance for arrays with large numbers\n- Ensure the solution is scalable for high input limits\n- Provide clear and concise output for each test case\nWe will use a greedy approach to solve the problem efficiently. By sorting the array and iteratively performing the minimum extraction operation, we can determine the maximum possible minimum value. This approach ensures that we handle large datasets efficiently by leveraging sorting, which is O(n log n) in complexity. We will use Python's built-in sorting capabilities to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and then subtracting it from all remaining elements.\n\n    'maximize the smallest number'\n    Explanation: The goal is to make the smallest number in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one'\n    Explanation: The operation can only be performed if the array length is more than one. In code, this means checking if the length of the array is greater than one before performing any operations.\n\n# [degree adverb]\n    'greatest possible value'\n    Explanation: This refers to finding the maximum value that the smallest element in the array can reach after performing the operations. In code, this involves keeping track of the maximum minimum value encountered during the operations.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. If n is 1, output the single element as no operations can be performed.\n3. Sort the array a.\n4. Initialize a variable to track the maximum possible minimum value.\n5. Iterate through the sorted array, calculating the difference between consecutive elements.\n6. Update the maximum possible minimum value with each difference.\n7. Output the maximum possible minimum value for each test case.\n\n# [edge case]\n    Test case 1: [1] = 1\n    Explanation: The array has only one element, so no operations can be performed, and the output is the element itself.\n\n    Test case 2: [0, 0] = 0\n    Explanation: The array consists of zeros, so any operation will result in zeros, and the maximum possible minimum is 0.\n\n    Test case 3: [-1, -1, -1] = -1\n    Explanation: All elements are the same negative number, so any operation will result in the same number, and the maximum possible minimum is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of sorting and calculating differences will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires processing multiple test cases efficiently, ensuring that the maximum possible minimum value is calculated correctly for each array. The solution must handle large input sizes and edge cases, such as arrays of length 1, where no operations can be performed.\nrequirement pool:\n- Efficiently handle up to 10^4 test cases.\n- Correctly compute the maximum possible minimum value for each test case.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases, such as arrays of length 1.\n- Provide clear and concise output for each test case.\nWe will use a sorting-based approach to efficiently determine the maximum possible minimum value after performing the minimum extraction operations. By sorting the array, we can simulate the operations and track the changes in the minimum value. This approach ensures that we handle large input sizes efficiently and correctly compute the desired result for each test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and then subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after performing this operation multiple times.\n\n    'maximize the smallest number'\n    Explanation: The objective is to make the smallest number in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': Indicates that the operation can only be performed if the array has more than one element.\n    \n    'multiple times': Implies that the operation can be repeated as many times as needed until the desired result is achieved.\n\n# [degree adverb]\n    'greatest': Refers to finding the maximum possible value of the smallest element in the array after performing the operations.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. If n is 1, output the single element as no operations can be performed.\n3. Sort the array a.\n4. Initialize a variable to track the maximum possible minimum value.\n5. Iterate through the sorted array, calculating the difference between consecutive elements.\n6. Update the maximum possible minimum value with each difference.\n7. Output the maximum possible minimum value for each test case.\n\n# [edge case]\n    Test case with a single element: \n    Input: 1\n           10\n    Output: 10\n    Explanation: No operations can be performed, so the output is the single element itself.\n\n    Test case with all elements being zero:\n    Input: 2\n           0 0\n    Output: 0\n    Explanation: The array remains unchanged after operations, so the output is 0.\n\n    Test case with negative and positive numbers:\n    Input: 3\n           -1 2 0\n    Output: 2\n    Explanation: After performing operations, the maximum possible minimum value is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and calculating differences will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the maximum possible minimum value of an array after performing a series of operations. The operations involve removing the smallest element and reducing the remaining elements by this value. The solution must efficiently handle up to 10,000 test cases with arrays summing up to 200,000 elements in total.\nrequirement pool:\n- Implement the main algorithm to solve the problem efficiently.\n- Ensure the solution handles edge cases, such as arrays of length 1.\n- Optimize the solution to run within time limits for large inputs.\n- Provide detailed comments and documentation for the code.\n- Create test cases to validate the solution against various scenarios.\nWe will implement a function that processes each test case independently. The key idea is to sort the array and then calculate the maximum possible minimum value by iteratively applying the minimum extraction operation. We will use a greedy approach to ensure the smallest element is maximized after each operation. The solution will efficiently handle large inputs by leveraging sorting and linear traversal.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after several operations.\n\n    'maximize the smallest number'\n    Explanation: The objective is to make the minimum element in the array as large as possible through repeated operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': Indicates that the operation can only be performed if the array has more than one element.\n    'maximize': Implies finding the largest possible value for the smallest element in the array.\n\n# [degree adverb]\n    'greatest': Refers to the largest possible value that the smallest element can reach after performing operations.\n\n# [code logic]\n    1. For each test case, check if the array length is 1. If so, return the single element as no operations can be performed.\n    2. Sort the array to facilitate easy extraction of the minimum element.\n    3. Initialize a variable to track the maximum possible minimum value.\n    4. Iterate through the sorted array, applying the minimum extraction operation and updating the maximum possible minimum value.\n    5. Return the maximum possible minimum value for each test case.\n\n# [edge case]\n    Case 1: Input = [1], Output = 10\n    Explanation: With only one element, no operation can be performed, so the output is the element itself.\n\n    Case 2: Input = [0, 0], Output = 0\n    Explanation: All elements are zero, so after any operation, they remain zero.\n\n    Case 3: Input = [-1, 2, 0], Output = 2\n    Explanation: After performing operations, the maximum possible minimum value is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles arrays of length 1 and arrays with all zero elements naturally.\n", "requirement analysis:\nThe task requires processing multiple test cases efficiently, ensuring that the solution can handle large arrays and high input limits. The goal is to maximize the smallest element in the array after performing a series of minimum extraction operations. The solution must be robust and provide accurate results for all test cases, including edge cases.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure the solution handles large arrays and high input limits\n- Optimize the algorithm for performance\n- Provide clear input/output instructions\n- Test the solution against edge cases\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then calculate the maximum possible minimum value by iterating through the sorted array and computing the difference between consecutive elements. This approach ensures that we efficiently find the maximum possible minimum value after performing the minimum extraction operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from all remaining elements.\n\n    'maximize the smallest number'\n    Explanation: The goal is to make the minimum element in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': Indicates that the operation can only be performed if the array length is more than one.\n    'maximal possible minimum': Refers to finding the largest value that the smallest element can reach after operations.\n\n# [degree adverb]\n    'greatest': Refers to the largest possible value of the minimum element after operations.\n\n# [code logic]\n    1. For each test case, check if the array length is 1. If so, return the single element as the result.\n    2. Sort the array to facilitate finding differences between consecutive elements.\n    3. Initialize a variable to track the maximum possible minimum value.\n    4. Iterate through the sorted array, calculating the difference between consecutive elements and updating the maximum possible minimum value.\n    5. Return the maximum possible minimum value for each test case.\n\n# [edge case]\n    Test case with a single element: [10] = 10\n    Explanation: Since the array length is 1, no operation can be performed, so the result is the element itself.\n\n    Test case with all zeros: [0, 0] = 0\n    Explanation: The array consists only of zeros, so no matter how many operations are performed, the minimum remains zero.\n\n    Test case with negative and positive numbers: [-1, 1] = 2\n    Explanation: After performing operations, the maximum possible minimum value is achieved when subtracting -1 from 1, resulting in 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers these scenarios by checking array length and iterating through sorted elements.\n", "requirement analysis:\nThe requirements focus on maximizing the smallest element in an array through a series of operations. The solution must efficiently handle multiple test cases and large arrays, ensuring the output is accurate and follows the specified format.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure the solution handles large input sizes\n- Provide clear and consistent output format\n- Optimize for edge cases and unusual inputs\n- Document the solution for maintainability\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then calculate the maximum possible minimum value by iterating through the sorted array and computing the difference between consecutive elements. This approach ensures that we efficiently find the maximum minimal value by leveraging the sorted order of the array.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and then subtracting it from all remaining elements.\n\n    'maximize the smallest number'\n    Explanation: The goal is to make the smallest number in the array as large as possible after performing the minimum extraction operation multiple times.\n\n# [phrase showing quantity relationship]\n    'greater than one': This indicates that the operation can only be performed if the array has more than one element.\n    Implementation: Check if the length of the array is greater than one before performing operations.\n\n# [degree adverb]\n    'greatest possible value': This means finding the maximum value that the smallest element can reach after operations.\n    Implementation: Track the maximum value of the minimum element during iterations.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. If n is 1, output the single element as no operations can be performed.\n3. Sort the array a.\n4. Initialize a variable to track the maximum possible minimum value.\n5. Iterate through the sorted array and calculate differences between consecutive elements.\n6. Update the maximum possible minimum value based on these differences.\n7. Output the maximum possible minimum value for each test case.\n\n# [edge case]\n    Test case with a single element: \n    Input: 1\n           5\n    Output: 5\n    Explanation: No operation can be performed, so the output is the single element itself.\n\n    Test case with all elements being zero:\n    Input: 3\n           0 0 0\n    Output: 0\n    Explanation: All elements are zero, so no matter how many operations are performed, the minimum remains zero.\n\n    Test case with negative and positive numbers:\n    Input: 4\n           -3 -1 2 4\n    Output: 3\n    Explanation: After sorting and performing operations, the maximum possible minimum value is 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and calculating differences will naturally handle these cases.\n", "requirement analysis:\nThe task requires processing multiple test cases efficiently, ensuring that the minimum extraction operation is applied optimally to maximize the smallest element in the array. The solution must handle large input sizes and provide accurate results for each test case.\nrequirement pool:\n- Efficiently handle up to 10^4 test cases\n- Accurately compute the maximal possible minimum for each test case\n- Optimize the algorithm for performance and speed\n- Ensure the solution handles edge cases correctly\n- Provide clear and concise output for each test case\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then perform the minimum extraction operation iteratively. By sorting the array, we can easily identify the smallest element and perform the required operations to maximize the smallest element in the array. This approach ensures that we handle large input sizes efficiently and accurately.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This refers to the operation where the smallest element in the array is removed, and its value is subtracted from all remaining elements.\n\n    'maximize the smallest number'\n    Explanation: The goal is to make the smallest number in the array as large as possible after performing several minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': Indicates that the operation can only be performed if the array length is more than one.\n    'greatest possible value': Refers to finding the maximum value that the smallest element can reach after operations.\n\n# [degree adverb]\n    'greatest': Refers to the largest possible value that can be achieved for the minimum element in the array.\n\n# [code logic]\n    1. For each test case, check if the array length is 1. If so, return the single element as no operation can be performed.\n    2. Sort the array to easily identify and extract the minimum element.\n    3. Initialize a variable to track the maximum possible minimum value.\n    4. Iterate through the sorted array, performing minimum extraction and updating the maximum possible minimum value.\n    5. After processing all elements, return the maximum possible minimum value for each test case.\n\n# [edge case]\n    Test case with a single element: \n    Input: 1\n           -2\n    Output: -2\n    Explanation: No operation can be performed, so the output is the single element itself.\n\n    Test case with all elements being zero:\n    Input: 2\n           0 0\n    Output: 0\n    Explanation: The array will always consist only of zeros, and no extraction will change this.\n\n    Test case with negative and positive numbers:\n    Input: 3\n           -1 2 0\n    Output: 2\n    Explanation: After performing extractions, the maximum possible minimum value is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and iterating through the array will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the maximum possible minimum value of an array after performing a series of operations. The operations involve removing the smallest element and reducing the rest by this value. The challenge is to efficiently compute this for large arrays and multiple test cases, ensuring the solution is both performant and easy to understand.\nrequirement pool:\n- Implement the main algorithm to solve the problem efficiently.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Improve code readability and maintainability.\n- Add error handling for invalid inputs.\nWe will implement a function that processes each test case independently. The key idea is to sort the array and then calculate the differences between consecutive elements. The maximum of these differences will be the answer for each test case. This approach ensures that we efficiently find the maximum possible minimum value after performing the operations. We will use Python's built-in sorting function, which is efficient for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves removing the smallest element from the array and subtracting it from all other elements. The goal is to maximize the smallest number in the array after performing this operation multiple times.\n\n    'maximize the smallest number'\n    Explanation: The objective is to make the minimum element in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': This indicates that the operation can only be performed if the array has more than one element.\n    'multiple times': This means the operation can be repeated as many times as needed until the desired condition is met.\n\n# [degree adverb]\n    'greatest possible value': This refers to finding the maximum value that the smallest element can reach after performing the operations.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. If n is 1, output the single element since no operations can be performed.\n3. Sort the array a.\n4. Initialize a variable to track the maximum possible minimum value.\n5. Iterate through the sorted array and calculate differences between consecutive elements.\n6. Update the maximum possible minimum value with these differences.\n7. Output the maximum possible minimum value for each test case.\n\n# [edge case]\n    Test case: [1] = 10\n    Explanation: With only one element, no operations can be performed, so the output is the element itself.\n\n    Test case: [0, 0] = 0\n    Explanation: All elements are zero, so no matter how many operations are performed, the minimum remains zero.\n\n    Test case: [-1, 2, 0] = 2\n    Explanation: After sorting and performing operations, the maximum possible minimum value is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and calculating differences will naturally handle these cases.\n", "requirement analysis:\nThe problem requires an efficient algorithm to maximize the smallest element in an array after performing a series of minimum extraction operations. The solution must handle multiple test cases and large input sizes, ensuring that the output is correct and formatted as specified. The algorithm should be optimized to minimize computational complexity while maintaining accuracy.\nrequirement pool:\n- Develop an efficient algorithm to handle up to 10^4 test cases.\n- Ensure the solution correctly identifies the maximum possible minimum value.\n- Optimize the algorithm to handle large input sizes efficiently.\n- Format the output correctly for each test case.\n- Consider edge cases, such as arrays with only one element.\nWe will implement a function that processes each test case independently. The key idea is to sort the array and then calculate the maximum possible minimum value by iterating through the sorted array and computing the differences between consecutive elements. This approach ensures that we efficiently handle the constraints and optimize the solution for performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves removing the smallest element from the array and subtracting it from all other elements, effectively reducing the array size by one each time.\n\n    'maximize the smallest number'\n    Explanation: The goal is to perform operations in such a way that the smallest number in the array becomes as large as possible after all operations.\n\n# [phrase showing quantity relationship]\n    'greater than one'\n    Explanation: The operation can only be performed if the array length is more than one. In code, this can be checked using `if len(array) > 1`.\n\n    'multiple times'\n    Explanation: The operation can be repeated as many times as needed until the array length is reduced to one. This implies a loop or iterative process in the code.\n\n# [degree adverb]\n    'greatest possible value'\n    Explanation: The aim is to achieve the highest value for the smallest element after performing the operations. This requires careful selection of operations to maximize the minimum value.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. If n is 1, output the single element as no operation can be performed.\n3. Sort the array a.\n4. Initialize a variable `max_min` to store the maximum possible minimum value.\n5. Iterate through the sorted array and calculate differences between consecutive elements.\n6. Update `max_min` with the maximum difference encountered.\n7. Output `max_min` for each test case.\n\n# [edge case]\n    Test case 1: [1] = 10\n    Explanation: With only one element, no operation can be performed, so the output is the element itself.\n\n    Test case 2: [0, 0] = 0\n    Explanation: All elements are zero, so any operation will result in zero as the minimum.\n\n    Test case 3: [-1, 2, 0] = 2\n    Explanation: After performing operations, the maximum possible minimum value is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of sorting and calculating differences inherently handles these scenarios.\n", "requirement analysis:\nThe requirements focus on maximizing the smallest element in an array after performing a series of operations. The challenge lies in efficiently processing potentially large datasets while ensuring the accuracy of results. The solution must handle edge cases and provide clear output for each test case.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure the solution handles large arrays within constraints\n- Optimize the algorithm for speed and accuracy\n- Provide clear input/output instructions\n- Test the solution against edge cases\nWe will implement a function that processes each test case by sorting the array and calculating the differences between consecutive elements. This approach ensures that we efficiently determine the maximum possible minimum value after performing the minimum extraction operation. The sorting step is O(n log n), which is efficient given the constraints. We will use Python's built-in sorting and list operations to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves removing the smallest element from the array and subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after performing this operation multiple times.\n\n    'maximize the smallest number'\n    Explanation: The objective is to make the smallest number in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': This indicates that the operation can only be performed if the array has more than one element.\n    'multiple times': This means the operation can be repeated as many times as needed, including zero times.\n\n# [degree adverb]\n    'greatest possible value': This refers to the highest value that the smallest element in the array can reach after performing the operations.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. If n is 1, output the single element as no operation can be performed.\n3. Sort the array a.\n4. Initialize a variable `max_min` to store the maximum possible minimum value.\n5. Iterate through the sorted array and calculate the difference between consecutive elements.\n6. Update `max_min` with the maximum of its current value and each calculated difference.\n7. Output `max_min` for each test case.\n\n# [edge case]\n    Test case 1: [1] = 10\n    Explanation: With only one element, no operation can be performed, so the output is the element itself.\n\n    Test case 2: [0, 0] = 0\n    Explanation: All elements are zero, so any operation will result in zero as the minimum.\n\n    Test case 3: [-1, 2, 0] = 2\n    Explanation: After performing operations, the maximum possible minimum is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and calculating differences will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on maximizing the smallest element in an array through a series of operations. The challenge lies in efficiently processing potentially large datasets while ensuring the accuracy of results. The solution must handle edge cases and provide clear output for each test case.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure accurate computation of the maximal possible minimum\n- Optimize performance for large input sizes\n- Handle edge cases robustly\n- Provide clear instructions and output format\nWe will implement a function that processes each test case independently. The function will utilize a priority queue (min-heap) to efficiently extract the minimum element and update the array. This approach ensures optimal performance even for large datasets, as heap operations are logarithmic in complexity. We will use Python's built-in heapq library for this purpose.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after several operations.\n\n    'maximize the smallest number'\n    Explanation: The objective is to make the minimum element in the array as large as possible through repeated minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'greater than one': Indicates that the operation can only be performed if the array length is more than one.\n    'greatest possible value': Refers to finding the maximum value that the minimum element can reach after operations.\n\n# [degree adverb]\n    'greatest': Refers to the largest possible value that the minimum element can achieve after performing the operations.\n\n# [code logic]\n1. For each test case, check if the array length is 1. If so, return the single element as no operations can be performed.\n2. Use a min-heap to efficiently extract the minimum element from the array.\n3. Initialize a variable to track the maximum of the minimums encountered during operations.\n4. Perform minimum extraction operations:\n   - Extract the smallest element using the heap.\n   - Subtract this element from all remaining elements.\n   - Update the maximum of minimums if the current minimum is larger.\n5. Continue until only one element remains in the array.\n6. Return the maximum of minimums for each test case.\n\n# [edge case]\n    Test case with a single element: [10] = 10\n    Explanation: No operations can be performed, so the output is the single element itself.\n\n    Test case with all elements being zero: [0, 0] = 0\n    Explanation: The array remains unchanged after operations, as subtracting zero does not affect other zeros.\n\n    Test case with negative and positive numbers: [-1, 1] = 2\n    Explanation: After extracting -1 and updating, the array becomes [2], which is the maximum possible minimum.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where no operations can be performed or where all elements are zero.\n"], "scores": [], "pass_results": [true, false, true, true, true, false, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 742, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "mutate_method": "rephrase_one", "parent_index": 74}
