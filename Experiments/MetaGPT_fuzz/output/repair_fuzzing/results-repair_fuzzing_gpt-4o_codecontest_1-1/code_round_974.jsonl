{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other. They can freely communicate without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This means everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other. They can freely communicate without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This means everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This rule ensures that they can all talk to each other during the party. They can freely communicate without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This means everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful, as a party is a gathering of exactly 5 people and will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other, they can freely communicate without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This means everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of individuals.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for nodes in combinations(G.nodes, 5):\n        subgraph = G.subgraph(nodes)\n        if nx.is_clique(subgraph):\n            return list(nodes)\n\n    # Check for an independent set of size 5\n    for nodes in combinations(G.nodes, 5):\n        subgraph = G.subgraph(nodes)\n        if nx.is_empty(subgraph):\n            return list(nodes)\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party(N: int, M: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of 5 people on the island of Baltia.\n\n    A successful party is defined as a group of 5 people where either all are friends\n    with each other (a clique) or none are friends with each other (an independent set).\n\n    Args:\n        N (int): The number of people on the island.\n        M (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 integers representing the people in a successful party, or -1 if not possible.\n    \"\"\"\n    # Create a graph to represent friendships\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in G is a clique in the complement of G\n    G_complement = nx.complement(G)\n    for independent_set in nx.find_cliques(G_complement):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nN, M = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Output interface\nresult = find_successful_party(N, M, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Determine if a successful party can be organized with exactly 5 people.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (list): List of tuples representing friendship pairs.\n\n    Returns:\n        list: A list of 5 individuals if a successful party can be organized, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Iterate over all combinations of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the combination forms a clique (complete subgraph)\n        if nx.is_clique(subgraph):\n            return list(combination)\n        \n        # Check if the combination forms an independent set (no edges)\n        if subgraph.number_of_edges() == 0:\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Union\n\ndef find_successful_party(n: int, m: int, friendships: List[tuple]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[tuple]): A list of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph from the friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: list) -> list:\n    \"\"\"Find a successful party of 5 people based on friendship rules.\n\n    Args:\n        N (int): Number of individuals on the island.\n        M (int): Number of friendship pairs.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 individuals for a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of nodes with no edges between them\n    complement_graph = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nN, M = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Call the function\nresult = find_successful_party(N, M, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Find a successful party of 5 people either all friends or none friends.\n\n    Args:\n        N (int): Number of individuals on the island.\n        M (int): Number of friendships.\n        friendships (list[tuple[int, int]]): List of pairs representing friendships.\n\n    Returns:\n        list[int]: List of 5 individuals for a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent set of size 5 by analyzing the complement graph\n    complement_graph = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of exactly 5 people based on friendship rules.\n\n    Args:\n        n (int): Number of individuals in Baltia.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    Args:\n        N (int): The number of people in Baltia.\n        M (int): The number of friendship pairs.\n        friendships (list): A list of tuples representing friendship pairs.\n\n    Returns:\n        list: A list of 5 people if a successful party can be organized, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by checking the complement graph for cliques.\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Output interface\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of exactly 5 people where either all are friends or none are friends.\n\n    Args:\n        n (int): The number of individuals in Baltia.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph to represent friendships\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nimport networkx as nx\n\ndef plan_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Plan a successful party by finding either a clique or an independent set of size 5.\n\n    Args:\n        n (int): Number of individuals.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an undirected graph using networkx\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of nodes with no edges between them\n    # We can find independent sets by checking combinations of nodes\n    nodes = list(G.nodes)\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            for k in range(j + 1, len(nodes)):\n                for l in range(k + 1, len(nodes)):\n                    for m in range(l + 1, len(nodes)):\n                        subset = [nodes[i], nodes[j], nodes[k], nodes[l], nodes[m]]\n                        if all(not G.has_edge(u, v) for u in subset for v in subset if u != v):\n                            return subset\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = plan_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle edge cases like minimal friendships or maximal friendships effectively.\nrequirement pool:\n- Develop an efficient algorithm to find a successful party of 5 people.\n- Ensure the solution handles edge cases with minimal and maximal friendships.\n- Optimize the solution for large inputs to ensure scalability.\n- Provide clear and concise output as per the specified format.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem efficiently. The problem can be modeled as a graph where nodes represent individuals and edges represent friendships. We need to find either a complete subgraph (clique) of size 5 or an independent set of size 5. We will use the NetworkX library to handle graph operations efficiently. The approach involves checking combinations of nodes to find either a clique or an independent set of size 5.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other (a clique) or no two attendees are friends (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In the context of an independent set, it means that none of the selected individuals should have a direct friendship link.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Model the problem as a graph where nodes represent individuals and edges represent friendships.\n2. Check for a clique of size 5:\n   - Iterate through combinations of 5 individuals.\n   - For each combination, check if every pair within the combination is connected by an edge.\n3. Check for an independent set of size 5:\n   - Iterate through combinations of 5 individuals.\n   - For each combination, check if no pair within the combination is connected by an edge.\n4. If either a clique or an independent set is found, print the individuals involved. Otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships (M=0), any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships (a complete graph), no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: Again, with no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends with each other or none are friends with each other. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of the friendships. The solution must efficiently handle up to 200,000 nodes and edges, suggesting the need for optimized graph algorithms. Edge cases include scenarios with minimal friendships or maximal friendships, and the presence of cycles in the friendship graph.\nrequirement pool:\n- Implement an efficient algorithm to find cliques or independent sets of size 5.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Provide clear output as specified in the requirements.\n- Consider edge cases such as minimal or maximal friendships.\n- Optimize for performance to handle large input sizes.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to represent the friendship graph and check for cliques and independent sets of size 5. NetworkX provides efficient methods for finding cliques, which will help us identify groups of 5 people who are all friends. For independent sets, we will check combinations of 5 people to ensure no two are friends. This approach is scalable and efficient for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people on the island of Baltia.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using a graph where nodes are individuals and edges are friendships.\n    2. Check for cliques of size 5 in the graph, which represent groups where all members are friends.\n    3. Check for independent sets of size 5, where no members are friends with each other.\n    4. If either a clique or independent set is found, print the members; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every group of 5 individuals forms a clique, but if N is small, it might not be possible to form a successful party.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of exactly 5 people can be selected such that they are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The solution must efficiently handle up to 200,000 people and friendships, suggesting the need for graph algorithms that can quickly identify such structures.\nrequirement pool:\n- Implement an efficient algorithm to find cliques of size 5.\n- Implement an efficient algorithm to find independent sets of size 5.\n- Optimize the solution for large datasets.\n- Ensure the solution handles edge cases, such as no friendships or everyone being friends.\n- Provide user-friendly output formatting.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and use algorithms to find cliques of size 5 or independent sets of size 5. The NetworkX library in Python is suitable for this task as it provides efficient graph operations. We will iterate over all possible combinations of 5 people and check if they form a clique or an independent set.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other (a clique) or no two attendees are friends (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In the context of an independent set, it means that none of the 5 people should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using adjacency lists or a similar structure.\n2. Iterate over all possible combinations of 5 people from the N individuals.\n3. For each combination, check if they form a clique (all are friends) or an independent set (none are friends).\n4. If a valid combination is found, print the 5 individuals.\n5. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Case 1: N = 5, M = 0\n    Explanation: With 5 people and no friendships, any group of 5 forms an independent set. Expected output: 1 2 3 4 5\n\n    Case 2: N = 6, M = 15\n    Explanation: With 6 people and maximum friendships (a complete graph), any group of 5 forms a clique. Expected output: Any combination of 5 people, e.g., 1 2 3 4 5\n\n    Case 3: N = 5, M = 10\n    Explanation: With 5 people and all possible friendships among them, they form a complete graph. Expected output: -1, as no independent set of size 5 can exist.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations for cliques or independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints where N and M can be as large as 200,000. The solution must handle both dense and sparse friendship graphs and provide a valid output or indicate impossibility.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Handle edge cases where N is small or M is at extremes.\n- Optimize for both dense and sparse friendship graphs.\n- Provide clear and concise output format.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for cliques of size 5 (where all nodes are connected) or independent sets of size 5 (where no nodes are connected). We will utilize the NetworkX library, which provides efficient graph operations and algorithms to help identify cliques and independent sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or no two attendees are friends.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the 5 people should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using NetworkX.\n2. Check for cliques of size 5 in the graph, where all nodes are connected.\n3. Check for independent sets of size 5, where no nodes are connected.\n4. If either a clique or an independent set of size 5 is found, print the nodes involved.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every group of 5 people forms a clique, but since N=6, it's impossible to have a group of exactly 5 people without any friendships.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships and more than 5 people, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a group of 5 people who are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph. The constraints suggest the need for efficient graph traversal and checking algorithms, especially given the large possible input size.\nrequirement pool:\n- Implement an efficient algorithm to find cliques of size 5.\n- Implement an efficient algorithm to find independent sets of size 5.\n- Optimize the solution for edge cases with maximum constraints.\n- Ensure the solution handles both small and large values of N and M.\n- Provide clear documentation and comments in the code.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 or independent sets of size 5 in the graph. We will use the NetworkX library, which provides efficient algorithms for finding cliques and independent sets. This library is well-suited for handling large graphs and provides functions that can directly be used to find cliques and independent sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as a graph where nodes are individuals and edges are friendships.\n    2. Check for cliques of size 5 (where all nodes are connected) using graph theory algorithms.\n    3. Check for independent sets of size 5 (where no nodes are connected) using graph theory algorithms.\n    4. If either a clique or independent set of size 5 is found, print the individuals involved.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, all individuals are connected, making it impossible to have an independent set of size 5.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 individuals from a larger group such that they either all know each other or none know each other. This involves graph theory concepts, specifically cliques and independent sets. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for optimized graph traversal and analysis techniques.\nrequirement pool:\n- Develop an algorithm to find a clique or independent set of size 5.\n- Ensure the solution is optimized for large N and M values.\n- Implement edge case handling for minimal and maximal friendship scenarios.\n- Provide clear output formatting as specified in the requirements.\n- Document the code for maintainability and future updates.\nWe will use graph theory concepts to solve this problem. Specifically, we will utilize the NetworkX library to efficiently manage and analyze the graph of friendships. The goal is to find either a clique of size 5 or an independent set of size 5. NetworkX provides functions to find cliques and can be used to check for independent sets by analyzing the complement graph.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using a graph where nodes are individuals and edges are friendships.\n    2. Check for cliques of size 5 using NetworkX's clique finding functions.\n    3. If a clique of size 5 is found, print the individuals in the clique.\n    4. If no clique is found, check for an independent set of size 5 by analyzing the complement graph.\n    5. If an independent set of size 5 is found, print the individuals in the set.\n    6. If neither a clique nor an independent set is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, all individuals form an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, all individuals are connected, making it impossible to have an independent set of size 5.\n\n    Input: 7 3\n    Output: -1\n    Explanation: Not enough friendships to form a clique of size 5 and not enough individuals to form an independent set without exceeding the party size.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for finding cliques and independent sets inherently handles these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship connections. The solution must efficiently handle large numbers of individuals and friendships, ensuring that the output is clear and concise. Edge cases, such as minimal friendships or cyclical friendships, must be considered to ensure robustness.\nrequirement pool:\n- Develop an algorithm to check for successful party arrangements.\n- Ensure the solution handles up to 200,000 individuals and friendships.\n- Optimize the algorithm for performance with large datasets.\n- Provide clear output indicating party success or failure.\n- Consider edge cases like minimal friendships or cyclical friendships.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to represent the friendships as a graph. The problem can be reduced to finding cliques of size 5 or independent sets of size 5 in the graph. NetworkX provides efficient methods to find cliques, which will help in determining if a successful party can be organized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the 5 people should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using NetworkX.\n2. Check for cliques of size 5 in the graph, which represent groups where everyone is friends with each other.\n3. Check for independent sets of size 5, which represent groups where no one is friends with each other.\n4. If either a clique or an independent set of size 5 is found, print the members of that group.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every group of 5 people forms a clique, but since N=6, it's impossible to have a group of exactly 5 people without any friendships.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships and more than 5 people, any group of 5 people can be chosen as an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who either all know each other or none know each other. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The solution must efficiently handle up to 200,000 people and friendships, suggesting the need for optimized graph algorithms.\nrequirement pool:\n- Implement an efficient algorithm to find cliques or independent sets of size 5.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Optimize the solution for edge cases with minimal friendships or dense friendship networks.\n- Provide clear and concise output as per the specified format.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and use algorithms to find cliques of size 5 or independent sets of size 5. NetworkX, a Python library for the creation, manipulation, and study of complex networks, will be used to efficiently handle graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other or none of them are friends with each other.\n\n    'friends'\n    Explanation: Friendship is represented as pairs of individuals who can communicate freely with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group selected for the party contains exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using NetworkX.\n    2. Check for cliques of size 5 in the graph, where all members are friends with each other.\n    3. Check for independent sets of size 5, where no members are friends with each other.\n    4. If either condition is met, print the members of the successful party.\n    5. If neither condition is met, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every person is friends with every other person, making it impossible to have an independent set of size 5.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, multiple independent sets of size 5 are possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle large inputs and edge cases, such as no friendships or complete graphs.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles maximum constraints for N and M.\n- Optimize for performance to handle large datasets quickly.\n- Provide clear output format as specified in the requirements.\n- Consider user-friendly error messages for invalid inputs.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We will utilize the NetworkX library, which provides efficient graph operations, to handle the graph representation and search for these subgraphs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other or none of them are friends with each other.\n\n    'cliques' and 'independent sets'\n    Explanation: A clique is a subset of vertices in a graph such that every two distinct vertices are adjacent. An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5': means the party must consist of precisely 5 individuals.\n    'no two people': means that in an independent set, none of the selected individuals should be friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using a graph where nodes are individuals and edges represent friendships.\n    2. Check for cliques of size 5 using graph traversal methods.\n    3. Check for independent sets of size 5 using graph traversal methods.\n    4. If either a clique or an independent set is found, print the individuals involved; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist, and if no clique of size 5 exists, return -1.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on identifying groups of 5 people who are either all friends or none are friends. The solution must efficiently handle large numbers of people and friendships, considering edge cases and cyclical friendships. The output should be clear and concise, indicating either a successful party arrangement or impossibility.\nrequirement pool:\n- Efficiently identify groups of 5 people who are all friends.\n- Efficiently identify groups of 5 people who are not friends.\n- Handle edge cases where N is small or M is at extremes.\n- Consider cyclical friendships in party arrangements.\n- Provide clear output indicating success or impossibility.\nWe will use graph theory to solve this problem. The friendships can be represented as an undirected graph where nodes are individuals and edges are friendships. We need to find either a complete subgraph (clique) of size 5 or an independent set of size 5. For this, we can use networkx, a Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. This library will help us efficiently find cliques and independent sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other (forming a complete subgraph or clique) or none of the attendees are friends with each other (forming an independent set).\n\n    'graph theory'\n    Explanation: The problem can be modeled using graph theory, where individuals are nodes and friendships are edges. The task is to find specific subgraphs (cliques or independent sets) within this graph.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 nodes from the graph.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using a suitable data structure (e.g., adjacency list).\n2. Check for cliques of size 5:\n   - Use a graph traversal method to identify complete subgraphs of size 5.\n3. Check for independent sets of size 5:\n   - Use a graph traversal method to identify sets of 5 nodes with no edges between them.\n4. If either a clique or an independent set is found, print the nodes involved.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any selection of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist, and a clique of size 5 may not be possible due to constraints.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any selection of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 974, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "parent_index": 585}
