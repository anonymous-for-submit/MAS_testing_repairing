{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, and they have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, and they have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, and they have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other. This allows all the attendees to communicate freely. Alternatively, the party is successful if no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. On the island of Baltia, a party includes exactly 5 persons, and the party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends (enabling everyone to focus on their phones without interruptions). Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 individuals.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship conditions.\n\n    Args:\n        N: The number of people on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples where each tuple represents a friendship between two people.\n\n    Returns:\n        A list of 5 integers representing the people to invite to the party, or -1 if no such configuration is possible.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check all combinations of 5 people\n    for combination in combinations(range(1, N + 1), 5):\n        if is_clique(combination, adjacency_list) or is_independent_set(combination, adjacency_list):\n            return list(combination)\n\n    return -1\n\ndef is_clique(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a group of 5 people forms a clique.\n\n    Args:\n        group: A tuple of 5 people.\n        adjacency_list: The adjacency list representing friendships.\n\n    Returns:\n        True if the group forms a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] not in adjacency_list[group[i]]:\n                return False\n    return True\n\ndef is_independent_set(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a group of 5 people forms an independent set.\n\n    Args:\n        group: A tuple of 5 people.\n        adjacency_list: The adjacency list representing friendships.\n\n    Returns:\n        True if the group forms an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] in adjacency_list[group[i]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport itertools\nfrom typing import List, Tuple, Union\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship criteria.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    if n < 5:\n        return -1\n\n    # Create adjacency matrix to represent friendships\n    friends = [[False] * (n + 1) for _ in range(n + 1)]\n\n    for u, v in friendships:\n        friends[u][v] = True\n        friends[v][u] = True\n\n    # Check for cliques or independent sets of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(friends[i][j] for i, j in itertools.combinations(combination, 2)):\n            return list(combination)\n        if all(not friends[i][j] for i, j in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: typing.List[typing.Tuple[int, int]]) -> typing.Union[typing.List[int], int]:\n    \"\"\"Finds a successful party configuration of exactly 5 people.\n\n    A successful party is defined as either a clique of size 5 or an independent set of size 5.\n    \n    Args:\n        n: The number of people on the island.\n        m: The number of friendships.\n        friendships: A list of tuples representing friendships between people.\n\n    Returns:\n        A list of 5 integers representing the people to invite to the party if successful, otherwise -1.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # To find independent sets, we can check the complement graph for cliques of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif isinstance(result, list):\n    print(' '.join(map(str, result)))\nelse:\n    print(result)\n", "from typing import List\n## main.py\n\nimport itertools\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for combination in itertools.combinations(G.nodes, 5):\n        subgraph = G.subgraph(combination)\n        if nx.is_clique(subgraph):\n            return list(combination)\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for combination in itertools.combinations(complement_graph.nodes, 5):\n        subgraph = complement_graph.subgraph(combination)\n        if nx.is_clique(subgraph):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport itertools\nimport sys\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party configuration is found, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for combination in itertools.combinations(G.nodes, 5):\n        if all(G.has_edge(u, v) for u, v in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in itertools.combinations(G.nodes, 5):\n        if all(not G.has_edge(u, v) for u, v in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\ndef main():\n    # Read input\n    input_data = sys.stdin.read().strip().split()\n    n = int(input_data[0])\n    m = int(input_data[1])\n    friendships = [(int(input_data[i]), int(input_data[i + 1])) for i in range(2, len(input_data), 2)]\n\n    # Call the function\n    result = find_successful_party(n, m, friendships)\n\n    # Output the result\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration of 5 people on the island of Baltia.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a complement of a clique in the complement graph\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people on the island of Baltia.\n\n    A successful party is defined as either a clique of size 5 (all attendees are friends)\n    or an independent set of size 5 (no attendees are friends).\n\n    Args:\n        N: The number of people on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples where each tuple represents a friendship between two people.\n\n    Returns:\n        A list of 5 integers representing the people to invite to the party if a successful\n        configuration is possible, otherwise returns -1.\n    \"\"\"\n    # Create an adjacency list to represent the friendships\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a subset of vertices forms a clique\n    def is_clique(subset: List[int]) -> bool:\n        for i in range(len(subset)):\n            for j in range(i + 1, len(subset)):\n                if subset[j] not in adjacency_list[subset[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a subset of vertices forms an independent set\n    def is_independent_set(subset: List[int]) -> bool:\n        for i in range(len(subset)):\n            for j in range(i + 1, len(subset)):\n                if subset[j] in adjacency_list[subset[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    def find_configuration() -> List[int]:\n        # Check all combinations of 5 people\n        from itertools import combinations\n        for subset in combinations(range(1, N + 1), 5):\n            if is_clique(subset) or is_independent_set(subset):\n                return list(subset)\n        return -1\n\n    return find_configuration()\n\n# Input interface\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party configuration on the island of Baltia.\n\n    Args:\n        N: The number of individuals on the island.\n        M: The number of friendships.\n        friendships: A list of tuples representing pairs of friends.\n\n    Returns:\n        A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a completely disconnected group of 5 individuals\n    for i in range(1, N - 4):\n        for j in range(i + 1, N - 3):\n            for k in range(j + 1, N - 2):\n                for l in range(k + 1, N - 1):\n                    for m in range(l + 1, N):\n                        if (not adjacency_list[i] & {j, k, l, m} and\n                            not adjacency_list[j] & {i, k, l, m} and\n                            not adjacency_list[k] & {i, j, l, m} and\n                            not adjacency_list[l] & {i, j, k, m} and\n                            not adjacency_list[m] & {i, j, k, l}):\n                            return [i, j, k, l, m]\n\n    # Check for a complete subgraph of 5 individuals\n    for i in range(1, N - 4):\n        for j in range(i + 1, N - 3):\n            for k in range(j + 1, N - 2):\n                for l in range(k + 1, N - 1):\n                    for m in range(l + 1, N):\n                        if (adjacency_list[i] & {j, k, l, m} == {j, k, l, m} and\n                            adjacency_list[j] & {i, k, l, m} == {i, k, l, m} and\n                            adjacency_list[k] & {i, j, l, m} == {i, j, l, m} and\n                            adjacency_list[l] & {i, j, k, m} == {i, j, k, m} and\n                            adjacency_list[m] & {i, j, k, l} == {i, j, k, l}):\n                            return [i, j, k, l, m]\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport itertools\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    A successful party is defined as a group of exactly 5 people where either\n    all attendees are friends with each other (forming a complete subgraph or clique)\n    or none of the attendees are friends (forming an independent set).\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 integers representing the people at the party, or -1 if no such party is possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for combination in itertools.combinations(G.nodes, 5):\n        subgraph = G.subgraph(combination)\n        if nx.is_clique(subgraph):\n            return list(combination)\n\n    # Check for independent sets of size 5\n    for combination in itertools.combinations(G.nodes, 5):\n        subgraph = G.subgraph(combination)\n        if subgraph.number_of_edges() == 0:\n            return list(combination)\n\n    # If no valid configuration is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The constraints suggest that an efficient algorithm is necessary due to the potential size of N and M.\nrequirement pool:\n- Develop an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints of N and M.\n- Provide clear output as specified in the requirements.\n- Optimize for edge cases where M is 0 or very large.\n- Consider multiple successful configurations if possible.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these configurations using combinatorial techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all attendees are friends with each other or none of them are friends.\n\n    'clique' and 'independent set'\n    Explanation: A clique is a subset of vertices in a graph such that every two distinct vertices are adjacent. An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 individuals.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5:\n        - Iterate over all combinations of 5 individuals.\n        - For each combination, check if every pair within the combination is friends.\n    3. Check for an independent set of size 5:\n        - Iterate over all combinations of 5 individuals.\n        - For each combination, check if no pair within the combination is friends.\n    4. If either condition is met, print the combination; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 individuals is friends, no independent set of size 5 can exist.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, multiple independent sets are possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M. The solution must handle large inputs and provide a clear output format.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for large input sizes.\n- Provide clear documentation and comments in the code.\n- Consider user-friendly error messages for invalid inputs.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will use combinations to check possible groups of 5 people and verify if they meet the criteria for a successful party.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of exactly 5 individuals.\n    'no pair': This means that none of the selected individuals should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of people (N) and the number of friendships (M).\n2. Construct an adjacency list to represent the friendships.\n3. Iterate over all possible combinations of 5 people from the N individuals.\n4. For each combination, check if it forms a clique (all are friends) or an independent set (none are friends).\n5. If a valid combination is found, print the indices of these 5 people.\n6. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no group of 5 can be an independent set.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: Again, with no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles the maximum constraints of N and M.\n- Optimize the solution for speed and memory usage.\n- Provide clear documentation and examples for users.\n- Consider edge cases such as no friendships or all possible friendships.\nWe will use graph theory to solve this problem. The idea is to check for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We can use the NetworkX library to efficiently manage and query the graph structure.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques of size 5'\n    Explanation: A clique of size 5 means a subset of 5 people where every pair of people are friends with each other.\n\n    'independent sets of size 5'\n    Explanation: An independent set of size 5 means a subset of 5 people where no pair of people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 individuals.\n    \n    'no pairs are repeated': Each friendship is unique and appears only once in the input.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to create a graph representation of the friendships using an adjacency list or matrix.\n2. Check for cliques of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if every pair within the combination is friends.\n3. Check for independent sets of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if no pair within the combination is friends.\n4. If a valid clique or independent set is found, print the indices of the 5 people.\n5. If no valid configuration is found after checking all possibilities, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no independent set can exist, and if N > 5, no clique of exactly 5 can be formed without excluding someone.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to the large constraints.\n    \n```python\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if N < 5:\n        return -1\n    \n    # Create adjacency matrix\n    friends = [[False] * (N + 1) for _ in range(N + 1)]\n    \n    for u, v in friendships:\n        friends[u][v] = True\n        friends[v][u] = True\n    \n    # Check for cliques or independent sets\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        if all(friends[i][j] for i, j in itertools.combinations(combination, 2)):\n            return combination\n        if all(not friends[i][j] for i, j in itertools.combinations(combination, 2)):\n            return combination\n    \n    return -1\n\n# Example usage:\nN = 6\nM = 3\nfriendships = [(1, 4), (4, 2), (5, 4)]\nprint(find_successful_party(N, M, friendships)) # Output could be any valid combination or -1\n```\nThis code efficiently checks for cliques and independent sets using combinations and adjacency matrix representation.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of the friendships. The solution must efficiently handle up to 200,000 nodes and edges, suggesting the need for an algorithm with a time complexity better than O(N^5).\nrequirement pool:\n- Efficiently determine if a successful party configuration is possible.\n- Handle large input sizes up to the maximum constraints.\n- Provide clear and correct output format as specified.\n- Consider edge cases such as no friendships or maximum friendships.\n- Optimize for both time and space complexity.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 or independent sets of size 5 in the graph. We will use the NetworkX library, which provides efficient graph operations. The algorithm will involve creating a graph from the input data and then checking for cliques and independent sets of size 5.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all attendees are friends with each other.\n    \n    'independent sets': An independent set in a graph is a set of vertices such that no two vertices in the set are adjacent. In this context, it means no pair of people at the party are friends.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must include exactly 5 persons, no more, no less.\n    \n    'no pairs are repeated': Each friendship pair is unique and not repeated in the input.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to create a graph representation using the NetworkX library.\n    2. Check for cliques of size 5 in the graph.\n    3. If a clique of size 5 is found, print the vertices.\n    4. If no clique is found, check for independent sets of size 5.\n    5. If an independent set of size 5 is found, print the vertices.\n    6. If neither a clique nor an independent set of size 5 is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist.\n\n    Input: 7 3\n    Output: -1\n    Explanation: With only three friendships among seven people, neither a clique nor an independent set of size 5 can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining if a successful party configuration is possible given the friendship pairs. The solution must efficiently handle large datasets and provide accurate results. The output should be clear and concise, indicating either a successful configuration or impossibility.\nrequirement pool:\n- Develop an algorithm to check for successful party configurations.\n- Ensure the solution handles up to 200,000 individuals and friendships efficiently.\n- Optimize the algorithm for speed and accuracy.\n- Provide clear output format as specified in the requirements.\n- Consider edge cases and ensure robustness of the solution.\nWe will use graph theory to solve this problem. Specifically, we will use adjacency lists to represent friendships and check for cliques or independent sets of size 5. NetworkX, a Python library for the creation, manipulation, and study of complex networks, will be used to efficiently handle graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all attendees are friends with each other (forming a clique) or none of the attendees are friends (forming an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of vertices in a graph such that every two distinct vertices are adjacent.\n\n    'independent set'\n    Explanation: An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for cliques of size 5 by iterating through combinations of 5 people and verifying if all pairs are friends.\n    3. Check for independent sets of size 5 by iterating through combinations of 5 people and verifying if no pairs are friends.\n    4. If either condition is met, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is friends, no independent set of size 5 can exist.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, multiple independent sets of size 5 are possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of the friendships. The solution must efficiently handle up to 200,000 nodes and edges.\nrequirement pool:\n- Develop an efficient algorithm to find cliques or independent sets of size 5.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Optimize the solution for edge cases with minimal friendships.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem. The task is to find either a clique of size 5 or an independent set of size 5 in the graph. We will represent the friendships as an adjacency list and use efficient algorithms to check for cliques and independent sets. NetworkX, a Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks, will be used to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all 5 people at the party are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. In this context, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 individuals.\n    Implementation: Ensure that any solution involves exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an adjacency list.\n2. Check for a clique of size 5:\n   - Iterate through all possible combinations of 5 people.\n   - For each combination, check if every pair within the combination is friends.\n3. Check for an independent set of size 5:\n   - Iterate through all possible combinations of 5 people.\n   - For each combination, check if no pair within the combination is friends.\n4. If either a clique or an independent set is found, print the combination.\n5. If no such combination is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships (a complete graph), no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: Again, with no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that either all are friends or none are friends. This involves analyzing the graph of friendships and checking for cliques or independent sets of size 5. The solution must efficiently handle up to 200,000 people and friendships, suggesting the use of graph algorithms optimized for large datasets.\nrequirement pool:\n- Efficiently determine if a successful party configuration is possible.\n- Handle maximum constraints of N and M efficiently.\n- Provide clear output format as specified.\n- Consider edge cases where M is 0 or very large.\n- Optimize for multiple successful party configurations.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to represent the graph of friendships and check for cliques or independent sets of size 5. NetworkX provides efficient algorithms for finding cliques, which will help us determine if a successful party configuration is possible.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other (forming a clique) or none of the attendees are friends (forming an independent set).\n\n    'clique' and 'independent set'\n    Explanation: A clique is a subset of vertices in a graph such that every two distinct vertices are adjacent. An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of exactly 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using a graph structure.\n    2. Check for cliques of size 5 using graph algorithms.\n    3. Check for independent sets of size 5 using graph algorithms.\n    4. If either a clique or an independent set of size 5 is found, print the members of the party.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no group of 5 can be an independent set.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that either all are friends or none are friends. This involves analyzing the friendship graph to find cliques or independent sets of size 5. The solution must efficiently handle up to 200,000 people and friendships.\nrequirement pool:\n- Develop an efficient algorithm to find cliques or independent sets of size 5\n- Ensure the solution handles edge cases like no friendships or maximum friendships\n- Optimize for large input sizes to ensure performance\n- Provide clear output format as specified\n- Test the solution against multiple scenarios to ensure accuracy\nWe will use graph theory to solve this problem. The task is to find either a clique of size 5 or an independent set of size 5 in the friendship graph. We will represent the friendships as an adjacency list and use a combination of depth-first search (DFS) and backtracking to explore possible configurations. Given the constraints, we need an efficient approach, so we will also consider using a library like NetworkX to handle graph operations if necessary.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people at the party are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. Here, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This indicates that the party must consist of precisely 5 individuals.\n    'no pairs are repeated': This means each friendship is unique and not duplicated in the input.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an adjacency list.\n    2. Check for a clique of size 5:\n        - Use DFS to explore subsets of vertices and check if they form a clique.\n    3. Check for an independent set of size 5:\n        - Use DFS to explore subsets of vertices and check if they form an independent set.\n    4. If either configuration is found, print the 5 individuals.\n    5. If no configuration is possible, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, all people are connected, making it impossible to have an independent set.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to determine if a successful party configuration is possible given the constraints of friendships among individuals. The solution must efficiently handle large inputs and provide a clear output indicating either a successful configuration or impossibility.\nrequirement pool:\n- Efficient algorithm to determine party configuration\n- Handle large datasets up to 200,000 individuals and friendships\n- Provide clear output format as specified\n- Ensure no duplicate friendships are processed\n- Optimize for speed and memory usage\nWe will use a graph-based approach to solve this problem. The individuals can be represented as nodes and friendships as edges in an undirected graph. The task is to find a subset of 5 nodes that either form a complete subgraph (clique) or are completely disconnected. We will use a combination of depth-first search (DFS) and adjacency list representation to efficiently explore possible configurations. Given the constraints, we will focus on optimizing the search to handle up to 200,000 nodes and edges.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all attendees are friends with each other or none of them are friends.\n\n    'buddies'\n    Explanation: Buddies refer to pairs of individuals who are friends, represented as edges in a graph.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any subset selected for the party contains exactly 5 individuals.\n\n# [degree adverb]\n    'successful': This indicates the requirement for the party to meet specific conditions (either all friends or none).\n    Implementation: Check for either a complete subgraph (clique) or a completely disconnected subgraph.\n\n# [code logic]\n1. Represent individuals and friendships using a graph with nodes and edges.\n2. Use an adjacency list to store friendships.\n3. Iterate through possible combinations of 5 individuals.\n4. For each combination, check if they form a complete subgraph or are completely disconnected.\n5. If a valid combination is found, print the individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals is completely disconnected, making the party successful.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no group of 5 can be completely disconnected, and not all can be friends due to the odd number of individuals.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 individuals is completely disconnected, making the party successful.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The constraints suggest the need for an efficient algorithm, likely involving graph theory concepts such as cliques and independent sets.\nrequirement pool:\n- Develop an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Provide clear and concise output as per the problem statement.\n- Optimize the solution to handle edge cases effectively.\n- Consider multiple successful configurations if possible.\nWe will use graph theory concepts to solve this problem efficiently. Specifically, we will utilize adjacency lists to represent friendships and check for cliques (complete subgraphs) and independent sets (no edges between nodes) of size 5. The NetworkX library will be used to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all attendees are friends with each other (forming a complete subgraph or clique) or none of the attendees are friends (forming an independent set).\n\n    'buddies'\n    Explanation: Buddies refer to pairs of individuals who are friends, represented as edges in a graph.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    'successful': This means the party must meet one of the two conditions (all friends or no friends).\n    Implementation: Check for either a complete subgraph of size 5 or an independent set of size 5.\n\n# [code logic]\n    1. Represent friendships using an adjacency list.\n    2. Check for cliques of size 5 by iterating through combinations of 5 people and verifying if all are friends.\n    3. Check for independent sets of size 5 by iterating through combinations of 5 people and verifying if none are friends.\n    4. If a valid configuration is found, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no independent set of size 5 can exist.\n\n    Input: 7 0\n    Output: Any valid group of 5 individuals, e.g., 1 2 3 4 5\n    Explanation: With no friendships, multiple independent sets of size 5 are possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, true, true, false, true, false, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 689, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "add_1_sentence_at_end", "parent_index": 406}
