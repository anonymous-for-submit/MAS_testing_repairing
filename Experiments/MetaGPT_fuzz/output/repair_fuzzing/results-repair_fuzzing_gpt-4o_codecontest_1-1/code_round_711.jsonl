{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi has a strong preference for sorting the books. He wants to arrange them in lexicographically ascending order. Meanwhile, Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi has a strong preference for sorting the books. He wants to arrange them in lexicographically ascending order. Meanwhile, Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n. Each string has a length of m. Andi has a strong preference for sorting the books. He wants to arrange them in lexicographically ascending order. Meanwhile, Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi has a strong preference for sorting the books, and he wants to arrange them in lexicographically ascending order, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly by comparing the odd-indexed characters ascendingly and the even-indexed characters descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed positions (0-based) are sorted ascending\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even-indexed positions (0-based) are sorted descending\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\nfrom typing import List\nimport functools\n\ndef custom_sort(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles according to the custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of titles.\n    \"\"\"\n    def comparator(a: str, b: str) -> int:\n        \"\"\"Custom comparator function for sorting titles.\n\n        Args:\n            a (str): First title to compare.\n            b (str): Second title to compare.\n\n        Returns:\n            int: Negative if a < b, positive if a > b, zero if a == b.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if i % 2 == 0:\n                    # Even index: descending order\n                    return -1 if a[i] > b[i] else 1\n                else:\n                    # Odd index: ascending order\n                    return -1 if a[i] < b[i] else 1\n        return 0\n\n    # Sort titles using the custom comparator\n    sorted_titles = sorted(titles, key=functools.cmp_to_key(comparator))\n    \n    # Return the indices of the sorted titles\n    return [titles.index(title) + 1 for title in sorted_titles]\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = custom_sort(n, m, titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport functools\n\ndef asc_desc_ending_sort(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles according to the asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of titles.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Compares two strings based on asc-desc-ending order.\n\n        Args:\n            a (str): First string to compare.\n            b (str): Second string to compare.\n\n        Returns:\n            int: Negative if a < b, positive if a > b, zero if equal.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if i % 2 == 0:\n                    # Even index: descending order\n                    return -1 if a[i] > b[i] else 1\n                else:\n                    # Odd index: ascending order\n                    return -1 if a[i] < b[i] else 1\n        return 0\n\n    # Sort titles using the custom comparator\n    sorted_titles = sorted(titles, key=functools.cmp_to_key(custom_comparator))\n    \n    # Return the indices of the sorted titles\n    return [titles.index(title) + 1 for title in sorted_titles]\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Call the sorting function\nsorted_indices = asc_desc_ending_sort(n, m, titles)\n\n# Output interface\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc_ending(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles according to the asc-desc-ending order logic.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of original indices of the sorted book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: The custom sort key based on asc-desc-ending logic.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Pair each title with its original index\n    indexed_titles = [(i + 1, title) for i, title in enumerate(book_titles)]\n\n    # Sort using the custom key function\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the original indices of the sorted titles\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc_ending(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on the specified asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple used as a key for sorting.\n        \"\"\"\n        # Create a tuple where odd-indexed characters are sorted in ascending order\n        # and even-indexed characters are sorted in descending order.\n        return tuple(\n            (char if i % 2 == 0 else -ord(char)) for i, char in enumerate(title)\n        )\n\n    # Pair each book with its index\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\ndef sort_books_asc_desc_ending(n: int, m: int, books: list[str]) -> list[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order based on specified conditions.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (list[str]): List of book titles.\n\n    Returns:\n        list[int]: List of indices representing the sorted order of book titles.\n    \"\"\"\n    def custom_sort_key(book: str) -> list:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            book (str): The book title to generate the key for.\n\n        Returns:\n            list: A list of tuples representing the sorting key.\n        \"\"\"\n        return [(char, index % 2 == 0) for index, char in enumerate(book)]\n\n    # Pair each book with its index\n    indexed_books = [(index + 1, book) for index, book in enumerate(books)]\n\n    # Sort books using the custom key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in sorted_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the sorting function\nsorted_indices = sort_books_asc_desc_ending(n, m, books)\n\n# Output interface\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Odd-indexed positions (0-based index) - ascending order\n                key.append((char, i))\n            else:\n                # Even-indexed positions (0-based index) - descending order\n                key.append((-ord(char), i))\n        return key\n\n    # Create a list of tuples (index, book title)\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom functools import cmp_to_key\n\ndef asc_desc_sort(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of titles.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Compares two strings based on asc-desc-ending order.\n\n        Args:\n            a (str): First string to compare.\n            b (str): Second string to compare.\n\n        Returns:\n            int: Negative if a < b, positive if a > b, zero if a == b.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd position (1-based index)\n                    return -1 if a[i] < b[i] else 1\n                else:  # Even position (1-based index)\n                    return -1 if a[i] > b[i] else 1\n        return 0\n\n    # Sort titles using the custom comparator\n    sorted_titles = sorted(titles, key=cmp_to_key(custom_comparator))\n    \n    # Return the indices of the sorted titles\n    return [titles.index(title) + 1 for title in sorted_titles]\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = asc_desc_sort(n, m, titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom functools import cmp_to_key\n\ndef asc_desc_ending_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of book titles.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Custom comparator for sorting book titles.\n\n        Args:\n            a (str): First book title.\n            b (str): Second book title.\n\n        Returns:\n            int: Negative if a < b, positive if a > b, zero if equal.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd position (1-based index)\n                    return -1 if a[i] < b[i] else 1\n                else:  # Even position (1-based index)\n                    return -1 if a[i] > b[i] else 1\n        return 0\n\n    # Sort the book titles using the custom comparator\n    sorted_titles = sorted(book_titles, key=cmp_to_key(custom_comparator))\n    \n    # Return the indices of the sorted titles\n    return [book_titles.index(title) + 1 for title in sorted_titles]\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = asc_desc_ending_sort(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef asc_desc_ending_sort(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on the asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = [title[i] for i in range(m) if i % 2 == 0]\n        even_chars = [title[i] for i in range(m) if i % 2 == 1]\n        return (odd_chars, [-ord(c) for c in even_chars])\n\n    # Create a list of tuples (index, title) to maintain original indices\n    indexed_titles = list(enumerate(titles, start=1))\n    \n    # Sort the indexed titles using the custom sort key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = asc_desc_ending_sort(n, m, titles)\nprint(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules for odd and even positions. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize performance for large input sizes\n- Ensure correct handling of edge cases\n- Provide clear documentation and comments\n- Develop test cases to validate the solution\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters by leveraging Python's efficient string and list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of books (n) and the length of each book title (m).\n    2. Store each book title in a list.\n    3. Implement a custom sorting function:\n        - For each pair of book titles, compare characters at odd positions in ascending order.\n        - Compare characters at even positions in descending order.\n    4. Use Python's built-in sorting with the custom key function to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 3 2 1\n    Explanation: At position 2 (even), 'D' comes before 'C' and 'B', so AD comes first, followed by AC, then AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of custom sorting based on odd and even positions will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output format as specified.\n- Optimize for performance and memory usage.\n- Include error handling for edge cases.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that adheres to the asc-desc-ending order. We will use the functools.cmp_to_key function to create a comparator that can handle the sorting logic efficiently. This approach leverages Python's efficient sorting algorithms and allows us to handle the maximum input size within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting strings based on dictionary order from A to Z.\n    'lexicographically descending': means sorting strings based on dictionary order from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom comparator function:\n   - For each character position `i` in the strings:\n     - If `i` is odd, compare characters in ascending order.\n     - If `i` is even, compare characters in descending order.\n4. Use Python's `sorted()` function with `functools.cmp_to_key()` to sort the list of book titles using the custom comparator.\n5. Output the indices of the sorted book titles.\n\n# [edge case]\n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At index 1 (even), 'B' > 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 1 2 3\n    Explanation: At index 1 (even), all have 'A', so sorted by index 2 (odd) in ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom comparator logic inherently handles all cases, including edge cases, by comparing each character position according to the specified rules.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified conditions for odd and even indexed characters. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Validate the output format against multiple test cases\n- Optimize the algorithm for performance\n- Document the code for maintainability\nWe will implement a custom sorting function that adheres to the asc-desc-ending order using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that checks the odd and even indexed characters according to the specified rules. We will use the functools.cmp_to_key utility to convert the comparator function into a key function for sorting.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom comparator function:\n        - Compare characters at odd indices in ascending order.\n        - Compare characters at even indices in descending order.\n    4. Use functools.cmp_to_key to convert the comparator into a key function for sorting.\n    5. Sort the list of book titles using the custom key function.\n    6. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: Sorting by asc-desc-ending order results in ABC, CAB, BAC.\n\n    Input: 2 2\n           AA\n           AB\n    Output: 1 2\n    Explanation: The first book is already in asc-desc-ending order compared to the second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle all cases correctly, including edge cases.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified conditions for odd and even indexed characters. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize for performance with large input sizes\n- Ensure correct handling of edge cases\n- Provide clear documentation and comments\n- Develop test cases to validate the solution\nWe will implement a custom sorting function that adheres to the asc-desc-ending order logic. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution is optimized for performance with large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This is a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Store each book title along with its original index.\n    3. Define a custom sorting key function:\n       - For each character in the string, determine if its index is odd or even.\n       - If odd, use the character as is for ascending comparison.\n       - If even, use the negative ASCII value of the character for descending comparison.\n    4. Sort the list of book titles using this custom key function.\n    5. Extract and print the original indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (odd), 'B' comes after 'A', so 'BA' comes after 'AB'. At index 2 (even), 'A' comes before 'B', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BCA\n           CAB\n    Output: 3 1 2\n    Explanation: The sorting is determined by comparing characters at each position according to the asc-desc-ending rule.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by applying the defined rules consistently across all input strings.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is a combination of lexicographical ascending and descending orders based on the position of characters in the string. Odd-indexed characters are sorted in ascending order, while even-indexed characters are sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Read the n book titles.\n    3. Implement a custom sorting function:\n       - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n       - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key function.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At the first position, 'B' (from BA) comes after 'A' (from AB) in descending order, so BA comes first.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At the first position, 'C' (from CAB) comes after 'A' (from ABC) and 'B' (from BAC) in descending order, so CAB comes first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a custom sorting function with a tuple key will handle all cases, including edge cases.\n", "requirement analysis:\nThe requirements focus on sorting strings based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified conditions for odd and even indexed characters. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm for performance with large input sizes.\n- Ensure the solution passes all test cases with correct output format.\n- Design a user-friendly interface for input and output.\n- Provide documentation for the sorting logic and usage.\nWe will implement a custom sorting function that adheres to the asc-desc-ending order. The function will compare strings based on the specified conditions for odd and even indexed characters. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters by leveraging Python's efficient string and list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Store each book title along with its index.\n    3. Implement a custom sorting function:\n        - For each pair of book titles, compare them character by character.\n        - If the index is odd, sort the characters in ascending order.\n        - If the index is even, sort the characters in descending order.\n    4. Use Python's sorted function with the custom key to sort the list of book titles.\n    5. Extract and print the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At index 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           BA\n           AA\n    Output: 3 1 2\n    Explanation: At index 2 (even), 'B' comes before 'A', so AB comes after AA and BA.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of custom sorting based on odd and even indices will handle all cases correctly.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd and even positions differently. Odd-indexed characters are sorted in ascending order, while even-indexed characters are sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd and even positions differently, using Python's built-in sorting capabilities with a custom key function. This approach will efficiently handle the constraints of up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    'odd-indexed': Refers to positions 1, 3, 5, etc., where sorting is done in ascending order.\n    'even-indexed': Refers to positions 2, 4, 6, etc., where sorting is done in descending order.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each pair of titles, compare characters at odd positions in ascending order.\n        - Compare characters at even positions in descending order.\n    4. Use Python's sorted function with the custom key to sort the list of titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case]\n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At position 1 (odd), 'A' comes before 'B' and 'C', so 'ABC' comes first. At position 2 (even), 'A' comes after 'B', so 'BAC' comes before 'CAB'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing odd and even positions as specified.\n", "requirement analysis:\nThe task is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd and even positions differently. Odd-indexed characters are sorted in ascending order, while even-indexed characters are sorted in descending order. The input consists of n book titles, each of length m, and the output should be the indices of the titles sorted according to the custom order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Optimize the code for readability and maintainability.\n- Include test cases to validate the sorting algorithm.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator function that adheres to the asc-desc-ending order. We will use the functools library to create a comparator function that can be used with the sorted() function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of the characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Read the book titles into a list.\n    3. Define a custom comparator function that compares two strings based on the asc-desc-ending order:\n        - For each character position in the strings, check if it is odd or even.\n        - If odd, compare characters in ascending order.\n        - If even, compare characters in descending order.\n    4. Use Python's sorted() function with the custom comparator to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: The first position is odd, so ABC comes before BAC. The second position is even, so CAB comes before BAC.\n\n    Input: 2 2\n           AA\n           AB\n    Output: 1 2\n    Explanation: The first position is odd, so AA comes before AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a custom comparator function will naturally handle these cases.\n", "requirement analysis:\nThe requirement involves sorting book titles based on a unique order combining ascending and descending lexicographical sorting. The challenge is to implement an efficient sorting algorithm that adheres to these rules, ensuring the solution can handle large inputs up to 10^6 characters.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize the algorithm for large inputs\n- Ensure the solution is tested against multiple test cases\n- Provide clear documentation for the sorting logic\n- Enhance user interface for input and output display\nWe will implement a custom sorting function that adheres to the asc-desc-ending order using Python's built-in sorting capabilities. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will utilize the functools library to create a custom comparator for sorting.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function using a comparator:\n        - For each pair of titles, compare characters at odd positions in ascending order.\n        - Compare characters at even positions in descending order.\n    4. Use Python's sorting capabilities with the custom comparator to sort the list of titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AA\n           AB\n           BA\n    Output: 1 3 2\n    Explanation: At position 2 (even), 'A' comes after 'B', so AA comes before BA, and AB comes last.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom comparator logic inherently handles all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The solution must efficiently handle up to 10^6 characters in total, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Validate the output format against multiple test cases\n- Optimize the code for readability and maintainability\n- Include comments and documentation for clarity\nWe will implement a custom sorting function that sorts book titles based on the asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the n book titles.\n    3. Implement a custom sorting function:\n       - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n       - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key function.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At index 1 (odd), 'B' comes before 'A', and at index 2 (even), 'A' comes after 'B', so BAC comes before ABC.\n\n    Input: 3 2\n           AA\n           AB\n           BA\n    Output: 1 3 2\n    Explanation: At index 1 (odd), 'A' comes before 'B', so AA comes before BA, and at index 2 (even), 'B' comes after 'A', so BA comes before AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases.\n"], "scores": [], "pass_results": [false, false, true, false, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 711, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "expand_one2two", "parent_index": 146}
