{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This means everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This means everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, N individuals reside, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other. This situation allows everyone to be on their phones, creating an environment where no one is bothered by others. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, N individuals reside, numbered from 1 to N. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful, and there are exactly M pairs of people that are friends with each other. On the island of Baltia, a party is a gathering of exactly 5 people. The party will be considered successful if all the people attending are friends with each other. This ensures they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, the party can be successful if no two people at the party are friends with each other, meaning everyone can just be on their phones without anyone else bothering them. Kindly assist the residents of Baltia in planning a successful party or inform them if accomplishing this is not possible. Consider edge cases where N is relatively small or M is at its extremes. Be aware of potential cyclical friendships that may impact party arrangements.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport networkx as nx\n\ndef plan_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Plan a successful party on the island of Baltia.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 individuals for a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(graph))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of nodes with no edges between them\n    # We can find independent sets by checking complement graph cliques\n    complement_graph = nx.complement(graph)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Output interface\n    result = plan_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    A successful party is defined as a group of 5 people where either all are friends\n    with each other (a clique) or none are friends with each other (an independent set).\n\n    Args:\n        N: The number of individuals on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples where each tuple represents a friendship between two individuals.\n\n    Returns:\n        A list of 5 integers representing the individuals in a successful party, or -1 if no such party exists.\n    \"\"\"\n    # Create a graph from the friendships\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5 by examining the complement graph\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party can be organized, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        N: The number of people on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples representing friendship pairs.\n\n    Returns:\n        A list of 5 integers representing the people invited to the party if successful, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5 (all friends)\n    for combination in combinations(range(1, N + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5 (no friends)\n    for combination in combinations(range(1, N + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship constraints.\n\n    Args:\n        n (int): The number of individuals in Baltia.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] not in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Try all combinations of 5 people\n    from itertools import combinations\n    for group in combinations(range(1, n + 1), 5):\n        if is_clique(group) or is_independent_set(group):\n            return list(group)\n\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Finds a successful party of exactly 5 people where either all are friends or none are friends.\n    \n    Args:\n        N: The number of individuals on the island.\n        M: The number of friendships.\n        friendships: A list of tuples where each tuple represents a friendship between two individuals.\n    \n    Returns:\n        A list of 5 integers representing the individuals in a successful party, or -1 if no such party exists.\n    \"\"\"\n    if N < 5:\n        return -1\n\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for independent set of size 5\n    def find_independent_set():\n        for i in range(1, N + 1):\n            for j in range(i + 1, N + 1):\n                for k in range(j + 1, N + 1):\n                    for l in range(k + 1, N + 1):\n                        for m in range(l + 1, N + 1):\n                            if (j not in adjacency_list[i] and\n                                k not in adjacency_list[i] and\n                                l not in adjacency_list[i] and\n                                m not in adjacency_list[i] and\n                                k not in adjacency_list[j] and\n                                l not in adjacency_list[j] and\n                                m not in adjacency_list[j] and\n                                l not in adjacency_list[k] and\n                                m not in adjacency_list[k] and\n                                m not in adjacency_list[l]):\n                                return [i, j, k, l, m]\n        return -1\n\n    # Check for clique of size 5\n    def find_clique():\n        for i in range(1, N + 1):\n            for j in adjacency_list[i]:\n                if j > i:\n                    for k in adjacency_list[i].intersection(adjacency_list[j]):\n                        if k > j:\n                            for l in adjacency_list[i].intersection(adjacency_list[j], adjacency_list[k]):\n                                if l > k:\n                                    for m in adjacency_list[i].intersection(adjacency_list[j], adjacency_list[k], adjacency_list[l]):\n                                        if m > l:\n                                            return [i, j, k, l, m]\n        return -1\n\n    # Try to find either a clique or an independent set of size 5\n    result = find_clique()\n    if result != -1:\n        return result\n\n    result = find_independent_set()\n    if result != -1:\n        return result\n\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of 5 people based on friendship rules.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of exactly 5 people based on friendship rules.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (list): List of tuples representing friendship pairs.\n\n    Returns:\n        list: A list of 5 individuals if a successful party can be organized, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    # An independent set can be found by checking complement graph cliques\n    complement_graph = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple, Union\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party configuration of exactly 5 people.\n\n    Args:\n        N: The number of individuals on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples representing friendships between individuals.\n\n    Returns:\n        A list of 5 integers representing the individuals in a successful party,\n        or -1 if no such party can be organized.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Output interface\n    result = find_successful_party(N, M, friendships)\n    if isinstance(result, list):\n        print(' '.join(map(str, result)))\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship criteria.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for an algorithm with a complexity better than O(N^5). Edge cases include scenarios with no friendships or complete friendships.\nrequirement pool:\n- Develop an efficient algorithm to determine if a successful party can be organized.\n- Ensure the solution handles edge cases such as no friendships or complete friendships.\n- Optimize the solution for large inputs to ensure scalability.\n- Provide clear and concise output as per the specified format.\n- Consider user-friendly documentation or comments in the code for maintainability.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 where all members are friends or independent sets of size 5 where no members are friends. We will utilize the NetworkX library to handle graph operations efficiently, as it provides functions for clique detection and graph traversal.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people on the island of Baltia.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using a graph where nodes are individuals and edges are friendships.\n    2. Check for cliques of size 5 in the graph where all members are friends.\n    3. Check for independent sets of size 5 where no members are friends.\n    4. If either condition is met, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, it's impossible to have a group of 5 where no two are friends.\n    \n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 individuals from a larger group such that they either all know each other or none know each other. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for graph algorithms that can quickly identify such structures.\nrequirement pool:\n- Implement an efficient algorithm to find cliques or independent sets of size 5.\n- Ensure the solution handles edge cases, such as minimal friendships or maximal friendships.\n- Optimize for performance to handle the upper limits of input size.\n- Provide clear and correct output format as specified.\n- Consider user-friendly error messages or outputs for impossible cases.\nWe will use the NetworkX library to model the friendships as a graph. The problem requires finding either a clique of size 5 or an independent set of size 5. NetworkX provides efficient algorithms for finding cliques, which we can leverage to check for cliques of size 5. For independent sets, we can use a complement graph and check for cliques of size 5 in it. This approach is efficient and leverages existing, well-optimized algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Model the friendships using a graph where nodes represent individuals and edges represent friendships.\n    2. Check for a clique of size 5 in the graph, which represents a group where all attendees are friends.\n    3. If no clique is found, check the complement graph for a clique of size 5, representing a group where no attendees are friends.\n    4. If either condition is met, print the individuals in the successful party; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals will be a successful party where no two people are friends.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every individual is friends with every other individual, making it impossible to have a group where no two people are friends.\n\n    Input: 7 3\n    Output: -1\n    Explanation: With only three friendships among seven individuals, it might be impossible to form a clique of size 5 or an independent set of size 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of checking both cliques and independent sets inherently handles these scenarios.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 individuals from a larger group such that they either all know each other or none know each other. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for graph algorithms that can operate in polynomial time.\nrequirement pool:\n- Implement an efficient algorithm to find cliques or independent sets of size 5.\n- Ensure the solution handles edge cases, such as minimal or maximal friendships.\n- Optimize for performance to handle the upper limits of input size.\n- Provide clear and user-friendly output.\n- Consider multiple solutions if they exist and return any valid one.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for cliques of size 5 or independent sets of size 5. We can use the NetworkX library, which provides efficient graph algorithms to find cliques and independent sets. This library is well-suited for handling large graphs and will help us efficiently determine if a successful party can be organized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or no two attendees are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the 5 people should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using a suitable data structure (e.g., adjacency list).\n2. Check for cliques of size 5 in the graph, where every pair of nodes in the clique is connected by an edge.\n3. If a clique of size 5 is found, print the nodes in the clique.\n4. If no clique is found, check for independent sets of size 5, where no pair of nodes in the set is connected by an edge.\n5. If an independent set of size 5 is found, print the nodes in the set.\n6. If neither a clique nor an independent set of size 5 is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships (M=0), any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships (M=15 for N=6), every group of 5 people forms a clique, but since we need exactly 5 people, and all are interconnected, it is not possible to have a successful party as per the second condition.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships (M=0), any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle large inputs and edge cases, such as no friendships or complete graphs.\nrequirement pool:\n- Develop an algorithm to find a group of 5 people who are all friends or none are friends.\n- Ensure the solution is efficient for the maximum constraints of N and M.\n- Handle edge cases such as no friendships or complete graphs.\n- Provide clear and concise output as specified in the requirements.\n- Optimize the solution for readability and maintainability.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (all friends) or an independent set of size 5 (no friends) in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these subgraphs using combinations and adjacency checks.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5 (all friends) by iterating through combinations of 5 people and verifying if all pairs are friends.\n    3. Check for an independent set of size 5 (no friends) by iterating through combinations of 5 people and verifying if no pairs are friends.\n    4. If either condition is met, print the combination; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every person is friends with every other person, making it impossible to have an independent set.\n\n    Input: 7 3\n    Output: -1\n    Explanation: With only three friendships, it's unlikely to form a clique of size 5 or an independent set due to insufficient connections.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle edge cases like minimal friendships or maximal friendships effectively.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles edge cases with minimal and maximal friendships.\n- Optimize the solution for large input sizes.\n- Provide clear and concise output as per the format.\n- Consider multiple successful party configurations if possible.\nWe will use a graph-based approach to solve this problem. The individuals can be represented as nodes and friendships as edges in a graph. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). We will use a combination of depth-first search (DFS) and combinatorial checks to efficiently find such sets. Given the constraints, we will optimize the search by limiting unnecessary checks and using adjacency lists for efficient graph traversal.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    Implementation: Ensure the selected group of people contains exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent individuals and friendships as nodes and edges in a graph.\n    2. Use adjacency lists to store friendships for efficient traversal.\n    3. Implement DFS to explore potential cliques (fully connected subgraphs) of size 5.\n    4. Check for independent sets of size 5 (no connections between nodes).\n    5. If a successful party configuration is found, print the individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist, and a clique of size 5 may not be possible due to constraints.\n    \n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can form a successful party based on friendship conditions. The solution must efficiently handle up to 200,000 people and friendships, considering both fully connected and fully disconnected groups. Edge cases include minimal friendships and large, complex networks.\nrequirement pool:\n- Efficiently check for fully connected groups of 5 friends.\n- Efficiently check for fully disconnected groups of 5 people.\n- Handle edge cases with minimal friendships.\n- Optimize for large input sizes.\n- Provide user-friendly output format.\nWe will use graph theory to solve this problem. The problem can be reduced to finding cliques of size 5 (fully connected subgraphs) or independent sets of size 5 (fully disconnected subgraphs) in a graph. We will represent the friendships as an undirected graph using adjacency lists. We will then use a combination of depth-first search (DFS) and combinatorial techniques to efficiently find these subgraphs. Given the constraints, we need to ensure our solution is optimized for both time and space complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using adjacency lists.\n    2. Use depth-first search (DFS) to explore the graph and find cliques of size 5 (fully connected subgraphs).\n    3. Use combinatorial techniques to find independent sets of size 5 (fully disconnected subgraphs).\n    4. If a clique or independent set of size 5 is found, print the individuals involved.\n    5. If no such subgraph is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms a successful party as no two are friends.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, all individuals are connected, making it impossible to have a group where no two are friends.\n\n    Input: 7 3\n    Output: -1\n    Explanation: With only three friendships, it's unlikely to form a fully connected group of 5 or a fully disconnected group of 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for scenarios with zero friendships to directly form a successful party.\n        - Implement checks for scenarios with maximum friendships to directly return -1 if no independent set can be formed.\n        - Use efficient graph traversal and combinatorial checks to handle varying friendship distributions.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can form a successful party based on friendship conditions. The solution must efficiently handle up to 200,000 people and friendships, considering both fully connected and fully disconnected groups of 5.\nrequirement pool:\n- Develop an algorithm to find a fully connected group of 5 friends.\n- Develop an algorithm to find a group of 5 people with no friendships among them.\n- Optimize the solution for large inputs.\n- Ensure the solution handles edge cases effectively.\n- Provide multiple successful party configurations if possible.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 (fully connected subgraphs) or independent sets of size 5 (no edges between nodes). We will utilize the NetworkX library, which provides efficient graph algorithms to find cliques and independent sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    Implementation: Ensure that any subset of people considered for the party has exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as a graph where nodes are individuals and edges are friendships.\n    2. Check for cliques of size 5 (fully connected subgraphs) using graph algorithms.\n    3. Check for independent sets of size 5 (no edges between nodes) using graph algorithms.\n    4. If either a clique or an independent set of size 5 is found, print the members of the set.\n    5. If no such set is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, all individuals are connected, making it impossible to find an independent set of size 5.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, multiple independent sets of size 5 are possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship connections. The solution must efficiently handle large datasets and provide accurate results. Edge cases, such as minimal friendships or cyclical relationships, must be considered to ensure robustness.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Handle large datasets of friendships without performance issues.\n- Consider edge cases like minimal friendships or cyclical relationships.\n- Provide clear output indicating party success or failure.\n- Optimize for speed and reliability in processing.\nWe will use a graph-based approach to solve this problem. The individuals can be represented as nodes and friendships as edges in an undirected graph. We need to check for two conditions: a clique of size 5 (where every pair of nodes is connected) or an independent set of size 5 (where no pair of nodes is connected). We will use the NetworkX library to handle graph operations efficiently. This library provides functions to find cliques and independent sets, which will help us determine if a successful party can be organized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means a group of 5 people where everyone is friends with everyone else.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. In this context, it means a group of 5 people where no one is friends with anyone else in the group.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'no two people': This implies that in the independent set, none of the selected individuals should have a friendship link between them.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the individuals and friendships as a graph using an adjacency list or matrix.\n2. Check for a clique of size 5:\n   - Use a function to find all cliques in the graph and check if any of them have exactly 5 members.\n3. Check for an independent set of size 5:\n   - Use a function to find all independent sets in the graph and check if any of them have exactly 5 members.\n4. If either a clique or an independent set of size 5 is found, print the members.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible friendship present among 6 people, no independent set of size 5 can exist.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can form a successful party based on friendship conditions. The solution must efficiently handle up to 200,000 people and friendships, considering both fully connected and fully disconnected groups of 5. Edge cases include minimal friendships and maximal friendships, as well as potential cycles in the friendship graph.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Handle large input sizes up to 200,000 people and friendships.\n- Consider edge cases with minimal and maximal friendships.\n- Provide clear output format as specified.\n- Optimize for both time and space complexity.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and use algorithms to detect cliques (fully connected subgraphs) and independent sets (fully disconnected subgraphs) of size 5. NetworkX, a Python library for the creation, manipulation, and study of complex networks, will be used to efficiently handle graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other (a clique) or no attendees are friends with each other (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'no two people': In the context of an independent set, it means that none of the 5 people are friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using NetworkX.\n2. Check for cliques of size 5 in the graph:\n   - Use a clique-finding algorithm to identify fully connected subgraphs of size 5.\n3. Check for independent sets of size 5:\n   - Use a method to find sets of 5 nodes where no edges exist between any pair of nodes.\n4. If either a clique or an independent set of size 5 is found, print the nodes involved.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, every group of 5 people forms a clique, but since N > 5, we cannot select exactly 5 people without leaving someone out.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships and more than 5 people, any subset of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship connections. The solution must efficiently handle large numbers of individuals and friendships, ensuring that the output is clear and adheres to the specified format. Edge cases, such as minimal friendships or cyclical friendship patterns, must be considered to ensure robustness.\nrequirement pool:\n- Develop the main algorithm to determine successful party arrangements.\n- Ensure the solution handles large datasets efficiently.\n- Implement edge case handling for minimal and cyclical friendships.\n- Provide clear and concise output format.\n- Optimize for multiple successful party arrangements.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We will utilize the NetworkX library, which is efficient for graph operations and can handle large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': In one scenario, none of the attendees should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using NetworkX.\n    2. Check for cliques of size 5 in the graph, where all members are friends.\n    3. Check for independent sets of size 5, where no members are friends.\n    4. If either condition is met, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 individuals is a friendship, no independent set of size 5 can exist.\n    \n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, false, true, false, false, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 938, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "parent_index": 576}
