{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, connected by n - 1 tunnels allowing travel between any pair of rooms. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and traveling through a tunnel between room x and room y requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| is the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, prompting Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, connected by n - 1 tunnels allowing travel between any pair of rooms. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and traveling through a tunnel between room x and room y requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| is the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, prompting Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. These rooms are connected by n - 1 tunnels. These tunnels allow travel between any pair of rooms. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and traveling through a tunnel between room x and room y requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| is the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, prompting Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, connected by n - 1 tunnels allowing travel between any pair of rooms, each with a_i illusion rate, and traveling through a tunnel between room x and room y requires max(|a_x + a_y|, |a_x - a_y|) energy, where |z| is the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, prompting Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient range updates and queries.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        \"\"\"Initialize the segment tree with the given data.\"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree from the initial data.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, index: int, value: int):\n        \"\"\"Update the value at the given index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef dfs(u: int, parent: int, graph: List[List[int]], depth: List[int], parent_list: List[int]):\n    \"\"\"Perform DFS to calculate parent and depth information.\"\"\"\n    for v in graph[u]:\n        if v == parent:\n            continue\n        depth[v] = depth[u] + 1\n        parent_list[v] = u\n        dfs(v, u, graph, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Find the lowest common ancestor of u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    # Bring u and v to the same depth\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, lca_node: int, illusion_rates: List[int], parent_list: List[int]) -> int:\n    \"\"\"Calculate the energy required to travel from u to v using the LCA.\"\"\"\n    total_energy = 0\n    # Calculate energy from u to LCA\n    current = u\n    while current != lca_node:\n        parent = parent_list[current]\n        total_energy += max(abs(illusion_rates[current] + illusion_rates[parent]), abs(illusion_rates[current] - illusion_rates[parent]))\n        current = parent\n    # Calculate energy from v to LCA\n    current = v\n    while current != lca_node:\n        parent = parent_list[current]\n        total_energy += max(abs(illusion_rates[current] + illusion_rates[parent]), abs(illusion_rates[current] - illusion_rates[parent]))\n        current = parent\n    return total_energy\n\ndef minimum_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    graph = [[] for _ in range(n)]\n    for s, t in tunnels:\n        graph[s - 1].append(t - 1)\n        graph[t - 1].append(s - 1)\n\n    depth = [0] * n\n    parent_list = [-1] * n\n    dfs(0, -1, graph, depth, parent_list)\n\n    lca_node = lca(u - 1, v - 1, depth, parent_list)\n    return calculate_energy(u - 1, v - 1, lca_node, illusion_rates, parent_list)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    segment_tree = SegmentTree(illusion_rates)\n\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = minimum_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: list) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (list): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: list, tree: dict) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (list): The list of current illusion rates for all rooms.\n        tree (dict): The adjacency list representing the tree structure of rooms.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Perform DFS to find the path from u to v\n    path = []\n    visited = set()\n\n    def dfs(current, target):\n        if current == target:\n            path.append(current)\n            return True\n        visited.add(current)\n        for neighbor in tree[current]:\n            if neighbor not in visited:\n                if dfs(neighbor, target):\n                    path.append(current)\n                    return True\n        return False\n\n    dfs(u, v)\n    path.reverse()\n\n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        a_x, a_y = illusion_rates[x - 1], illusion_rates[y - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = {}\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        if s not in tree:\n            tree[s] = []\n        if t not in tree:\n            tree[t] = []\n        tree[s].append(t)\n        tree[t].append(s)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n\n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n\n    for result in results:\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom collections import defaultdict, deque\nfrom typing import List, Dict\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy_path(start_room: int, end_room: int, illusion_rates: List[int], tree: Dict[int, List[int]]) -> int:\n    \"\"\"Calculate the minimum energy path between two rooms using BFS.\"\"\"\n    if start_room == end_room:\n        return 0\n\n    # BFS to find the path from start_room to end_room\n    queue = deque([(start_room, 0)])  # (current_room, accumulated_energy)\n    visited = set()\n    visited.add(start_room)\n\n    while queue:\n        current_room, current_energy = queue.popleft()\n\n        for neighbor in tree[current_room]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                # Calculate energy for the path from current_room to neighbor\n                energy = max(abs(illusion_rates[current_room - 1] + illusion_rates[neighbor - 1]),\n                             abs(illusion_rates[current_room - 1] - illusion_rates[neighbor - 1]))\n                total_energy = current_energy + energy\n\n                if neighbor == end_room:\n                    return total_energy\n\n                queue.append((neighbor, total_energy))\n\n    return -1  # Should not reach here if the input is valid\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    queries = [input().strip() for _ in range(q)]\n\n    # Output interface\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            u, c = int(parts[1]), int(parts[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif parts[0] == '2':\n            u, v = int(parts[1]), int(parts[2])\n            result = calculate_min_energy_path(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, index: int, value: int):\n        # Update the leaf node\n        pos = index + self.n\n        self.tree[pos] = value\n        # Update the tree\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n    def query(self, left: int, right: int) -> int:\n        # Query the sum in the range [left, right)\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    # Update the illusion rate in the segment tree\n    segment_tree.update(room - 1, new_rate)\n    illusion_rates[room - 1] = new_rate\n\ndef dfs_path_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], visited: List[bool]) -> int:\n    # Perform DFS to find the path and calculate energy\n    stack = [(u, 0)]\n    parent = {u: None}\n    path_energy = 0\n\n    while stack:\n        current, energy = stack.pop()\n        if current == v:\n            path_energy = energy\n            break\n        visited[current - 1] = True\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor - 1]:\n                parent[neighbor] = current\n                stack.append((neighbor, energy + max(abs(illusion_rates[current - 1] + illusion_rates[neighbor - 1]),\n                                                     abs(illusion_rates[current - 1] - illusion_rates[neighbor - 1]))))\n\n    return path_energy\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    # Create adjacency list for the tree\n    global adjacency_list\n    adjacency_list = {i: [] for i in range(1, len(illusion_rates) + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    visited = [False] * len(illusion_rates)\n    return dfs_path_energy(u, v, illusion_rates, tunnels, visited)\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n    segment_tree = SegmentTree(illusion_rates)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates, segment_tree)\n        elif query[0] == 2:\n            result = calculate_minimum_energy(query[1], query[2], illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int, edges: List[Tuple[int, int]], illusion_rates: List[int]):\n        self.n = n\n        self.edges = edges\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.lca_preprocessed = False\n        self.lca_ancestor = [[-1] * (n + 1) for _ in range(20)]\n        self.build_tree()\n\n    def build_tree(self):\n        for u, v in self.edges:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.dfs(1, -1, 0)\n        self.preprocess_lca()\n\n    def dfs(self, node: int, par: int, dep: int):\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def preprocess_lca(self):\n        for i in range(1, self.n + 1):\n            self.lca_ancestor[0][i] = self.parent[i]\n        for j in range(1, 20):\n            for i in range(1, self.n + 1):\n                if self.lca_ancestor[j - 1][i] != -1:\n                    self.lca_ancestor[j][i] = self.lca_ancestor[j - 1][self.lca_ancestor[j - 1][i]]\n        self.lca_preprocessed = True\n\n    def find_lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.lca_ancestor[i][u]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.lca_ancestor[i][u] != self.lca_ancestor[i][v]:\n                u = self.lca_ancestor[i][u]\n                v = self.lca_ancestor[i][v]\n        return self.parent[u]\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_energy(self, u: int, v: int) -> int:\n        lca = self.find_lca(u, v)\n        path = self.get_path(u, lca) + self.get_path(v, lca)[::-1][1:]\n        total_energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.illusion_rates[path[i] - 1]\n            a_y = self.illusion_rates[path[i + 1] - 1]\n            total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return total_energy\n\n    def get_path(self, start: int, end: int) -> List[int]:\n        path = []\n        while start != end:\n            path.append(start)\n            start = self.parent[start]\n        path.append(end)\n        return path\n\ndef find_minimum_energy_path(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int], queries: List[Tuple[int, int, int]]) -> List[int]:\n    tree = Tree(n, edges, illusion_rates)\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            tree.update_illusion_rate(room, new_rate)\n        elif query[0] == 2:\n            _, u, v = query\n            results.append(tree.calculate_energy(u, v))\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = find_minimum_energy_path(n, edges, illusion_rates, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.lca_preprocessed = False\n        self.lca_ancestor = [[-1] * (n + 1) for _ in range(20)]  # Assuming log2(n) < 20\n\n    def dfs(self, node: int, par: int):\n        \"\"\"Perform DFS to set up parent and depth arrays.\"\"\"\n        self.parent[node] = par\n        for neighbor in self.tree[node]:\n            if neighbor != par:\n                self.depth[neighbor] = self.depth[node] + 1\n                self.dfs(neighbor, node)\n\n    def preprocess_lca(self):\n        \"\"\"Preprocess the LCA using binary lifting technique.\"\"\"\n        self.dfs(1, -1)  # Assuming 1 is the root\n        for i in range(1, self.n + 1):\n            self.lca_ancestor[0][i] = self.parent[i]\n        \n        for j in range(1, 20):\n            for i in range(1, self.n + 1):\n                if self.lca_ancestor[j - 1][i] != -1:\n                    self.lca_ancestor[j][i] = self.lca_ancestor[j - 1][self.lca_ancestor[j - 1][i]]\n        \n        self.lca_preprocessed = True\n\n    def find_lca(self, u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor of nodes u and v.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        \n        # Bring u and v to the same depth\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.lca_ancestor[i][u]\n        \n        if u == v:\n            return u\n        \n        for i in range(19, -1, -1):\n            if self.lca_ancestor[i][u] != self.lca_ancestor[i][v]:\n                u = self.lca_ancestor[i][u]\n                v = self.lca_ancestor[i][v]\n        \n        return self.parent[u]\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Update the illusion rate of a specified room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def min_energy_path(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy required to travel between two rooms.\"\"\"\n        if not self.lca_preprocessed:\n            self.preprocess_lca()\n        \n        lca = self.find_lca(u, v)\n        path = self.get_path(u, lca) + self.get_path(v, lca)[::-1][1:]\n        \n        min_energy = 0\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            energy = max(abs(self.illusion_rates[x - 1] + self.illusion_rates[y - 1]),\n                         abs(self.illusion_rates[x - 1] - self.illusion_rates[y - 1]))\n            min_energy += energy\n        \n        return min_energy\n\n    def get_path(self, start: int, end: int) -> List[int]:\n        \"\"\"Get the path from start to end node.\"\"\"\n        path = []\n        while start != end:\n            path.append(start)\n            start = self.parent[start]\n        path.append(end)\n        return path\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    maze = Maze(n, illusion_rates, tree)\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            maze.update_illusion_rate(u, c)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = maze.min_energy_path(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], current: int, parent: int, depth: List[int], parent_list: List[int]) -> None:\n    \"\"\"Perform Depth First Search to calculate depth and parent of each node.\"\"\"\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            depth[neighbor] = depth[current] + 1\n            parent_list[neighbor] = current\n            dfs(tree, neighbor, current, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], parent_list: List[int]) -> int:\n    \"\"\"Calculate the energy required to travel between two rooms.\"\"\"\n    energy = 0\n    while u != v:\n        parent_u = parent_list[u]\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent_u - 1]), abs(illusion_rates[u - 1] - illusion_rates[parent_u - 1]))\n        u = parent_u\n    return energy\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(tree) - 1\n    depth = [0] * (n + 1)\n    parent_list = [0] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_list)\n    ancestor = lca(u, v, depth, parent_list)\n    energy_u_to_ancestor = calculate_energy(u, ancestor, illusion_rates, tree, parent_list)\n    energy_v_to_ancestor = calculate_energy(v, ancestor, illusion_rates, tree, parent_list)\n    return energy_u_to_ancestor + energy_v_to_ancestor\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = calculate_minimum_energy(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree for handling updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Update the value at index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Implement DFS to find the path from u to v\n    def dfs(current: int, target: int, visited: set, path: List[int]) -> List[int]:\n        if current == target:\n            return path\n        visited.add(current)\n        for neighbor in adjacency_list[current]:\n            if neighbor not in visited:\n                result = dfs(neighbor, target, visited, path + [neighbor])\n                if result:\n                    return result\n        return []\n\n    # Build adjacency list from tunnels\n    adjacency_list = {i: [] for i in range(1, len(illusion_rates) + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Find path using DFS\n    path = dfs(u, v, set(), [u])\n    \n    # Calculate energy cost along the path\n    energy_cost = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy_cost += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    return energy_cost\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    # Initialize Segment Tree\n    segment_tree = SegmentTree(illusion_rates)\n    \n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int, illusion_rates: List[int], edges: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = [[] for _ in range(n + 1)]\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.subtree_size = [0] * (n + 1)\n        self.chain_head = [-1] * (n + 1)\n        self.chain_index = [-1] * (n + 1)\n        self.pos_in_base = [-1] * (n + 1)\n        self.base_array = []\n        self.segment_tree = []\n        self.chain_count = 0\n        self.ptr = 0\n\n        for u, v in edges:\n            self.tree[u].append(v)\n            self.tree[v].append(u)\n\n        self._dfs(1, -1, 0)\n        self._hld(1, -1)\n        self._build_segment_tree()\n\n    def _dfs(self, node: int, parent: int, depth: int):\n        self.parent[node] = parent\n        self.depth[node] = depth\n        self.subtree_size[node] = 1\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self._dfs(neighbor, node, depth + 1)\n                self.subtree_size[node] += self.subtree_size[neighbor]\n\n    def _hld(self, node: int, parent: int):\n        if self.chain_head[self.chain_count] == -1:\n            self.chain_head[self.chain_count] = node\n\n        self.chain_index[node] = self.chain_count\n        self.pos_in_base[node] = self.ptr\n        self.base_array.append(self.illusion_rates[node])\n        self.ptr += 1\n\n        special_child = -1\n        max_size = -1\n        for neighbor in self.tree[node]:\n            if neighbor != parent and self.subtree_size[neighbor] > max_size:\n                max_size = self.subtree_size[neighbor]\n                special_child = neighbor\n\n        if special_child != -1:\n            self._hld(special_child, node)\n\n        for neighbor in self.tree[node]:\n            if neighbor != parent and neighbor != special_child:\n                self.chain_count += 1\n                self._hld(neighbor, node)\n\n    def _build_segment_tree(self):\n        self.segment_tree = [0] * (4 * self.n)\n        self._build(0, self.ptr - 1, 0)\n\n    def _build(self, start: int, end: int, node: int):\n        if start == end:\n            self.segment_tree[node] = self.base_array[start]\n        else:\n            mid = (start + end) // 2\n            self._build(start, mid, 2 * node + 1)\n            self._build(mid + 1, end, 2 * node + 2)\n            self.segment_tree[node] = max(self.segment_tree[2 * node + 1], self.segment_tree[2 * node + 2])\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room] = new_rate\n        self._update(0, self.ptr - 1, self.pos_in_base[room], new_rate, 0)\n\n    def _update(self, start: int, end: int, idx: int, value: int, node: int):\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self._update(start, mid, idx, value, 2 * node + 1)\n            else:\n                self._update(mid + 1, end, idx, value, 2 * node + 2)\n            self.segment_tree[node] = max(self.segment_tree[2 * node + 1], self.segment_tree[2 * node + 2])\n\n    def min_energy_path(self, u: int, v: int) -> int:\n        return self._query(u, v)\n\n    def _query(self, u: int, v: int) -> int:\n        result = 0\n        while self.chain_index[u] != self.chain_index[v]:\n            if self.depth[self.chain_head[self.chain_index[u]]] < self.depth[self.chain_head[self.chain_index[v]]]:\n                u, v = v, u\n            chain_head_u = self.chain_head[self.chain_index[u]]\n            result += self._query_segment_tree(self.pos_in_base[chain_head_u], self.pos_in_base[u], 0, self.ptr - 1, 0)\n            u = self.parent[chain_head_u]\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        result += self._query_segment_tree(self.pos_in_base[u], self.pos_in_base[v], 0, self.ptr - 1, 0)\n        return result\n\n    def _query_segment_tree(self, start: int, end: int, l: int, r: int, node: int) -> int:\n        if start > r or end < l:\n            return 0\n        if start <= l and r <= end:\n            return self.segment_tree[node]\n        mid = (l + r) // 2\n        left_query = self._query_segment_tree(start, end, l, mid, 2 * node + 1)\n        right_query = self._query_segment_tree(start, end, mid + 1, r, 2 * node + 2)\n        return max(left_query, right_query)\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    tree.update_illusion_rate(room, new_rate)\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    return tree.min_energy_path(u, v)\n\n# Input and Output Interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\ntree = Tree(n, illusion_rates, edges)\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        # Update query\n        update_illusion_rate(query[1], query[2], illusion_rates)\n    elif query[0] == 2:\n        # Path query\n        result = min_energy_path(query[1], query[2], illusion_rates, tree)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], current: int, parent: int, path: List[int]) -> None:\n    \"\"\"Perform Depth First Search to find the path from the root to all nodes.\"\"\"\n    path.append(current)\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            dfs(tree, neighbor, current, path)\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    \"\"\"Calculate the energy required to travel between two rooms.\"\"\"\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    path_u = []\n    path_v = []\n    dfs(tree, u, -1, path_u)\n    dfs(tree, v, -1, path_v)\n    \n    # Find the common ancestor\n    i = 0\n    while i < len(path_u) and i < len(path_v) and path_u[i] == path_v[i]:\n        i += 1\n    \n    # Calculate energy from u to common ancestor and from common ancestor to v\n    energy = 0\n    for j in range(i, len(path_u) - 1):\n        energy += calculate_energy(illusion_rates[path_u[j] - 1], illusion_rates[path_u[j + 1] - 1])\n    for j in range(i, len(path_v) - 1):\n        energy += calculate_energy(illusion_rates[path_v[j] - 1], illusion_rates[path_v[j + 1] - 1])\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = min_energy_path(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling a tree structure representing a maze with dynamic updates to node values and pathfinding queries. The solution must handle large input sizes and provide quick responses to both update and pathfinding queries.\nrequirement pool:\n- Implement efficient data structures for dynamic updates and queries.\n- Optimize pathfinding algorithm for minimum energy calculation.\n- Ensure the system can handle edge cases and invalid inputs gracefully.\n- Develop a user-friendly interface for input and output operations.\n- Include detailed logging for debugging and performance monitoring.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficiently handling dynamic updates to the illusion rates. The Segment Tree will allow us to update and query the illusion rates in logarithmic time, which is crucial given the constraints. For pathfinding, we will use DFS to calculate the minimum energy required to move between rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost of traveling through tunnels.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each tunnel, the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of the connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': In the context of the queries, it refers to finding the path with the least total energy cost from room u to room v. This can be implemented using algorithms that find the shortest path in a tree, such as DFS or BFS.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Use DFS to precompute necessary information for efficient path queries (e.g., parent-child relationships, subtree sizes).\n3. Implement a Segment Tree to handle updates to illusion rates and efficiently compute energy costs.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate using the Segment Tree.\n   - If it's a type 2 query, use precomputed information and the Segment Tree to calculate the minimum energy path from room u to room v.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: 2 1\n              5 -5\n              1 2\n              2 1 2\n       Expected Output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, all energy costs are zero.\n\n    3. Maximum possible illusion rate change:\n       Input: 3 2\n              0 0 0\n              1 2\n              2 3\n              1 1 1000000000\n              2 1 3\n       Expected Output: max(|1000000000 + 0|, |1000000000 - 0|) = 1000000000\n       Explanation: After changing the illusion rate of room 1 to the maximum possible value, the energy cost reflects this change.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently using a Segment Tree.\n    ```python\n    class SegmentTree:\n        def __init__(self, data):\n            # Initialize segment tree with data\n            pass\n\n        def update(self, index, value):\n            # Update value at index in segment tree\n            pass\n\n        def query(self, left, right):\n            # Query range [left, right] in segment tree\n            pass\n\n    # Use this SegmentTree class to handle updates and queries efficiently.\n    ```\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to changing illusion rates and calculating minimum energy paths in a tree structure. The solution must handle large input sizes and provide quick responses to ensure user satisfaction.\nrequirement pool:\n- Implement efficient data structures for query handling\n- Develop algorithms for minimum energy path calculation\n- Optimize for large input sizes\n- Ensure accurate energy calculations\n- Provide a user-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. The DFS will help in determining the path between two nodes in the tree, and the Segment Tree will allow us to update and query the illusion rates efficiently. This approach is suitable for handling large input sizes and ensures quick response to queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, meaning there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel through tunnels. It can be changed by queries.\n\n    'energy'\n    Explanation: Energy is calculated using the formula max(|a_x + a_y|, |a_x - a_y|) for traveling between rooms x and y.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the max function and abs function.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the path with the least sum of energy required to travel from room u to room v. This can be implemented using pathfinding algorithms like DFS or Dijkstra's algorithm.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists from the tunnel connections.\n    3. Implement DFS to find paths between rooms for type 2 queries.\n    4. Use a Segment Tree to efficiently update and query illusion rates for type 1 queries.\n    5. For each type 2 query, calculate the minimum energy required using DFS and the current illusion rates.\n    6. Output the result for each type 2 query.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, the energy required is zero regardless of the path.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate of room 1, traveling from room 1 to room 3 requires max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will handle these cases efficiently.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates are processed quickly and that pathfinding queries return the minimum energy path accurately. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of the queries requires a data structure that supports quick updates and queries.\nrequirement pool:\n- Efficiently process type 2 queries to find the minimum energy path.\n- Implement a data structure that supports quick updates to illusion rates.\n- Optimize the algorithm to handle the maximum constraints smoothly.\n- Ensure the solution is scalable and performs well under stress tests.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will allow us to update the illusion rates quickly and calculate the minimum energy path efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost of traveling through tunnels.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute sum and absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'minimum': In the context of the queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented using algorithms that find the shortest path or minimum cost path in a tree, such as DFS or BFS.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, use DFS or BFS to find the path from room u to room v and calculate the total energy using the given formula.\n6. Output the result for each type 2 query.\n\n# [edge case] \n    1. Minimum number of rooms (n=2) with maximum illusion rates (10^9).\n       Explanation: This tests the handling of large numbers and minimal tree size.\n       Expected output: The energy calculation should handle large values correctly.\n       \n    2. All rooms have an illusion rate of zero.\n       Explanation: This tests if the code correctly handles zero values in calculations.\n       Expected output: The energy for any path should be zero since max(|0 + 0|, |0 - 0|) = 0.\n\n    3. A query where u and v are the same room.\n       Explanation: This tests if the code correctly handles queries where no movement is needed.\n       Expected output: The energy should be zero since no travel is required.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where u and v are the same room.\n        if u == v:\n            return 0\n        (other code)\n", "requirement analysis:\nThe project requires efficient handling of tree structures and dynamic updates to node values. The main challenge is to ensure that energy calculations are performed quickly even with frequent updates to the illusion rates. The solution should be scalable to handle the maximum constraints of rooms and queries.\nrequirement pool:\n- Implement efficient pathfinding algorithm for tree structures.\n- Support dynamic updates to room illusion rates.\n- Optimize energy calculation for large datasets.\n- Ensure the system can handle up to 100,000 queries efficiently.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) for pathfinding in the tree structure and a Segment Tree for efficiently handling updates and queries on the illusion rates. The Segment Tree will allow us to update the illusion rate of any room in logarithmic time and also help in calculating the minimum energy required for traveling between two rooms efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, forming a connected acyclic graph.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel through tunnels.\n\n    'queries'\n    Explanation: There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy required to travel through a tunnel between two rooms. It is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves finding the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Implement a Segment Tree to handle updates and queries efficiently.\n    4. For type 1 queries, update the illusion rate of the specified room in the Segment Tree.\n    5. For type 2 queries, use DFS to find the path between the specified rooms and calculate the energy using the Segment Tree.\n    6. Return the minimum energy for each type 2 query.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, no energy is required for any path.\n\n    Case 3: Large illusion rates\n    Input:\n    ```\n    3 1\n    1000000000 -1000000000 1000000000\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    3000000000\n    ```\n    Explanation: The path from room 1 to room 3 requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) + max(|-1000000000 + 1000000000|, |-1000000000 - 1000000000|) = 2000000000 + 1000000000 = 3000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will naturally handle these scenarios.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates are processed quickly and that pathfinding queries return the minimum energy path accurately. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of the queries requires a data structure that supports quick updates and queries.\nrequirement pool:\n- Efficiently process type 2 queries to find minimum energy paths.\n- Implement a data structure that supports quick updates to illusion rates.\n- Optimize the algorithm to handle the maximum constraints smoothly.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle pathfinding queries in the tree structure. For dynamic updates to the illusion rates, we will use a Segment Tree or Fenwick Tree (Binary Indexed Tree) to allow quick updates and queries. This approach ensures that both types of queries are processed efficiently, even for the maximum constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It is used in the calculation of energy needed to move through tunnels.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, forming a connected acyclic graph.\n\n    'queries'\n    Explanation: There are two types of queries: one for updating the illusion rate of a room and another for calculating the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates the calculation of energy required to travel between two rooms. It involves finding the maximum of the absolute values of the sum and difference of the illusion rates of two rooms.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the least amount of energy required to travel from one room to another.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to preprocess the tree for LCA queries.\n    4. Use a Segment Tree or Fenwick Tree to manage dynamic updates to illusion rates.\n    5. For type 1 queries, update the illusion rate using the Segment Tree/Fenwick Tree.\n    6. For type 2 queries, calculate the path using LCA and compute the energy using the preprocessed data and current illusion rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 2 -1000000000\n    Output: 2000000000\n    Explanation: The path from room 1 to room 3 initially requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 energy.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases involving large values and zero values.\n        Ensure that calculations involving large numbers do not cause overflow by using appropriate data types.\n        Handle cases where illusion rates are zero separately to avoid unnecessary calculations.\n", "requirement analysis:\nThe requirements focus on efficiently processing a large number of queries on a tree structure representing a maze. The main challenge is to handle updates to the illusion rates and compute the minimum energy path efficiently. The solution should be optimized for both time and space complexity to handle the upper limits of input sizes.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Optimize the algorithm to compute the minimum energy path in a tree structure.\n- Design a user-friendly interface for input and output operations.\n- Ensure the solution is scalable to handle the maximum constraints.\n- Provide detailed documentation and examples for users.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. For dynamic updates of the illusion rates, we will use a Segment Tree or Fenwick Tree (Binary Indexed Tree) to allow for efficient updates and queries. This approach will ensure that both update and query operations are handled in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It is used in the calculation of energy as max(|a_x + a_y|, |a_x - a_y|).\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected graph with no cycles.\n\n    'queries'\n    Explanation: There are two types of queries: one for updating the illusion rate of a room and another for calculating the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the path with the least energy cost between two rooms. This can be implemented using algorithms that find the shortest path, such as DFS combined with LCA.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Implement DFS to preprocess the tree for LCA queries.\n    4. Use a Segment Tree or Fenwick Tree to handle dynamic updates of illusion rates efficiently.\n    5. For type 1 queries, update the illusion rate in the Segment Tree or Fenwick Tree.\n    6. For type 2 queries, use LCA to find the path between two rooms and calculate the minimum energy using the current illusion rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required to travel between them is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 3000000000\n    Explanation: The path from room 1 to room 3 involves traveling through room 2, with high illusion rates leading to large energy costs.\n\n    Input: 4 2\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           1 4 -10\n           2 1 4\n    Expected Output: 20\n    Explanation: After updating room 4's illusion rate to -10, calculate the energy from room 1 to room 4 considering updated rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree/Fenwick Tree will handle these cases efficiently.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of the queries requires a robust data structure to manage updates and calculations.\nrequirement pool:\n- Implement efficient data structures for maze representation and query processing\n- Develop algorithms for accurate energy calculation based on illusion rates\n- Ensure scalability to handle maximum input sizes\n- Provide clear documentation on energy calculation methods\n- Optimize user interface for quick query input and result display\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure of the maze. For dynamic updates of illusion rates, we will use a Segment Tree or Fenwick Tree (Binary Indexed Tree) to allow for quick updates and queries. This approach ensures that we can handle the maximum input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, forming a connected acyclic graph.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel through tunnels.\n\n    'energy'\n    Explanation: The energy required to travel between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the max function with abs for absolute values.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the path with the least sum of energy required to travel from room u to room v. This can be implemented using pathfinding algorithms like DFS combined with LCA to efficiently find the minimum path.\n\n# [code logic]\n    1. Parse the input to construct the tree structure using adjacency lists.\n    2. Implement DFS to calculate the path and energy between rooms.\n    3. Use LCA to efficiently find paths between any two rooms.\n    4. Implement a Segment Tree or Fenwick Tree for dynamic updates of illusion rates.\n    5. For type 1 queries, update the illusion rate of a specified room.\n    6. For type 2 queries, calculate and return the minimum energy required using DFS and LCA.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Output: 20\n    Explanation: The path from room 1 to room 3 is through room 2, requiring max(|10 + (-10)|, |10 - (-10)|) = 20 energy.\n\n    Input: 4 2\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           1 1 -10\n           2 1 4\n    Output: 30\n    Explanation: After updating room 1's illusion rate to -10, traveling from room 1 to room 4 requires max(|-10 + (-5)|, |-10 - (-5)|) = 15 energy for each tunnel.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle these cases correctly by calculating the energy based on updated illusion rates and tree structure.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree-structured maze with dynamic updates and queries. The main challenge is to ensure that the solution can handle the maximum constraints of n and q efficiently, likely requiring advanced data structures and algorithms such as segment trees or heavy-light decomposition.\nrequirement pool:\n- Implement efficient data structures to handle updates and queries.\n- Ensure the solution can handle the maximum constraints of n and q.\n- Optimize the algorithm for minimum energy calculation between rooms.\n- Provide robust error handling for invalid inputs.\n- Enhance user experience with clear output formatting.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficiently handling updates and queries. The Segment Tree will allow us to update the illusion rates and calculate the minimum energy required between rooms efficiently. This approach is suitable for handling large input sizes and dynamic updates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost of traveling through tunnels.\n\n    'energy calculation'\n    Explanation: The energy required to travel through a tunnel is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the connected rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that for each tunnel, the energy cost is the maximum of the absolute sum or absolute difference of the illusion rates of the connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible sum of energy required to travel from one room to another. In code, this can be implemented by keeping track of the minimum energy path using algorithms like DFS or Dijkstra's algorithm.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Implement a Segment Tree to handle updates to illusion rates and efficiently calculate energy costs.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, use DFS or another pathfinding algorithm to calculate the minimum energy required to travel from room u to room v.\n6. Output the result for each type 2 query.\n\n# [edge case]\n    1. Minimum number of rooms (n=2) with maximum illusion rates (10^9) = 0\n       Explanation: With only two rooms and maximum illusion rates, the energy calculation will be straightforward but large.\n       \n    2. All rooms have an illusion rate of zero = 0\n       Explanation: If all rooms have an illusion rate of zero, the energy required for any path will be zero.\n       \n    3. A single path from start to end with alternating positive and negative maximum illusion rates = 10^9\n       Explanation: This tests the handling of large values and alternating signs in energy calculations.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large values and alternating signs in energy calculations.\n    \n```python\ndef handle_edge_cases(n, q, illusion_rates, tunnels, queries):\n    # Initialize data structures\n    # Handle edge cases like all zero illusion rates or maximum values\n    # Implement logic for handling large values and alternating signs\n    pass\n```\n\nThis plan ensures that we efficiently handle updates and queries while considering edge cases that could affect performance or correctness.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates and queries on a tree structure representing the maze. The solution must be optimized for both time and space to manage up to 100,000 rooms and queries. The algorithm should leverage data structures that allow quick updates and path calculations, such as segment trees or heavy-light decomposition.\nrequirement pool:\n- Implement efficient data structures for quick updates and queries.\n- Ensure the solution can handle the maximum constraints without performance issues.\n- Develop a user-friendly interface for input and output handling.\n- Include comprehensive error handling for invalid inputs.\n- Optimize the algorithm for minimal memory usage.\nWe will use a combination of Depth First Search (DFS) and Heavy-Light Decomposition (HLD) to efficiently handle the tree structure and queries. This approach allows us to quickly update the illusion rates and calculate the minimum energy required for paths between rooms. We will use Segment Trees to manage the updates and queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy required to travel through tunnels.\n\n    'energy calculation'\n    Explanation: The energy required to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'n - 1 tunnels'\n    Explanation: This indicates that there are exactly n-1 connections in the tree, which is a characteristic of trees having n nodes.\n\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the calculation of energy required to travel between two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum sum of energy'\n    Explanation: This indicates that we need to find the path with the least total energy cost between two rooms. This can be implemented using algorithms that find the shortest path or minimum cost path in a tree, such as DFS combined with HLD.\n\n# [code logic]\n1. Parse the input to construct the tree and initialize the illusion rates.\n2. Implement Heavy-Light Decomposition (HLD) to handle path queries efficiently.\n3. Use Segment Trees to manage updates to illusion rates and calculate path energies.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, calculate the minimum energy required to travel from room u to room v using HLD and Segment Trees.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: 2 1\n              5 -5\n              1 2\n              2 1 2\n       Expected Output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, the energy for any path is zero.\n\n    3. Maximum possible illusion rate change:\n       Input: 3 2\n              0 0 0\n              1 2\n              2 3\n              1 1 1000000000\n              2 1 3\n       Expected Output: max(|1000000000 + 0|, |1000000000 - 0|) = 1000000000\n       Explanation: After changing the illusion rate of room 1 to the maximum value, the energy calculation reflects this change.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using HLD and Segment Trees should naturally handle these scenarios as they are part of the general solution approach.\n", "requirement analysis:\nThe project requires handling a tree structure efficiently to manage room connections and updates. The main challenge is to compute the minimum energy path quickly, even with frequent updates to the illusion rates. The solution must be optimized for both time and space to handle the upper limits of input constraints.\nrequirement pool:\n- Implement efficient data structures to manage room connections and updates.\n- Develop an algorithm to compute the minimum energy path quickly.\n- Ensure the system can handle the maximum input size without performance issues.\n- Provide clear error messages for invalid inputs.\n- Optimize the user interface for ease of use and quick navigation.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle updates and queries on the tree structure. DFS will help in traversing the tree and calculating paths, while the Segment Tree will allow us to update and query the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, forming a connected acyclic graph.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to travel between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to travel between two rooms is the greater of the absolute value of the sum or the absolute value of the difference of their illusion rates. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves finding the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to traverse the tree and calculate paths.\n    4. Use a Segment Tree to efficiently handle updates to illusion rates and queries for minimum energy paths.\n    5. For type 1 queries, update the illusion rate of a specified room.\n    6. For type 2 queries, calculate the minimum energy required to travel from one room to another using DFS and Segment Tree.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, the energy required for any path is zero.\n\n    Case 3: Large illusion rate values\n    Input:\n    ```\n    3 1\n    1000000000 -1000000000 1000000000\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    3000000000\n    ```\n    Explanation: The large values test the handling of maximum integer values in calculations.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree should be able to handle them efficiently.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 886, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "condense_two2one", "parent_index": 2}
