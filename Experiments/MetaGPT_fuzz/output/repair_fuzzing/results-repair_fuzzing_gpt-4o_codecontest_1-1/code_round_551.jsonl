{"name": "1618_A. Polycarp and Sums of Subsequences", "description": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "tags": ["math", "sortings"], "difficulty": 7, "id": 1618, "sample_io": [{"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}], "test_list": [{"input": "1\n69696868 69696868 69696868 139393736 139393736 139393736 209090604\n", "output": ["69696868 69696868 69696868 \n"]}, {"input": "2\n1 1 2 69696874 69696875 69696875 69696876\n1 1 1 2 2 2 3\n", "output": ["1 1 69696874\n1 1 1\n"]}, {"input": "1\n1 1 2 69696880 69696881 69696881 69696882\n", "output": ["1 1 69696880\n"]}, {"input": "2\n1 1 2 69696967 69696968 69696968 69696969\n1 1 1 2 2 2 3\n", "output": ["1 1 69696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696868 69696869 69696869 69696870\n1 2 3 4 5 6 7\n", "output": ["1 1 69696868\n1 2 4\n"]}, {"input": "2\n1 1 2 696967 696968 696968 696969\n1 1 1 2 2 2 3\n", "output": ["1 1 696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696873 69696874 69696874 69696875\n1 1 1 2 2 2 3\n", "output": ["1 1 69696873\n1 1 1\n"]}, {"input": "2\n1 1 2 69696889 69696890 69696890 69696891\n1 1 1 2 2 2 3\n", "output": ["1 1 69696889\n1 1 1\n"]}, {"input": "1\n1 2 3 69696875 69696876 69696877 69696878\n", "output": ["1 2 69696875\n"]}, {"input": "2\n1 1 2 69696870 69696871 69696871 69696872\n1 1 1 2 2 2 3\n", "output": ["1 1 69696870\n1 1 1\n"]}, {"input": "2\n1 1 2 69696881 69696882 69696882 69696883\n1 1 1 2 2 2 3\n", "output": ["1 1 69696881\n1 1 1\n"]}, {"input": "2\n1 1 2 598989 598990 598990 598991\n1 3 4 4 5 7 8\n", "output": ["1 1 598989\n1 3 4\n"]}, {"input": "2\n1 1 2 69696875 69696876 69696876 69696877\n1 1 1 2 2 2 3\n", "output": ["1 1 69696875\n1 1 1\n"]}, {"input": "1\n1 1 2 69696884 69696885 69696885 69696886\n", "output": ["1 1 69696884\n"]}, {"input": "1\n1 1 2 69696883 69696884 69696884 69696885\n", "output": ["1 1 69696883\n"]}, {"input": "2\n1 1 2 69696885 69696886 69696886 69696887\n1 1 1 2 2 2 3\n", "output": ["1 1 69696885\n1 1 1\n"]}, {"input": "2\n1 1 2 69696879 69696880 69696880 69696881\n1 1 1 2 2 2 3\n", "output": ["1 1 69696879\n1 1 1\n"]}, {"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}, {"input": "2\n1 1 2 69696886 69696887 69696887 69696888\n1 1 1 2 2 2 3\n", "output": ["1 1 69696886\n1 1 1\n"]}, {"input": "2\n1 1 2 69696869 69696870 69696870 69696871\n1 1 1 2 2 2 3\n", "output": ["1 1 69696869\n1 1 1\n"]}, {"input": "2\n1 1 2 69696887 69696888 69696888 69696889\n1 1 1 2 2 2 3\n", "output": ["1 1 69696887\n1 1 1\n"]}, {"input": "2\n1 1 2 69696877 69696878 69696878 69696879\n1 1 1 2 2 2 3\n", "output": ["1 1 69696877\n1 1 1\n"]}, {"input": "2\n1 1 2 69696871 69696872 69696872 69696873\n1 1 1 2 2 2 3\n", "output": ["1 1 69696871\n1 1 1\n"]}, {"input": "2\n1 1 2 69696882 69696883 69696883 69696884\n1 1 1 2 2 2 3\n", "output": ["1 1 69696882\n1 1 1\n"]}, {"input": "1\n1 2 3 69696887 69696888 69696889 69696890\n", "output": ["1 2 69696887\n"]}, {"input": "2\n1 1 2 69696872 69696873 69696873 69696874\n1 1 1 2 2 2 3\n", "output": ["1 1 69696872\n1 1 1\n"]}, {"input": "2\n1 1 2 69696878 69696879 69696879 69696880\n1 1 1 2 2 2 3\n", "output": ["1 1 69696878\n1 1 1\n"]}], "task_id": "codecontest/132", "prompt": "Polycarp possessed an array a consisting of three positive integers. He listed the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b containing 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Assume that each integer in the array a is distinct.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "repair_prompt": ["Polycarp possessed an array a consisting of three positive integers. He listed the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b containing 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Assume that each integer in the array a is distinct.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "Polycarp possessed an array a consisting of three positive integers. He listed the sums of all non-empty subsequences of this array. Then he arranged them in ascending order, and got an array b containing 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Assume that each integer in the array a is distinct.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "Polycarp possessed an array a consisting of three positive integers and listed the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b containing 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a, and he only has the array b left, so help him to restore the array a. Assume that each integer in the array a is distinct.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array(t: int, test_cases: List[List[int]]) -> List[List[int]]:\n    \"\"\"Restores the original array 'a' from the given sorted array 'b' for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing 7 integers.\n\n    Returns:\n        List[List[int]]: A list of restored arrays 'a', each containing 3 integers.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in 'b' is one of the elements in 'a'\n        a1 = b[0]\n        # The largest element in 'b' is the sum of all elements in 'a'\n        sum_a = b[-1]\n        # The sum of the other two elements in 'a'\n        sum_a2_a3 = sum_a - a1\n        # The second smallest element in 'b' is the sum of a1 and one of the other elements\n        a2 = b[1] - a1\n        # The third element can be deduced from the sum of the other two elements\n        a3 = sum_a2_a3 - a2\n        # Append the result for this test case\n        results.append([a1, a2, a3])\n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [list(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = restore_array(n, test_cases)\nfor result in results:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array_from_sums(b: List[int]) -> List[int]:\n    \"\"\"Restores the original array 'a' from the given sorted array 'b' of sums of all non-empty subsequences.\n\n    Args:\n        b (List[int]): A sorted list of sums of all non-empty subsequences of array 'a'.\n\n    Returns:\n        List[int]: The original array 'a' consisting of three distinct positive integers.\n    \"\"\"\n    # The smallest element in 'b' is one of the elements of 'a'.\n    a1 = b[0]\n    # The second smallest element in 'b' is another element of 'a'.\n    a2 = b[1]\n    # The largest element in 'b' is the sum of all elements in 'a'.\n    sum_a = b[-1]\n    # The third element of 'a' can be found by subtracting the smallest and second smallest elements from the largest element.\n    a3 = sum_a - a1 - a2\n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        b = list(map(int, input().split()))\n        result = restore_array_from_sums(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array_from_sums(b: List[int]) -> List[int]:\n    \"\"\"Restores the original array a from the given array b of sums of all non-empty subsequences.\n\n    Args:\n        b (List[int]): A list of 7 integers representing the sums of all non-empty subsequences\n                       of a three-element array a.\n\n    Returns:\n        List[int]: The original array a consisting of three positive integers.\n    \"\"\"\n    # The smallest element in b is the smallest element in a\n    a1 = b[0]\n    # The largest element in b is the sum of all three elements of a\n    sum_a = b[6]\n    # The second largest element in b is the sum of the two largest elements of a\n    sum_a2_a3 = b[5]\n    \n    # Calculate a3 as the largest element in a\n    a3 = sum_a - a1\n    # Calculate a2 as the second largest element in a\n    a2 = sum_a2_a3 - a3\n    \n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        b = list(map(int, input().split()))\n        result = restore_array_from_sums(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\n\ndef restore_array(t: int, test_cases: typing.List[typing.List[int]]) -> typing.List[typing.Tuple[int, int, int]]:\n    \"\"\"Restores the original array a from the sorted array b of sums of non-empty subsequences.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of test cases, each containing 7 integers representing the sorted array b.\n\n    Returns:\n        A list of tuples, each containing 3 integers representing the restored array a.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in b is the smallest element in a\n        a1 = b[0]\n        # The second largest element in b is the sum of the two largest elements in a\n        sum_a2_a3 = b[-2]\n        # The largest element in b is the sum of all elements in a\n        sum_a1_a2_a3 = b[-1]\n        \n        # Calculate a2 and a3 using the identified sums\n        a2 = sum_a2_a3 - a1\n        a3 = sum_a1_a2_a3 - a1 - a2\n        \n        # Append the result as a tuple\n        results.append((a1, a2, a3))\n    \n    return results\n\n# Interface using input() and print()\ndef main():\n    t = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(t)]\n    results = restore_array(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array_from_sums(b: List[int]) -> List[int]:\n    \"\"\"Restores the original array of three distinct integers from the sorted array of subsequence sums.\n\n    Args:\n        b (List[int]): A sorted list of 7 integers representing the sums of all non-empty subsequences of the original array.\n\n    Returns:\n        List[int]: The original array of three distinct integers.\n    \"\"\"\n    # The smallest element in b is one of the original integers\n    a1 = b[0]\n    # The largest element in b is the sum of all three integers\n    sum_all = b[-1]\n    # The second smallest element in b is the sum of the smallest two integers\n    sum_two_smallest = b[1]\n    # The second largest element in b is the sum of the largest two integers\n    sum_two_largest = b[-2]\n\n    # Deduce the other two integers\n    a2 = sum_two_smallest - a1\n    a3 = sum_all - sum_two_largest\n\n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    num_test_cases = int(input())\n    for _ in range(num_test_cases):\n        b = list(map(int, input().split()))\n        result = restore_array_from_sums(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef restore_original_array(test_cases: List[List[int]]) -> List[Tuple[int, int, int]]:\n    \"\"\"Restores the original array of three distinct positive integers from the sorted array of sums of its subsequences.\n\n    Args:\n        test_cases: A list of test cases, each containing a sorted list of 7 integers.\n\n    Returns:\n        A list of tuples, each containing the three integers of the original array.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in b is a_1\n        a_1 = b[0]\n        # The second smallest element in b is a_2\n        a_2 = b[1]\n        # The largest element in b is the sum of all elements in a\n        a_3 = b[6] - a_1 - a_2\n        results.append((a_1, a_2, a_3))\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    n = int(input())\n    # Read each test case\n    test_cases = [list(map(int, input().split())) for _ in range(n)]\n    # Restore original arrays\n    results = restore_original_array(test_cases)\n    # Output results\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_original_array(test_cases: List[List[int]]) -> List[List[int]]:\n    \"\"\"Restores the original array of three distinct integers from the given subsequence sums.\n\n    Args:\n        test_cases: A list of test cases, each containing a list of 7 integers representing\n                    the sorted sums of all non-empty subsequences of an array of three integers.\n\n    Returns:\n        A list of lists, where each inner list contains the three integers of the original array.\n    \"\"\"\n    results = []\n    for b in test_cases:\n        # The smallest element in b is one of the original elements\n        a1 = b[0]\n        # The second smallest element in b is another original element\n        a2 = b[1]\n        # The largest element in b is the sum of all three original elements\n        sum_all = b[6]\n        # Deduce the third element\n        a3 = sum_all - a1 - a2\n        # Append the result for this test case\n        results.append([a1, a2, a3])\n    return results\n\n# Input interface\ndef main():\n    num_cases = int(input())\n    test_cases = [list(map(int, input().split())) for _ in range(num_cases)]\n    \n    # Output interface\n    results = restore_original_array(test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array(t: int, test_cases: List[List[int]]) -> List[List[int]]:\n    \"\"\"Restores the original array 'a' from the given sorted array 'b' for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing 7 integers.\n\n    Returns:\n        List[List[int]]: List of restored arrays 'a' for each test case.\n    \"\"\"\n    result = []\n    for b in test_cases:\n        # The smallest element in 'b' corresponds to the smallest element in 'a'\n        a1 = b[0]\n        # The largest element in 'b' is the sum of all elements in 'a'\n        sum_all = b[-1]\n        # The second largest element in 'b' is the sum of the two largest elements in 'a'\n        sum_two_largest = b[-2]\n        \n        # Deduce the three elements of 'a'\n        a2 = sum_two_largest - a1\n        a3 = sum_all - sum_two_largest\n        \n        # Append the result for the current test case\n        result.append([a1, a2, a3])\n    \n    return result\n\n# Input interface\nn = int(input())\ntest_cases = [list(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresult = restore_array(n, test_cases)\nfor res in result:\n    print(' '.join(map(str, res)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array_from_sums(b: List[int]) -> List[int]:\n    \"\"\"Restores the original array of three distinct positive integers from the given subsequence sums.\n\n    Args:\n        b (List[int]): A list of 7 integers representing the sorted sums of all non-empty subsequences of the original array.\n\n    Returns:\n        List[int]: The original array of three distinct positive integers.\n    \"\"\"\n    # The smallest element in b is the smallest element in the original array a\n    a1 = b[0]\n    # The second smallest element in b minus a1 gives the second element in the original array a\n    a2 = b[1] - a1\n    # The largest element in b is the sum of all elements in the original array a\n    # Subtracting a1 and a2 from this gives the third element in the original array a\n    a3 = b[6] - (a1 + a2)\n    \n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        b = list(map(int, input().split()))\n        result = restore_array_from_sums(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef restore_array_from_sums(b: List[int]) -> List[int]:\n    \"\"\"Restores the original array of three distinct integers from the given sorted array of sums.\n\n    Args:\n        b (List[int]): A list of 7 integers representing the sums of all non-empty subsequences\n                       of an array of three distinct integers.\n\n    Returns:\n        List[int]: The original array of three distinct integers.\n    \"\"\"\n    # The smallest element in b is one of the integers in a\n    a1 = b[0]\n    # The largest element in b is the sum of all three integers in a\n    sum_all = b[6]\n    # The sum of the other two integers\n    sum_two = sum_all - a1\n    # The second smallest element in b is the smallest sum of two integers\n    a2 = b[1]\n    # The third integer can be found by subtracting a2 from sum_two\n    a3 = sum_two - a2\n    \n    return [a1, a2, a3]\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    n = int(input())\n    for _ in range(n):\n        b = list(map(int, input().split()))\n        result = restore_array_from_sums(b)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe task requires restoring an original array of three distinct integers from a given sorted array of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases, each with large integer values. The output should be concise and correct for each test case.\nrequirement pool:\n- Efficiently compute the original array from the given subsequence sums.\n- Ensure the solution is optimized for large input sizes.\n- Provide a clear and concise output format.\n- Develop a user-friendly interface for input and output.\n- Include an explanation of the solution logic for user understanding.\nWe will use a simple mathematical approach to restore the original array 'a' from the given sorted array 'b'. Since 'b' contains the sums of all non-empty subsequences of 'a', we can deduce that the smallest element in 'b' is one of the elements of 'a'. The largest element in 'b' is the sum of all elements of 'a'. By subtracting the smallest element from the largest, we can find the sum of the other two elements. Using these deductions, we can efficiently compute the original array 'a'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements. Non-empty means that the subsequence must contain at least one element.\n\n    'distinct'\n    Explanation: Each integer in the array 'a' is unique, meaning no two integers in 'a' are the same.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Identify the smallest element in array 'b', which corresponds to one of the elements in array 'a'.\n2. Identify the largest element in array 'b', which is the sum of all elements in array 'a'.\n3. Subtract the smallest element from the largest to find the sum of the other two elements in 'a'.\n4. Use the remaining elements in 'b' to deduce the individual values of the other two elements in 'a'.\n5. Return the three elements of array 'a'.\n\n# [edge case] \n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are the same, so each element in 'a' is 1.\n    \n    b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest element is 1, and the largest is 7. The sum of the other two elements is 6. Using other elements, deduce that they are 2 and 4.\n    \n    b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = 1000000000 1000000000 1000000000\n    Explanation: All elements are large but equal, so each element in 'a' is 1000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle these cases by correctly identifying and using the smallest and largest elements in 'b'.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a sorted list of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases with large integer values, ensuring correct and formatted output for each case.\nrequirement pool:\n- Restore the original array from the given sums\n- Handle up to 5000 test cases efficiently\n- Ensure the solution is easy to understand and maintain\n- Optimize for large integer values\n- Provide detailed error messages for incorrect inputs\nWe will use a straightforward approach to restore the original array 'a' from the given array 'b'. Since 'b' is the sorted list of sums of all non-empty subsequences of 'a', we can deduce that the smallest element in 'b' is one of the elements of 'a'. The largest element in 'b' is the sum of all elements in 'a'. By using these properties, we can efficiently determine the elements of 'a'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements. Non-empty means that the subsequence must contain at least one element.\n\n    'distinct'\n    Explanation: Each integer in the array 'a' is unique, meaning no two integers in 'a' are the same.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Identify the smallest element in 'b', which is one of the elements of 'a'.\n2. Identify the largest element in 'b', which is the sum of all elements in 'a'.\n3. The second smallest element in 'b' is another element of 'a'.\n4. The third element of 'a' can be found by subtracting the smallest and second smallest elements from the largest element.\n5. Return these three elements as the array 'a'.\n\n# [edge case] \n    b = [1, 1, 1, 2, 2, 2, 3] = 1 1 1\n    Explanation: All elements are the same, so each element of 'a' is 1.\n    \n    b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest element is 1, the second smallest is 2, and the largest sum is 7. The third element is calculated as 7 - (1 + 2) = 4.\n    \n    b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = 1000000000 1000000000 1000000000\n    Explanation: All elements are the same large number, so each element of 'a' is that number.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle these cases correctly by identifying the smallest and largest elements and calculating the third element accordingly.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a sorted list of sums of its non-empty subsequences. The solution must efficiently handle up to 5000 test cases and large integer values, ensuring the output format is strictly followed.\nrequirement pool:\n- Restore the original array from subsequence sums\n- Ensure scalability for up to 5000 test cases\n- Handle large integer values efficiently\n- Provide output in the correct format\n- Optimize for performance and simplicity\nWe will solve the problem by recognizing that the smallest element in the array b is one of the original elements in array a. The largest element in b is the sum of all three elements of a. The second largest element in b is the sum of the two largest elements of a. By using these observations, we can deduce the original array a from b. We will iterate over each test case, extract the necessary elements from b, and print the result.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'array a consisting of three positive integers'\n    Explanation: The original array a has exactly three distinct positive integers.\n\n    'sums of all non-empty subsequences'\n    Explanation: This refers to all possible sums that can be formed by adding one or more elements from the array a.\n\n# [phrase showing quantity relationship]\n    'three': indicates the number of elements in array a.\n    '7 integers': indicates the number of sums in array b, which corresponds to all non-empty subsequences of a three-element array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Identify the smallest element in array b, which corresponds to the smallest element in array a.\n2. Identify the largest element in array b, which is the sum of all three elements in array a.\n3. Identify the second largest element in array b, which is the sum of the two largest elements in array a.\n4. Use these observations to deduce the original elements of array a:\n   - Let `a1` be the smallest element in b.\n   - Let `a3` be the largest element in b minus `a1`.\n   - Let `a2` be the second largest element in b minus `a3`.\n5. Output the elements `a1`, `a2`, and `a3`.\n\n# [edge case]\n    1 3 4 4 5 7 8 = 1 4 3\n    Explanation: The smallest element is 1, the largest is 8, and the second largest is 7. Thus, a = {1, 4, 3}.\n\n    1 2 2 3 3 4 5 = 1 2 2\n    Explanation: The smallest element is 1, the largest is 5, and the second largest is 4. Thus, a = {1, 2, 2}.\n\n    300000000 300000000 300000000 600000000 600000000 600000000 900000000 = 300000000 300000000 300000000\n    Explanation: All elements are equal, so a = {300000000, 300000000, 300000000}.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided inherently handles these cases by using the properties of sums and ordering in array b.\n", "requirement analysis:\nThe problem requires reconstructing an original array of three distinct integers from the sums of its non-empty subsequences. The solution must efficiently handle up to 5000 test cases, each with 7 integers. The output should be three integers for each test case, representing the original array. The solution should be robust, handling large integer values and ensuring the output format is consistent.\nrequirement pool:\n- Efficiently process up to 5000 test cases\n- Correctly reconstruct the original array from the given sums\n- Handle large integer values up to 10^9\n- Ensure output format is consistent and easy to understand\n- Optimize for both speed and clarity\nWe will leverage the fact that the array b is sorted and represents all possible sums of the non-empty subsequences of a three-element array a. The smallest element in b is the smallest element in a, the largest element in b is the sum of all elements in a, and the second largest element in b is the sum of the two largest elements in a. Using these observations, we can reconstruct the original array a efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: This refers to all possible combinations of elements from the array a, excluding the empty set. For an array of three elements, there are 7 non-empty subsequences.\n\n    'distinct'\n    Explanation: Each integer in the array a is unique, meaning no two integers are the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'smallest': The smallest element in array b corresponds to the smallest element in array a.\n    'largest': The largest element in array b corresponds to the sum of all elements in array a.\n\n# [code logic]\n    1. Identify the smallest element in b, which corresponds to the smallest element in a.\n    2. Identify the largest element in b, which is the sum of all elements in a.\n    3. Identify the second largest element in b, which is the sum of the two largest elements in a.\n    4. Use these observations to reconstruct the original array a:\n       - Let a_1 be the smallest element in b.\n       - Let a_2 be the difference between the second largest element and a_1.\n       - Let a_3 be the difference between the largest element and the sum of a_1 and a_2.\n\n# [edge case] \n    b = [1, 1, 2, 999999998, 999999999, 999999999, 1000000000] = a = [999999998, 1, 1]\n    Explanation: The smallest element is 1, the largest is 1000000000, and the second largest is 999999999. Using these values, we reconstruct a as [999999998, 1, 1].\n\n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = a = [300000000, 300000000, 300000000]\n    Explanation: All elements are equal, so each element in a is 300000000.\n\n    b = [1, 2, 2, 3, 3, 4, 5] = a = [1, 2, 2]\n    Explanation: The smallest element is 1, the largest is 5, and the second largest is 4. Using these values, we reconstruct a as [1, 2, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of identifying smallest and largest elements and using them to reconstruct array a will handle all cases correctly.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a sorted list of sums of its non-empty subsequences. The solution must efficiently handle up to 5000 test cases and large integer values, ensuring the output format is strictly followed.\nrequirement pool:\n- Restore the original array from subsequence sums\n- Handle multiple test cases efficiently\n- Ensure output format compliance\n- Optimize for large integer values\n- Provide clear documentation\nWe will implement a function that takes the sorted array b of subsequence sums and deduces the original array a of three distinct integers. The key observation is that the smallest element in b is one of the original integers, and the largest element in b is the sum of all three integers. By using these observations, we can efficiently restore the original array. We will use Python's built-in capabilities to handle large integers and ensure the solution is scalable for multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'subsequence'\n    Explanation: A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. In this context, it refers to all possible sums of non-empty subsequences of the array a.\n\n    'distinct'\n    Explanation: Each integer in the array a is unique, meaning no two integers in the array are the same.\n\n# [phrase showing quantity relationship]\n    'sum of all three integers': This refers to the largest element in array b, which is the sum of all elements in array a.\n\n# [degree adverb]\n    'smallest': Refers to the smallest element in array b, which is one of the original integers in array a.\n    'largest': Refers to the largest element in array b, which is the sum of all three integers in array a.\n\n# [code logic]\n    1. Identify the smallest element in b, which corresponds to one of the integers in a.\n    2. Identify the largest element in b, which is the sum of all three integers in a.\n    3. Use the second smallest and second largest elements in b to deduce the other two integers in a.\n    4. Return the three integers as the restored array a.\n\n# [edge case]\n    b = [1, 1, 2, 999999998, 999999999, 999999999, 1000000000] = [999999998, 1, 1]\n    Explanation: The smallest element is 1, and the largest element is 1000000000. The second smallest and second largest elements help deduce the other two integers.\n    \n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = [300000000, 300000000, 300000000]\n    Explanation: All elements are equal except for the largest one, which is three times the smallest one.\n\n    b = [1, 2, 2, 3, 3, 4, 5] = [1, 2, 2]\n    Explanation: The smallest element is 1 and the largest element is 5. The second smallest and second largest elements help deduce the other two integers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will correctly deduce the integers from array b.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a sorted list of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases with large integer values, ensuring correct output format.\nrequirement pool:\n- Restore the original array from the given subsequence sums.\n- Ensure the solution is efficient for large inputs.\n- Handle edge cases and ensure robustness.\n- Provide clear and concise output formatting.\n- Optimize for readability and maintainability.\nWe will solve the problem by leveraging the properties of the sums of subsequences. Given the sorted array b of length 7, the smallest element is the smallest number in the original array a. The largest element in b is the sum of all elements in a. By using these properties, we can deduce the original array a. Specifically, the three numbers in a can be found as follows: a_1 = b[0], a_2 = b[1], and a_3 = b[6] - a_1 - a_2. This approach is efficient and straightforward, ensuring it handles the maximum constraints effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be deleted without changing the order of the remaining elements. In this problem, it refers to all possible non-empty combinations of the elements in array a.\n\n    'distinct'\n    Explanation: Each integer in the array a is unique, meaning no two integers in a are the same.\n\n# [phrase showing quantity relationship]\n    'three positive integers': The array a consists of exactly three integers, all greater than zero.\n    \n    '7 integers': The array b contains exactly seven integers, which are the sums of all non-empty subsequences of array a.\n\n# [degree adverb] \n    'smallest': Refers to the smallest element in the sorted array b, which corresponds to the smallest element in array a.\n    \n    'largest': Refers to the largest element in the sorted array b, which is the sum of all elements in array a.\n\n# [code logic]\n1. For each test case, read the sorted array b of length 7.\n2. Identify the smallest element in b as a_1.\n3. Identify the second smallest element in b as a_2.\n4. Calculate a_3 as the largest element in b minus a_1 and a_2.\n5. Output the three integers a_1, a_2, and a_3 for each test case.\n\n# [edge case] \n    Edge Case 1: b = [1, 1, 2, 3, 3, 4, 5] = 1 1 2\n    Explanation: The smallest element is 1, which is a_1. The second smallest is also 1, which is a_2. The largest element is 5, so a_3 = 5 - 1 - 1 = 3.\n\n    Edge Case 2: b = [1000000000, 1000000000, 1000000000, 2000000000, 2000000000, 2000000000, 3000000000] = 1000000000 1000000000 1000000000\n    Explanation: All elements are equal, so each element in a is equal to the smallest element in b.\n\n    Edge Case 3: b = [1, 2, 3, 4, 5, 6, 7] = 1 2 4\n    Explanation: The smallest element is 1 (a_1), the second smallest is 2 (a_2), and the largest is 7. So a_3 = 7 - 1 - 2 = 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of identifying a_1 as b[0], a_2 as b[1], and calculating a_3 as b[6] - a_1 - a_2 inherently handles these cases.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a given sorted list of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases with large integer values, ensuring that the output is correct and adheres to the input-output format.\nrequirement pool:\n- Restore the original array from the given subsequence sums.\n- Ensure the solution is efficient for large inputs.\n- Provide clear and concise output for each test case.\n- Handle edge cases and ensure robustness.\n- Optimize for both speed and clarity.\nWe will solve the problem by recognizing that the smallest element in the sorted array b is one of the original elements a. The largest element in b is the sum of all three elements of a. The second smallest element in b is another element of a. By using these observations, we can deduce the three elements of a efficiently. We will use simple arithmetic operations to extract the original array from the given subsequence sums.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed, but the order of the remaining elements is preserved. Non-empty subsequences mean that at least one element is present in each subsequence.\n\n    'distinct'\n    Explanation: Each integer in the array a is unique, meaning no two integers are the same.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Identify the smallest element in array b, which corresponds to one of the original elements in array a.\n    2. Identify the largest element in array b, which is the sum of all three elements in array a.\n    3. The second smallest element in array b is another element of array a.\n    4. Use these observations to deduce the three elements of array a:\n       - Let a_1 be the smallest element in b.\n       - Let a_2 be the second smallest element in b.\n       - Let a_3 be the largest element minus the sum of a_1 and a_2.\n    5. Return the three elements a_1, a_2, and a_3.\n\n# [edge case] \n    Input: 1 1 2 999999998 999999999 999999999 1000000000\n    Output: 999999998 1 1\n    Explanation: The smallest element is 1, the second smallest is also 1, and the largest element is 1000000000. The third element can be deduced as 1000000000 - (1 + 1) = 999999998.\n\n    Input: 300000000 300000000 300000000 600000000 600000000 600000000 900000000\n    Output: 300000000 300000000 300000000\n    Explanation: All elements are the same, so each element of a is equal to the smallest element in b.\n\n    Input: 1 2 2 3 3 4 5\n    Output: 1 2 2\n    Explanation: The smallest element is 1, the second smallest is 2, and the largest element is 5. The third element can be deduced as 5 - (1 + 2) = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all possible scenarios by using simple arithmetic operations to deduce the original array from the given subsequence sums.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a sorted list of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases with large integer values, ensuring correct and quick output.\nrequirement pool:\n- Efficiently compute the original array from the given subsequence sums.\n- Ensure the solution is optimized for large inputs and multiple test cases.\n- Provide clear and concise output for each test case.\n- Handle edge cases where the input values are at their maximum constraints.\n- Maintain simplicity in the implementation for ease of understanding.\nWe will use a straightforward approach to restore the original array 'a' from the given sorted array 'b'. The smallest element in 'b' is the smallest element in 'a'. The largest element in 'b' is the sum of all elements in 'a'. The second largest element in 'b' is the sum of the two largest elements in 'a'. Using these observations, we can deduce the three elements of 'a'. This approach is simple and efficient, suitable for handling up to 5000 test cases with large integer values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Non-empty subsequences mean that we consider all possible combinations of the elements except the empty set.\n\n    'distinct'\n    Explanation: Each integer in the array 'a' is unique, meaning no two integers are the same.\n\n# [phrase showing quantity relationship]\n    'sum of all elements'\n    Explanation: The largest element in array 'b' is the sum of all elements in array 'a'. This can be implemented by identifying the largest number in 'b'.\n\n    'sum of two largest elements'\n    Explanation: The second largest element in array 'b' is the sum of the two largest elements in array 'a'. This can be implemented by identifying the second largest number in 'b'.\n\n# [degree adverb]\n    'smallest'\n    Explanation: The smallest element in array 'b' corresponds to the smallest element in array 'a'. This can be implemented by identifying the smallest number in 'b'.\n\n# [code logic]\n1. For each test case, read the array 'b'.\n2. Identify the smallest element in 'b', which corresponds to one element in 'a'.\n3. Identify the largest element in 'b', which is the sum of all elements in 'a'.\n4. Identify the second largest element in 'b', which is the sum of the two largest elements in 'a'.\n5. Deduce the three elements of 'a' using these observations:\n   - Let a1 be the smallest element.\n   - Let a2 and a3 be such that a2 + a3 = second largest element and a1 + a2 + a3 = largest element.\n6. Print the three integers a1, a2, and a3 for each test case.\n\n# [edge case]\n    b = [1, 1, 2, 999999998, 999999999, 999999999, 1000000000] = 999999998 1 1\n    Explanation: The smallest element is 1, the largest is 1000000000 (sum of all), and second largest is 999999999 (sum of two largest). Deduce a = [999999998, 1, 1].\n\n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = 300000000 300000000 300000000\n    Explanation: All elements are equal, so deduce a = [300000000, 300000000, 300000000].\n\n    b = [1, 2, 2, 3, 3, 4, 5] = 1 2 2\n    Explanation: The smallest element is 1, the largest is 5 (sum of all), and second largest is 4 (sum of two largest). Deduce a = [1, 2, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles them correctly by deducing values based on sorted properties and sums.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a sorted list of sums of all non-empty subsequences. The solution must handle up to 5000 test cases efficiently, ensuring each test case is processed correctly and outputs the original array in the specified format.\nrequirement pool:\n- Restore the original array from subsequence sums\n- Ensure output format matches the requirements\n- Optimize for large input values\n- Handle multiple test cases efficiently\n- Provide flexibility in output if multiple solutions exist\nWe will use a simple mathematical approach to restore the original array from the given subsequence sums. The smallest element in the sorted array b is the smallest element of the original array a. The largest element in b is the sum of all elements in a. By using these two values and the second smallest value in b, we can deduce the original array. This approach is efficient and handles large numbers well without requiring complex algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'subsequence'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed without changing the order of the remaining elements. In this context, it refers to all possible non-empty combinations of the elements in array a.\n\n    'distinct'\n    Explanation: Each integer in the array a is unique, meaning no two integers are the same.\n\n# [phrase showing quantity relationship]\n    'three positive integers': indicates that the array a consists of exactly three integers, each greater than zero.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Identify the smallest element in array b, which corresponds to the smallest element in array a.\n    2. Identify the largest element in array b, which is the sum of all elements in array a.\n    3. Use the second smallest element in array b to deduce the remaining elements of array a.\n    4. Calculate the three elements of array a using these values:\n       - Let a_1 be the smallest element in b.\n       - Let a_2 be the second smallest element in b minus a_1.\n       - Let a_3 be the largest element in b minus (a_1 + a_2).\n\n# [edge case]\n    Input: 1 1 2 999999998 999999999 999999999 1000000000\n    Output: 999999998 1 1\n    Explanation: The smallest element is 1, the second smallest is also 1, and the largest is 1000000000. Using these, we deduce that a_1 = 999999998, a_2 = 1, and a_3 = 1.\n\n    Input: 300000000 300000000 300000000 600000000 600000000 600000000 900000000\n    Output: 300000000 300000000 300000000\n    Explanation: All elements are equal, so each element of array a is 300000000.\n\n    Input: 1 2 2 3 3 4 5\n    Output: 1 2 2\n    Explanation: The smallest element is 1, the second smallest is 2, and the largest is 5. Using these, we deduce that a_1 = 1, a_2 = 2, and a_3 = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by using mathematical deduction based on sorted subsequence sums.\n", "requirement analysis:\nThe task requires restoring an original array of three distinct integers from a given sorted array of sums of all non-empty subsequences. The solution must efficiently handle up to 5000 test cases with large integer values, ensuring the output is correct and easy to interpret.\nrequirement pool:\n- Develop an algorithm to restore the original array from subsequence sums.\n- Ensure the solution is efficient for the maximum input constraints.\n- Provide clear and concise output for each test case.\n- Handle edge cases where the input values are at their maximum.\n- Optimize the solution for readability and maintainability.\nWe will use a straightforward approach to restore the original array from the given sorted array of sums. Since the array 'a' consists of three distinct integers, the smallest element in 'b' will be one of the integers in 'a'. The largest element in 'b' will be the sum of all three integers in 'a'. By subtracting the smallest element from the largest, we can find the sum of the other two integers. Using these insights, we can efficiently deduce the original array 'a'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'non-empty subsequences'\n    Explanation: A subsequence is a sequence derived from another sequence where some elements may be removed without changing the order of the remaining elements. Non-empty means that at least one element is present in the subsequence.\n\n    'distinct integers'\n    Explanation: Each integer in the array 'a' is unique, meaning no two integers are the same.\n\n# [phrase showing quantity relationship]\n    'sum of all non-empty subsequences'\n    Explanation: This refers to calculating the sum of every possible combination of elements from the array 'a', excluding the empty set. In code, this involves iterating through combinations of elements and summing them.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Identify the smallest element in array 'b', which corresponds to one of the integers in array 'a'.\n    2. Identify the largest element in array 'b', which is the sum of all three integers in array 'a'.\n    3. Subtract the smallest element from the largest to find the sum of the other two integers.\n    4. Use the second smallest and second largest elements in 'b' to deduce the individual values of the remaining two integers.\n    5. Return the three integers as array 'a'.\n\n# [edge case]\n    b = [1, 1, 2, 999999998, 999999999, 999999999, 1000000000] = [999999998, 1, 1]\n    Explanation: The smallest element is 1, and the largest is 1000000000. The sum of the other two integers is 999999999. The second smallest and second largest elements help deduce the individual values.\n\n    b = [300000000, 300000000, 300000000, 600000000, 600000000, 600000000, 900000000] = [300000000, 300000000, 300000000]\n    Explanation: All elements are equal, indicating that all integers in 'a' are equal.\n\n    b = [1, 2, 2, 3, 3, 4, 5] = [1, 2, 2]\n    Explanation: The smallest element is 1, and the largest is 5. The sum of the other two integers is 4. The second smallest and second largest elements help deduce the individual values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle these cases by correctly identifying and using the smallest and largest elements in 'b'.\n"], "scores": [], "pass_results": [true, false, true, false, false, true, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 551, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "mutate_method": "add_1_sentence_at_end", "parent_index": 296}
