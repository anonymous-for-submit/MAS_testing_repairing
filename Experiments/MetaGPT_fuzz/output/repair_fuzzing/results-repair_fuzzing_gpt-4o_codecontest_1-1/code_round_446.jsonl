{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems, each carrying a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n) that none of his students have seen yet, and all problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems, each carrying a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n) that none of his students have seen yet, and all problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems, each carrying a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). None of his students have seen these problems yet. All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session. Monocarp has n problems, each carrying a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n), and all problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize hash maps to count the frequency of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics or difficulties are not different\n        invalid_combinations = 0\n\n        for topic, count in topic_count.items():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid ways to select three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid ways to select three problems for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count the frequency of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics or difficulties repeat\n        invalid_combinations = 0\n\n        # Subtract combinations where topics are not unique\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract combinations where difficulties are not unique\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples with topic and difficulty.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not all different\n        invalid_combinations = 0\n\n        for topic, count in topic_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        for topic, count in topic_count.items():\n            if count >= 2:\n                # Choose 2 problems with the same topic and 1 with a different difficulty\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                # Choose 2 problems with the same difficulty and 1 with a different topic\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract invalid combinations from total to get valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Count the number of valid sets of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of counts of valid problem sets for each test case.\n    \"\"\"\n    results = []\n    \n    for n, problems in test_cases:\n        valid_count = 0\n        \n        # Generate all combinations of three problems\n        for combination in itertools.combinations(problems, 3):\n            topics = {problem[0] for problem in combination}\n            difficulties = {problem[1] for problem in combination}\n            \n            # Check if all topics are different or all difficulties are different\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_count += 1\n        \n        results.append(valid_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    \n    results = count_valid_problem_sets(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problem tuples (topic, difficulty).\n\n    Returns:\n        A list of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    def calculate_combinations(n: int) -> int:\n        \"\"\"Calculates the number of ways to choose 3 items from n items.\"\"\"\n        if n < 3:\n            return 0\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        problem_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and problem\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            problem_count[(topic, difficulty)] += 1\n\n        # Calculate total combinations\n        total_combinations = calculate_combinations(n)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for topic, count in topic_count.items():\n            invalid_combinations += calculate_combinations(count)\n        for difficulty, count in difficulty_count.items():\n            invalid_combinations += calculate_combinations(count)\n        for problem, count in problem_count.items():\n            if count >= 3:\n                invalid_combinations -= calculate_combinations(count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples with topic and difficulty.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid sets.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total number of ways to select 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n\n        # Count frequencies of topics and difficulties\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n\n        for topic, difficulty in problems:\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n\n        # Calculate invalid sets where topics are not all different\n        invalid_topic_sets = 0\n        for freq in topic_counter.values():\n            if freq >= 2:\n                invalid_topic_sets += (freq * (freq - 1) // 2) * (n - freq)\n\n        # Calculate invalid sets where difficulties are not all different\n        invalid_difficulty_sets = 0\n        for freq in difficulty_counter.values():\n            if freq >= 2:\n                invalid_difficulty_sets += (freq * (freq - 1) // 2) * (n - freq)\n\n        # Calculate valid sets by subtracting invalid sets from total\n        valid_sets = total_ways - invalid_topic_sets - invalid_difficulty_sets\n        results.append(valid_sets)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples with topic and difficulty.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid problem sets.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count frequencies of topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where all topics or all difficulties are the same\n        invalid_combinations = 0\n\n        # Subtract combinations where all topics are the same\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract combinations where all difficulties are the same\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where neither topics nor difficulties are all different\n        invalid_combinations = 0\n\n        # Calculate invalid combinations based on topics\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Calculate invalid combinations based on difficulties\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Populate the dictionaries with counts\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems: C(n, 3) = n * (n-1) * (n-2) / 6\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics are not all different\n        invalid_topic_combinations = sum(count * (count - 1) * (count - 2) // 6 for count in topic_count.values())\n\n        # Calculate invalid combinations where difficulties are not all different\n        invalid_difficulty_combinations = sum(count * (count - 1) * (count - 2) // 6 for count in difficulty_count.values())\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires selecting three problems from a set such that either all topics or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the output is accurate.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum input size within the given constraints.\n- Provide clear and correct output for each test case.\n- Optimize the solution to run within time limits for large datasets.\n- Include comments and documentation for code clarity.\nWe will use a combination of combinatorial mathematics and hash maps to efficiently count the number of valid problem sets. The key idea is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will use hash maps to store the frequency of each topic and difficulty, and then calculate the number of valid combinations using combinatorial formulas.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    Implementation: Use combinations to select three items from the list.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the details of each problem.\n2. For each test case, initialize hash maps to count the frequency of each topic and difficulty.\n3. Calculate the total number of ways to select any three problems using combinatorial mathematics (n choose 3).\n4. Subtract invalid combinations where topics or difficulties are not different using the frequency data.\n5. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) satisfies both conditions.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No combination of three problems can satisfy either condition.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy both conditions as all topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial mathematics and hash maps will naturally account for these scenarios.\n", "requirement analysis:\nThe task is to determine the number of ways to select three problems from a given set of problems such that the selected problems have either all different topics or all different difficulties. The constraints ensure that the solution must be efficient, as the number of problems can be large.\nrequirement pool:\n- Implement an efficient algorithm to count valid problem sets.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize for performance to handle multiple test cases quickly.\n- Consider edge cases where n is minimal or maximal.\n- Provide clear and concise output as per the format.\nWe will use combinatorial counting to efficiently determine the number of valid sets of three problems. The key is to count combinations where either all topics or all difficulties are different. We can utilize collections like defaultdict from the Python standard library to count occurrences and calculate combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a unique combination of topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of exactly three problems from the given set.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a distinct topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a distinct difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    \n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems, n.\n2. Store the topics and difficulties of each problem in separate lists.\n3. Use combinatorial counting to calculate the total number of ways to choose 3 problems from n.\n4. Subtract combinations where topics or difficulties are not unique:\n   - Count the frequency of each topic and difficulty.\n   - Calculate invalid combinations where topics or difficulties repeat using these frequencies.\n5. The result for each test case is the total combinations minus invalid combinations.\n\n# [edge case] \n    Test case with minimum n:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Test case with all topics or difficulties the same:\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    = 0\n    Explanation: All topics are the same, so no valid selection can be made.\n\n    Test case with maximum n:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations and subtracting invalid ones will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on selecting three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficiently handle large datasets\n- Accurately calculate valid problem sets\n- Optimize for speed and performance\n- Ensure scalability across test cases\n- Provide clear output format\nWe will use combinatorial mathematics to efficiently calculate the number of valid problem sets. Specifically, we will use combinations to select three problems and check the conditions using hash maps to count occurrences of topics and difficulties. This approach ensures scalability and performance for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates in terms of both attributes.\n\n    'select exactly 3 problems'\n    Explanation: The requirement is to choose precisely three problems from the given set for each test case.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    Implementation: Use combinations to select three items from the list.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial mathematics to calculate combinations of three problems.\n4. Use hash maps to count occurrences of each topic and difficulty.\n5. Check combinations to ensure they meet at least one of the conditions (different topics or different difficulties).\n6. Count and output the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Expected Output: \n    1\n    Explanation: Only one combination is possible, and it meets both conditions.\n\n    Test case with all topics or difficulties the same:\n    Input:\n    1\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    Expected Output:\n    0\n    Explanation: No combination can have all different topics or difficulties.\n\n    Test case with maximum n = 5:\n    Input:\n    1\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Expected Output:\n    10\n    Explanation: All combinations meet at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinations and hash maps will naturally account for these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that they meet at least one of the specified conditions: all topics are different or all difficulties are different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficient algorithm to count valid problem sets\n- Handle large input sizes up to 2 \u22c5 10^5\n- Ensure no duplicate topic-difficulty pairs\n- Optimize for speed and accuracy\n- Provide clear output format\nWe will use a combinatorial approach to efficiently count the number of valid problem sets. The key is to calculate the total number of ways to choose three problems and then subtract the invalid combinations where neither condition is satisfied. We will use dictionaries to count occurrences of topics and difficulties, which will help in determining invalid combinations. This approach ensures that we handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates in terms of both attributes.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specified conditions.\n\n# [phrase showing quantity relationship]\n    'ranging from 1 to n': indicates that both topic and difficulty values are within the range of 1 to n.\n    Explanation: This means that the values for topics and difficulties are bounded by the number of problems, ensuring a finite set of possibilities.\n\n# [degree adverb]\n    'exactly': means that the selection must be precisely three problems, not more or less.\n    Explanation: This restricts the selection to a fixed number, ensuring uniformity in the problem set size.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and details for each test case.\n    2. For each test case, initialize dictionaries to count occurrences of each topic and difficulty.\n    3. Calculate the total number of ways to choose three problems using combinatorial methods.\n    4. Determine invalid combinations where neither condition is satisfied by analyzing topic and difficulty counts.\n    5. Subtract invalid combinations from the total to get valid combinations.\n    6. Output the result for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) satisfies both conditions as all topics and difficulties are different.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No combination satisfies either condition as all pairs have overlapping topics and difficulties.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy both conditions as all topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by considering all possible combinations and filtering out invalid ones based on topic and difficulty counts.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems across all test cases.\nrequirement pool:\n- Efficiently calculate combinations of problems meeting criteria\n- Ensure solution scalability for large input sizes\n- Provide accurate results for all test cases\n- Optimize for performance and memory usage\n- User-friendly output format\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. Specifically, we will leverage the itertools library to generate combinations and use dictionaries to efficiently count occurrences of topics and difficulties. This approach ensures scalability and performance for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates in terms of both attributes.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    Implementation: Use combinations to select groups of three problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the list of problems for each test case.\n    2. For each test case, generate all possible combinations of three problems.\n    3. For each combination, check if the topics are all different or if the difficulties are all different.\n    4. Count the number of valid combinations that satisfy at least one of the conditions.\n    5. Output the count for each test case.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Expected output: 1\n    Explanation: Only one combination is possible, and it satisfies both conditions.\n\n    Test case with all same topics:\n    Input:\n    1\n    4\n    1 2\n    1 3\n    1 4\n    1 5\n    Expected output: 0\n    Explanation: No combination can satisfy the condition of different topics.\n\n    Test case with all same difficulties:\n    Input:\n    1\n    4\n    2 1\n    3 1\n    4 1\n    5 1\n    Expected output: 0\n    Explanation: No combination can satisfy the condition of different difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations will naturally handle these scenarios by returning zero when no valid combinations exist.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that either all topics or all difficulties are different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficiently calculate combinations of problems meeting criteria\n- Handle large input sizes up to 2 \u22c5 10^5 problems\n- Ensure no duplicate topic-difficulty pairs\n- Provide results for multiple test cases\n- Optimize for speed and accuracy\nWe will use a combination of combinatorial mathematics and hash maps to efficiently count the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will utilize Python's collections library to manage counts and combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in terms of its topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of three problems from the given set of problems.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a unique topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a unique difficulty level.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial mathematics to calculate the total number of ways to choose 3 problems from n (n choose 3).\n4. Use hash maps to count occurrences of each topic and difficulty.\n5. Calculate the number of invalid combinations where topics or difficulties are not unique.\n6. Subtract invalid combinations from the total combinations to get valid combinations.\n7. Output the result for each test case.\n\n# [edge case] \n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 0\n    Explanation: No way to select three problems such that all topics or all difficulties are different.\n\n    Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial mathematics and hash maps will naturally account for these scenarios.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the output is correct for each test case.\nrequirement pool:\n- Efficiently calculate combinations of problems meeting the criteria\n- Ensure the solution is optimized for large input sizes\n- Provide clear and concise output for each test case\n- Handle edge cases where n is the minimum value\n- Include comments and documentation for code clarity\nWe will use combinatorial counting to efficiently determine the number of valid sets of problems. The key is to count the total number of ways to select three problems and then subtract the invalid sets where either topics or difficulties are not all different. We will utilize collections.Counter to count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a unique combination of topic and difficulty, ensuring no duplicates.\n\n    'select exactly 3 problems'\n    Explanation: We need to choose three distinct problems from the given list.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must have different topics.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must have different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select precisely three problems.\n    'at least one': At least one of the conditions (different topics or different difficulties) must be satisfied.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. Store the topics and difficulties in separate lists.\n3. Use combinatorial counting to calculate the total number of ways to select three problems: C(n, 3) = n * (n-1) * (n-2) / 6.\n4. Use `collections.Counter` to count the frequency of each topic and difficulty.\n5. Calculate the number of invalid sets where topics are not all different and subtract from the total:\n   - For each topic with frequency `f`, subtract C(f, 2) * (n-f) from the total.\n6. Calculate the number of invalid sets where difficulties are not all different and subtract from the total:\n   - For each difficulty with frequency `f`, subtract C(f, 2) * (n-f) from the total.\n7. The result for each test case is the total number of valid sets after subtracting invalid ones.\n\n# [edge case]\n    Test case with minimum n:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select all three problems, satisfying both conditions.\n\n    Test case with all topics or difficulties the same:\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    = 0\n    Explanation: No valid set as all topics are the same.\n\n    Test case with maximum n:\n    Consider a test case with n = 200000, where topics and difficulties are distributed evenly.\n    The expected output would depend on specific distribution but should be calculated efficiently using the logic above.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and subtraction of invalid sets will handle these cases efficiently.\n", "requirement analysis:\nThe problem requires selecting three problems from a set such that either all topics or all difficulties are different. The constraints are large, so the solution must be efficient, likely involving combinatorial counting and data structures to track unique topics and difficulties.\nrequirement pool:\n- Implement an efficient algorithm to count valid problem sets.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize for performance to meet the constraints.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will use dictionaries to track the frequency of each topic and difficulty, and then apply combinatorial logic to calculate the valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique': means no two tasks possess identical topic and difficulty simultaneously.\n    'different': means the selected problems must have different topics or difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means we need to select precisely three problems.\n    'at least one': means the selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topics and difficulties.\n    3. Use dictionaries to count the frequency of each topic and difficulty.\n    4. Calculate the total number of ways to select any three problems using combinatorial counting (n choose 3).\n    5. Subtract invalid combinations where all topics or all difficulties are the same.\n    6. Output the result for each test case.\n\n# [edge case]\n    Input: \n    3\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one way to select three problems, all topics and difficulties are different.\n    \n    Input: \n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output: \n    4\n    Explanation: All combinations of three problems have different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and frequency tracking will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that they meet at least one of the specified conditions: all topics are different or all difficulties are different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficiently handle large datasets\n- Ensure accurate selection of problem sets\n- Optimize for speed and performance\n- Provide clear output format\n- Maintain code readability and maintainability\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics are different or all difficulties are different. We will utilize Python's collections library to count occurrences and combinations to calculate the number of valid sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is defined by a unique pair of topic and difficulty, meaning no two problems share the same topic and difficulty simultaneously.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose three problems from the given set of problems.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a distinct topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a distinct difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select precisely three problems.\n    'different': This implies a need for uniqueness in either topics or difficulties among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial counting to determine the number of ways to select three problems:\n   - Calculate the total number of ways to choose any three problems.\n   - Subtract the number of invalid combinations where neither topics nor difficulties are all different.\n4. Use collections to count occurrences of each topic and difficulty.\n5. Calculate invalid combinations by considering cases where two or more problems share the same topic or difficulty.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum n (n=3):\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Test case with all topics and difficulties the same:\n    Input: 3\n           1 1\n           1 1\n           1 1\n    Expected output: 0\n    Explanation: No valid selection as all problems are identical.\n\n    Test case with maximum n (n=200000) but only one valid set:\n    Input: 200000\n           (1,1), (2,2), ..., (200000,200000)\n    Expected output: Large number based on combinatorial calculation.\n    Explanation: Each problem is unique, allowing for many valid combinations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and checking for uniqueness in topics or difficulties will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that either their topics or difficulties are all different. The solution must efficiently handle multiple test cases and large datasets, ensuring scalability and accuracy.\nrequirement pool:\n- Efficient algorithm to select valid problem sets\n- Scalable solution for large input sizes\n- Accurate results for all test cases\n- User-friendly output format\n- Detailed error handling and reporting\nWe will use a combinatorial approach to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that either their topics or difficulties are all different. We will utilize dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures scalability and efficiency, especially for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates in terms of both attributes.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing a subset of three problems from the given list.\n\n    'topics and difficulties are different'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    'different': means that the topics or difficulties must not be the same among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and details for each test case.\n2. For each test case, initialize dictionaries to count occurrences of each topic and difficulty.\n3. Iterate through the list of problems to populate these dictionaries.\n4. Calculate the total number of ways to select three problems using combinatorial logic:\n   - Total combinations of three problems: C(n, 3) = n * (n-1) * (n-2) / 6\n   - Subtract combinations where topics are not all different.\n   - Subtract combinations where difficulties are not all different.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with maximum n:\n    Input: 200000 (with unique topic and difficulty pairs)\n    Output: Large number (depends on specific distribution)\n    Explanation: The number of ways will be large due to many combinations possible.\n\n    Test case with all same topics:\n    Input: 4\n           1 1\n           1 2\n           1 3\n           1 4\n    Output: 0\n    Explanation: No valid selection as all topics are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The combinatorial logic inherently handles these scenarios by considering all possible combinations and subtracting invalid ones.\n"], "scores": [], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 446, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "condense_two2one", "parent_index": 160}
