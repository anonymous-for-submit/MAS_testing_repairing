{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A of dimensions n \u00d7 m containing n rows and m columns of blocks. Each square in the rectangle consists of either an obsidian block or it is vacant, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block in a single operation.\n\nA rectangle M of dimension a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5, b \u2265 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For every 1 < x < a, 1 < y < b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nPlease be aware that there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A of dimensions n \u00d7 m containing n rows and m columns of blocks. Each square in the rectangle consists of either an obsidian block or it is vacant, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block in a single operation.\n\nA rectangle M of dimension a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5, b \u2265 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For every 1 < x < a, 1 < y < b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nPlease be aware that there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A of dimensions n \u00d7 m containing n rows and m columns of blocks. Each square in the rectangle consists of either an obsidian block or it is vacant, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block in a single operation.\n\nA rectangle M of dimension a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5 and b \u2265 4. For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. These blocks are important for the portal formation.\n  * For every 1 < x < a, 1 < y < b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nPlease be aware that there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A of dimensions n \u00d7 m containing n rows and m columns of blocks. Each square in the rectangle consists of either an obsidian block or it is vacant, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block in a single operation. A rectangle M of dimension a \u00d7 b is referred to as a portal if and only if it meets the following criteria: a \u2265 5, b \u2265 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, and for each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For every 1 < x < a, 1 < y < b, block M_{x,y} is an empty block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. Please be aware that there must be a rows and b columns, not b rows and a columns, and corners can be any type. CQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed to meet the portal criteria\n                        operations = 0\n\n                        # Check border rows\n                        for col in range(start_col + 1, end_col):\n                            if matrix[start_row, col] != 1:\n                                operations += 1\n                            if matrix[end_row, col] != 1:\n                                operations += 1\n\n                        # Check border columns\n                        for row in range(start_row + 1, end_row):\n                            if matrix[row, start_col] != 1:\n                                operations += 1\n                            if matrix[row, end_col] != 1:\n                                operations += 1\n\n                        # Check inner blocks\n                        for row in range(start_row + 1, end_row):\n                            for col in range(start_col + 1, end_col):\n                                if matrix[row, col] != 0:\n                                    operations += 1\n\n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Process and output results\nresults = min_operations_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n\n                        # Check the border conditions for the portal\n                        for x in range(start_row + 1, start_row + a - 1):\n                            if case[x][start_col] != '1':\n                                operations += 1\n                            if case[x][start_col + b - 1] != '1':\n                                operations += 1\n\n                        for y in range(start_col + 1, start_col + b - 1):\n                            if case[start_row][y] != '1':\n                                operations += 1\n                            if case[start_row + a - 1][y] != '1':\n                                operations += 1\n\n                        # Check the inner conditions for the portal\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if case[x][y] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n\n                        # Check and count operations for the sides\n                        for x in range(1, a - 1):\n                            if test_case[start_row + x][start_col] != '1':\n                                operations += 1\n                            if test_case[start_row + x][start_col + b - 1] != '1':\n                                operations += 1\n\n                        for y in range(1, b - 1):\n                            if test_case[start_row][start_col + y] != '1':\n                                operations += 1\n                            if test_case[start_row + a - 1][start_col + y] != '1':\n                                operations += 1\n\n                        # Check and count operations for the interior\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if test_case[start_row + x][start_col + y] != '0':\n                                    operations += 1\n\n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, matrix = case['n'], case['m'], case['matrix']\n        min_operations = float('inf')\n\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix])\n\n        # Iterate over all possible sub-rectangles of size 5x4\n        for i in range(n - 4):\n            for j in range(m - 3):\n                operations = 0\n\n                # Check and count operations needed for edges and inner blocks\n                for x in range(i, i + 5):\n                    for y in range(j, j + 4):\n                        if (x == i or x == i + 4 or y == j or y == j + 3):\n                            # Edge blocks should be obsidian ('1')\n                            if grid[x, y] != '1':\n                                operations += 1\n                        else:\n                            # Inner blocks should be vacant ('0')\n                            if grid[x, y] != '0':\n                                operations += 1\n\n                # Update the minimum operations found\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append({'n': n, 'm': m, 'matrix': grid})\n\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(i + 4, n):\n                    for b in range(j + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        operations = 0\n                        for x in range(i, a + 1):\n                            for y in range(j, b + 1):\n                                if (x == i or x == a or y == j or y == b):\n                                    # Border condition\n                                    if (x == i or x == a) and (y == j or y == b):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    if case[x][y] == '0':\n                                        operations += 1\n                                else:\n                                    # Inner condition\n                                    if case[x][y] == '1':\n                                        operations += 1\n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n\n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n\n                        # Check the borders (except corners)\n                        for i in range(start_row + 1, end_row):\n                            if grid[i][start_col] != '1':\n                                operations += 1\n                            if grid[i][end_col] != '1':\n                                operations += 1\n                        for j in range(start_col + 1, end_col):\n                            if grid[start_row][j] != '1':\n                                operations += 1\n                            if grid[end_row][j] != '1':\n                                operations += 1\n\n                        # Check the inner blocks\n                        for i in range(start_row + 1, end_row):\n                            for j in range(start_col + 1, end_col):\n                                if grid[i][j] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: Minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_matrix = matrix[i:i+a, j:j+b]\n                        operations = calculate_operations(sub_matrix, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_matrix: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-matrix into a portal.\n\n    Args:\n        sub_matrix (np.ndarray): The sub-matrix to transform.\n        a (int): Number of rows in the sub-matrix.\n        b (int): Number of columns in the sub-matrix.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and transform borders to obsidian\n    for x in range(1, a - 1):\n        if sub_matrix[x, 0] != 1:\n            operations += 1\n        if sub_matrix[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_matrix[0, y] != 1:\n            operations += 1\n        if sub_matrix[a - 1, y] != 1:\n            operations += 1\n\n    # Check and transform inner blocks to vacant\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_matrix[x, y] != 0:\n                operations += 1\n\n    return operations\n\ndef handle_edge_cases(n: int, m: int, matrix: np.ndarray) -> int:\n    \"\"\"Handle edge cases where the rectangle already meets portal criteria or is entirely obsidian/vacant.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        matrix (np.ndarray): The matrix to check.\n\n    Returns:\n        int: Number of operations needed for edge cases.\n    \"\"\"\n    if is_portal(matrix):\n        return 0\n\n    # Calculate operations for all obsidian or all vacant cases\n    # Implement logic to count necessary transformations for these specific cases\n    # This is a placeholder for additional logic if needed\n    return float('inf')\n\ndef is_portal(matrix: np.ndarray) -> bool:\n    \"\"\"Check if a matrix already meets portal criteria.\n\n    Args:\n        matrix (np.ndarray): The matrix to check.\n\n    Returns:\n        bool: True if the matrix is a portal, False otherwise.\n    \"\"\"\n    a, b = matrix.shape\n    for x in range(1, a - 1):\n        if matrix[x, 0] != 1 or matrix[x, b - 1] != 1:\n            return False\n\n    for y in range(1, b - 1):\n        if matrix[0, y] != 1 or matrix[a - 1, y] != 1:\n            return False\n\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[x, y] != 0:\n                return False\n\n    return True\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_min_operations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing the grid dimensions and the grid itself.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed to convert this sub-rectangle into a portal\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the borders (except corners)\n    for i in range(start_row + 1, end_row):\n        if grid[i][start_col] != '1':\n            operations += 1\n        if grid[i][end_col] != '1':\n            operations += 1\n\n    for j in range(start_col + 1, end_col):\n        if grid[start_row][j] != '1':\n            operations += 1\n        if grid[end_row][j] != '1':\n            operations += 1\n\n    # Check the inner blocks\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i][j] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef is_portal(sub_rect: np.ndarray) -> bool:\n    \"\"\"Check if the sub-rectangle already meets portal criteria.\"\"\"\n    a, b = sub_rect.shape\n    # Check borders (except corners)\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1 or sub_rect[x, b - 1] != 1:\n            return False\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1 or sub_rect[a - 1, y] != 1:\n            return False\n    # Check inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                return False\n    return True\n\ndef calculate_operations(sub_rect: np.ndarray) -> int:\n    \"\"\"Calculate the number of operations needed to transform sub-rectangle into a portal.\"\"\"\n    if is_portal(sub_rect):\n        return 0\n    \n    a, b = sub_rect.shape\n    operations = 0\n    \n    # Calculate operations for borders (except corners)\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n    \n    # Calculate operations for inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n    \n    return operations\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to make at least one sub-rectangle a portal.\"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles with dimensions a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rect)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing dimensions n, m and the grid.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Initialize the minimum operations to a large number\n        min_operations = n * m\n        \n        # Iterate over all possible sub-rectangles of at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate operations needed for current sub-rectangle\n                operations = calculate_operations_for_subrectangle(n, m, grid, start_row, start_col)\n                # Update the minimum operations\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations_for_subrectangle(n: int, m: int, grid: List[str], start_row: int, start_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): The grid representation.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n    \n    # Check borders and inner blocks\n    for i in range(start_row, start_row + 5):\n        for j in range(start_col, start_col + 4):\n            if i == start_row or i == start_row + 4 or j == start_col or j == start_col + 3:\n                # Border condition: should be obsidian (1)\n                if grid[i][j] == '0':\n                    operations += 1\n            else:\n                # Inner condition: should be empty (0)\n                if grid[i][j] == '1':\n                    operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires transforming a sub-rectangle within a larger rectangle into a portal with specific obsidian and vacant block arrangements. The solution must efficiently compute the minimum number of operations needed for this transformation across multiple test cases, ensuring clarity and correctness in output.\nrequirement pool:\n- Efficiently compute minimum operations for portal transformation\n- Handle multiple test cases with varying dimensions\n- Ensure output format is clear and concise\n- Optimize algorithm for large input sizes\n- Consider edge cases and ensure robustness\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m': This refers to the main grid or matrix that contains blocks, where n is the number of rows and m is the number of columns.\n    'obsidian block or vacant': Each block in the rectangle can either be an obsidian block (represented by '1') or a vacant block (represented by '0').\n    'portal': A sub-rectangle within the main rectangle that meets specific criteria regarding the arrangement of obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'for every 1 < x < a': This indicates a range condition for rows within the portal, excluding the first and last row.\n    'for each 1 < x < b': This indicates a range condition for columns within the portal, excluding the first and last column.\n\n# [degree adverb]\n    'minimum number of operations': The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure that all border blocks (except corners) are obsidian.\n   - Ensure that all inner blocks are vacant.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle with all blocks already meeting the portal criteria.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already forms a portal.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, requiring 12 operations.\n\n    Case 3: A rectangle with dimensions exactly matching the minimum portal size but with incorrect block types.\n    Input:\n    1\n    5 4\n    0000\n    0110\n    0110\n    0110\n    0000\n    Expected Output: 8\n    Explanation: The borders need to be changed to obsidian, and inner blocks need to be vacant.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the problem is computationally feasible within the given limits. The solution must efficiently handle multiple test cases and provide accurate results.\nrequirement pool:\n- Develop an algorithm to identify the minimum operations needed to form a portal.\n- Ensure the solution handles the maximum constraints efficiently.\n- Optimize the algorithm for better performance.\n- Provide detailed comments and documentation for the code.\n- Implement additional test cases to verify edge cases.\nWe will use a brute-force approach to check all possible sub-rectangles of dimensions a \u00d7 b within the given n \u00d7 m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints for a portal are met. The algorithm will be optimized to minimize operations by checking only valid sub-rectangles and using efficient data structures to store intermediate results.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where 'n' is the number of rows and 'm' is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria regarding the placement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: The action of switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means checking sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations required to transform a sub-rectangle into a portal. In code, this involves keeping track of the smallest number of operations found.\n\n# [code logic]\n1. Parse the input to get the number of test cases and for each test case, the dimensions of the rectangle and its block configuration.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal by checking each block against the portal criteria.\n4. Keep track of the minimum number of operations needed for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle with all blocks already forming a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All required obsidian blocks need to be placed, resulting in maximum operations.\n\n    Case 3: A rectangle with alternating blocks.\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on specific arrangement but should be calculated based on transforming alternating pattern to meet portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should handle multiple test cases and provide results for each one.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations.\n- Ensure the solution handles the maximum input size within time limits.\n- Optimize the code for readability and maintainability.\n- Include edge case handling in the solution.\n- Provide detailed comments and documentation for the code.\nWe will use a brute-force approach to check all possible sub-rectangles of dimensions a \u00d7 b within the given n \u00d7 m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints for a portal are met. The algorithm will be optimized to minimize operations by checking only valid sub-rectangles and using efficient counting techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where 'n' is the number of rows and 'm' is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the rectangle, represented by '1' and '0', respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means checking sub-rectangles with these minimum dimensions.\n\n    '1 < x < a', '1 < x < b'\n    Explanation: These phrases define the range for the indices within the sub-rectangle that must meet certain conditions. In code, this involves iterating over these indices to check or set block types.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the least number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing operation counts for different sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the sides (except corners) are obsidian blocks.\n   - Ensure the interior is empty blocks.\n4. Track the minimum number of operations across all sub-rectangles for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already a portal\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Case 2: Minimum size rectangle with all obsidian blocks\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: All interior blocks need to be changed to empty blocks, requiring a significant number of operations.\n\n    Case 3: Large rectangle with no possible portal\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: 14\n    Explanation: The entire perimeter needs to be converted to obsidian blocks, except corners, requiring many operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are clearly defined, ensuring the solution is both efficient and accurate. The challenge lies in optimizing the transformation process while adhering to the portal criteria.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal.\n- Optimize the algorithm for minimal operations.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output format.\n- Test the solution against multiple test cases for reliability.\nWe will implement a function to transform the given rectangle into a portal with minimal operations. The approach involves iterating over possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle and calculating the number of operations needed to convert each sub-rectangle into a portal. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with n rows and m columns.\n    'obsidian block': A block represented by '1' in the matrix.\n    'vacant': A block represented by '0' in the matrix.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5 and b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Refers to the range of rows excluding the first and last row.\n    'For each 1 < x < b': Refers to the range of columns excluding the first and last column.\n\n# [degree adverb]\n    'minimum': The least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to extract the number of test cases, dimensions, and block configurations.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\n3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal:\n   - Ensure the edges (except corners) are obsidian blocks.\n   - Ensure the inner blocks are vacant.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: Minimum size rectangle (5x4) with all blocks as obsidian.\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: Convert inner blocks to vacant, requiring 8 operations.\n\n    Case 2: Minimum size rectangle (5x4) with all blocks as vacant.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: Convert edge blocks to obsidian, requiring 12 operations.\n\n    Case 3: Large rectangle (400x400) with alternating pattern.\n    Input:\n    1\n    400 400\n    (pattern alternating between '0' and '1')\n    Expected Output: Depends on specific pattern, but should be calculated based on portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently, especially for large matrices.\n```python\nimport numpy as np\n\ndef min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, matrix = case['n'], case['m'], case['matrix']\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a x b\n        for i in range(n - 4):\n            for j in range(m - 3):\n                operations = 0\n                \n                # Check and count operations needed for edges and inner blocks\n                for x in range(i, i + 5):\n                    for y in range(j, j + 4):\n                        if (x == i or x == i + 4 or y == j or y == j + 3):\n                            if matrix[x][y] != '1':\n                                operations += 1\n                        else:\n                            if matrix[x][y] != '0':\n                                operations += 1\n                \n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\n# Example usage:\ntest_cases = [\n    {'n': 5, 'm': 4, 'matrix': ['1000', '0000', '0110', '0000', '0001']},\n    {'n': 9, 'm': 9, 'matrix': ['001010001', '101110100', '000010011', '100000001', '101010101', '110001111', '000001111', '111100000', '000110000']}\n]\n\nprint(min_operations_to_portal(2, test_cases))\n```\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an algorithm to identify potential portal sub-rectangles.\n- Calculate the minimum number of operations needed for transformation.\n- Optimize the solution for large input sizes.\n- Ensure the solution is robust and handles edge cases.\n- Provide detailed documentation and examples for users.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use a brute-force method due to the manageable constraints, ensuring that the solution is efficient enough for the given input limits.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5 and b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range from 2 to a-1 for rows.\n    'For each 1 < x < b': Indicates a range from 2 to b-1 for columns.\n\n# [degree adverb]\n    'minimum': Refers to the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n       - Ensure the borders are obsidian blocks where required.\n       - Ensure the inner blocks are empty.\n    4. Track the minimum number of changes across all sub-rectangles for each test case.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria.\n    Explanation: If a rectangle already meets the portal criteria, no operations are needed, so the expected output is 0.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Explanation: The maximum number of changes will be needed to convert inner blocks to empty, while maintaining border obsidian blocks.\n\n    Case 3: A rectangle with all blocks as empty.\n    Explanation: The maximum number of changes will be needed to convert border blocks to obsidian, while maintaining inner empty blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should focus on optimizing the number of operations while ensuring correctness across all test cases.\nrequirement pool:\n- Develop an efficient algorithm to minimize operations for portal formation.\n- Ensure the solution handles all edge cases effectively.\n- Optimize the solution for large input sizes.\n- Provide clear documentation and comments in the code.\n- Implement comprehensive test cases to validate the solution.\nWe will use a brute-force approach to check all possible sub-rectangles of dimensions at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. The solution will iterate over all possible top-left corners of the sub-rectangles and check the conditions for a portal, counting the necessary changes. This approach ensures that we handle all edge cases and provide an efficient solution given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions, n \u00d7 m, where n is the number of rows and m is the number of columns.\n    'obsidian block': A block represented by '1' in the grid.\n    'empty block': A block represented by '0' in the grid.\n    'portal': A sub-rectangle within the grid that meets specific criteria for block arrangement.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5 and b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range from 2 to a-1 for rows.\n    'For each 1 < x < b': Indicates a range from 2 to b-1 for columns.\n\n# [degree adverb]\n    'minimum': Refers to the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of dimensions at least 5x4 within the given n x m grid.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed:\n        - Ensure the borders (except corners) are obsidian blocks.\n        - Ensure the inner blocks are empty blocks.\n    3. Keep track of the minimum number of operations required across all sub-rectangles.\n    4. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    8\n    Explanation: The entire grid is filled with obsidian blocks. To form a portal, we need to change all inner blocks (2x2 area) to empty blocks, requiring 8 operations.\n\n    Input: \n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Output: \n    16\n    Explanation: The entire grid is filled with empty blocks. To form a portal, we need to change all border blocks (except corners) to obsidian blocks, requiring 16 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute-force approach inherently checks all possible sub-rectangles and calculates the necessary operations for each, ensuring edge cases are covered.\n", "requirement analysis:\nThe problem requires finding a sub-rectangle within a given grid that can be transformed into a portal with the minimum number of operations. The constraints on dimensions and block types must be carefully considered to ensure the solution is both efficient and correct.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations needed.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear documentation and comments within the code.\n- Develop test cases to validate the solution.\nWe will use a dynamic programming approach to efficiently calculate the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost encountered. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria regarding block types and positions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b \u2265 4': The number of columns in the portal must be at least 4.\n    'minimum number of operations': The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'minimum': Refers to the smallest number of operations required to achieve the transformation.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions a \u00d7 b where a \u2265 5 and b \u2265 4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the borders meet the obsidian block criteria.\n        - Ensure the inner blocks are vacant.\n    4. Keep track of the minimum number of operations for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meets the portal criteria.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: Calculated based on transforming inner blocks to vacant.\n\n    Case 3: A rectangle with all blocks vacant.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Calculated based on transforming border blocks to obsidian.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the rectangle already meets portal criteria or is entirely obsidian/vacant.\n    \n```python\ndef handle_edge_cases(n, m, matrix):\n    # Check if already a portal\n    if is_portal(matrix):\n        return 0\n    \n    # Calculate operations for all obsidian or all vacant cases\n    # Implement logic to count necessary transformations for these specific cases\n\ndef is_portal(matrix):\n    # Implement logic to check if matrix already meets portal criteria\n```\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must handle multiple test cases and provide results for each.\nrequirement pool:\n- Develop an efficient algorithm to calculate minimum operations\n- Ensure the solution handles maximum constraints\n- Provide clear and concise output for each test case\n- Optimize the algorithm for performance\n- Include detailed comments and documentation\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use a brute-force method optimized with early stopping if a perfect portal is found. The function will handle multiple test cases efficiently by processing each independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m': A grid with n rows and m columns, where each cell can be either an obsidian block or vacant.\n    'portal': A sub-rectangle of dimension a \u00d7 b that meets specific criteria regarding the placement of obsidian blocks and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'for every 1 < x < a': This means for all rows except the first and last, certain conditions must be met.\n    'for each 1 < x < b': This means for all columns except the first and last, certain conditions must be met.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to convert it into a portal:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are vacant.\n4. Keep track of the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Explanation: If a sub-rectangle already meets the portal criteria, no operations are needed, so the output should be 0.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Explanation: The maximum number of changes will be needed to convert the inner blocks to vacant while maintaining the border conditions.\n\n    Case 3: A rectangle with all blocks vacant.\n    Explanation: The maximum number of changes will be needed to convert the border blocks to obsidian while maintaining the inner blocks as vacant.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimum operations. The constraints on dimensions and block types are crucial for determining the solution approach. The solution must efficiently handle multiple test cases and large input sizes while ensuring accuracy in portal formation.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations.\n- Ensure accurate transformation of sub-rectangle into portal.\n- Optimize solution for handling maximum constraints.\n- Provide clear and concise output format.\n- Develop user-friendly interface for input and output.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and calculates the minimum number of operations required to transform each into a portal. The function will use dynamic programming to efficiently compute the minimum operations by storing intermediate results. We will use numpy for efficient array manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix that contains either obsidian blocks (1) or empty blocks (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria: dimensions a \u00d7 b with a \u2265 5, b \u2265 4, and specific block arrangements.\n\n    'minimum number of operations'\n    Explanation: The least number of changes required to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible number of operations needed. In code, this involves finding the least value among calculated operations for all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Use dynamic programming to store and reuse results for efficiency.\n5. Track the minimum number of operations across all sub-rectangles for each test case.\n6. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already a portal\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Case 2: Minimum size rectangle with no obsidian blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, requiring 12 operations.\n\n    Case 3: Maximum size rectangle with all obsidian blocks\n    Input:\n    1\n    400 400\n    (all blocks are '1')\n    Expected Output: Calculated based on specific implementation logic.\n    Explanation: All inner blocks need to be changed to empty, requiring a large number of operations.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently by checking if a sub-rectangle already meets the portal criteria before calculating operations. This can be done by adding a quick check at the start of each sub-rectangle evaluation:\n    \n```python\ndef is_portal(sub_rect):\n    # Check if the sub-rectangle already meets portal criteria\n    # Return True if it does, False otherwise\n\ndef calculate_operations(sub_rect):\n    if is_portal(sub_rect):\n        return 0\n    # Otherwise, calculate the number of operations needed\n\n# Use these functions in the main logic to handle edge cases efficiently.\n```\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal transformation.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Optimize the code for performance and scalability.\n- Provide detailed comments and documentation for the code.\n- Implement comprehensive test cases to validate the solution.\nWe will iterate over all possible sub-rectangles of dimensions at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. This involves checking the borders and the inner blocks of the sub-rectangle to ensure they meet the portal criteria. We will use a dynamic programming approach to efficiently calculate the number of operations needed for each sub-rectangle, keeping track of the minimum operations required across all sub-rectangles.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where 'n' is the number of rows and 'm' is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid, represented by '1' and '0', respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means checking sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the least number of operations across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and for each test case, read the dimensions n and m, followed by the grid.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Check the borders to ensure they are obsidian blocks where required.\n   - Check the inner blocks to ensure they are empty.\n4. Use dynamic programming to efficiently calculate and update the minimum operations needed for each sub-rectangle.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Edge Case 1: A grid that is already a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already meets the portal criteria, so no operations are needed.\n\n    Edge Case 2: A grid with no possible portal.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: A large number (e.g., n*m) indicating that transforming any sub-rectangle into a portal is not feasible without significant changes.\n\n    Edge Case 3: A grid with minimal changes needed.\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 1\n    Explanation: Only one change is needed to make the bottom-left corner an obsidian block.\n\n# [extra code for edge case]\nWe need extra code to handle edge cases where no portal is possible or when the grid is already a portal. This can be managed by initializing a variable to track the minimum operations and updating it only when a valid portal configuration is found. If no valid configuration is found, return a predefined large number or handle it as an exception case.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 746, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 474}
