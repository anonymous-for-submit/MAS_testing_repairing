{"name": "1598_E. Staircases", "description": "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "tags": ["brute force", "combinatorics", "data structures", "dfs and similar", "dp", "implementation", "math"], "difficulty": 11, "id": 1598, "sample_io": [{"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n"]}, {"input": "1000 1000 2\n239 634\n239 634\n", "output": ["1332632508\n1333333000\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n1\n0\n"]}], "test_list": [{"input": "1 1 1\n1 1\n", "output": ["0\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n238\n233\n222\n207\n186\n180\n162\n140\n151\n144\n137\n144\n137\n111\n109\n91\n82\n77\n87\n78\n76\n83\n81\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 2\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n12\n8\n13\n23\n19\n15\n"]}, {"input": "1 1 2\n1 1\n1 1\n", "output": ["0\n1\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n86\n81\n91\n82\n80\n86\n84\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 1\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n3\n6\n2\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n77\n68\n66\n72\n70\n"]}, {"input": "3 4 10\n1 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n31\n45\n25\n17\n15\n12\n14\n16\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n17\n14\n12\n15\n17\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n16\n14\n"]}, {"input": "1000 1000 2\n252 634\n239 634\n", "output": ["1332594366\n1331893874\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n74\n69\n79\n70\n68\n74\n72\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n9\n6\n5\n4\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n78\n76\n64\n77\n74\n80\n71\n69\n75\n73\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n14\n12\n8\n13\n23\n31\n27\n"]}, {"input": "1000 1000 2\n59 634\n239 634\n", "output": ["1333160628\n1332460136\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n162\n140\n135\n124\n111\n104\n117\n114\n94\n92\n80\n77\n85\n101\n92\n90\n96\n94\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n90\n76\n64\n77\n74\n80\n69\n67\n71\n69\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n78\n70\n56\n62\n56\n"]}, {"input": "1000 1000 2\n239 634\n418 634\n", "output": ["1332632508\n1331406830\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n74\n65\n63\n69\n67\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n75\n72\n"]}, {"input": "3 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n"]}, {"input": "1000 1000 2\n59 323\n239 634\n", "output": ["1333014458\n1332313966\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n142\n137\n126\n116\n109\n103\n99\n91\n77\n65\n78\n73\n79\n68\n66\n70\n69\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n52\n54\n49\n47\n41\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n66\n63\n"]}, {"input": "2 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "1000 1000 2\n59 323\n239 999\n", "output": ["1333014458\n1333011116\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n83\n72\n70\n74\n73\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n75\n73\n67\n70\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n124\n113\n123\n119\n111\n97\n85\n98\n88\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n194\n183\n154\n151\n138\n130\n121\n129\n126\n119\n118\n106\n100\n95\n105\n92\n90\n76\n79\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n77\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n109\n101\n96\n106\n93\n95\n81\n84\n"]}, {"input": "6 3 4\n1 2\n1 3\n2 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n63\n61\n"]}, {"input": "2 1 2\n1 1\n1 1\n", "output": ["1\n3\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n27\n23\n31\n21\n25\n18\n15\n13\n"]}, {"input": "1000 1000 2\n341 634\n239 634\n", "output": ["1332333240\n1331632748\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n116\n109\n112\n109\n83\n81\n69\n78\n73\n83\n74\n72\n77\n75\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n17\n15\n12\n14\n16\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n179\n163\n157\n135\n130\n119\n112\n108\n103\n100\n80\n78\n64\n73\n70\n76\n67\n65\n71\n69\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n35\n31\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 4\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n43\n33\n26\n24\n"]}, {"input": "1000 1000 2\n252 634\n239 877\n", "output": ["1332594366\n1332358004\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n112\n100\n97\n92\n102\n93\n91\n97\n87\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n234\n229\n218\n195\n188\n186\n164\n144\n133\n126\n119\n114\n111\n91\n89\n71\n62\n59\n65\n56\n54\n60\n58\n"]}, {"input": "3 3 10\n1 2\n2 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n11\n14\n18\n14\n25\n35\n25\n21\n"]}, {"input": "1000 1000 2\n59 634\n239 35\n", "output": ["1333160628\n1332948862\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n107\n98\n96\n102\n100\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n98\n86\n99\n96\n90\n68\n64\n68\n66\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n23\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n10\n5\n2\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n78\n75\n"]}, {"input": "1000 1000 2\n59 323\n448 634\n", "output": ["1333014458\n1331700760\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 1\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n170\n165\n150\n122\n115\n109\n105\n97\n83\n71\n84\n79\n85\n74\n72\n76\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n74\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n5 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n83\n81\n72\n75\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n127\n113\n101\n114\n104\n92\n81\n79\n83\n82\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n102\n105\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n21\n17\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n208\n197\n174\n159\n153\n131\n126\n113\n110\n121\n124\n121\n95\n93\n81\n90\n85\n95\n86\n84\n89\n87\n"]}, {"input": "3 4 10\n1 4\n2 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n29\n25\n19\n11\n9\n8\n5\n6\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n1 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n197\n181\n175\n152\n157\n139\n132\n128\n123\n120\n97\n93\n79\n93\n90\n96\n81\n79\n73\n71\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n21\n17\n"]}, {"input": "1000 1000 2\n142 634\n239 877\n", "output": ["1332917106\n1332680744\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 5\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n110\n98\n95\n90\n100\n93\n91\n98\n88\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n180\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n56\n"]}, {"input": "1000 1000 2\n59 634\n239 24\n", "output": ["1333160628\n1333015896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n127\n115\n109\n117\n133\n122\n120\n127\n119\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 2\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n119\n107\n120\n117\n111\n81\n77\n81\n78\n"]}, {"input": "3 3 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["26\n18\n15\n14\n"]}, {"input": "2 3 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["12\n18\n12\n7\n10\n18\n10\n7\n"]}, {"input": "3 3 4\n1 3\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n5 2\n2 3\n3 1\n", "output": ["31\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n223\n212\n195\n169\n163\n128\n125\n114\n107\n101\n108\n105\n98\n97\n83\n80\n75\n85\n72\n70\n72\n69\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n120\n108\n105\n116\n106\n94\n88\n86\n93\n92\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n2 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n127\n130\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n180\n164\n158\n135\n132\n114\n107\n103\n98\n95\n87\n85\n71\n76\n73\n79\n66\n64\n58\n56\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n60\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n137\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n34\n26\n23\n"]}, {"input": "6 3 4\n1 1\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n75\n71\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n132\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 4\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 4\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n113\n112\n92\n90\n70\n61\n56\n61\n52\n50\n56\n58\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n126\n133\n136\n"]}, {"input": "3 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n4 2\n7 2\n2 3\n3 0\n", "output": ["39\n33\n43\n53\n"]}, {"input": "6 3 4\n1 1\n2 3\n1 2\n2 3\n1 3\n1 5\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n71\n68\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n5 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n118\n111\n83\n90\n110\n107\n95\n89\n94\n100\n85\n87\n94\n97\n"]}, {"input": "3 6 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 4\n2 2\n5 2\n2 3\n3 1\n", "output": ["79\n59\n56\n50\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n197\n"]}, {"input": "2 5 1\n1 4\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["26\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n179\n181\n"]}, {"input": "12 3 4\n2 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["177\n173\n170\n174\n"]}, {"input": "2 5 1\n1 2\n1 6\n2 1\n1 3\n4 1\n3 2\n0 3\n0 4\n1 3\n3 1\n", "output": ["25\n"]}, {"input": "1 2 1\n1 1\n", "output": ["1\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n244\n239\n225\n210\n189\n183\n165\n143\n154\n145\n138\n147\n140\n114\n112\n94\n85\n82\n74\n65\n63\n70\n68\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n28\n39\n29\n23\n17\n22\n20\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n116\n123\n120\n100\n98\n86\n95\n90\n100\n91\n89\n95\n93\n"]}, {"input": "3 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n30\n39\n22\n14\n12\n9\n11\n9\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n2 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n272\n251\n209\n205\n194\n171\n164\n159\n137\n132\n121\n114\n107\n102\n100\n80\n78\n66\n75\n72\n78\n69\n67\n73\n71\n"]}, {"input": "3 4 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n29\n27\n41\n21\n17\n13\n10\n14\n15\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n20\n22\n25\n29\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n2 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n10\n19\n9\n13\n11\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 2\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n18\n14\n12\n9\n6\n4\n"]}, {"input": "1000 1000 2\n494 634\n239 634\n", "output": ["1331884338\n1331183846\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n111\n99\n96\n91\n101\n86\n84\n91\n89\n"]}, {"input": "3 4 6\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n98\n78\n74\n62\n82\n79\n85\n76\n74\n80\n78\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n106\n99\n112\n109\n101\n99\n87\n84\n92\n108\n95\n93\n87\n85\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n96\n88\n74\n80\n96\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n96\n93\n79\n78\n66\n75\n72\n75\n66\n64\n70\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n170\n160\n128\n123\n116\n109\n102\n109\n102\n88\n87\n81\n76\n71\n81\n72\n74\n80\n77\n"]}, {"input": "3 3 3\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n57\n"]}, {"input": "1000 1000 2\n59 323\n239 587\n", "output": ["1333014458\n1332224196\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n78\n82\n71\n69\n73\n72\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 7\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n112\n110\n98\n91\n86\n96\n81\n79\n72\n75\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n1 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n144\n137\n136\n129\n109\n104\n114\n101\n103\n89\n92\n"]}, {"input": "3 4 10\n1 1\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n33\n22\n20\n28\n20\n26\n19\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 3\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n132\n125\n118\n115\n89\n87\n75\n84\n79\n87\n78\n76\n83\n81\n"]}, {"input": "1000 1000 2\n252 412\n239 877\n", "output": ["1332147258\n1331910896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n80\n72\n80\n71\n69\n75\n70\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n15\n10\n14\n11\n7\n"]}, {"input": "1000 1000 2\n59 722\n239 35\n", "output": ["1333201988\n1332990222\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n75\n73\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n2 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 1\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["25\n23\n31\n22\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 6\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n282\n259\n227\n220\n209\n187\n174\n166\n134\n130\n123\n116\n107\n114\n111\n97\n96\n84\n78\n73\n83\n74\n72\n81\n78\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n565\n560\n549\n532\n517\n511\n476\n473\n462\n455\n448\n455\n452\n445\n444\n420\n417\n404\n470\n457\n447\n449\n446\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 3\n1 3\n1 3\n3 3\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n77\n79\n77\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n85\n83\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["79\n77\n71\n73\n"]}, {"input": "6 3 4\n2 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 2\n2 3\n3 1\n", "output": ["69\n65\n63\n61\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n27\n25\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 10\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n278\n230\n223\n212\n189\n163\n157\n135\n130\n117\n114\n121\n124\n121\n95\n93\n79\n88\n83\n93\n84\n82\n87\n85\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n37\n32\n28\n31\n20\n18\n"]}, {"input": "1000 1000 2\n63 634\n239 24\n", "output": ["1333148892\n1333004160\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n137\n125\n120\n128\n144\n129\n127\n134\n126\n"]}, {"input": "3 3 4\n1 3\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["31\n23\n19\n20\n"]}, {"input": "3 3 4\n1 2\n1 2\n1 2\n1 3\n1 3\n3 3\n4 2\n5 2\n2 3\n3 1\n", "output": ["25\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n222\n217\n200\n169\n163\n128\n125\n114\n109\n99\n104\n101\n94\n93\n79\n76\n73\n78\n65\n63\n65\n62\n"]}, {"input": "2 4 1\n2 4\n1 6\n2 1\n1 2\n4 3\n3 2\n1 3\n0 4\n1 3\n3 1\n", "output": ["20\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 3\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n264\n216\n231\n220\n197\n158\n152\n145\n140\n129\n132\n121\n131\n127\n108\n96\n90\n101\n91\n87\n81\n79\n86\n85\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["132\n126\n138\n120\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 7\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n56\n54\n66\n68\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n143\n137\n145\n161\n131\n127\n134\n142\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n25\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n3 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n223\n213\n202\n179\n161\n153\n137\n126\n115\n108\n105\n100\n96\n76\n74\n66\n59\n56\n62\n53\n51\n57\n59\n"]}, {"input": "2 4 1\n1 2\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["17\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n185\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n29\n43\n33\n43\n33\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 8\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n346\n323\n306\n290\n246\n212\n206\n195\n172\n157\n151\n129\n124\n113\n106\n104\n111\n108\n88\n86\n82\n91\n86\n96\n87\n89\n95\n93\n"]}, {"input": "6 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["144\n128\n120\n130\n110\n78\n76\n71\n73\n65\n"]}, {"input": "3 8 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["115\n100\n98\n113\n90\n86\n79\n74\n81\n82\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n1 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n21\n19\n21\n25\n"]}, {"input": "1000 1000 2\n494 749\n239 634\n", "output": ["1332338588\n1331638096\n"]}, {"input": "5 10 15\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n1 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n106\n86\n82\n70\n90\n87\n93\n84\n82\n88\n86\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 4\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n104\n97\n84\n81\n78\n76\n64\n61\n69\n79\n68\n66\n63\n61\n"]}, {"input": "3 4 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["39\n33\n43\n33\n25\n15\n10\n15\n23\n21\n"]}, {"input": "3 3 4\n1 2\n1 3\n2 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n0 1\n", "output": ["25\n23\n12\n14\n"]}, {"input": "5 7 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["243\n216\n187\n192\n243\n227\n209\n162\n168\n184\n"]}, {"input": "5 10 30\n5 3\n5 8\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n372\n354\n328\n313\n297\n268\n234\n229\n218\n180\n165\n159\n124\n119\n112\n104\n97\n92\n89\n75\n74\n70\n79\n76\n79\n70\n72\n86\n83\n"]}, {"input": "3 4 4\n1 4\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["49\n41\n31\n35\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n5 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n69\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 4\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n119\n109\n98\n92\n88\n79\n77\n65\n78\n74\n78\n69\n67\n70\n69\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 4\n2 3\n3 1\n", "output": ["132\n126\n138\n148\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n3 3\n1 3\n1 3\n2 2\n3 2\n2 3\n2 1\n", "output": ["79\n77\n85\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 10\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n78\n70\n78\n69\n67\n73\n68\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n18\n11\n8\n6\n4\n"]}, {"input": "5 10 28\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 10\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n611\n606\n595\n548\n527\n521\n486\n480\n469\n462\n458\n465\n458\n451\n450\n420\n417\n404\n470\n457\n447\n450\n447\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 9\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n89\n87\n"]}, {"input": "6 3 4\n1 3\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["85\n89\n79\n75\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 1\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n15\n13\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 4\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n24\n20\n17\n21\n26\n37\n35\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n5 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n228\n213\n206\n171\n166\n151\n119\n112\n144\n151\n174\n170\n158\n153\n161\n177\n154\n152\n137\n128\n"]}, {"input": "6 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["536\n474\n446\n413\n358\n342\n336\n280\n267\n262\n245\n214\n208\n173\n170\n159\n154\n144\n149\n146\n139\n138\n116\n113\n108\n121\n108\n102\n104\n101\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 3\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n136\n130\n138\n144\n114\n102\n109\n114\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 2\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n14\n11\n14\n17\n"]}, {"input": "6 3 4\n1 1\n1 3\n2 2\n2 3\n1 3\n1 8\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n75\n62\n60\n"]}, {"input": "12 3 3\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n3 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "2 4 1\n1 4\n1 6\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 0\n", "output": ["25\n23\n31\n23\n"]}], "task_id": "codecontest/62", "prompt": "You are given a matrix, made up of n rows and m columns. The rows are labeled from top to bottom, and the columns are labeled from left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nAt the start, all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "repair_prompt": ["You are given a matrix, made up of n rows and m columns. The rows are labeled from top to bottom, and the columns are labeled from left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nAt the start, all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a matrix, made up of n rows and m columns. The rows are labeled from top to bottom, and the columns are labeled from left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one. Then, the third cell is 1 to the bottom from the second one. The fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nAt the start, all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a matrix, made up of n rows and m columns. Each cell of the matrix can be either free or locked. Let's call a path in the matrix a staircase if it: starts and ends in the free cell; visits only free cells; has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. In particular, a path, consisting of a single cell, is considered to be a staircase. Here are some examples of staircases: <image> At the start, all the cells of the matrix are free. You have to process q queries, each of them flips the state of a single cell so, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free. Print the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list[tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to flip.\n\n    Returns:\n        list[int]: List of integers where each integer is the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = np.ones((n, m), dtype=bool)\n    \n    # Function to count staircases in the current matrix state\n    def count_current_staircases() -> int:\n        # Count single cell staircases\n        count = np.sum(matrix)\n        \n        # Count zigzag staircases\n        for i in range(n):\n            for j in range(m):\n                if matrix[i, j]:\n                    # Check right-down-right pattern\n                    if j + 1 < m and i + 1 < n and matrix[i, j + 1] and matrix[i + 1, j + 1]:\n                        count += 1\n                    # Check down-right-down pattern\n                    if i + 1 < n and j + 1 < m and matrix[i + 1, j] and matrix[i + 1, j + 1]:\n                        count += 1\n        return count\n\n    results = []\n    for x, y in queries:\n        # Flip the state of the cell (x-1, y-1) because input is 1-based index\n        matrix[x - 1, y - 1] = not matrix[x - 1, y - 1]\n        \n        # Count staircases after the query\n        results.append(count_current_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a grid after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        List[int]: List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free\n    grid = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    def toggle_cell(x: int, y: int):\n        \"\"\"Toggle the state of the cell at position (x, y).\"\"\"\n        if grid[x][y]:\n            grid[x][y] = False\n            free_cells.remove((x, y))\n        else:\n            grid[x][y] = True\n            free_cells.add((x, y))\n    \n    def dfs(x: int, y: int, visited: set, pattern: int) -> int:\n        \"\"\"Perform DFS to count staircases starting from (x, y) following a specific pattern.\"\"\"\n        if (x, y) in visited or (x, y) not in free_cells:\n            return 0\n        visited.add((x, y))\n        count = 1  # Count the current cell as a valid staircase\n        if pattern == 0:\n            # Pattern 1: right, down, right, down...\n            if y + 1 < m:\n                count += dfs(x, y + 1, visited, 1)\n            if x + 1 < n:\n                count += dfs(x + 1, y, visited, 0)\n        else:\n            # Pattern 2: down, right, down, right...\n            if x + 1 < n:\n                count += dfs(x + 1, y, visited, 1)\n            if y + 1 < m:\n                count += dfs(x, y + 1, visited, 0)\n        return count\n    \n    results = []\n    for x, y in queries:\n        # Convert to zero-based index\n        x -= 1\n        y -= 1\n        toggle_cell(x, y)\n        \n        # Recalculate the number of unique staircases\n        visited = set()\n        total_staircases = 0\n        for cell in free_cells:\n            if cell not in visited:\n                total_staircases += dfs(cell[0], cell[1], visited, 0)\n                total_staircases += dfs(cell[0], cell[1], visited, 1)\n        \n        results.append(total_staircases)\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of distinct staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the matrix with all cells marked as free\n    matrix = [['free' for _ in range(m)] for _ in range(n)]\n    \n    # Helper function to perform DFS for right-down staircase\n    def dfs_right_down(x: int, y: int, visited: set) -> int:\n        if (x, y) in visited or matrix[x][y] == 'locked':\n            return 0\n        visited.add((x, y))\n        count = 1\n        if y + 1 < m and x + 1 < n and matrix[x][y + 1] == 'free' and matrix[x + 1][y + 1] == 'free':\n            count += dfs_right_down(x + 1, y + 1, visited)\n        return count\n\n    # Helper function to perform DFS for down-right staircase\n    def dfs_down_right(x: int, y: int, visited: set) -> int:\n        if (x, y) in visited or matrix[x][y] == 'locked':\n            return 0\n        visited.add((x, y))\n        count = 1\n        if x + 1 < n and y + 1 < m and matrix[x + 1][y] == 'free' and matrix[x + 1][y + 1] == 'free':\n            count += dfs_down_right(x + 1, y + 1, visited)\n        return count\n\n    # Function to count distinct staircases\n    def count_distinct_staircases() -> int:\n        visited = set()\n        total_staircases = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'free' and (i, j) not in visited:\n                    total_staircases += dfs_right_down(i, j, visited)\n                    total_staircases += dfs_down_right(i, j, visited)\n        return total_staircases\n\n    results = []\n    for x, y in queries:\n        # Toggle the state of the specified cell\n        matrix[x - 1][y - 1] = 'locked' if matrix[x - 1][y - 1] == 'free' else 'free'\n        # Count distinct staircases after the query\n        results.append(count_distinct_staircases())\n\n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\nfrom collections import deque\n\ndef count_staircases(matrix: np.ndarray, n: int, m: int) -> int:\n    \"\"\"Count the number of unique staircases in the matrix.\n\n    Args:\n        matrix (np.ndarray): The matrix representing free and locked cells.\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n\n    Returns:\n        int: The count of unique staircases.\n    \"\"\"\n    def is_valid(x, y):\n        \"\"\"Check if a cell is within bounds and free.\"\"\"\n        return 0 <= x < n and 0 <= y < m and matrix[x, y]\n\n    def bfs(start_x, start_y):\n        \"\"\"Perform BFS to find all staircases starting from a given cell.\"\"\"\n        queue = deque([(start_x, start_y, 0)])  # (x, y, direction)\n        visited = set()\n        visited.add((start_x, start_y))\n        count = 0\n\n        while queue:\n            x, y, direction = queue.popleft()\n            count += 1\n\n            # Zigzag pattern: right then down, or down then right\n            if direction == 0:  # Right then down\n                if is_valid(x, y + 1) and (x, y + 1) not in visited:\n                    visited.add((x, y + 1))\n                    queue.append((x, y + 1, 1))\n                if is_valid(x + 1, y) and (x + 1, y) not in visited:\n                    visited.add((x + 1, y))\n                    queue.append((x + 1, y, 0))\n            else:  # Down then right\n                if is_valid(x + 1, y) and (x + 1, y) not in visited:\n                    visited.add((x + 1, y))\n                    queue.append((x + 1, y, 0))\n                if is_valid(x, y + 1) and (x, y + 1) not in visited:\n                    visited.add((x, y + 1))\n                    queue.append((x, y + 1, 1))\n\n        return count\n\n    total_staircases = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i, j]:\n                total_staircases += bfs(i, j)\n\n    return total_staircases\n\ndef process_queries(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Process queries to flip cell states and count staircases.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list[tuple[int, int]]): List of queries to flip cell states.\n\n    Returns:\n        list[int]: List of staircase counts after each query.\n    \"\"\"\n    matrix = np.ones((n, m), dtype=bool)  # Initialize all cells as free\n    results = []\n\n    for x, y in queries:\n        # Flip the state of the cell\n        matrix[x - 1, y - 1] = not matrix[x - 1, y - 1]\n\n        # Count staircases\n        count = count_staircases(matrix, n, m)\n        results.append(count)\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Count the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        List[int]: List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to count staircases in the current matrix state\n    def count_staircases_in_matrix() -> int:\n        # Dynamic programming table to store the number of staircases ending at each cell\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n        \n        total_staircases = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:  # If the cell is free\n                    # A single cell is a valid staircase\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n                    total_staircases += 1\n                    \n                    # Check for staircases ending at (i, j) coming from the left\n                    if j > 0 and matrix[i][j - 1]:\n                        dp_right[i][j] += dp_down[i][j - 1]\n                    \n                    # Check for staircases ending at (i, j) coming from above\n                    if i > 0 and matrix[i - 1][j]:\n                        dp_down[i][j] += dp_right[i - 1][j]\n                    \n                    # Add the new staircases to the total count\n                    total_staircases += dp_right[i][j] - 1\n                    total_staircases += dp_down[i][j] - 1\n        \n        return total_staircases\n    \n    results = []\n    \n    for x, y in queries:\n        # Toggle the state of the cell (x-1, y-1) because input is 1-based index\n        matrix[x - 1][y - 1] = not matrix[x - 1][y - 1]\n        \n        # Count staircases after the toggle\n        results.append(count_staircases_in_matrix())\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Count the number of different staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of different staircases after each query.\n    \"\"\"\n    # Initialize matrix and free cells set\n    matrix = np.ones((n, m), dtype=bool)\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n\n    def toggle_cell(x: int, y: int):\n        \"\"\"Toggle the state of a cell in the matrix.\"\"\"\n        if (x, y) in free_cells:\n            free_cells.remove((x, y))\n            matrix[x, y] = False\n        else:\n            free_cells.add((x, y))\n            matrix[x, y] = True\n\n    def count_staircases_dfs() -> int:\n        \"\"\"Count staircases using DFS.\"\"\"\n        visited = set()\n        staircase_count = 0\n\n        def dfs(x: int, y: int, direction: int):\n            \"\"\"Perform DFS to find staircases.\"\"\"\n            if (x, y) in visited or not matrix[x, y]:\n                return\n            visited.add((x, y))\n            if direction == 0:  # Right then down\n                if y + 1 < m and matrix[x, y + 1]:\n                    dfs(x, y + 1, 1)\n                if x + 1 < n and matrix[x + 1, y]:\n                    dfs(x + 1, y, 0)\n            else:  # Down then right\n                if x + 1 < n and matrix[x + 1, y]:\n                    dfs(x + 1, y, 0)\n                if y + 1 < m and matrix[x, y + 1]:\n                    dfs(x, y + 1, 1)\n\n        for cell in free_cells:\n            if cell not in visited:\n                dfs(cell[0], cell[1], 0)\n                dfs(cell[0], cell[1], 1)\n                staircase_count += 1\n\n        return staircase_count\n\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)\n        results.append(count_staircases_dfs())\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresult = count_staircases(n, m, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True represents free, False represents locked)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to check if a cell is within bounds and free\n    def is_free(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m and matrix[x][y]\n\n    # Function to count staircases starting from a given cell\n    def count_staircases_from(x: int, y: int) -> int:\n        if not is_free(x, y):\n            return 0\n        \n        # Initialize staircase count\n        count = 1  # Single cell is a valid staircase\n        \n        # Check zigzag pattern 1: right, down, right, down...\n        i, j = x, y\n        while is_free(i, j + 1) and is_free(i + 1, j + 1):\n            count += 1\n            j += 1\n            i += 1\n        \n        # Reset i, j for the second pattern\n        i, j = x, y\n        # Check zigzag pattern 2: down, right, down, right...\n        while is_free(i + 1, j) and is_free(i + 1, j + 1):\n            count += 1\n            i += 1\n            j += 1\n        \n        return count\n\n    # List to store results after each query\n    results = []\n\n    # Process each query\n    for x, y in queries:\n        # Toggle the state of the cell\n        matrix[x - 1][y - 1] = not matrix[x - 1][y - 1]\n        \n        # Recalculate the number of unique staircases\n        total_staircases = 0\n        for i in range(n):\n            for j in range(m):\n                total_staircases += count_staircases_from(i, j)\n        \n        # Append the result for the current query\n        results.append(total_staircases)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef count_staircases(n: int, m: int, queries: list) -> list:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list): List of queries where each query is a tuple (x, y) indicating\n                        the cell to flip.\n\n    Returns:\n        list: A list of integers where each integer represents the number of unique\n              staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = np.ones((n, m), dtype=bool)\n    \n    # Function to count staircases in the current matrix\n    def count_current_staircases() -> int:\n        # Dynamic programming table to store the number of staircases ending at each cell\n        dp_right = np.zeros((n, m), dtype=int)\n        dp_down = np.zeros((n, m), dtype=int)\n        \n        # Initialize the count of staircases\n        total_staircases = 0\n        \n        # Iterate over each cell in the matrix\n        for i in range(n):\n            for j in range(m):\n                if matrix[i, j]:  # If the cell is free\n                    # A single cell is a staircase\n                    dp_right[i, j] = 1\n                    dp_down[i, j] = 1\n                    total_staircases += 1\n                    \n                    # Check for staircases ending to the right\n                    if j > 0 and matrix[i, j - 1]:\n                        dp_right[i, j] += dp_down[i, j - 1]\n                    \n                    # Check for staircases ending downwards\n                    if i > 0 and matrix[i - 1, j]:\n                        dp_down[i, j] += dp_right[i - 1, j]\n                    \n                    # Add the new staircases to the total count\n                    total_staircases += dp_right[i, j] - 1\n                    total_staircases += dp_down[i, j] - 1\n        \n        return total_staircases\n\n    # List to store the results after each query\n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Flip the state of the cell (x-1, y-1) because input is 1-based\n        matrix[x - 1, y - 1] = not matrix[x - 1, y - 1]\n        \n        # Recalculate the number of unique staircases\n        results.append(count_current_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query toggles the state of a cell.\n\n    Returns:\n        List[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Initialize staircase counts\n    horizontal_staircases = [[0] * m for _ in range(n)]\n    vertical_staircases = [[0] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = not matrix[x][y]\n        update_staircases(x, y)\n\n    # Function to update staircase counts\n    def update_staircases(x: int, y: int):\n        # Update horizontal staircases\n        if matrix[x][y]:\n            horizontal_staircases[x][y] = (horizontal_staircases[x][y - 1] if y > 0 else 0) + 1\n        else:\n            horizontal_staircases[x][y] = 0\n        \n        # Update vertical staircases\n        if matrix[x][y]:\n            vertical_staircases[x][y] = (vertical_staircases[x - 1][y] if x > 0 else 0) + 1\n        else:\n            vertical_staircases[x][y] = 0\n\n    # Function to count unique staircases\n    def count_unique_staircases() -> int:\n        total_staircases = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    total_staircases += horizontal_staircases[i][j] + vertical_staircases[i][j] - 1\n        return total_staircases\n\n    # Initialize staircase counts for the initial matrix\n    for i in range(n):\n        for j in range(m):\n            update_staircases(i, j)\n\n    results = []\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        x -= 1\n        y -= 1\n        \n        # Toggle the cell state\n        toggle_cell(x, y)\n        \n        # Count the staircases after the toggle\n        staircase_count = count_unique_staircases()\n        \n        # Store the result\n        results.append(staircase_count)\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output results\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = [[True for _ in range(m)] for _ in range(n)]\n    \n    # Function to count staircases starting from a given cell\n    def count_staircases_from(x: int, y: int) -> int:\n        if not matrix[x][y]:\n            return 0\n        \n        # Count single cell staircase\n        count = 1\n        \n        # Check for staircases starting with right then down\n        i, j = x, y\n        while i < n - 1 and j < m - 1:\n            j += 1\n            if not matrix[i][j]:\n                break\n            i += 1\n            if not matrix[i][j]:\n                break\n            count += 1\n        \n        # Check for staircases starting with down then right\n        i, j = x, y\n        while i < n - 1 and j < m - 1:\n            i += 1\n            if not matrix[i][j]:\n                break\n            j += 1\n            if not matrix[i][j]:\n                break\n            count += 1\n        \n        return count\n    \n    # Process each query\n    results = []\n    total_staircases = 0\n    \n    # Pre-calculate initial staircases\n    for i in range(n):\n        for j in range(m):\n            total_staircases += count_staircases_from(i, j)\n    \n    for x, y in queries:\n        # Convert to zero-based index\n        x -= 1\n        y -= 1\n        \n        # Toggle the state of the specified cell\n        matrix[x][y] = not matrix[x][y]\n        \n        # Recalculate staircases affected by the toggle\n        affected_staircases = 0\n        for i in range(max(0, x-1), min(n, x+2)):\n            for j in range(max(0, y-1), min(m, y+2)):\n                affected_staircases += count_staircases_from(i, j)\n        \n        # Update total staircases\n        total_staircases = affected_staircases\n        \n        # Append the number of unique staircases to results\n        results.append(total_staircases)\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to efficiently handle a matrix of up to 1000x1000 cells and process up to 10,000 queries. Each query flips the state of a cell, and the task is to count the number of unique staircase paths after each query. The solution must be optimized for performance given the potential size of the input.\nrequirement pool:\n- Efficiently process up to 10,000 queries on a 1000x1000 matrix.\n- Accurately count unique staircase paths after each query.\n- Optimize the solution for performance with large inputs.\n- Provide clear output for each query result.\n- Ensure the solution is easy to understand and maintain.\nWe will use a combination of data structures to efficiently track the state of the matrix and count the number of unique staircase paths. The key challenge is to update the path count dynamically as each query flips the state of a cell. We will leverage numpy for efficient matrix operations and use a custom function to count paths based on the staircase definition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern (either right-down-right or down-right-down).\n\n    'query'\n    Explanation: An operation that flips the state of a specific cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the current cell by +1 in the respective direction (right or down).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix of size n x m with all cells marked as free.\n2. For each query, flip the state of the specified cell.\n3. After each query, count the number of unique staircases:\n   - Use a function to traverse the matrix and identify valid staircases based on the defined patterns.\n   - Keep track of visited cells to ensure each staircase is counted only once.\n4. Output the count of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A 1x1 matrix with 1 query flipping the only cell.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: Flipping the only cell makes it locked, so no staircases are possible.\n\n    Edge Case 2: A 2x2 matrix with all cells initially free and no queries.\n    Input: 2 2 0\n    Expected Output: No output since there are no queries, but initially, there are 5 staircases (each cell individually and two zigzag paths).\n\n    Edge Case 3: A large matrix (1000x1000) with a single query flipping a corner cell.\n    Input: 1000 1000 1\n           1 1\n    Expected Output: A large number representing all possible staircases minus those affected by the flipped corner cell.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the matrix size is minimal or when queries affect critical path cells.\n    \n```python\ndef handle_edge_cases(matrix, queries):\n    # Example code to handle edge cases\n    if len(matrix) == 1 and len(matrix[0]) == 1:\n        return [0] * len(queries)\n    \n    # Additional logic for other edge cases\n```\n\nThis code snippet is a placeholder to illustrate where additional logic might be needed to handle specific edge cases effectively.\n", "requirement analysis:\nThe task requires processing a matrix to identify and count unique staircase paths after each query. The challenge lies in efficiently updating the count of staircases as cells are toggled between free and locked states. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently handle matrix updates and query processing.\n- Accurately count and differentiate staircase paths.\n- Optimize performance for large matrices and high query volumes.\n- Provide clear output format as specified in requirements.\n- Implement user-friendly input and output handling.\nWe will use a matrix to represent the grid and a set to keep track of free cells. For each query, we will toggle the state of the specified cell and recalculate the number of unique staircases using a depth-first search (DFS) approach. This will allow us to efficiently explore all possible staircase paths starting from each free cell.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    A grid of n rows and m columns where each cell can be either free or locked.\n\n    'staircase'\n    A path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific patterns.\n\n    'query'\n    An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    These phrases describe the movement pattern of the staircase path, indicating a step to the adjacent cell in the specified direction.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix to represent the grid and a set to track free cells.\n2. For each query, toggle the state of the specified cell.\n3. Use a depth-first search (DFS) to explore all possible staircase paths starting from each free cell.\n4. Count and store the number of unique staircases after each query.\n5. Output the number of unique staircases for each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially free and a single query that locks one cell.\n    Explanation: The number of staircases will decrease by the number of staircases that included the locked cell.\n\n    Edge Case 2: A matrix with all cells initially locked and a single query that frees one cell.\n    Explanation: The number of staircases will increase by 1, as a single-cell staircase is now possible.\n\n    Edge Case 3: A matrix with alternating free and locked cells, and a query that toggles a central cell.\n    Explanation: The number of staircases may change significantly depending on how the central cell affects connectivity.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement a function to toggle the state of a cell.\n        - Implement DFS to explore staircase paths efficiently.\n        - Ensure that toggling a cell updates the set of free cells correctly.\n        - Recalculate staircases only for affected areas to optimize performance.\n", "requirement analysis:\nThe requirements focus on processing queries to flip cell states in a matrix and counting distinct staircases. The solution must handle large matrices and numerous queries efficiently, ensuring accurate staircase differentiation.\nrequirement pool:\n- Efficient query processing to update matrix state\n- Accurate counting of distinct staircases\n- Scalability for large matrices and numerous queries\n- User-friendly input and output format\n- Robust error handling\nWe will use a matrix to represent the grid and a set to keep track of free cells. For each query, we will toggle the state of the specified cell and recalculate the number of distinct staircases using a depth-first search (DFS) approach. This will allow us to efficiently explore all possible paths and count distinct staircases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix': A grid structure with rows and columns where each cell can be either free or locked.\n    'staircase': A path in the matrix that follows specific movement rules and consists only of free cells.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom': These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix with all cells marked as free.\n    2. For each query, toggle the state of the specified cell.\n    3. Use DFS to explore all possible staircase paths starting from each free cell.\n    4. Count distinct paths by ensuring no overlap in visited cells between paths.\n    5. Output the count of distinct staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist, so the output for each query will be 0.\n    \n    Edge Case 2: A matrix with only one cell.\n    Explanation: The single cell is a staircase itself if it is free, so the output will be 1 if free, 0 if locked.\n    \n    Edge Case 3: A matrix where all queries toggle the same cell repeatedly.\n    Explanation: The number of staircases will alternate between a count based on the initial state and zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            # Special handling for single-cell matrix\n            return [1 if matrix[0][0] == 'free' else 0 for _ in range(q)]\n        elif all(matrix[i][j] == 'locked' for i in range(n) for j in range(m)):\n            # Special handling for fully locked matrix\n            return [0 for _ in range(q)]\n        # Other logic for handling repeated toggling of the same cell\n        (other code)\n", "requirement analysis:\nThe task requires processing a matrix with dynamic updates and counting specific path structures called staircases. The solution must efficiently handle up to 10,000 queries on matrices as large as 1000x1000, ensuring accurate and timely outputs. The challenge lies in maintaining performance while updating the matrix state and recalculating the number of unique staircases after each query.\nrequirement pool:\n- Efficiently update matrix state after each query\n- Accurately count the number of different staircases\n- Optimize for large matrix sizes and numerous queries\n- Provide clear and correct output for each query\n- Ensure the solution is user-friendly and easy to understand\nWe will use a combination of a matrix representation and efficient path counting algorithms to handle the dynamic updates and staircase counting. The key challenge is efficiently updating the matrix state and recalculating the number of unique staircases after each query. We will leverage NumPy for efficient matrix operations and use a custom algorithm to count staircases based on the matrix state.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix of size n x m with all cells marked as free.\n2. For each query, flip the state of the specified cell.\n3. After each query, count the number of unique staircases:\n   - Use a depth-first search (DFS) or breadth-first search (BFS) to explore all possible staircase paths starting from each free cell.\n   - Ensure paths follow the zigzag pattern as described.\n   - Keep track of visited cells to avoid counting duplicate paths.\n4. Output the count of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist, so the output should be 0 after each query.\n\n    Edge Case 2: A single cell matrix (1x1).\n    Explanation: The only possible staircase is the single cell itself if it is free. The output should be 1 if the cell is free and 0 if it is locked.\n\n    Edge Case 3: A matrix with alternating free and locked cells in a checkerboard pattern.\n    Explanation: Depending on the starting point of the staircase, some paths may not be possible. The output will vary based on the specific queries.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For a single cell matrix, directly check if the cell is free or locked and return 1 or 0 accordingly.\n    - For matrices with all cells initially locked, ensure that no paths are counted until a cell is flipped to free.\n\n```python\ndef count_staircases(matrix, n, m):\n    # Implement DFS/BFS to count staircases\n    pass\n\ndef process_queries(n, m, queries):\n    matrix = [[True] * m for _ in range(n)]  # Initialize all cells as free\n    results = []\n    \n    for x, y in queries:\n        # Flip the state of the cell\n        matrix[x-1][y-1] = not matrix[x-1][y-1]\n        \n        # Count staircases\n        count = count_staircases(matrix, n, m)\n        results.append(count)\n    \n    return results\n```\n\nThis code provides a framework for handling queries and counting staircases, with placeholders for implementing the actual path counting logic.\n", "requirement analysis:\nThe task requires processing a matrix with dynamic cell states and calculating the number of unique staircases after each query. The solution must handle large matrices and a high number of queries efficiently, ensuring accurate results.\nrequirement pool:\n- Efficiently handle matrix state changes and query processing.\n- Accurately calculate the number of unique staircases after each query.\n- Optimize performance for large matrices and high query volumes.\n- Ensure the solution is scalable and can handle edge cases.\n- Provide clear and concise output for each query.\nWe will use a matrix to represent the grid and a set to track the free cells. For each query, we will toggle the state of the specified cell and recalculate the number of unique staircases. To efficiently count staircases, we will use a dynamic programming approach to track possible paths and update them as cells are toggled. Libraries like NumPy can be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to track free cells.\n    2. For each query, toggle the state of the specified cell.\n    3. Use dynamic programming to count possible staircase paths:\n        - Track paths that follow the zigzag pattern.\n        - Update paths as cells are toggled.\n    4. Use efficient matrix operations (e.g., NumPy) to handle large matrices.\n    5. Output the number of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: Matrix with all cells initially free and no queries.\n    Expected Output: Number of staircases equals the number of free cells since each cell can be a staircase on its own.\n    Explanation: Each free cell is a valid staircase.\n\n    Edge Case 2: Matrix with all cells initially locked and no queries.\n    Expected Output: 0\n    Explanation: No staircases can exist as there are no free cells.\n\n    Edge Case 3: A single query that toggles a cell in a matrix with only one row or one column.\n    Expected Output: Depends on initial state; if initially free, toggling reduces staircases; if initially locked, toggling increases staircases.\n    Explanation: The change in state directly affects the count of staircases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 0 or m == 0:\n            return [0] * q\n        if all_locked_initially:\n            return [0] * q\n        # Additional logic to handle single row/column matrices and toggle effects\n        (other code)\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to update the matrix state and accurately counting staircases. The solution must handle large matrices and numerous queries, ensuring scalability and performance.\nrequirement pool:\n- Efficient query processing to update matrix state\n- Accurate counting and differentiation of staircases\n- Scalability for large matrices and numerous queries\n- User-friendly input and output format\n- Optimization for performance in high query volume scenarios\nWe will use a matrix to represent the grid and a set to track free cells. For each query, we will toggle the state of the specified cell and recalculate the number of staircases using a depth-first search (DFS) approach. This will efficiently handle the matrix updates and staircase counting. We will use NumPy for efficient matrix operations and collections for managing sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific pattern of movement (either right then down or down then right).\n\n    'query'\n    An operation that flips the state of a specified cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    These phrases describe the movement pattern of the staircase path, indicating a step to the adjacent cell in the specified direction.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix to represent the grid and a set to track free cells.\n2. For each query, toggle the state of the specified cell.\n3. Use a depth-first search (DFS) approach to recalculate the number of staircases:\n   - Start from each free cell and attempt to build a staircase path following the defined patterns.\n   - Track visited cells to avoid counting the same path multiple times.\n4. After processing each query, output the number of different staircases.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially free and no queries.\n    Explanation: The number of staircases is determined by all possible paths that can be formed in the matrix.\n\n    Edge Case 2: A matrix with all cells initially locked and no queries.\n    Explanation: There are no staircases since all cells are locked.\n\n    Edge Case 3: A single cell matrix with one query that toggles its state.\n    Explanation: The number of staircases will be 1 when the cell is free and 0 when it is locked.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For an empty matrix or fully locked matrix, return 0 staircases.\n    - For a single cell matrix, handle toggling directly without DFS.\n\n```python\ndef process_queries(n, m, q, queries):\n    # Initialize matrix and free cells set\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    def toggle_cell(x, y):\n        if (x, y) in free_cells:\n            free_cells.remove((x, y))\n        else:\n            free_cells.add((x, y))\n    \n    def count_staircases():\n        # Implement DFS or other logic to count staircases\n        pass\n    \n    results = []\n    for x, y in queries:\n        toggle_cell(x-1, y-1)\n        results.append(count_staircases())\n    \n    return results\n```\n\nThis code provides a basic structure for handling queries and counting staircases. The `count_staircases` function needs to be implemented with DFS logic to accurately count paths based on the current state of the matrix.\n", "requirement analysis:\nThe requirement is to efficiently calculate the number of unique staircases in a matrix after each query that toggles the state of a cell. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently process matrix queries to update staircase counts.\n- Ensure accurate calculation of unique staircases.\n- Optimize performance for large matrices and high query volumes.\n- Provide clear and understandable output for users.\n- Implement a user-friendly interface for input and output.\nWe will use a combination of data structures to efficiently track the state of the matrix and the number of unique staircases. A 2D list will represent the matrix, where each cell can be toggled between free and locked. We will use a set to keep track of unique staircases by storing their starting and ending points. For each query, we will update the matrix and recalculate the number of staircases by checking possible paths from each free cell. This approach ensures that we can handle large matrices and a high number of queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that toggles the state of a specific cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the matrix, with all cells initially set to free.\n2. For each query, toggle the state of the specified cell.\n3. After each query, recalculate the number of unique staircases:\n   - Iterate over each cell in the matrix.\n   - For each free cell, attempt to construct a staircase path following the defined patterns.\n   - Use a set to track unique staircases by storing their starting and ending points.\n4. Output the number of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist if all cells are locked. The output should be 0 after each query unless a cell is toggled to free.\n\n    Edge Case 2: A single cell matrix (1x1).\n    Explanation: The only possible staircase is the single cell itself if it is free. The output should be 1 if the cell is free and 0 if it is locked.\n\n    Edge Case 3: A matrix with alternating free and locked cells in a checkerboard pattern.\n    Explanation: Depending on the initial state and queries, staircases may be limited due to blocked paths. The output will vary based on specific queries.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For a single cell matrix, directly check if the cell is free or locked and return 1 or 0 accordingly.\n    - For matrices with all cells initially locked, ensure that no staircases are counted until a cell is toggled to free.\n    - Implement logic to efficiently handle checkerboard patterns by checking adjacent cells' states before attempting to form staircases.\n", "requirement analysis:\nThe task requires efficiently processing a matrix to count unique staircase paths after each query. The challenge lies in handling large matrices and numerous queries while maintaining performance and accuracy. The solution should dynamically update the matrix state and recalculate the number of staircases efficiently.\nrequirement pool:\n- Efficiently handle matrix state changes and query processing.\n- Accurately count and differentiate unique staircase paths.\n- Optimize performance for large matrices and high query volumes.\n- Provide clear output for each query result.\n- Implement a user-friendly interface for input and output.\nWe will use a dynamic programming approach to efficiently count the number of unique staircases after each query. The matrix will be represented as a 2D list, and we will maintain a separate data structure to track the number of staircases. We will use the NumPy library for efficient matrix operations and updates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix': A 2D grid of cells, each of which can be either free or locked.\n    'staircase': A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n    'query': An operation that flips the state of a single cell in the matrix.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix of size n x m with all cells marked as free.\n2. For each query, flip the state of the specified cell (free to locked or locked to free).\n3. After each query, recalculate the number of unique staircases:\n   - Use dynamic programming to track possible staircases starting from each free cell.\n   - Consider both zigzag patterns for each starting cell.\n   - Count unique staircases by ensuring no overlap in paths.\n4. Output the number of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Input: 2 2 1\n           1 1\n    Expected Output: 0\n    Explanation: No free cells to form a staircase.\n\n    Edge Case 2: A single cell matrix.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: Flipping the only cell doesn't create a staircase.\n\n    Edge Case 3: A matrix with alternating free and locked cells.\n    Input: 3 3 2\n           1 1\n           2 2\n    Expected Output: Depends on initial configuration and queries, but should handle alternating patterns correctly.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the matrix is too small or has no free cells initially. \n    - Check if the matrix is entirely locked initially and return 0 for all queries.\n    - Handle single-cell matrices by checking if flipping creates a valid path (which it won't).\n", "requirement analysis:\nThe requirement is to efficiently calculate the number of unique staircases in a matrix after each query that toggles the state of a cell. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently process matrix queries to update staircase counts.\n- Accurately calculate the number of unique staircases after each query.\n- Optimize the algorithm for large matrices and high query volumes.\n- Provide clear output for each query result.\n- Implement a user-friendly interface for input and output.\nWe will use a combination of data structures to efficiently track the state of the matrix and calculate the number of unique staircases. The approach involves using a 2D list to represent the matrix and a set to store unique staircases. For each query, we will toggle the state of the specified cell and update the staircase count accordingly. The algorithm will be optimized to handle large matrices and high query volumes by minimizing redundant calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix': A grid-like structure consisting of rows and columns where each cell can be either free or locked.\n    'staircase': A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom': These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the matrix, marking all cells as free initially.\n    2. Create a function to toggle the state of a cell based on the query.\n    3. Implement a function to count unique staircases by checking possible paths from each free cell.\n    4. For each query, toggle the cell state and recalculate the number of unique staircases.\n    5. Store and print the result after each query.\n\n# [edge case]\n    Edge Case 1: Matrix with all cells initially locked (e.g., 2x2 matrix with queries that lock all cells)\n    Expected Output: 0\n    Explanation: No staircases can exist if all cells are locked.\n\n    Edge Case 2: Matrix with only one cell (e.g., 1x1 matrix)\n    Expected Output: 1\n    Explanation: A single free cell is considered a staircase.\n\n    Edge Case 3: Large matrix with no queries (e.g., 1000x1000 matrix with no queries)\n    Expected Output: Large number of staircases\n    Explanation: All cells are free, allowing maximum possible staircases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            print(1)\n            return\n        elif all cells are locked:\n            print(0)\n            return\n        (other code for handling queries and counting staircases)\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to update the matrix state and accurately counting staircases. The solution must handle large matrices and provide output after each query, ensuring performance optimization and differentiation of staircases.\nrequirement pool:\n- Efficient query processing to update matrix state\n- Accurate counting and differentiation of staircases\n- Optimize performance for large matrices\n- User-friendly input and output format\n- Scalable solution for varying matrix sizes\nWe will use a matrix to represent the grid and a set to track the unique staircases. For each query, we will toggle the state of the specified cell and recalculate the number of unique staircases. The recalculation will involve checking possible staircase paths starting from each free cell. We will use efficient data structures to ensure that the solution can handle large matrices and a high number of queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array consisting of rows and columns. In this requirement, it represents the grid where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific structures: alternating right and down movements or alternating down and right movements.\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix, changing it from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid with all cells initially free.\n    2. Initialize a set to track unique staircases.\n    3. For each query:\n        - Toggle the state of the specified cell.\n        - Recalculate the number of unique staircases by checking possible paths starting from each free cell.\n        - Use efficient data structures to handle large matrices and numerous queries.\n    4. Output the number of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: Matrix with all cells initially locked\n    Explanation: If all cells are locked, no staircases can exist. The expected output after any query would be 0.\n\n    Edge Case 2: Matrix with only one cell\n    Explanation: A single cell matrix can only have one staircase if the cell is free. The expected output would be 1 if the cell is free, 0 if locked.\n\n    Edge Case 3: Queries that toggle the same cell repeatedly\n    Explanation: Repeatedly toggling the same cell will alternate between allowing and disallowing staircases involving that cell. The output will reflect these changes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            # Handle single cell matrix separately\n            return [1 if matrix[0][0] == 'free' else 0 for _ in range(q)]\n        \n        # Handle all locked cells scenario\n        if all(matrix[i][j] == 'locked' for i in range(n) for j in range(m)):\n            return [0 for _ in range(q)]\n        \n        # Additional logic for toggling same cell repeatedly\n        # Efficiently update staircase count without recalculating entire matrix each time\n"], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 87, "examples": "\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "mutate_method": "rephrase_one", "parent_index": 27}
