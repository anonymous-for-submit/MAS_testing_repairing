{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows is at least 5 and columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows is at least 5 and columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block. CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows is at least 5. Additionally, the number of columns must be at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks, and each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows is at least 5 and columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(n: int, m: int, grid: list[str]) -> int:\n    \"\"\"Calculate the minimum number of operations needed to form a portal.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[str]): The grid represented as a list of strings.\n\n    Returns:\n        int: Minimum number of operations required to form a portal.\n    \"\"\"\n    # Convert grid to a numpy array for efficient manipulation\n    grid_array = np.array([list(row) for row in grid], dtype=int)\n    \n    # Initialize the minimum operations to a large number\n    min_operations = float('inf')\n    \n    # Iterate over all possible sub-rectangles of size at least 5x4\n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            for end_row in range(start_row + 4, n):\n                for end_col in range(start_col + 3, m):\n                    # Calculate the number of operations for the current sub-rectangle\n                    operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                    # Update the minimum operations if the current one is smaller\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n    \n    # Check the borders\n    for i in range(start_row + 1, end_row):\n        if grid[i, start_col] != 1:\n            operations += 1\n        if grid[i, end_col] != 1:\n            operations += 1\n    \n    for j in range(start_col + 1, end_col):\n        if grid[start_row, j] != 1:\n            operations += 1\n        if grid[end_row, j] != 1:\n            operations += 1\n    \n    # Check the inner blocks\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i, j] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    # Output interface\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The grid represented as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure border blocks are obsidian\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] == 0:\n            operations += 1\n        if matrix[x, end_col] == 0:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] == 0:\n            operations += 1\n        if matrix[end_row, y] == 0:\n            operations += 1\n\n    # Ensure inner blocks are empty\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the borders\n    for x in range(start_row + 1, end_row):\n        if grid[x][start_col] != '1':\n            operations += 1\n        if grid[x][end_col] != '1':\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row][y] != '1':\n            operations += 1\n        if grid[end_row][y] != '1':\n            operations += 1\n\n    # Check the inner blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x][y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(start_row + 1, end_row):\n        if grid[x][start_col] != '1':\n            operations += 1\n        if grid[x][end_col] != '1':\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row][y] != '1':\n            operations += 1\n        if grid[end_row][y] != '1':\n            operations += 1\n\n    # Check the inner conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x][y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a list of strings representing the rectangle.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = calculate_operations(case, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(rectangle: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        rectangle (List[str]): The rectangle represented as a list of strings.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(start_row, start_row + a):\n        for y in range(start_col, start_col + b):\n            if x == start_row or x == start_row + a - 1:\n                if start_col < y < start_col + b - 1:\n                    if rectangle[x][y] != '1':\n                        operations += 1\n            elif y == start_col or y == start_col + b - 1:\n                if start_row < x < start_row + a - 1:\n                    if rectangle[x][y] != '1':\n                        operations += 1\n            else:\n                if rectangle[x][y] != '0':\n                    operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        rectangle = [input().strip() for _ in range(n)]\n        test_cases.append(rectangle)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing n, m, and the grid as a list of strings.\n\n    Returns:\n    list: A list of integers representing the minimum operations for each test case.\n    \"\"\"\n    def calculate_operations(sub_rectangle: np.ndarray, a: int, b: int) -> int:\n        \"\"\"\n        Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n        Parameters:\n        sub_rectangle (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n        Returns:\n        int: The number of operations needed.\n        \"\"\"\n        operations = 0\n        # Check the border conditions\n        for x in range(1, a - 1):\n            if sub_rectangle[x, 0] != 1:\n                operations += 1\n            if sub_rectangle[x, b - 1] != 1:\n                operations += 1\n        for y in range(1, b - 1):\n            if sub_rectangle[0, y] != 1:\n                operations += 1\n            if sub_rectangle[a - 1, y] != 1:\n                operations += 1\n        # Check the inner conditions\n        for x in range(1, a - 1):\n            for y in range(1, b - 1):\n                if sub_rectangle[x, y] != 0:\n                    operations += 1\n        return operations\n\n    def find_min_operations(rectangle: np.ndarray, n: int, m: int) -> int:\n        \"\"\"\n        Find the minimum number of operations needed to transform any sub-rectangle into a portal.\n\n        Parameters:\n        rectangle (np.ndarray): The grid representing the rectangle.\n        n (int): Number of rows in the rectangle.\n        m (int): Number of columns in the rectangle.\n\n        Returns:\n        int: The minimum number of operations needed.\n        \"\"\"\n        min_operations = float('inf')\n        a, b = 5, 4  # Minimum dimensions for a portal\n        for i in range(n - a + 1):\n            for j in range(m - b + 1):\n                sub_rectangle = rectangle[i:i + a, j:j + b]\n                operations = calculate_operations(sub_rectangle, a, b)\n                min_operations = min(min_operations, operations)\n        return min_operations\n\n    results = []\n    for n, m, grid in test_cases:\n        rectangle = np.array([[int(char) for char in line] for line in grid])\n        result = find_min_operations(rectangle, n, m)\n        results.append(result)\n    return results\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a matrix of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    def check_if_already_portal(sub_rectangle: np.ndarray) -> bool:\n        \"\"\"Check if the given sub-rectangle already meets the portal criteria.\n\n        Args:\n            sub_rectangle (np.ndarray): Sub-rectangle to check.\n\n        Returns:\n            bool: True if the sub-rectangle is already a portal, False otherwise.\n        \"\"\"\n        a, b = sub_rectangle.shape\n        for x in range(1, a - 1):\n            if sub_rectangle[x, 0] != '1' or sub_rectangle[x, b - 1] != '1':\n                return False\n        for y in range(1, b - 1):\n            if sub_rectangle[0, y] != '1' or sub_rectangle[a - 1, y] != '1':\n                return False\n        for x in range(1, a - 1):\n            for y in range(1, b - 1):\n                if sub_rectangle[x, y] != '0':\n                    return False\n        return True\n\n    def calculate_operations(sub_rectangle: np.ndarray) -> int:\n        \"\"\"Calculate the number of operations needed to transform the sub-rectangle into a portal.\n\n        Args:\n            sub_rectangle (np.ndarray): Sub-rectangle to transform.\n\n        Returns:\n            int: Number of operations needed.\n        \"\"\"\n        a, b = sub_rectangle.shape\n        operations = 0\n        for x in range(1, a - 1):\n            if sub_rectangle[x, 0] != '1':\n                operations += 1\n            if sub_rectangle[x, b - 1] != '1':\n                operations += 1\n        for y in range(1, b - 1):\n            if sub_rectangle[0, y] != '1':\n                operations += 1\n            if sub_rectangle[a - 1, y] != '1':\n                operations += 1\n        for x in range(1, a - 1):\n            for y in range(1, b - 1):\n                if sub_rectangle[x, y] != '0':\n                    operations += 1\n        return operations\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        matrix = np.array([list(row) for row in test_case])\n        min_operations = float('inf')\n\n        for i in range(n - 4):\n            for j in range(m - 3):\n                sub_rectangle = matrix[i:i+5, j:j+4]\n                if check_if_already_portal(sub_rectangle):\n                    min_operations = 0\n                    break\n                operations = calculate_operations(sub_rectangle)\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append(matrix)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions (n, m) and a matrix of n lines with m characters.\n\n    Returns:\n        list: List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n\n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid[i:i + a, j:j + b]\n\n                        # Calculate the number of operations needed\n                        operations = 0\n\n                        # Check the border conditions\n                        # Top and bottom borders\n                        operations += np.sum(sub_rect[0, 1:b-1] == 0)  # Top border\n                        operations += np.sum(sub_rect[a-1, 1:b-1] == 0)  # Bottom border\n\n                        # Left and right borders\n                        operations += np.sum(sub_rect[1:a-1, 0] == 0)  # Left border\n                        operations += np.sum(sub_rect[1:a-1, b-1] == 0)  # Right border\n\n                        # Check the inner conditions\n                        operations += np.sum(sub_rect[1:a-1, 1:b-1] == 1)  # Inner area\n\n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and a matrix of n lines with m characters\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to form a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient manipulation\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check and transform the border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] == 0:\n            operations += 1\n        if sub_rect[x, b - 1] == 0:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] == 0:\n            operations += 1\n        if sub_rect[a - 1, y] == 0:\n            operations += 1\n\n    # Check and transform the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n\n                        # Check border conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            if grid[x][start_col] != '1':\n                                operations += 1\n                            if grid[x][start_col + b - 1] != '1':\n                                operations += 1\n\n                        for y in range(start_col + 1, start_col + b - 1):\n                            if grid[start_row][y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][y] != '1':\n                                operations += 1\n\n                        # Check inner blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n\n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given grid into a portal with minimal operations. The constraints on dimensions and block types are critical for ensuring the portal's validity. Efficient handling of multiple test cases and large inputs is essential.\nrequirement pool:\n- Implement efficient algorithm to transform grid into portal.\n- Ensure output format is clear and concise.\n- Optimize algorithm for minimal operations.\n- Handle edge cases effectively.\n- Provide user-friendly interface for input and output.\nWe will implement a function that iterates over all possible sub-rectangles of the given grid that meet the minimum size requirements. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will return the minimum number of operations required across all sub-rectangles. We will use numpy for efficient grid manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle meeting specific criteria for block arrangement.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure the dimensions of the sub-rectangle are checked before processing.\n    \n# [degree adverb]\n    'minimum': The least number of operations needed to transform a sub-rectangle into a portal.\n    Implementation: Track the number of operations for each sub-rectangle and return the smallest count.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the grid dimensions for each test case.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the borders meet the obsidian block criteria.\n        - Ensure the inner blocks are empty.\n    4. Track the minimum number of operations across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: Minimum size grid with all blocks as obsidian\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: Transforming all inner blocks to empty requires 12 operations.\n\n    Case 2: Minimum size grid with all blocks as empty\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: Transforming border blocks to obsidian requires 12 operations.\n\n    Case 3: Larger grid with mixed blocks\n    Input:\n    1\n    6 5\n    10101\n    01010\n    10101\n    01010\n    10101\n    01010\n    Expected Output: Depends on specific arrangement; calculate based on logic.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal transformation.\n- Ensure the solution handles the maximum input size within reasonable time limits.\n- Optimize the algorithm to reduce computational complexity.\n- Provide detailed comments and documentation for the code.\n- Implement additional test cases to cover edge scenarios.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n by m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will return the minimum number of operations required for each test case. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria regarding block types and positions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': For rows between the first and last, specific blocks must be obsidian.\n    '1 < x < b': For columns between the first and last, specific blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': We need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the border blocks are obsidian as per the portal criteria.\n        - Ensure the inner blocks are empty.\n    4. Track the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    Explanation: All blocks need to be transformed to meet portal criteria, resulting in maximum operations.\n\n    Test case with all blocks already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: \n    Explanation: No operations needed as it already meets portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must handle large inputs efficiently. The output format must be consistent and clear for each test case.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations\n- Ensure solution handles maximum constraints effectively\n- Provide clear output format for each test case\n- Optimize for both small and large rectangles\n- Include detailed comments and documentation\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes required to convert each into a portal. We will use a brute-force method with optimizations to handle the constraints efficiently. The solution will be implemented in Python, leveraging its built-in data structures for simplicity and performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle of size a \u00d7 b that meets certain criteria regarding block types and positions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'minimum number of operations': The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'minimum': Refers to the smallest number of operations required to achieve the transformation.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n        - Ensure the borders are obsidian blocks where required.\n        - Ensure the inner blocks are empty.\n    4. Track the minimum number of operations across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meets the portal criteria.\n    Explanation: If a rectangle is already a portal, no operations are needed, so the expected output is 0.\n\n    Case 2: A rectangle with dimensions exactly 5x4 and all blocks are empty.\n    Explanation: The entire border needs to be converted to obsidian, resulting in a high number of operations.\n\n    Case 3: A rectangle with dimensions larger than 5x4 but with no possible portal configuration.\n    Explanation: If no sub-rectangle can be transformed into a portal, the function should return the minimum operations needed for any valid configuration.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide detailed comments and documentation.\n- Create test cases to validate the solution.\nWe will implement a function to find the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to convert each into a portal. We will use a brute-force method to check each sub-rectangle, but optimize by stopping early if a minimal operation count is found. The solution will be efficient enough given the constraints, as the maximum size of the grid is 400x400.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': This indicates that for rows between the first and last, certain blocks must be obsidian.\n    '1 < x < b': This indicates that for columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size at least 5x4 within the given n by m grid.\n    2. For each sub-rectangle, calculate the number of operations needed to convert it into a portal.\n    3. Keep track of the minimum number of operations found across all sub-rectangles.\n    4. Return the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The grid already meets the portal criteria, so no operations are needed.\n\n    Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be converted to meet the portal criteria.\n\n    Case 3: A grid with alternating obsidian and empty blocks.\n    Example:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on the specific arrangement; requires calculation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to transform a given rectangle into a portal with minimal operations. The constraints on the dimensions and block types are clearly defined, ensuring the solution must efficiently handle the transformation process while adhering to the rules.\nrequirement pool:\n- Implement the main algorithm to determine minimum operations for portal creation\n- Optimize the solution for handling large input sizes efficiently\n- Ensure the solution is robust and handles edge cases\n- Provide clear output format as specified in requirements\n- Enhance user experience with detailed explanations of results\nWe will use a brute-force approach to check all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The minimum number of operations across all sub-rectangles will be the answer for that test case. Given the constraints, this approach should be efficient enough.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    Explanation: This sets the minimum size for the portal, ensuring it is large enough to meet the criteria.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n    Explanation: This implies optimizing the number of changes needed to achieve the desired configuration.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal by checking each block against the portal criteria.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already configured as a portal\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as the rectangle already meets the portal criteria.\n\n    Case 2: A rectangle with all empty blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be switched to meet the portal criteria.\n\n    Case 3: A rectangle with all obsidian blocks\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: Only the inner blocks need to be switched to empty blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each sub-rectangle and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and provide accurate results.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation\n- Ensure solution handles maximum input constraints effectively\n- Provide clear output format for easy verification\n- Optimize for speed and accuracy\n- Include detailed comments and documentation\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of operations. The function will use a brute-force approach to evaluate each sub-rectangle, but will be optimized to skip unnecessary checks based on the constraints provided. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, where each block can be either an obsidian block or an empty block.\n    'portal': A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    '1 < x < a': For rows between the first and last, specific blocks must be obsidian.\n    '1 < x < b': For columns between the first and last, specific blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\n    4. Keep track of the minimum number of operations for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already in portal form\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as the rectangle is already a portal.\n\n    Case 2: A rectangle with all empty blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be transformed to meet portal criteria.\n\n    Case 3: A rectangle with alternating blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on the arrangement; requires calculation.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n        def calculate_operations(sub_rectangle):\n            # Implement logic to count operations needed for transformation\n            pass\n\n        def find_min_operations(rectangle, n, m):\n            min_operations = float('inf')\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    sub_rectangle = extract_sub_rectangle(rectangle, i, j, a, b)\n                    operations = calculate_operations(sub_rectangle)\n                    min_operations = min(min_operations, operations)\n            return min_operations\n\n        # Main function to process input and output results for each test case\n        def process_test_cases(test_cases):\n            results = []\n            for rectangle in test_cases:\n                n, m = rectangle['dimensions']\n                grid = rectangle['grid']\n                result = find_min_operations(grid, n, m)\n                results.append(result)\n            return results\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and large input sizes while ensuring accuracy.\nrequirement pool:\n- Implement the main algorithm to determine minimum operations\n- Optimize for large input sizes\n- Ensure accurate handling of edge cases\n- Provide clear output formatting\n- Test extensively with diverse test cases\nWe will use a dynamic programming approach to efficiently determine the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost. We will utilize numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria for block types.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    '1 < x < a': For rows between the first and last, specific blocks must be obsidian.\n    '1 < x < b': For columns between the first and last, specific blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the given rectangle.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal by checking each block against the portal criteria.\n    4. Keep track of the minimum number of operations across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meets the portal criteria.\n    Explanation: If a rectangle already meets the criteria, no operations are needed, so the expected output is 0.\n\n    Case 2: A rectangle with dimensions exactly equal to the minimum required (5x4) but all blocks are empty.\n    Explanation: The expected output would be the number of operations needed to convert all required blocks to obsidian.\n\n    Case 3: A rectangle with dimensions larger than required but no possible sub-rectangle meets the criteria without changes.\n    Explanation: The expected output would be the minimum number of operations needed to convert any sub-rectangle into a portal.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where a rectangle already meets the portal criteria or where no changes are needed.\n        if check_if_already_portal(sub_rectangle):\n            return 0\n        (other code for calculating operations)\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must iterate over possible sub-rectangles and calculate the operations needed, ensuring it meets the portal criteria.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for portal creation.\n- Ensure the solution is efficient for maximum constraints.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for speed and memory usage.\n- Include detailed comments and documentation for the code.\nWe will use a dynamic programming approach to efficiently calculate the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and compute the number of changes needed to meet the portal criteria. We will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain criteria to be considered a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    '1 < x < a': For rows between the first and last, certain blocks must be obsidian.\n    '1 < x < b': For columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to meet the portal criteria:\n        - Ensure the border blocks are obsidian where required.\n        - Ensure the inner blocks are empty.\n    4. Use dynamic programming to store and update the minimum number of operations for each sub-rectangle.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n   0000\n   0000\n   0000\n   0000\n    Expected Output: \n    12\n    Explanation: All border blocks need to be changed to obsidian, requiring a total of 12 operations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed.\nrequirement pool:\n- Develop an algorithm to identify the optimal sub-rectangle for transformation.\n- Ensure the solution handles the maximum constraints efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation for the solution.\n- Implement additional test cases to ensure robustness.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to convert each into a portal. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the smallest number of operations across all valid sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Keep track of the minimum number of operations needed for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as it already meets the portal criteria.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: Transforming the inner blocks to empty requires changing all but the border blocks.\n\n    Case 3: A rectangle with all blocks as empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: Transforming the border blocks to obsidian requires changing all but the inner blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The algorithm should focus on minimizing operations while ensuring the output is clear and concise.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for portal transformation.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution is scalable and efficient.\n- Provide detailed documentation and examples.\n- Implement error handling for invalid inputs.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes required to convert each into a portal. We will use a brute-force method due to the manageable constraints, ensuring the solution is efficient for the given input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles starting from these minimum dimensions.\n\n    'For every 1 < x < a'\n    Explanation: This indicates a range condition for rows within the sub-rectangle, excluding the first and last row.\n\n    'For all 1 < x < b'\n    Explanation: This indicates a range condition for columns within the sub-rectangle, excluding the first and last column.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the smallest number of changes required across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and then the grid itself.\n3. Iterate over all possible starting points for sub-rectangles of size at least 5x4.\n4. For each starting point, calculate the number of changes needed to convert it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n5. Track the minimum number of changes required for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, requiring a total of 12 changes.\n\n    Case 3: A grid with maximum dimensions but minimal changes needed.\n    Input:\n    1\n    9 9\n    111111111\n    100000001\n    100000001\n    100000001\n    100000001\n    100000001\n    100000001\n    100000001\n    111111111\n    Expected Output: 0\n    Explanation: The grid already contains a portal with minimal changes needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 198, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 144}
