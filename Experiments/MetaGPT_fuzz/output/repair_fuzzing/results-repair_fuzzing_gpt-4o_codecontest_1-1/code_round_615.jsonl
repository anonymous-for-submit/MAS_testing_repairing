{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array and can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array and can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x). The right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e., the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array and can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a, perform eversions on this array, and can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef eversion_count(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to make the array stop changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing\n            the number of elements and the array itself.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for n, a in test_cases:\n        k = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Initialize list to store test cases\n    test_cases = []\n    for _ in range(t):\n        # Read the length of the array\n        n = int(input())\n        # Read the array elements\n        a = list(map(int, input().split()))\n        # Append the test case as a tuple\n        test_cases.append((n, a))\n    \n    # Call the function and store the result\n    results = eversion_count(t, test_cases)\n    \n    # Output the results for each test case\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing an array of integers.\n\n    Returns:\n        A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    for a in test_cases:\n        n = len(a)\n        max_so_far = a[-1]\n        eversion_count = 0\n        \n        # Iterate from the end to the start of the array\n        for i in range(n - 2, -1, -1):\n            if a[i] > max_so_far:\n                eversion_count += 1\n                max_so_far = a[i]\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport sys\nfrom typing import List, Tuple\n\ndef min_eversions(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing an integer n and an array a.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    for n, a in test_cases:\n        k = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            if new_a == a:\n                break\n            a = new_a\n            k += 1\n        results.append(k)\n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    input_data = sys.stdin.read().split()\n    t = int(input_data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(input_data[index])\n        index += 1\n        a = list(map(int, input_data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        eversion_count = 0\n        \n        # Perform eversions until the array stops changing\n        while True:\n            x = a[-1]  # Last element of the array\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing an array of integers.\n\n    Returns:\n        A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    for case in test_cases:\n        n = len(case)\n        max_so_far = case[-1]\n        eversion_count = 0\n        \n        # Iterate backwards through the array\n        for i in range(n - 2, -1, -1):\n            if case[i] > max_so_far:\n                eversion_count += 1\n                max_so_far = case[i]\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        k = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef min_eversions(t: int, test_cases: list[tuple[int, list[int]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, list[int]]]): List of test cases, each containing\n            a tuple with the number of elements and the array itself.\n\n    Returns:\n        list[int]: List of integers representing the minimum number of eversions\n            required for each test case.\n    \"\"\"\n    results = []\n    for n, a in test_cases:\n        max_so_far = float('-inf')\n        eversion_count = 0\n        # Iterate from the end to the start of the array\n        for i in range(n - 1, -1, -1):\n            if a[i] > max_so_far:\n                max_so_far = a[i]\n                eversion_count += 1\n        # Subtract 1 because the last increment is unnecessary\n        results.append(eversion_count - 1)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        current_array = case[:]\n        eversion_count = 0\n        \n        while True:\n            last_element = current_array[-1]\n            left_section = [x for x in current_array if x <= last_element]\n            right_section = [x for x in current_array if x > last_element]\n            new_array = left_section + right_section\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    such that the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        eversion_count = 0\n        \n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on performing a series of eversion operations on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the minimum number of operations required. The solution must handle multiple test cases and large input sizes while ensuring stable partitioning and correct output format.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles multiple test cases efficiently\n- Optimize the algorithm for large input sizes\n- Provide clear documentation for the code\n- Test the solution against edge cases\nWe will implement the eversion operation using a simple iterative approach. The key is to partition the array based on the last element and repeat the process until the array stabilizes. We will use Python's built-in list operations to efficiently handle the partitioning and concatenation. The solution will be optimized to handle large input sizes by minimizing unnecessary operations and ensuring stable partitioning.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stops changing'\n    Explanation: The array stops changing when further eversions do not alter the order or composition of the array.\n\n# [phrase showing quantity relationship]\n    'not more than (\u2264)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than (>)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array is not stable:\n   - Set x as the last element of the array.\n   - Partition the array into left and right sections based on x.\n   - Concatenate the left and right sections to form a new array.\n   - Increment k.\n4. Check if the new array is the same as the previous one. If so, break the loop.\n5. Output k for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion, all elements will be in the left section since they are all less than or equal to x (1), resulting in a stable array.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if further eversions change the array.\n", "requirement analysis:\nThe requirements focus on implementing an eversion operation on arrays, ensuring the process is stable and efficient. The key challenge is to determine the minimum number of eversions needed for the array to stop changing, which requires careful handling of array partitions and concatenations.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles large inputs efficiently\n- Optimize the performance to minimize execution time\n- Provide clear and concise output for each test case\n- Document the process for better understanding\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered so far. The number of eversions required is equal to the number of times we encounter a new maximum element as we iterate backwards. This approach ensures that we efficiently determine the minimum number of eversions needed for the array to stop changing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. Elements less than or equal to x form the left section, and elements greater than x form the right section. The array is then reformed by concatenating the left and right sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': Elements in the left section are less than or equal to x.\n    'strictly greater than x (> x)': Elements in the right section are greater than x.\n\n# [degree adverb]\n    'minimum number': We need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n1. Initialize a counter for eversions.\n2. Iterate over the array from the end to the start.\n3. Keep track of the maximum element encountered so far.\n4. Each time a new maximum is encountered, increment the eversion counter.\n5. The counter will represent the minimum number of eversions needed.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 4\n    Explanation: Each element is greater than the next, requiring an eversion for each element until stability is reached.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting new maximums encountered while iterating backward inherently handles these cases.\n", "requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of operations needed for stabilization. The solution must handle multiple test cases and large input sizes while ensuring accurate and clear output.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles large input sizes\n- Optimize the algorithm for performance\n- Provide clear output for each test case\n- Document the code for maintainability\nWe will implement the eversion operation using a simple loop to partition the array based on the last element. The algorithm will repeatedly perform eversions until the array stabilizes. We will use Python's built-in list operations to efficiently handle the partitioning and concatenation. The solution will be optimized to handle large input sizes by minimizing unnecessary operations and using efficient list manipulations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stops changing'\n    Explanation: This means that after a certain number of eversions, further eversions do not alter the array's order.\n\n# [phrase showing quantity relationship]\n    'not more than': means elements in the left section are less than or equal to x.\n    'strictly greater than': means elements in the right section are greater than x.\n\n# [degree adverb] \n    'minimum number': means the smallest count of eversions needed for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array is not stable:\n   - Set x as the last element of the array.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. Check if the array is stable (i.e., no change after an eversion).\n5. Output k for each test case.\n\n# [edge case] \n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Case 2: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion moves one element to the left section until all are sorted.\n\n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if further eversions change the array.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of such operations required. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the eversion operation as described.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation.\n- Include edge case handling and validation.\nWe will implement a function that performs the eversion operation on the array until it no longer changes. The function will efficiently handle large input sizes by iterating through the array and partitioning it based on the last element. We will use Python's list operations to maintain the stability of the partition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, while the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for eversions.\n    3. Perform the eversion operation:\n        - Identify the last element, x.\n        - Partition the array into left and right sections based on x.\n        - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it changes, increment the counter and repeat; otherwise, stop.\n    6. Return the counter as the result for each test case.\n\n# [edge case]\n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so k = 0.\n    \n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 1\n    Explanation: Only one eversion is needed as all elements are less than or equal to the last element initially.\n    \n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = n-1\n    Explanation: Each eversion will move one element to the left section until only one element remains in the right section.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles them by checking if the array changes after each eversion.\n", "requirement analysis:\nThe requirements focus on efficiently partitioning the array using the eversion operation until it stabilizes. The challenge lies in ensuring the algorithm can handle the maximum constraints without performance degradation.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles up to 2 \u22c5 10^5 elements efficiently\n- Optimize the algorithm for performance\n- Provide clear output format for multiple test cases\n- Handle edge cases such as arrays with identical elements\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered so far. The number of eversions required is equal to the number of times we encounter a new maximum element as we iterate backwards. This approach ensures that we efficiently handle the maximum constraints without performance degradation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This means elements in the left section are less than or equal to x.\n    'strictly greater than x (> x)': This means elements in the right section are greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Iterate over the array from the end to the start.\n    3. Keep track of the maximum element encountered so far.\n    4. Each time a new maximum is encountered, increment the eversion counter.\n    5. Return the eversion counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion is needed as the array does not change.\n    \n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion is needed.\n    \n    Test case: [10, 9, 8, 7, 6] = 4\n    Explanation: Each element is a new maximum when iterating backwards, requiring an eversion for each.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating backwards and counting new maximums will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on efficiently performing eversions on an array until it stabilizes. The key challenge is to ensure the algorithm can handle the maximum constraints efficiently while providing accurate results for each test case.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the algorithm handles up to 100 test cases\n- Optimize the code for performance\n- Provide clear output format\n- Document the code for maintainability\nWe will implement a function to perform the eversion operation on the array until it stabilizes. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. This process will repeat until the array no longer changes. We will use Python's list operations to efficiently handle the partitioning and concatenation. The solution will be optimized to handle the maximum constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not more than x, and the right section contains elements greater than x. The array is then replaced with the concatenation of these two sections.\n\n    'stops changing'\n    Explanation: The array stops changing when further eversions do not alter the order or composition of the array.\n\n# [phrase showing quantity relationship]\n    'not more than (\u2264 x)': This means elements in the left section are less than or equal to x.\n    'strictly greater than (> x)': This means elements in the right section are greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for the number of eversions, k = 0.\n3. While the array changes:\n   - Set x as the last element of the array.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form a new array.\n   - Increment k.\n4. Stop when the array no longer changes and return k.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion with x = 1, all elements are greater than x, resulting in a stable array.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is efficiently partitioning the array and determining the number of operations needed for stabilization. The solution must handle multiple test cases and large input sizes while ensuring the output is correct and easy to interpret.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles multiple test cases\n- Optimize the code for large input sizes\n- Provide clear and concise output\n- Improve code readability and maintainability\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered so far. The number of eversions required is determined by counting how many times we encounter a new maximum element as we iterate backwards. This approach efficiently handles large input sizes by using a single pass through the array for each test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, start iterating from the last element of the array.\n    2. Keep track of the maximum element encountered so far.\n    3. Count how many times a new maximum element is encountered as you iterate backwards.\n    4. The count represents the number of eversions required for the array to stabilize.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition value, so no eversion is needed.\n    \n    Test case: [1, 2, 3, 4, 5] = 1\n    Explanation: Only one eversion is needed as the last element is the largest and all other elements are less than or equal to it.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting new maximums encountered during backward iteration inherently handles these cases.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of eversions on an array until it stabilizes. The key challenge is to efficiently determine the minimum number of eversions needed for the array to stop changing, especially given the constraints on input size.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm to handle the maximum input size within time limits.\n- Provide clear and concise output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that performs the eversion operation on the array as described. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. This process will be repeated until the array stops changing. We will use a simple loop to count the number of eversions required for stabilization. The solution will be efficient enough to handle the maximum constraints due to its linear complexity per eversion.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than (\u2264)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than (>)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array changes:\n   - Set x as the last element of the array.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. Stop when the array no longer changes and output k.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition point, so no eversion is needed.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after an eversion. If it doesn't change, the loop terminates naturally.\n", "requirement analysis:\nThe requirements focus on implementing an eversion operation on arrays, ensuring stability in partitioning and achieving a final state where the array no longer changes. The challenge lies in efficiently handling large arrays and multiple test cases while maintaining accuracy.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles large arrays efficiently\n- Optimize the code for minimal computational complexity\n- Provide accurate output for all test cases\n- Document the code for clarity and maintenance\nWe will implement the eversion operation using a simple loop to partition the array into left and right sections based on the last element. The process will be repeated until the array stops changing. We will use Python's built-in list operations for efficient partitioning and concatenation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than': means elements in the left section are less than or equal to x.\n    'strictly greater than': means elements in the right section are greater than x.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n        - Identify the last element, x.\n        - Partition the array into left and right sections based on x.\n        - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it is different, increment the counter and repeat the process.\n    6. If it is not different, stop and record the counter value as the result for that test case.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Input: [1, 2, 3, 4, 5] = 1\n    Explanation: The first eversion results in no change since all elements are less than or equal to the last element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after an eversion.\n", "requirement analysis:\nThe requirements focus on efficiently performing eversions on an array until it stabilizes. The key challenge is ensuring the algorithm can handle the maximum constraints while providing accurate results. The output format must be strictly followed to ensure compatibility with test cases.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles up to 100 test cases efficiently\n- Optimize the algorithm for large input sizes\n- Provide clear documentation for the eversion process\n- Enhance output readability\nWe will implement the eversion operation using a simple loop to partition the array based on the last element. The algorithm will repeatedly perform eversions until the array stabilizes. We will use Python's built-in list operations to efficiently handle the partitioning and concatenation. The approach will ensure clarity and performance by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than': means elements in the left section are less than or equal to x.\n    'strictly greater than': means elements in the right section are greater than x.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n        - Identify the last element, x.\n        - Partition the array into left and right sections based on x.\n        - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it is different, increment the counter and repeat the process.\n    6. If it is not different, stop and record the counter value as the result for that test case.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Input: [1, 2, 3, 4, 5] = 1\n    Explanation: Only one eversion is needed as all elements are already in order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after an eversion.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 615, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "condense_two2one", "parent_index": 380}
