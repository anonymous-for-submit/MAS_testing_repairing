{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaged in yet another computer game adventure. In this game, his character must defeat a dragon. The confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger. The i-th attack occurs at the onset of the a_i-th second from the commencement of the conflict. The dagger itself inflicts no damage, but it unleashes a poison effect on the dragon. This poison effect inflicts 1 damage during each of the following k seconds. The poison effect kicks off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter. Therefore, he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon. Monocarp needs your help to calculate this minimum viable value of k efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaged in yet another computer game adventure. In this game, his character must defeat a dragon. The confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger. The i-th attack occurs at the onset of the a_i-th second from the commencement of the conflict. The dagger itself inflicts no damage, but it unleashes a poison effect on the dragon. This poison effect inflicts 1 damage during each of the following k seconds. The poison effect kicks off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter. Therefore, he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon. Monocarp needs your help to calculate this minimum viable value of k efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in yet another computer game adventure. In this game, his character must defeat a dragon. The confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger. The i-th attack occurs when the conflict starts, specifically at the onset of the a_i-th second. The dagger itself inflicts no damage, but it unleashes a poison effect on the dragon. This poison effect inflicts 1 damage during each of the following k seconds. The poison effect kicks off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter. Therefore, he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon. Monocarp needs your help to calculate this minimum viable value of k efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in yet another computer game adventure, where his character must defeat a dragon, and the confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger, and the i-th attack occurs at the onset of the a_i-th second from the commencement of the conflict, but the dagger itself inflicts no damage and unleashes a poison effect on the dragon that inflicts 1 damage during each of the following k seconds, kicking off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter, therefore he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon. Monocarp needs your help to calculate this minimum viable value of k efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, 10**18  # High is set to a large number\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        # After the loop, low is the minimum viable k\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        left, right = 1, h\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_min_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    def calculate_damage(k: int, attacks: List[int]) -> int:\n        \"\"\"Calculate the total damage inflicted with a given k.\n\n        Args:\n            k (int): Duration of poison effect in seconds.\n            attacks (List[int]): List of attack times.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        n = len(attacks)\n        \n        for i in range(n):\n            if i == n - 1:\n                total_damage += k\n            else:\n                total_damage += min(k, attacks[i + 1] - attacks[i])\n        \n        return total_damage\n\n    results = []\n    \n    for n, h, attacks in test_cases:\n        low, high = 1, attacks[-1] - attacks[0] + 1\n        \n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(mid, attacks) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    test_cases.append((n, h, attacks))\n\n# Output interface\nresults = calculate_min_k(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of attacks.\n            - h: The required damage to defeat the dragon.\n            - attacks: A list of integers representing the seconds when each attack occurs.\n\n    Returns:\n        A list of integers where each integer is the minimum value of k for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # Initial bounds for k\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust bounds based on whether the damage is sufficient\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of attacks.\n            - h: The required damage to defeat the dragon.\n            - attacks: A list of integers representing the seconds when each attack occurs.\n\n    Returns:\n        A list of integers, each representing the minimum value of k for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        left, right = 1, 10**18\n\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search range based on total damage\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to defeat the dragon.\n            - a: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k_value(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, a[i + 1] - a[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = minimum_k_value(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to defeat the dragon.\n            - attack_times: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on damage calculation\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to defeat the dragon.\n            - attacks: List of integers representing the seconds when each attack occurs.\n\n    Returns:\n        A list of integers where each integer is the minimum k for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        # The minimum viable k is found\n        results.append(low)\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the minimum duration of poison effect needed to inflict at least h damage to the dragon. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Efficient calculation of minimum k\n- Handle large input sizes and multiple test cases\n- Provide clear output format\n- Ensure solution is easy to understand\n- Optimize for performance\nWe will use a binary search approach to efficiently determine the minimum viable value of k. The idea is to simulate the damage inflicted by the poison for different values of k and check if it meets or exceeds the required damage h. This approach is efficient and handles large input sizes well.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by Monocarp's dagger attack and inflicts 1 damage per second for k seconds. If another attack occurs during this period, the poison effect is renewed.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted by the poison must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Initialize variables for binary search: low = 1, high = maximum possible k (a large number).\n2. While low < high:\n   - Calculate mid = (low + high) // 2.\n   - Simulate the total damage for k = mid:\n     - Initialize total_damage = 0.\n     - For each attack time a_i, calculate the damage period and add to total_damage.\n     - If total_damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n3. After exiting the loop, low will be the minimum viable k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 2, h = 10^18, a = [1, 10^9] => Expected output: A large k\n    Explanation: The attacks are far apart, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 100, h = 100, a = [1, 2, ..., 100] => Expected output: 1\n    Explanation: Each second has an attack, so k = 1 is enough to deal continuous damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles different scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that Monocarp can inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large values for n and h, ensuring accurate and timely results.\nrequirement pool:\n- Efficient calculation of minimum k value\n- Handle large input sizes and multiple test cases\n- Provide clear output format\n- Ensure solution is scalable\n- Optimize for performance\nWe will use a binary search approach to efficiently determine the minimum viable value of k. This approach is suitable given the constraints, as it allows us to handle large input sizes and multiple test cases efficiently. We will iterate over each test case, calculate the damage for different values of k using a binary search, and find the minimum k that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack inflicts 1 damage per second for k seconds. If a new attack occurs before the previous poison effect ends, the effect is reset and starts anew.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration in seconds that the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. In code, this can be implemented as a condition where the accumulated damage is checked against h.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. For each test case, initialize the binary search range for k.\n2. Calculate the total damage for a given k by iterating through the attack times and summing up the effective damage periods.\n3. Use binary search to adjust k: if the total damage is at least h, try a smaller k; otherwise, increase k.\n4. Continue until the minimum k is found for which the total damage is at least h.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and 1 damage needed, k=1 is sufficient.\n    \n    Test case: 2 1\n    Explanation: With two attacks at different times and only 1 damage needed, k=1 is sufficient.\n    \n    Test case: 3 1000000000\n    Explanation: With three attacks spaced far apart and a large h, a larger k will be needed to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the accumulated damage compared to h.\n", "requirement analysis:\nThe requirements focus on calculating the minimum viable value of k efficiently for multiple test cases. The solution must handle large input sizes and provide clear output for each test case.\nrequirement pool:\n- Efficient calculation of minimum k value\n- Handle large input sizes and edge cases\n- Provide clear and accurate output\n- Ensure solution scalability\n- Optimize for performance\nWe will use a binary search approach to efficiently determine the minimum viable value of k. This approach is suitable given the constraints, as it allows us to handle large input sizes and edge cases effectively. We will iterate over the test cases, calculate the damage for each possible k using a helper function, and use binary search to find the minimum k that meets the damage requirement.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack inflicts 1 damage per second for k seconds. If a new attack occurs before the previous poison effect ends, the effect is reset and starts anew from that second.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration in seconds for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a loop or binary search to find the smallest k such that the total damage is >= h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the array of attack times.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = a_n - a_1 + 1 (maximum possible k).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid using a helper function:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage contributed by that attack.\n       - If an attack occurs before the previous poison effect ends, adjust the damage calculation.\n     - If total_damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n5. Output the value of low as the minimum k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 to inflict at least 1 damage.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack needs to inflict at least 1 damage separately.\n\n    Test case 3: n = 3, h = 3, a = [1, 2, 3] => k = 1\n    Explanation: Each attack occurs consecutively, so k = 1 is sufficient to inflict continuous damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to calculate the minimum viable value of k efficiently, ensuring that the poison effect inflicts at least h damage to the dragon. The solution must handle large input values and multiple test cases accurately.\nrequirement pool:\n- Efficient calculation of minimum k value\n- Accurate damage calculation\n- Optimization for large input values\n- Clear output format\n- User-friendly interface\nWe will implement a function to determine the minimum viable value of k for each test case. The approach involves iterating over the attack times and calculating the total damage inflicted by the poison effect for a given k. We will use binary search to efficiently find the minimum k that results in at least h damage. This approach ensures that we handle large input values efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by the dagger and inflicts 1 damage per second for k seconds. If the dragon is already poisoned, the effect is renewed, starting a fresh k-second duration.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest number of seconds the poison effect must last to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a condition to check if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. For each test case, initialize variables for binary search: low = 1, high = maximum possible k (e.g., h).\n2. While low < high:\n   - Calculate mid = (low + high) // 2.\n   - Calculate total damage for k = mid by iterating over attack times and summing up the damage.\n   - If total damage >= h, set high = mid (mid might be the answer).\n   - Otherwise, set low = mid + 1 (mid is too small).\n3. After exiting the loop, low will be the minimum viable k.\n4. Output low for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack must independently inflict at least 1 damage.\n\n    Test case 3: n = 3, h = 3, a = [1, 2, 3] => k = 1\n    Explanation: Each attack can renew the poison effect, so k = 1 is sufficient to cover all seconds.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that the total damage inflicted by the poison is at least h. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring damage calculations for h up to 10^18. The attacks are given in increasing order of time, and the solution should consider overlapping poison effects.\nrequirement pool:\n- Efficient calculation of minimum k for each test case\n- Handle large values of h and multiple test cases\n- Ensure correct handling of overlapping poison effects\n- Provide clear and formatted output\n- Optimize for performance with large input sizes\nWe will use a binary search approach to efficiently determine the minimum viable value of k. The key challenge is to handle large values of h and ensure the solution is efficient for up to 1000 test cases. We will leverage Python's built-in capabilities for handling large integers and use a binary search to minimize k by checking if the total damage is at least h for each test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp inflicts damage on the dragon. It lasts for k seconds and can be renewed with each attack.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Use binary search to find the minimum k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate the total damage for a given k.\n        - Adjust bounds based on whether the damage is sufficient.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case with attacks spaced far apart:\n    2 10\n    1 1000000000\n    Expected output: 10\n    Explanation: The attacks are spaced far apart, requiring a longer poison duration to accumulate enough damage.\n\n    Test case with large h:\n    3 1000000000000000000\n    1 2 3\n    Expected output: A large number (depends on implementation)\n    Explanation: Requires handling large values efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles different scenarios by adjusting k based on damage calculations.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that Monocarp can inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large values for n and h, ensuring accurate results.\nrequirement pool:\n- Efficient calculation of minimum k\n- Handle large input sizes and edge cases\n- Provide clear output format\n- Ensure solution scalability\n- Optimize for performance\nWe will use a binary search approach to efficiently determine the minimum viable value of k. This approach is suitable given the constraints, as it allows us to handle large input sizes and edge cases effectively. We will iterate over the attack times and calculate the total damage for each potential k value, adjusting our search range based on whether the damage meets or exceeds the required hit points h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is inflicted on the dragon. It lasts for k seconds and can be renewed by subsequent attacks.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize a binary search range for k, starting from 1 to a large number (e.g., 10^9).\n    2. For each test case, calculate the total damage for a given k by iterating over attack times.\n    3. If the total damage is greater than or equal to h, adjust the search range to find a smaller k.\n    4. If the total damage is less than h, increase k.\n    5. Continue until the minimum k is found for each test case.\n\n# [edge case]\n    Test case with minimum attacks and minimum h:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient to inflict the required damage.\n\n    Test case with maximum h and minimum attacks:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack, k must be equal to h to inflict the required damage.\n\n    Test case with attacks spaced far apart:\n    2 10\n    1 1000000000\n    Expected output: 10\n    Explanation: The attacks are spaced far apart, so k must be large enough to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting the search range based on the calculated damage.\n", "requirement analysis:\nThe problem requires determining the minimum duration of a poison effect that will ensure a dragon receives at least a specified amount of damage. The solution must efficiently handle multiple test cases and large input sizes, ensuring performance and accuracy.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum viable value of k.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large input sizes and high damage requirements.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for maintainability.\nWe will implement a binary search algorithm to efficiently determine the minimum viable value of k. The binary search will be used to find the smallest k such that the total damage inflicted is at least h. For each test case, we will simulate the damage calculation using the given attack times and check if the damage meets or exceeds h. This approach ensures that we handle large input sizes and high damage requirements efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by each attack and lasts for k seconds, inflicting 1 damage per second. If a new attack occurs while the poison is still active, the effect is reset to last for another k seconds from the new attack time.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration for which the poison effect must last to ensure that the total damage inflicted on the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. For each test case, initialize low and high bounds for binary search on k.\n2. While low < high:\n   - Calculate mid as the average of low and high.\n   - Simulate the total damage with k = mid.\n   - If the total damage is at least h, set high = mid.\n   - Otherwise, set low = mid + 1.\n3. After exiting the loop, low will be the minimum viable k.\n\n# [edge case] \n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack must independently inflict at least 1 damage.\n\n    Test case 3: n = 3, h = 3, a = [1, 2, 3] => k = 1\n    Explanation: Each attack occurs consecutively, so k = 1 is sufficient to inflict continuous damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirement is to calculate the minimum viable value of k efficiently for multiple test cases. The solution must handle large input sizes and ensure accurate damage calculation.\nrequirement pool:\n- Efficient calculation of minimum k value\n- Accurate damage calculation\n- Optimization for large input sizes\n- Handling multiple test cases efficiently\n- User-friendly output format\nWe will implement a function to calculate the minimum viable value of k for each test case. The function will iterate over the attack times and calculate the total damage inflicted by the poison. We will use a binary search approach to efficiently find the minimum k that results in at least h damage. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by each attack and lasts for k seconds, inflicting 1 damage per second. If a new attack occurs before the current poison effect ends, the poison effect is renewed.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a loop or binary search to find the smallest k such that the total damage is >= h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. For each test case, initialize variables for binary search (low = 1, high = maximum possible k).\n2. Use binary search to find the minimum k:\n   - Calculate mid = (low + high) // 2.\n   - Simulate the damage calculation with current k = mid.\n   - If total damage >= h, update high = mid.\n   - Otherwise, update low = mid + 1.\n3. Return low as the minimum viable k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 to inflict at least 1 damage.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack needs to inflict at least 1 damage separately.\n\n    Test case 3: n = 3, h = 3, a = [1, 2, 3] => k = 1\n    Explanation: Each attack occurs consecutively, so k = 1 is sufficient to inflict damage in each second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k based on the damage calculation.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to inflict at least h damage to a dragon, given multiple attack times. The solution must efficiently handle large input sizes and provide accurate results for each test case.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large values of h and a_i.\n- Provide clear input and output formatting.\n- Include detailed comments and documentation for the code.\nWe will implement a binary search algorithm to efficiently determine the minimum viable value of k. The key idea is to simulate the damage inflicted by the poison for different values of k and use binary search to find the smallest k that results in at least h damage. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by Monocarp's dagger and inflicts 1 damage per second for k seconds starting from the second of the attack. If another attack occurs during an active poison effect, the effect is reset to start again from that second.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest number of seconds the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted by the poison must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Implement a binary search for k:\n   - Set initial bounds for k (e.g., low = 1, high = maximum possible k).\n   - While low < high:\n     - Calculate mid as the average of low and high.\n     - Simulate the total damage for k = mid.\n     - If the damage is at least h, set high = mid.\n     - Otherwise, set low = mid + 1.\n4. After exiting the loop, low will be the minimum viable k.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Test case: 2 2\n    Explanation: With two attacks at different times and needing only 2 damage, k = 1 is sufficient as each attack contributes 1 damage.\n\n    Test case: 3 1000000000\n    Explanation: With three attacks spaced far apart and needing a large amount of damage, a large k will be required to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the required damage and attack timings.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that Monocarp can inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The attacks are given in increasing order of time, and the solution must account for overlapping poison effects.\nrequirement pool:\n- Efficient calculation of minimum k for each test case\n- Handle large input sizes and ensure accuracy\n- Optimize for speed and performance\n- Ensure solution is scalable for multiple test cases\n- Provide clear output format as specified\nWe will use a binary search approach to efficiently determine the minimum viable value of k. The key challenge is to handle large input sizes and ensure the solution is scalable for multiple test cases. We will iterate over each test case, calculate the damage inflicted for different values of k using a binary search, and find the minimum k that satisfies the condition. This approach ensures that we handle up to 1000 test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack inflicts 1 damage per second for k seconds. If another attack occurs during this period, the poison effect is reset, starting a new k-second duration.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest number of seconds the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimum': We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. For each test case, initialize low and high bounds for binary search on k.\n2. Use binary search to find the minimum k:\n   - Calculate mid as the average of low and high.\n   - Simulate the damage calculation for this mid value of k.\n   - If the total damage is at least h, adjust high to mid.\n   - Otherwise, adjust low to mid + 1.\n3. Once binary search completes, low will be the minimum viable k.\n4. Output the result for each test case.\n\n# [edge case] \n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case 2: n = 100, h = 10000, a = [1, 2, ..., 100] => k = 100\n    Explanation: Each attack occurs consecutively, so k must be large enough to cover all attacks without overlap.\n\n    Test case 3: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k based on the damage calculation.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 923, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "add_1_sentence_at_end", "parent_index": 547}
