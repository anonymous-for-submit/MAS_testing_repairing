{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "prompt": "The robot is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows are numbered 1 through n from top to bottom, and the columns are numbered 1 through m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot begins its movement from the cell located at (2, 1) (second row, first column). It navigates to the right, right, down, left, up, and finally up, ending in cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "repair_prompt": ["The robot is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows are numbered 1 through n from top to bottom, and the columns are numbered 1 through m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot begins its movement from the cell located at (2, 1) (second row, first column). It navigates to the right, right, down, left, up, and finally up, ending in cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "The robot is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows are numbered 1 through n from top to bottom, and the columns are numbered 1 through m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side. This means that from any position, the robot can move either vertically or horizontally. \n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot begins its movement from the cell located at (2, 1) (second row, first column). It navigates to the right, right, down, left, up, and finally up, ending in cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "The robot is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns), with rows numbered 1 through n from top to bottom, and columns numbered 1 through m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. The sequence of commands s executed by the robot is given, with each command denoted by one of the symbols 'L', 'R', 'D' or 'U', triggering movement to left, right, down or up, respectively. The robot can start its movement in any cell and executes commands starting from the first one, strictly in the order they are listed in s, with the risk of falling and breaking if it moves beyond the board's edge, and any command causing the robot to break is not considered successfully executed. The robot's task is to execute as many commands as possible without falling off the board; for instance, on a board 3 \u00d7 3, starting a sequence of actions s=\"RRDLUU\" from the central cell will result in one command being performed before an edge-crossing command, but starting from cell (2, 1) enables successful execution of all commands, ending at cell (1, 2). Determine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_cell(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        # Initialize the best starting position and maximum commands executed\n        best_start = (1, 1)\n        max_commands_executed = 0\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                # Simulate the robot's movement\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(best_start)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_cell(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_start(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, commands in test_cases:\n        max_commands_executed = 0\n        best_start_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in commands:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot falls off the board\n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n                    commands_executed += 1\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_position = (start_row, start_col)\n        \n        results.append(best_start_position)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_start(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    # Define movement directions\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_starting_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    delta_row, delta_col = direction_map[command]\n                    new_row = current_row + delta_row\n                    new_col = current_col + delta_col\n                    \n                    # Check if the new position is within bounds\n                    if 1 <= new_row <= n and 1 <= new_col <= m:\n                        current_row, current_col = new_row, new_col\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if a new maximum is found\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_starting_position = (start_row, start_col)\n        \n        results.append(best_starting_position)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        max_commands = 0\n        best_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_position = (start_row, start_col)\n        \n        results.append(best_position)\n    \n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        s = data[index + 1].strip()\n        test_cases.append((n, m, s))\n        index += 2\n    \n    # Call the function and print the results\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(best_start)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Find the optimal starting position for the robot to execute the maximum number of commands.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, str]]): List of test cases, each containing board dimensions and command sequence.\n\n    Returns:\n        List[Tuple[int, int]]: List of optimal starting positions for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_starting_position = (1, 1)\n\n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n\n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n\n                    # Check if the robot is still within the board boundaries\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n\n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_starting_position = (start_row, start_col)\n\n        results.append(best_starting_position)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    test_cases.append((n, m, s))\n\n# Output interface\nresults = find_optimal_starting_position(t, test_cases)\nfor r, c in results:\n    print(r, c)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_cell(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Finds the optimal starting cell for the robot to execute the maximum number of commands.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the dimensions of the board (n, m) and the command sequence (s).\n\n    Returns:\n        A list of tuples, each containing the optimal starting cell coordinates (row, column) for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_starting_position = (1, 1)\n\n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n\n                # Simulate the command sequence\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n\n                    # Check if the robot falls off the board\n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n\n                    commands_executed += 1\n\n                # Update the best starting position if a new maximum is found\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_starting_position = (start_row, start_col)\n\n        results.append(best_starting_position)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n\n    # Output interface\n    results = find_optimal_starting_cell(t, test_cases)\n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Determine the optimal starting position for the robot to execute the maximum number of commands.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, str]]): List of test cases, each containing the board dimensions and command sequence.\n\n    Returns:\n        List[Tuple[int, int]]: List of optimal starting positions for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, s in test_cases:\n        max_commands = 0\n        best_position = (1, 1)\n\n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n\n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n\n                    # Check if the robot is within the board boundaries\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n\n                # Update the best starting position if a new maximum is found\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_position = (start_row, start_col)\n\n        results.append(best_position)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n\n    # Call the function\n    results = find_optimal_starting_position(t, test_cases)\n\n    # Output interface\n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_cell(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    # Define movement deltas for each command\n    move_deltas = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_starting_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    delta_row, delta_col = move_deltas[command]\n                    new_row = current_row + delta_row\n                    new_col = current_col + delta_col\n                    \n                    # Check if the new position is within the board boundaries\n                    if 1 <= new_row <= n and 1 <= new_col <= m:\n                        current_row, current_col = new_row, new_col\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_starting_position = (start_row, start_col)\n        \n        results.append(best_starting_position)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Call the function and print the results\n    results = find_optimal_starting_cell(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot falls off the board\n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n                    \n                    commands_executed += 1\n                \n                # Update the best starting position if a new maximum is found\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(best_start)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe main requirement is to determine the optimal starting cell for the robot to execute the maximum number of commands without falling off the board. The solution must handle large board sizes and command sequences efficiently, ensuring that the total length of commands across all test cases does not exceed 10^6.\nrequirement pool:\n- Determine the optimal starting cell for maximum command execution.\n- Handle large board sizes and command sequences efficiently.\n- Provide clear and concise output for each test case.\n- Ensure the solution is tested against multiple test cases.\n- Optimize the algorithm for performance.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions on the board and simulate the execution of the command sequence from each position. It will track the number of commands executed before the robot falls off the board and return the starting position that allows the maximum number of commands to be executed. Given the constraints, we will optimize the simulation to handle large board sizes and command sequences efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    The robot can move in four directions: left ('L'), right ('R'), down ('D'), and up ('U') on a checkered board.\n\n    'starting position'\n    The robot can start from any cell on the board, and the goal is to find the starting position that allows the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means we need to maximize the number of commands executed without the robot falling off the board.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the dimensions of the board (n, m) and the sequence of commands (s).\n2. Initialize variables to track the best starting position and the maximum number of commands executed.\n3. Iterate over all possible starting positions on the board.\n4. For each starting position, simulate the robot's movement according to the command sequence.\n5. Track the number of commands executed before the robot falls off the board.\n6. Update the best starting position if the current position allows more commands to be executed.\n7. After checking all positions, output the best starting position for each test case.\n\n# [edge case]\n    1 1\n    R = 1 1\n    Explanation: On a 1x1 board, any move will cause the robot to fall off immediately, so any starting position is valid, but it will execute 0 commands.\n\n    2 2\n    LR = 1 1\n    Explanation: On a 2x2 board, starting at (1, 1) allows executing both commands without falling off.\n\n    3 3\n    UUU = 3 1\n    Explanation: Starting at (3, 1) allows executing all 'U' commands without falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements from all possible starting positions inherently handles these cases.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting cell for the robot to execute the maximum number of commands without falling off the board. The solution must efficiently handle large board sizes and command sequences, ensuring accurate output for each test case.\nrequirement pool:\n- Determine the optimal starting cell for maximum command execution\n- Handle large board sizes and command sequences efficiently\n- Provide accurate output for each test case\n- Optimize algorithm for scalability\n- Ensure solution is easy to understand and implement\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions and execute the command sequence to determine the maximum number of commands that can be executed without the robot falling off the board. We will use efficient iteration and boundary checks to ensure scalability for large board sizes and command sequences. The solution will be implemented using basic Python constructs without any external libraries, as the problem is primarily algorithmic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board'\n    Explanation: The board is a grid with n rows and m columns, where each cell can be accessed by the robot.\n\n    'sequence of commands'\n    Explanation: The robot follows a series of movements denoted by 'L', 'R', 'D', 'U' which correspond to left, right, down, and up movements respectively.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': means the robot should execute the maximum number of commands without falling off the board.\n    Implementation: Iterate through possible starting positions and simulate the command sequence to find the position that allows the maximum number of commands to be executed.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the dimensions of the board and the sequence of commands.\n    3. Initialize variables to track the best starting position and the maximum number of commands executed.\n    4. Iterate over all possible starting positions on the board.\n    5. For each starting position, simulate the robot's movement according to the command sequence.\n    6. Check if the robot falls off the board during simulation; if not, count the number of commands executed.\n    7. Update the best starting position if the current position allows more commands to be executed.\n    8. Output the best starting position for each test case.\n\n# [edge case]\n    Test case with smallest board and single command:\n    1 1\n    L\n    Expected output: 1 1\n    Explanation: The robot cannot move left as it would fall off immediately, so it starts at (1, 1) and executes zero commands.\n\n    Test case with a board where all commands lead to falling:\n    2 2\n    LLRR\n    Expected output: Any valid starting position (e.g., 1 1)\n    Explanation: Regardless of starting position, all commands lead to falling off, so any starting position is valid.\n\n    Test case with a large board and no movement:\n    1000000 1000000\n    ''\n    Expected output: Any valid starting position (e.g., 1 1)\n    Explanation: No commands are given, so any starting position is valid as no movement occurs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements and checking boundaries will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The solution must handle large input sizes efficiently and provide clear output for each test case. The algorithm should be robust and capable of handling edge cases.\nrequirement pool:\n- Determine the optimal starting position for the robot.\n- Ensure the robot executes maximum commands without falling.\n- Handle large input sizes efficiently.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm for edge cases.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions on the board and simulate the execution of the command sequence from each position. It will track the number of commands executed before the robot falls off the board and return the starting position that allows the maximum number of commands to be executed. Given the constraints, we will optimize the simulation to handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left, right, down, and up, based on the commands 'L', 'R', 'D', and 'U'. The goal is to execute as many commands as possible without the robot falling off the board.\n\n    'checkered rectangular board'\n    Explanation: The board is defined by dimensions n \u00d7 m, where n is the number of rows and m is the number of columns. The robot must stay within these boundaries.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means maximizing the number of commands executed without the robot falling off the board. In code, this involves simulating movements and checking boundaries to ensure the robot doesn't exceed them.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and details for each test case.\n    2. For each test case, initialize variables to track the best starting position and maximum commands executed.\n    3. Iterate over all possible starting positions on the board.\n    4. Simulate the robot's movement from each starting position using the command sequence.\n    5. Track the number of successful commands executed before the robot falls off the board.\n    6. Update the best starting position if a new maximum is found.\n    7. Output the best starting position for each test case.\n\n# [edge case]\n    Test case with a 1x1 board and any command sequence: \n    Input: 1 1 L\n    Output: 1 1\n    Explanation: The robot cannot move without falling off, so it starts at (1, 1) and executes zero commands.\n\n    Test case with a command sequence longer than the board dimensions:\n    Input: 2 2 RRR\n    Output: 1 1\n    Explanation: Starting at (1, 1), the robot can execute one command before falling off.\n\n    Test case with a command sequence that loops back to a safe position:\n    Input: 3 3 LURD\n    Output: Any valid starting position that allows all commands to be executed without falling off, such as (2, 2).\n    Explanation: The sequence allows movement within bounds without falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements and checking boundaries will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The solution must efficiently handle large board sizes and command sequences, ensuring accurate output for each test case.\nrequirement pool:\n- Determine the optimal starting position for maximum command execution.\n- Handle large board sizes and command sequences efficiently.\n- Ensure accurate output for each test case.\n- Optimize the algorithm for performance.\n- Provide clear documentation and user guidance.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions and simulate the execution of the command sequence from each position. It will track the number of commands executed before the robot falls off the board. The function will return the starting position that allows the maximum number of commands to be executed. Given the constraints, we will optimize the simulation to handle large board sizes and command sequences efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    The robot can move in four directions: left (L), right (R), down (D), and up (U) on a checkered board.\n\n    'starting position'\n    The robot can start from any cell on the board, and the goal is to find the starting position that allows the maximum number of commands to be executed without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means executing the maximum number of commands from the sequence without the robot falling off the board.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the dimensions of the board (n, m) and the sequence of commands (s).\n    2. Initialize variables to track the best starting position and the maximum number of commands executed.\n    3. Iterate over all possible starting positions on the board.\n    4. For each starting position, simulate the robot's movement according to the command sequence.\n    5. Track the number of commands executed before the robot falls off the board.\n    6. Update the best starting position if the current position allows more commands to be executed.\n    7. After checking all positions, store the best starting position for each test case.\n    8. Output the best starting position for each test case.\n\n# [edge case] \n    Test Case 1: 1 1, L = 1 1\n    Explanation: The board is 1x1, so any move will cause the robot to fall. The only possible starting position is (1, 1).\n\n    Test Case 2: 2 2, RR = 1 1\n    Explanation: The board is 2x2, and starting from (1, 1) allows executing one 'R' before falling off.\n\n    Test Case 3: 3 3, UUU = 3 1\n    Explanation: Starting from (3, 1) allows executing all 'U' commands without falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements from all possible starting positions inherently handles edge cases by checking boundary conditions during simulation.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The solution must efficiently handle large board sizes and command sequences, ensuring the output format is consistent with the given specifications.\nrequirement pool:\n- Determine the optimal starting position for maximum command execution\n- Ensure the solution handles large inputs efficiently\n- Provide clear and concise output for each test case\n- Optimize the algorithm for performance\n- Consider edge cases where multiple starting positions yield the same result\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions and execute the command sequence to determine the maximum number of commands that can be executed without the robot falling off the board. We will use efficient iteration and boundary checks to ensure the solution handles large inputs efficiently. The function will return the starting position that allows the maximum command execution.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left ('L'), right ('R'), down ('D'), and up ('U'). The goal is to execute as many commands as possible without the robot falling off the board.\n\n    'starting position'\n    Explanation: The robot can start from any cell on the board, and the task is to find the optimal starting position that allows the maximum number of commands to be executed.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means maximizing the number of commands executed without the robot falling off the board. In code, this involves checking each possible starting position and counting the number of successful moves.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Iterate over all possible starting positions on the board.\n2. For each starting position, simulate the robot's movement according to the command sequence.\n3. Keep track of the number of commands successfully executed for each starting position.\n4. Ensure boundary checks are in place to prevent the robot from moving off the board.\n5. Return the starting position that allows the maximum number of commands to be executed.\n\n# [edge case]\n    Case 1: 1 1, L = 1 1\n    Explanation: The board is 1x1, and any move will cause the robot to fall off. The only starting position is (1, 1), and no commands can be executed successfully.\n\n    Case 2: 1 2, L = 1 2\n    Explanation: The board is 1x2, and starting at (1, 2) allows executing the 'L' command successfully without falling off.\n\n    Case 3: 3 3, RRDLUU = 2 1\n    Explanation: Starting at (2, 1) allows executing all commands successfully without falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible starting positions and checking boundary conditions will naturally handle these cases.\n", "requirement analysis:\nThe task requires determining the optimal starting position for a robot on a board to execute the maximum number of commands without falling off. The solution must handle large board sizes and command sequences efficiently, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm for speed and performance.\n- Consider edge cases where the board size is minimal.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions and execute the sequence of commands, keeping track of the number of successful commands executed before the robot falls off the board. We will use efficient iteration and boundary checks to ensure the solution handles large inputs efficiently. The function will return the starting position that allows the maximum number of commands to be executed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left (L), right (R), down (D), and up (U) on a checkered board. The goal is to execute as many commands as possible without the robot falling off the board.\n\n    'starting position'\n    Explanation: The initial cell from which the robot begins its sequence of movements. The task is to find the starting position that allows the maximum number of commands to be executed without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means executing the maximum number of commands from the sequence without the robot falling off the board.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the dimensions of the board (n, m) and the sequence of commands (s).\n2. Initialize variables to track the best starting position and the maximum number of commands executed.\n3. Iterate over all possible starting positions on the board.\n4. For each starting position, simulate the robot's movement according to the command sequence:\n   - Check if the next move keeps the robot within the board boundaries.\n   - If a move causes the robot to fall off, stop executing further commands.\n   - Count the number of successful commands executed.\n5. Update the best starting position if the current one allows more commands to be executed.\n6. After checking all positions, store the best starting position for each test case.\n7. Output the best starting position for each test case.\n\n# [edge case] \n    1 1\n    L\n    = 1 1\n    Explanation: The board is 1x1, so any move will cause the robot to fall off. The only possible starting position is (1, 1).\n\n    2 2\n    RR\n    = 1 1\n    Explanation: Starting at (1, 1), moving right twice will cause a fall after one successful move. Starting at (1, 2) or (2, 2) will result in immediate fall. Thus, (1, 1) is optimal.\n\n    3 3\n    UUU\n    = 3 1\n    Explanation: Starting at (3, 1), moving up three times will keep the robot within bounds for two moves before falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements and checking boundaries inherently handles these scenarios.\n", "requirement analysis:\nThe main requirement is to determine the optimal starting cell for the robot to execute the maximum number of commands without falling off the board. The solution must handle large board sizes and command sequences efficiently, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Determine the optimal starting cell for maximum command execution.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance.\n- Consider edge cases where the board size is minimal.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions on the board and simulate the execution of the command sequence from each position. It will track the number of commands successfully executed before the robot would fall off the board. The function will return the starting position that allows the maximum number of commands to be executed. Given the constraints, we will optimize the solution to handle large inputs efficiently by avoiding unnecessary recalculations and using efficient data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board'\n    Explanation: The board is a grid with n rows and m columns, where the robot can move between adjacent cells.\n\n    'sequence of commands'\n    Explanation: A string of characters ('L', 'R', 'D', 'U') that dictate the robot's movement direction.\n\n    'falling off the board'\n    Explanation: The robot cannot move beyond the boundaries of the board; any such move is unsuccessful.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': means maximizing the number of commands executed without falling off the board.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the dimensions of the board and the sequence of commands.\n    3. Initialize variables to track the best starting position and the maximum number of commands executed.\n    4. Iterate over all possible starting positions on the board.\n    5. Simulate the execution of commands from each starting position, counting successful moves.\n    6. Update the best starting position if a new maximum is found.\n    7. Output the best starting position for each test case.\n\n# [edge case]\n    Test case with a 1x1 board and a command sequence: \n    Input: 1 1 L\n    Output: 1 1\n    Explanation: The robot cannot move anywhere, so it starts and ends at (1, 1).\n\n    Test case with a command sequence longer than the board dimensions:\n    Input: 2 2 LLRR\n    Output: 1 1\n    Explanation: Starting at (1, 1) allows executing all commands without falling off.\n\n    Test case with a command sequence that immediately causes a fall:\n    Input: 3 3 UUU\n    Output: 3 1\n    Explanation: Starting at (3, 1) allows executing no commands successfully, but it's a valid starting point.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements from each starting position inherently handles these scenarios by checking boundary conditions during simulation.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The solution must efficiently handle large board sizes and command sequences, ensuring accurate output for each test case.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot\n- Ensure the solution handles large inputs efficiently\n- Optimize the algorithm for edge cases\n- Provide clear documentation and output format\n- Test the solution against a variety of test cases\nWe will implement a function to determine the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The approach involves simulating the robot's movement from each possible starting position and tracking the number of successful commands executed. We will use efficient iteration and boundary checks to ensure the solution handles large inputs efficiently. The solution will be implemented in Python, leveraging its built-in data structures for simplicity and performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board'\n    Explanation: The board is a grid with n rows and m columns, where the robot can move between adjacent cells.\n\n    'commands'\n    Explanation: The sequence of movements ('L', 'R', 'D', 'U') that the robot executes to navigate the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': means maximizing the number of commands executed without falling off the board.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the dimensions of the board (n, m) and the sequence of commands (s).\n    2. Initialize variables to track the best starting position and the maximum number of commands executed.\n    3. Iterate over all possible starting positions on the board.\n    4. For each starting position, simulate the robot's movement according to the commands in s.\n    5. Check if each move keeps the robot within the board boundaries.\n    6. Track the number of successful commands executed from each starting position.\n    7. Update the best starting position if a new maximum number of commands is found.\n    8. Output the best starting position for each test case.\n\n# [edge case]\n    Test case with minimum board size and one command:\n    1 1\n    L\n    Expected output: 1 1\n    Explanation: The board is too small for any movement, so the robot cannot execute any command successfully.\n\n    Test case with a single row and multiple commands:\n    1 5\n    RRRRR\n    Expected output: 1 1\n    Explanation: Starting at (1,1), the robot can execute all commands without falling off.\n\n    Test case with a single column and multiple commands:\n    5 1\n    DDDDD\n    Expected output: 1 1\n    Explanation: Starting at (1,1), the robot can execute all commands without falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements and checking boundaries will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting cell for the robot to execute the maximum number of commands without falling off the board. The solution must efficiently handle large board sizes and command sequences, ensuring accurate results across multiple test cases.\nrequirement pool:\n- Develop an algorithm to find the optimal starting cell for maximum command execution.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear output format for each test case.\n- Optimize the algorithm for edge cases.\n- Implement additional features for visualizing the robot's path.\nWe will implement a function to determine the optimal starting cell for the robot to execute the maximum number of commands without falling off the board. The approach involves simulating the robot's movement from each possible starting cell and tracking the number of successful commands executed. We will use a greedy algorithm to efficiently handle large board sizes and command sequences. The solution will iterate over each test case, simulate the robot's path, and determine the best starting position.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    The robot can move in four directions: left ('L'), right ('R'), down ('D'), and up ('U').\n\n    'board dimensions'\n    The board is defined by n rows and m columns, and the robot must stay within these boundaries.\n\n    'optimal starting cell'\n    The goal is to find the starting cell that allows the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means maximizing the number of commands executed without the robot falling off the board.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the dimensions of the board (n, m) and the sequence of commands (s).\n2. Initialize variables to track the best starting position and the maximum number of commands executed.\n3. Iterate over all possible starting positions on the board.\n4. For each starting position, simulate the robot's movement according to the command sequence.\n5. Check if the robot stays within the board boundaries after each command.\n6. If a command causes the robot to fall off, stop the simulation for that starting position.\n7. Track the starting position that allows for the maximum number of commands to be executed successfully.\n8. Output the best starting position for each test case.\n\n# [edge case]\n    1 1\n    L = 1 1\n    Explanation: The board is 1x1, so any command will cause the robot to fall off immediately. The only valid starting position is (1, 1).\n\n    2 2\n    RR = 1 1\n    Explanation: On a 2x2 board, starting at (1, 1) allows executing no commands successfully since any move will cause a fall.\n\n    3 3\n    UUU = 3 1\n    Explanation: Starting at (3, 1) allows executing all 'U' commands successfully without falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements from each possible starting position inherently handles edge cases by stopping when a move would cause a fall.\n", "requirement analysis:\nThe main requirement is to determine the optimal starting position for the robot on a board of given dimensions to execute the maximum number of commands without falling off. The solution must handle up to 10,000 test cases efficiently, with each test case having a board size up to 1,000,000 x 1,000,000 and command sequence length up to 1,000,000. The output should be the starting cell coordinates for each test case.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance.\n- Consider edge cases where the board size is minimal.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions and execute the command sequence to determine the maximum number of commands that can be executed without the robot falling off the board. We will use efficient iteration and boundary checks to ensure the solution handles large inputs efficiently. The Python standard library will be sufficient for this task.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    The robot can move in four directions: left ('L'), right ('R'), down ('D'), and up ('U') on a checkered board.\n\n    'starting cell'\n    The robot can start from any cell on the board, and the goal is to find the starting cell that allows the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means we need to maximize the number of commands executed without the robot falling off the board.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the dimensions of the board (n, m) and the sequence of commands (s).\n2. Initialize variables to track the best starting position and the maximum number of commands executed.\n3. Iterate over all possible starting positions on the board.\n4. For each starting position, simulate the robot's movement according to the command sequence.\n5. Check if the robot falls off the board after executing each command. If it does, stop executing further commands for that starting position.\n6. Track the number of successfully executed commands for each starting position.\n7. Update the best starting position if a new maximum number of commands is found.\n8. Output the best starting position for each test case.\n\n# [edge case]\n    1 1\n    L = 1 1\n    Explanation: The board is 1x1, so any move will cause the robot to fall off immediately. The only starting position is (1, 1).\n\n    2 2\n    RR = 1 1\n    Explanation: Starting from (1, 1), moving right twice will cause the robot to fall off after the first move. The best starting position is (1, 1).\n\n    3 3\n    UUU = 3 1\n    Explanation: Starting from (3, 1), moving up three times will keep the robot on the board. Starting from any other position will cause it to fall off sooner.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements and checking boundaries will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 485, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "rephrase_one", "parent_index": 35}
