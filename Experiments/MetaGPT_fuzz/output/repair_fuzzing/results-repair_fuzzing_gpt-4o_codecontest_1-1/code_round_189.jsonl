{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. The element x is used as a pivot to split the array. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. The element x is used as a pivot to split the array. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. The element x is used as a pivot to split the array. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a. However, the right part contains only elements that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n.\n\nLet's define the eversion operation, where x = a_n and is used as a pivot to split the array into two parts: left containing the elements of a that are not greater than x (\u2264 x), and right consisting of elements strictly greater than x (> x), with element order in each part kept the same as before the operation, ensuring the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nimport typing\n\ndef min_eversions(t: int, test_cases: typing.List[typing.Tuple[int, typing.List[int]]]) -> typing.List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of elements in the array and the array itself.\n\n    Returns:\n        A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for n, a in test_cases:\n        # Initialize the number of eversions\n        eversion_count = 0\n        \n        # Start with the last element as the pivot\n        pivot = a[-1]\n        \n        # Track the maximum element encountered from the end\n        max_from_end = pivot\n        \n        # Iterate from the second last element to the start\n        for i in range(n - 2, -1, -1):\n            if a[i] > max_from_end:\n                # If current element is greater than the max_from_end, it means\n                # we need an eversion to move this element to the right part\n                eversion_count += 1\n                # Update the max_from_end to the current pivot\n                max_from_end = pivot\n            else:\n                # Update the max_from_end to the maximum of itself and the current element\n                max_from_end = max(max_from_end, a[i])\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        previous_array = a[:]\n        \n        while True:\n            pivot = a[-1]\n            left = [x for x in a if x <= pivot]\n            right = [x for x in a if x > pivot]\n            new_array = left + right\n            \n            if new_array == previous_array:\n                break\n            \n            previous_array = new_array\n            a = new_array\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        k = 0\n        while True:\n            pivot = a[-1]\n            left = [x for x in a if x <= pivot]\n            right = [x for x in a if x > pivot]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    # Call the function and print results\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            pivot = current_array[-1]\n            left_part = [x for x in current_array if x <= pivot]\n            right_part = [x for x in current_array if x > pivot]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    test_cases = []\n    \n    # Read each test case\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            pivot = a[-1]\n            left = [x for x in a if x <= pivot]\n            right = [x for x in a if x > pivot]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        k = 0\n        current_array = case[:]\n        \n        while True:\n            pivot = current_array[-1]\n            left_part = [x for x in current_array if x <= pivot]\n            right_part = [x for x in current_array if x > pivot]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            pivot = a[-1]\n            left = [x for x in a if x <= pivot]\n            right = [x for x in a if x > pivot]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            pivot = current_array[-1]\n            left = [x for x in current_array if x <= pivot]\n            right = [x for x in current_array if x > pivot]\n            new_array = left + right\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Get results from min_eversions function\n    results = min_eversions(t, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        if n <= 1:\n            results.append(0)\n            continue\n        \n        # Initialize the number of eversions\n        eversions = 0\n        current_array = case[:]\n        \n        while True:\n            pivot = current_array[-1]\n            left = [x for x in current_array if x <= pivot]\n            right = [x for x in current_array if x > pivot]\n            new_array = left + right\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversions += 1\n        \n        results.append(eversions)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            pivot = current_array[-1]\n            left_part = [x for x in current_array if x <= pivot]\n            right_part = [x for x in current_array if x > pivot]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Get results for each test case\n    results = min_eversions(t, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is to efficiently determine the minimum number of operations required for stabilization across multiple test cases. The solution must handle large input sizes and provide clear output for each test case.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles multiple test cases\n- Optimize the algorithm for large input sizes\n- Provide clear and concise output format\n- Handle edge cases gracefully\nWe will implement the eversion operation using a simple loop to partition the array based on the pivot element, which is the last element of the array. The algorithm will iterate over the array, performing eversions until the array stabilizes. We will use efficient list operations to ensure the solution handles large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion'\n    Explanation: Eversion is an operation that partitions an array into two parts based on a pivot element, which is the last element of the array. The left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to the pivot.\n    'strictly greater than': means elements in the right part are greater than the pivot.\n\n# [degree adverb]\n    'minimum': means we need to find the smallest number of eversions after which the array stops changing.\n\n# [code logic]\n    1. For each test case, initialize a counter for eversions.\n    2. Perform the eversion operation:\n        - Identify the pivot element (last element of the array).\n        - Partition the array into left and right parts based on the pivot.\n        - Concatenate the left and right parts to form a new array.\n    3. Check if the new array is identical to the previous array.\n    4. If not, increment the eversion counter and repeat the process.\n    5. Once the array stops changing, record the number of eversions.\n\n# [edge case]\n    Test case with all identical elements: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are identical, no eversion changes the array, so k = 0.\n    \n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 0\n    Explanation: The last element is always greater than all previous elements, so no eversion changes the array, so k = 0.\n    \n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will partition the array into [1] and [5, 4, 3, 2], resulting in [1, 5, 4, 3, 2]. The next eversion will not change the array further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe problem requires determining the minimum number of eversions needed for an array to stabilize. The key is to understand the partitioning process and how it affects the array. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the solution handles the maximum input size efficiently\n- Optimize the code for readability and maintainability\n- Provide detailed comments and documentation\n- Include edge case handling and testing\nWe will implement a function that performs the eversion operation on the array as described. The function will iterate over the array, partitioning it based on the pivot element (last element of the array) and count the number of eversions until the array stabilizes. The solution will be efficient enough to handle the maximum input size by leveraging Python's list comprehensions and built-in functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to partition the array into two parts: elements less than or equal to the pivot and elements greater than the pivot. The array is then reformed by concatenating these two parts.\n\n    'stops changing'\n    Explanation: This means that after a certain number of eversions, further eversions do not alter the array's order anymore.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to partition the array into elements greater than the pivot.\n    'not greater than': Used to partition the array into elements less than or equal to the pivot.\n\n# [degree adverb]\n    'minimum number': Refers to the smallest count of eversions needed for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements `n` and the array `a`.\n2. Initialize a counter `k` to track the number of eversions.\n3. While the array is not stable:\n   - Use the last element as a pivot.\n   - Partition the array into two parts: elements less than or equal to the pivot and elements greater than the pivot.\n   - Concatenate these two parts to form a new array.\n   - Increment `k`.\n4. Check if the new array is equal to the previous one. If yes, break the loop.\n5. Output `k` for each test case.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case 2: [10, 9, 8, 7, 6] = 1\n    Explanation: The first eversion will sort the array in ascending order, and it will remain unchanged after that.\n\n    Test case 3: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will sort the array in ascending order, and it will remain unchanged after that.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if further eversions change the array.\n", "requirement analysis:\nThe problem requires determining the minimum number of eversions needed for an array to stabilize. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring that the algorithm is both time and space efficient.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles multiple test cases efficiently.\n- Optimize the algorithm to minimize computational complexity.\n- Provide clear and correct output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that performs the eversion operation as described. The function will iterate over the array, partitioning it into two parts based on the pivot element, which is the last element of the array. The process will be repeated until the array stops changing. We will use a simple loop to count the number of eversions required for stabilization. The solution will be efficient enough to handle the constraints using basic list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to partition the array into two parts: elements not greater than the pivot and elements greater than the pivot. The array is then reformed by concatenating these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': This means elements that are less than or equal to the pivot.\n    'strictly greater than (>)': This means elements that are greater than the pivot.\n\n# [degree adverb] \n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the number of elements `n` and the array `a`.\n2. Initialize a counter `k` to track the number of eversions.\n3. Perform the eversion operation:\n   - Use the last element of the array as the pivot.\n   - Partition the array into two parts: left (elements \u2264 pivot) and right (elements > pivot).\n   - Concatenate the left and right parts to form a new array.\n4. Check if the new array is different from the previous one. If it is, increment `k` and repeat the process.\n5. Stop when the array no longer changes and output `k`.\n\n# [edge case] \n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Test case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic inherently handles cases where no change occurs after an eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of eversions on an array until it stabilizes. The key challenge is to efficiently determine the minimum number of eversions needed for the array to stop changing, especially given the constraints on input size.\nrequirement pool:\n- Implement the eversion operation as described.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm for large input sizes.\n- Maintain stable partitioning during eversions.\n- Provide detailed comments and documentation.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the pivot element, and then concatenate these parts. We will use a loop to perform eversions until the array no longer changes, and count the number of eversions required. The approach will be efficient, handling up to 100 test cases and large input sizes by leveraging Python's list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to split the array into two parts: elements not greater than the pivot and elements strictly greater than the pivot. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': means elements in the left part are less than or equal to the pivot.\n    'strictly greater than (> x)': means elements in the right part are greater than the pivot.\n\n# [degree adverb]\n    'minimum number': means finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, initialize a counter for eversions.\n    2. Perform the eversion operation:\n        - Use the last element as the pivot.\n        - Partition the array into two parts: left (elements \u2264 pivot) and right (elements > pivot).\n        - Concatenate left and right parts to form a new array.\n    3. Check if the array changes after each eversion.\n    4. Increment the counter until the array stops changing.\n    5. Return the counter as the result for each test case.\n\n# [edge case]\n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so k = 0.\n    \n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 0\n    Explanation: The last element is always greater than all previous elements, so no eversion changes the array, k = 0.\n    \n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = n-1\n    Explanation: Each eversion will move one element to the right part until only one element remains in the left part.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array changes after each eversion will naturally handle these cases.\n", "requirement analysis:\nThe problem requires implementing an eversion operation on an array, where the array is split into two parts based on a pivot element. The task is to determine the minimum number of eversions needed for the array to stop changing. The solution must handle multiple test cases efficiently, with a focus on maintaining the order of elements in each partition.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles up to 100 test cases efficiently\n- Optimize the solution for large input sizes\n- Maintain stability in the partitioning process\n- Provide clear and concise output formatting\nWe will implement the eversion operation by iteratively partitioning the array based on the last element as the pivot. The process will continue until the array remains unchanged after an eversion. We will use a simple loop to perform the eversions and check for stability. The solution will be efficient enough to handle the maximum constraints using basic list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to split the array into two parts: elements not greater than the pivot and elements strictly greater than the pivot. The array is then reformed by concatenating these two parts.\n\n    'stops changing'\n    Explanation: This means that after performing a certain number of eversions, the array remains the same in subsequent operations.\n\n# [phrase showing quantity relationship]\n    'greater than': Refers to elements that are strictly larger than the pivot element.\n    'not greater than': Refers to elements that are less than or equal to the pivot element.\n\n# [degree adverb]\n    'minimum number': Refers to the smallest count of eversions needed for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the number of elements `n` and the array `a`.\n2. Initialize a counter `k` to track the number of eversions.\n3. Perform the eversion operation:\n   - Use the last element of the array as the pivot.\n   - Partition the array into two parts: left (elements \u2264 pivot) and right (elements > pivot).\n   - Concatenate these parts to form a new array.\n4. Check if the new array is different from the previous one. If it is, increment `k` and repeat; otherwise, stop.\n5. Output `k` for each test case.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case 2: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion will move one element to the right part until all elements are sorted.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes it.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe problem requires implementing an eversion operation on an array and determining the minimum number of operations needed for the array to stabilize. The solution must handle multiple test cases efficiently, ensuring that the sum of elements across all test cases does not exceed the given constraint. The output must be correctly formatted for each test case.\nrequirement pool:\n- Implement the eversion operation correctly and efficiently.\n- Ensure the solution handles up to 100 test cases with a total of 200,000 elements.\n- Optimize the solution to minimize execution time and resource usage.\n- Provide clear and concise output for each test case.\n- Document the solution approach for better understanding and maintenance.\nWe will implement the eversion operation by iterating over the array from the end to the start, using the last element as a pivot to partition the array into two parts. We will continue performing eversions until the array stops changing. The solution will efficiently handle multiple test cases using a loop and will ensure the sum of elements across all test cases does not exceed the constraint. We will use basic list operations to maintain the stability and correctness of the eversion operation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to split the array into two parts: elements not greater than the pivot and elements strictly greater than the pivot. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': means elements in the left part are less than or equal to the pivot.\n    'strictly greater than (> x)': means elements in the right part are greater than the pivot.\n\n# [degree adverb] \n    'minimum number': means finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, start with the given array.\n    2. Use the last element as a pivot to partition the array into two parts: left (elements \u2264 pivot) and right (elements > pivot).\n    3. Concatenate the left and right parts to form a new array.\n    4. Repeat the eversion operation until the array stops changing.\n    5. Count and return the number of eversions performed.\n\n# [edge case] \n    Test case with all identical elements: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so k = 0.\n    \n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 0\n    Explanation: The last element is always greater than all previous elements, so no eversion changes the array, k = 0.\n    \n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = n-1\n    Explanation: Each eversion will move one element to the right part until only one element remains in the left part.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating and checking for changes in the array will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently partition the array using the last element as a pivot and determine the minimum number of eversions needed. The solution must handle multiple test cases and large input sizes within the given constraints.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles the maximum input size\n- Optimize the algorithm for performance\n- Provide clear and correct output for each test case\n- Include edge case handling in the implementation\nWe will implement a function to perform the eversion operation on an array until it stabilizes. The function will iterate over the array, using the last element as a pivot to partition the array into two parts: elements less than or equal to the pivot and elements greater than the pivot. The process will repeat until the array no longer changes. We will use a simple loop to count the number of eversions required for stabilization. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to split the array into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. The array is then reformed by concatenating these two parts.\n\n    'stabilizes'\n    Explanation: The array is said to stabilize when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to determine which elements go into the right part of the array during the eversion operation.\n    'less than or equal to': Used to determine which elements go into the left part of the array during the eversion operation.\n\n# [degree adverb] \n    'minimum': Refers to finding the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements `n` and the array `a`.\n2. Initialize a counter `k` to track the number of eversions.\n3. While the array changes:\n   - Use the last element as a pivot.\n   - Partition the array into two parts: left (elements \u2264 pivot) and right (elements > pivot).\n   - Concatenate left and right to form a new array.\n   - Increment `k`.\n4. Once the array stabilizes, output `k`.\n\n# [edge case] \n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will sort the array in ascending order, and it will stabilize immediately.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in ascending order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array changes after each eversion inherently handles these cases.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently determine the number of eversions needed for the array to stop changing, given the constraints on input size and value range.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the solution handles up to 100 test cases efficiently\n- Optimize the algorithm for large input sizes\n- Provide clear documentation and comments in the code\n- Include edge case handling for arrays with identical elements\nWe will implement the eversion operation using a simple loop to iterate over the array and partition it based on the pivot element. The algorithm will track the number of eversions required for the array to stabilize. Given the constraints, we will ensure the solution is efficient by minimizing unnecessary operations and using Python's built-in list operations for partitioning.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to split the array into two parts: elements not greater than the pivot and elements strictly greater than the pivot. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements \u2264 pivot\n    'strictly greater than': means elements > pivot\n\n# [degree adverb] \n    'minimum': means the smallest number of eversions required for the array to stop changing\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for eversions.\n    3. Perform the eversion operation:\n       - Use the last element as the pivot.\n       - Partition the array into two parts based on the pivot.\n       - Concatenate the two parts to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it changes, increment the counter and repeat; otherwise, stop.\n    6. Output the counter value for each test case.\n\n# [edge case] \n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the pivot, so no eversion changes the array.\n    \n    Case 3: [1, 2, 3, 4, 5] = 1\n    Explanation: The first eversion will stabilize the array as all elements \u2264 pivot.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after an eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently partition the array based on the pivot and determine the minimum number of eversions needed. The solution must handle multiple test cases and large input sizes within the given constraints.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles up to 100 test cases\n- Optimize the code for readability\n- Provide clear and concise output\n- Include comments and documentation for maintainability\nWe will implement the eversion operation using a simple loop to partition the array based on the pivot element, which is the last element of the array. The algorithm will iterate over the array, performing eversions until the array stabilizes. We will use Python's built-in list operations to efficiently partition the array and concatenate the results. The approach will be straightforward to ensure readability and maintainability, while also being efficient enough to handle large inputs within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to split the array into two parts: one containing elements not greater than the pivot and the other containing elements strictly greater than the pivot. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to determine which elements go into the right part of the partition during eversion.\n    'not greater than': Used to determine which elements go into the left part of the partition during eversion.\n\n# [degree adverb] \n    'minimum': Refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. For each test case, read the array and initialize a counter for eversions.\n    2. Perform the eversion operation:\n        - Use the last element as a pivot.\n        - Partition the array into two parts based on the pivot.\n        - Concatenate the two parts to form a new array.\n    3. Check if the new array is different from the previous one.\n    4. If it is different, increment the counter and repeat the process.\n    5. If it is not different, stop and record the counter value as the result for that test case.\n    6. Output the results for all test cases.\n\n# [edge case] \n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion will change the array, so the number of eversions required is 0.\n\n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 0\n    Explanation: The last element is always greater than all previous elements, so no eversion will change the array.\n\n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will rearrange the array to [1, 5, 4, 3, 2], and subsequent eversions will not change it further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe problem requires determining the minimum number of eversions needed for an array to stop changing. The solution must efficiently handle up to 200,000 elements across multiple test cases. The key challenge is to implement the eversion operation correctly and determine when the array stabilizes.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output for each test case.\n- Maintain code readability and simplicity.\n- Optimize for performance beyond the basic requirements.\nWe will implement the eversion operation by iterating through the array from the end to the start, using the last element as the pivot. We will partition the array into two parts based on the pivot and concatenate them. We will repeat this process until the array stops changing. The solution will efficiently handle multiple test cases by processing each test case independently and using a simple loop to determine the number of eversions required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves using the last element of the array as a pivot to partition the array into two parts: elements not greater than the pivot and elements greater than the pivot. The array is then reformed by concatenating these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264)': This means elements that are less than or equal to the pivot.\n    'strictly greater than (>)': This means elements that are greater than the pivot.\n\n# [degree adverb] \n    'minimum number': This refers to the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for eversions.\n3. Use a loop to perform eversions:\n   - Use the last element as the pivot.\n   - Partition the array into two parts: elements \u2264 pivot and elements > pivot.\n   - Concatenate these parts to form a new array.\n   - Check if the array has changed; if not, break the loop.\n4. Output the number of eversions for each test case.\n\n# [edge case] \n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion will move one element to the right part until all elements are sorted.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array has changed after each eversion will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 189, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "expand_one2two", "parent_index": 18}
