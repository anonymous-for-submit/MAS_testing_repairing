{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient, considering larger grid sizes and multiple poles.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient, considering larger grid sizes and multiple poles.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). It is important to understand that this grid represents the area where telephone poles are located within the city. There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient, considering larger grid sizes and multiple poles.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "Mr. Chanek's city can be represented as a plane, and he wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1) where a telephone pole is located at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y); formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m, so help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} and ensure that your solution is efficient, considering larger grid sizes and multiple poles.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid minus one.\n        m (int): The number of columns in the grid minus one.\n        grid (List[List[int]]): A 2D list representing the grid where 1 indicates a telephone pole.\n\n    Returns:\n        int: The sum of squared distances for each grid point to the nearest telephone pole.\n    \"\"\"\n    # Initialize the distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize the queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # If a shorter distance is found, update and enqueue\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Sum all the squared minimum distances\n    total_sum = sum(distance_grid[x][y] ** 2 for x in range(n + 1) for y in range(m + 1))\n    \n    return total_sum\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Output interface\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to its nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid.\n        m (int): The number of columns in the grid.\n        grid (List[List[int]]): A 2D list representing the grid, where 1 indicates a telephone pole.\n\n    Returns:\n        int: The sum of squared distances from each grid point to its nearest telephone pole.\n    \"\"\"\n    # Initialize a 2D list to store the minimum squared distances for each grid point\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with all telephone poles and set their distances to zero\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distances[x][y] = 0\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate the minimum squared distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # If a shorter path is found, update the distance and add to queue\n                if distances[nx][ny] > distances[x][y] + 1:\n                    distances[nx][ny] = distances[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Sum up all the squared distances stored in the 2D list\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += distances[x][y] ** 2\n    \n    return total_sum\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Function call and output\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[List[int]]): 2D list representing the grid with telephone poles.\n\n    Returns:\n        int: Sum of squared distances from each point to the nearest telephone pole.\n    \"\"\"\n    # Initialize the distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize the queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # If a shorter path is found, update the distance and enqueue the position\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Sum up all the minimum squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 0:  # Only consider non-pole positions\n                min_distance = distance_grid[x][y]\n                total_sum += min_distance ** 2\n    \n    return total_sum\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Function call\nresult = calculate_sum_of_squared_distances(n, m, grid)\n\n# Output interface\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the city area with telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each point on the grid to the nearest pole.\n    \"\"\"\n    # Initialize the distance matrix with infinity\n    distance_matrix = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles and set their distances to zero\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_matrix[x][y] = 0\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum squared distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate squared distance\n                squared_distance = (nx - x) ** 2 + (ny - y) ** 2\n                \n                # If a shorter distance is found, update and enqueue the position\n                if distance_matrix[nx][ny] > distance_matrix[x][y] + squared_distance:\n                    distance_matrix[nx][ny] = distance_matrix[x][y] + squared_distance\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of all squared distances\n    total_sum = sum(sum(row) for row in distance_matrix)\n    \n    return total_sum\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n + 1)]\n    \n    # Output interface\n    result = calculate_sum_of_distances(n, m, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom collections import deque\nfrom typing import List\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): 2D list representing the grid with telephone poles.\n\n    Returns:\n        int: Sum of squared distances from each point to the nearest telephone pole.\n    \"\"\"\n    # Initialize the distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize the queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum squared distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate squared distance\n                squared_distance = (nx - x) ** 2 + (ny - y) ** 2\n                \n                # If a shorter distance is found, update and enqueue\n                if distance_grid[nx][ny] > distance_grid[x][y] + squared_distance:\n                    distance_grid[nx][ny] = distance_grid[x][y] + squared_distance\n                    queue.append((nx, ny))\n    \n    # Sum all the minimum squared distances\n    total_distance = sum(sum(row) for row in distance_grid)\n    \n    return total_distance\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Function call and output\nresult = calculate_sum_of_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to its nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid minus one.\n        m (int): The number of columns in the grid minus one.\n        grid (List[List[int]]): A 2D list representing the grid with telephone poles.\n\n    Returns:\n        int: The sum of squared distances from each grid point to its nearest telephone pole.\n    \"\"\"\n    # Initialize a 2D list to store the minimum distances for each grid point\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with all pole positions and set their distances to zero\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distances[x][y] = 0\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate the new distance\n                new_distance = distances[x][y] + 1\n                if new_distance < distances[nx][ny]:\n                    distances[nx][ny] = new_distance\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distances[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Function call\nresult = calculate_sum_of_distances(n, m, grid)\n\n# Output interface\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each point to the nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid minus one.\n        m (int): The number of columns in the grid minus one.\n        grid (List[List[int]]): A 2D list representing the grid where 1 indicates a telephone pole.\n\n    Returns:\n        int: The sum of squared distances from each point to the nearest telephone pole.\n    \"\"\"\n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initialize the distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Initialize the queue with all telephone poles and set their distance to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0\n    \n    # Perform BFS\n    while queue:\n        x, y = queue.popleft()\n        \n        # Check all 4 possible directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check if the new position is within bounds\n            if 0 <= nx <= n and 0 <= ny <= m:\n                # If a shorter path is found, update the distance and enqueue the position\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Sum up all the minimum squared distances\n    total_sum = sum(sum(distance ** 2 for distance in row) for row in distance_grid)\n    \n    return total_sum\n\ndef main():\n    \"\"\"Main function to read input, process the grid, and output the result.\"\"\"\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n + 1)]\n    result = calculate_sum_of_squared_distances(n, m, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_distance_sum(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid.\n        m (int): The number of columns in the grid.\n        grid (List[List[int]]): A 2D list representing the grid where 1 indicates a telephone pole and 0 indicates an empty space.\n\n    Returns:\n        int: The sum of squared Euclidean distances for each grid point to the nearest telephone pole.\n    \"\"\"\n    # Initialize a queue for BFS and a distance matrix\n    queue = deque()\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n\n    # Populate the queue with initial positions of telephone poles and set their distances to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distances[x][y] = 0\n\n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Perform BFS to calculate the minimum distance to a telephone pole for each grid point\n    while queue:\n        x, y = queue.popleft()\n        current_distance = distances[x][y]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distances[nx][ny] == float('inf'):\n                distances[nx][ny] = current_distance + 1\n                queue.append((nx, ny))\n\n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += distances[x][y] ** 2\n\n    return total_sum\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Output interface\nresult = calculate_distance_sum(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to its nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid minus one.\n        m (int): The number of columns in the grid minus one.\n        grid (List[List[int]]): A 2D list representing the grid with telephone poles.\n\n    Returns:\n        int: The sum of squared distances from each grid point to its nearest telephone pole.\n    \"\"\"\n    # Directions for moving in the grid (right, left, down, up)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Initialize the distance matrix with infinity\n    distance = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Enqueue all telephone poles and set their distance to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance[x][y] = 0\n    \n    # Perform BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        # Explore all four directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check if the new position is within bounds\n            if 0 <= nx <= n and 0 <= ny <= m:\n                # If a shorter distance is found, update and enqueue\n                if distance[nx][ny] > distance[x][y] + 1:\n                    distance[nx][ny] = distance[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Sum all the minimum squared distances\n    total_sum = sum(distance[x][y] ** 2 for x in range(n + 1) for y in range(m + 1))\n    \n    return total_sum\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Function call\nresult = calculate_sum_of_distances(n, m, grid)\n\n# Output interface\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared Euclidean distances from each point to its nearest telephone pole.\n\n    Args:\n        n (int): The number of rows in the grid.\n        m (int): The number of columns in the grid.\n        grid (List[List[int]]): A 2D list representing the grid where 1 indicates a telephone pole and 0 indicates empty space.\n\n    Returns:\n        int: The sum of squared distances from each point to its nearest telephone pole.\n    \"\"\"\n    # Initialize the distance matrix with infinity\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize the queue for BFS\n    queue = deque()\n    \n    # Populate the queue with all telephone poles and set their distances to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distances[x][y] = 0\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum squared distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate squared distance\n                squared_distance = (nx - x) ** 2 + (ny - y) ** 2\n                \n                # If a closer pole is found, update the distance and enqueue the point\n                if distances[nx][ny] > distances[x][y] + squared_distance:\n                    distances[nx][ny] = distances[x][y] + squared_distance\n                    queue.append((nx, ny))\n    \n    # Sum all the minimum squared distances\n    total_distance_sum = sum(sum(row) for row in distances)\n    \n    return total_distance_sum\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Output interface\nresult = calculate_sum_of_distances(n, m, grid)\nprint(result)\n"], "plans": ["requirement analysis:\nThe requirement is to efficiently compute the sum of squared distances from each grid point to the nearest telephone pole. The solution must handle large grid sizes and multiple poles, ensuring accuracy and efficiency.\nrequirement pool:\n- Efficient calculation of squared distances for large grids\n- Accurate handling of multiple poles\n- Scalability for larger grid sizes\n- Optimization for edge cases\n- Visualization of results\nWe will use a breadth-first search (BFS) approach to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids and multiple poles as it explores all possible paths in a systematic manner, ensuring that the shortest path to a pole is found. We will utilize a queue to manage the BFS process and a 2D list to store the minimum squared distances for each grid point.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: In the requirement, Euclidean distance refers to the straight-line distance between two points in a plane. The square of this distance is used to calculate S(x, y).\n\n    'grid'\n    Explanation: The grid represents the city layout, with each cell indicating whether a telephone pole is present.\n\n# [phrase showing quantity relationship]\n    'nearest'\n    Explanation: This indicates that for each point (x, y), we need to find the closest telephone pole in terms of Euclidean distance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the grid dimensions and the grid itself.\n    2. Initialize a 2D list to store the minimum squared distances for each grid point.\n    3. Use a breadth-first search (BFS) starting from each telephone pole to calculate the minimum squared distance to each grid point.\n    4. For each grid point, update its minimum squared distance if a closer pole is found during BFS.\n    5. Sum all the minimum squared distances to get the final result.\n\n# [edge case]\n    Input: 0 0\n           1\n    Output: 0\n    Explanation: The grid is a single point with a telephone pole, so the distance to itself is zero.\n\n    Input: 1 1\n           11\n           11\n    Output: 0\n    Explanation: Every point in the grid is a telephone pole, so the distance to itself is zero for all points.\n\n    Input: 1 1\n           10\n           01\n    Output: 2\n    Explanation: The nearest pole for (0,1) and (1,0) is at (0,0) and (1,1) respectively, each with a squared distance of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by ensuring that each point's minimum squared distance is calculated correctly.\n", "requirement analysis:\nThe requirement is to calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The solution must be efficient to handle grids up to 2000x2000 in size. The presence of at least one pole is guaranteed, simplifying the nearest pole search.\nrequirement pool:\n- Implement an efficient algorithm to calculate the sum of squared distances.\n- Optimize the algorithm for large grid sizes.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as grids with poles only at the edges.\nWe will use a Breadth-First Search (BFS) approach to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable because it can handle large grid sizes and multiple poles efficiently by exploring the grid in layers, ensuring that the nearest pole is found quickly. We will utilize a queue to manage the BFS process and a 2D list to store the minimum squared distances for each grid point.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A two-dimensional array representing the city layout, where each cell can either have a telephone pole or not.\n    'Euclidean distance': The straight-line distance between two points in a plane, calculated using the formula \\((x_2 - x_1)^2 + (y_2 - y_1)^2\\).\n    'BFS (Breadth-First Search)': An algorithm for traversing or searching tree or graph data structures, used here to find the nearest telephone pole efficiently.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This means we need to calculate the total of all squared distances from each point to its nearest telephone pole.\n    'nearest pole': This indicates that for each point, we need to find the closest telephone pole in terms of Euclidean distance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the grid dimensions \\(n\\) and \\(m\\), and the grid itself.\n2. Initialize a 2D list to store the minimum squared distances for each grid point.\n3. Use a queue to perform BFS starting from all telephone poles simultaneously.\n4. For each point in the queue, calculate its neighbors and update their squared distances if a shorter path is found.\n5. Continue the BFS until all points have been processed.\n6. Sum up all the squared distances stored in the 2D list and output the result.\n\n# [edge case]\n    Edge Case 1: \n    Input: \n    0 0\n    1\n    Output: \n    0\n    Explanation: The grid is 1x1 with a single telephone pole, so the distance is zero.\n\n    Edge Case 2: \n    Input: \n    1 1\n    11\n    11\n    Output: \n    0\n    Explanation: Every point is a telephone pole, so all distances are zero.\n\n    Edge Case 3: \n    Input: \n    1 1\n    10\n    01\n    Output: \n    2\n    Explanation: The grid has two poles at opposite corners, and each non-pole point has a distance of 1 to its nearest pole.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles all cases by ensuring that each point's nearest pole is found efficiently.\n", "requirement analysis:\nThe requirement is to compute the sum of squared Euclidean distances from each grid point to the nearest telephone pole efficiently. The grid can be large, so the solution must be optimized for performance. The presence of at least one pole ensures that every point has a nearest pole.\nrequirement pool:\n- Efficiently calculate the sum of squared distances for large grids\n- Ensure accuracy of results for all test cases\n- Optimize algorithm to handle edge cases\n- Implement a solution that is easy to understand and maintain\n- Provide detailed documentation for the algorithm\nWe will use a breadth-first search (BFS) approach to efficiently calculate the nearest telephone pole for each point on the grid. This approach is suitable because it can handle large grids and multiple poles efficiently by propagating the distance from each pole simultaneously. We will utilize a queue to manage the BFS and a 2D list to store the minimum squared distances for each grid point.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A two-dimensional array representing the city layout, where each cell can either have a telephone pole or not.\n    'Euclidean distance': The straight-line distance between two points in a plane, calculated using the formula \\((x_2 - x_1)^2 + (y_2 - y_1)^2\\).\n    'BFS (Breadth-First Search)': An algorithm for traversing or searching tree or graph data structures, used here to find the nearest telephone pole efficiently.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This means we need to calculate the total of all squared distances from each point to its nearest telephone pole.\n    'nearest pole': This indicates that for each point, we need to find the closest telephone pole in terms of Euclidean distance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the grid dimensions \\(n\\) and \\(m\\), and the grid itself.\n2. Initialize a 2D list to store the minimum squared distances for each grid point.\n3. Use a queue to perform BFS starting from all telephone poles simultaneously.\n4. For each point in the queue, calculate its neighbors and update their distances if a shorter path is found.\n5. Continue the BFS until all points have been processed.\n6. Sum up all the minimum squared distances stored in the 2D list and return this sum as the result.\n\n# [edge case]\n    Edge Case 1: A grid with only one telephone pole at one corner.\n    Input: \n    0 0\n    1\n    Expected Output: 0\n    Explanation: The only point is a telephone pole itself, so the distance is zero.\n\n    Edge Case 2: A grid with telephone poles at every position.\n    Input:\n    1 1\n    11\n    11\n    Expected Output: 0\n    Explanation: Every point is a telephone pole, so all distances are zero.\n\n    Edge Case 3: A grid with maximum size and a single telephone pole at the center.\n    Input:\n    1999 1999\n    (grid with a single '1' at position (1000, 1000) and '0' elsewhere)\n    Expected Output: Large number (calculated based on distances)\n    Explanation: The distances will be largest at the corners and smallest near the center.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles all cases by ensuring that each point's distance is calculated based on its nearest pole.\n", "requirement analysis:\nThe requirement is to compute the sum of squared Euclidean distances from each grid point to the nearest telephone pole efficiently. The solution must handle large grid sizes and multiple poles, ensuring accuracy and performance.\nrequirement pool:\n- Efficient computation of distances for large grids\n- Accurate calculation of sum of distances\n- Optimization for performance and memory usage\n- Handling multiple test cases seamlessly\n- User-friendly output format\nWe will use a breadth-first search (BFS) algorithm to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it minimizes redundant calculations and ensures that each point is processed in a systematic manner. We will utilize a queue to manage the BFS traversal and a matrix to store the minimum squared distances.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A structured representation of the city area where telephone poles are located, defined by rows and columns.\n    'Euclidean distance': A measure of the straight-line distance between two points in a plane, squared in this context.\n    'nearest pole': The closest telephone pole to a given point on the grid.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This indicates that we need to calculate the total of squared distances for each point on the grid.\n    Implementation: Iterate over each grid point, calculate the squared distance to the nearest pole, and accumulate these values.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to create a grid representation.\n    2. Initialize a matrix to store the minimum squared distances for each point.\n    3. Use BFS to traverse the grid starting from each pole, updating the minimum squared distance for each point.\n    4. Accumulate the squared distances for all points to get the final sum.\n\n# [edge case]\n    Input: 0 0\n           1\n    Output: 0\n    Explanation: The grid is minimal with only one point which is a pole itself, so the distance is zero.\n\n    Input: 1 1\n           11\n           11\n    Output: 0\n    Explanation: All points are poles, so the nearest pole distance for each is zero.\n\n    Input: 1 1\n           10\n           01\n    Output: 2\n    Explanation: The nearest pole for (0,1) is (0,0) and for (1,0) is (1,1), both have a squared distance of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by ensuring that each point's distance is calculated correctly based on its nearest pole.\n", "requirement analysis:\nThe main requirement is to compute the sum of squared Euclidean distances from each grid point to the nearest telephone pole efficiently. The solution must handle large grid sizes up to 2000x2000 and ensure accuracy across all test cases.\nrequirement pool:\n- Efficient computation of distances for large grids\n- Accurate calculation of sum of distances\n- Optimization for performance\n- Handling edge cases with minimum poles\n- User-friendly output format\nWe will use a breadth-first search (BFS) approach to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it allows us to propagate the minimum distance from each pole to all other points in the grid. We will utilize a queue to manage the BFS process and a 2D list to store the minimum squared distances for each point.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A 2D array representing the city where each cell can either have a telephone pole (1) or not (0).\n    'Euclidean distance': The straight-line distance between two points in a plane, squared in this context.\n    'BFS (Breadth-First Search)': An algorithm for traversing or searching tree or graph data structures, used here to find the nearest pole efficiently.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This means we need to calculate the total of all squared distances from each point to its nearest telephone pole.\n    'nearest': This indicates that for each point, we need to find the closest telephone pole.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to create the grid and identify all positions of telephone poles.\n2. Initialize a 2D list to store the minimum squared distances for each point.\n3. Use a queue to perform BFS starting from all telephone pole positions simultaneously.\n4. For each point in the grid, calculate the squared Euclidean distance to its nearest pole using BFS.\n5. Sum all the minimum squared distances and return the result.\n\n# [edge case]\n    Edge Case 1: Grid with only one telephone pole at a corner.\n    Input: \n    1 1\n    10\n    00\n    Expected Output: 5\n    Explanation: The distances are calculated as follows: (0,0) = 0, (0,1) = 1, (1,0) = 1, (1,1) = 2. Sum = 0 + 1 + 1 + 2 = 4.\n\n    Edge Case 2: Grid with telephone poles at all corners.\n    Input:\n    1 1\n    11\n    11\n    Expected Output: 0\n    Explanation: Every point is a pole itself, so all distances are zero.\n\n    Edge Case 3: Grid with a single row or column.\n    Input:\n    0 2\n    101\n    Expected Output: 2\n    Explanation: The distances are calculated as follows: (0,0) = 0, (0,1) = 1, (0,2) = 0. Sum = 0 + 1 + 0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by ensuring that each point's distance is calculated based on its nearest pole.\n", "requirement analysis:\nThe requirement is to compute the sum of squared Euclidean distances from each grid point to the nearest telephone pole efficiently. The grid can be large, so the solution must be optimized for performance while ensuring accuracy.\nrequirement pool:\n- Efficient computation of distances for large grids\n- Accurate calculation of sum of distances\n- Optimization for performance\n- Handling multiple test cases\n- User-friendly output format\nWe will use a breadth-first search (BFS) approach to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it allows us to propagate the minimum distance from each pole to all other points in the grid. We will utilize a queue to manage the BFS and a 2D list to store the minimum distances. The BFS will start from all pole positions simultaneously, ensuring that each point is reached in the shortest possible path.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': Represents the area where telephone poles are located within the city.\n    'Euclidean distance': The straight-line distance between two points in a plane, squared in this context.\n    'telephone pole': A point in the grid where a pole is located, denoted by a value of 1.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': Refers to the total of squared distances from each grid point to its nearest telephone pole.\n    Implementation: Iterate over each grid point, calculate the squared distance to the nearest pole, and accumulate the sum.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get grid dimensions and pole positions.\n    2. Initialize a 2D list to store minimum distances for each grid point.\n    3. Use BFS starting from all pole positions to propagate minimum distances to all other points.\n    4. For each grid point, calculate the squared distance to its nearest pole and accumulate the sum.\n    5. Output the accumulated sum.\n\n# [edge case]\n    Input: 0 0\n           1\n    Output: 0\n    Explanation: The grid is a single point with a pole, so the distance is zero.\n\n    Input: 1 1\n           11\n           11\n    Output: 0\n    Explanation: All points are poles, so the distance to the nearest pole is zero for every point.\n\n    Input: 1 1\n           10\n           01\n    Output: 2\n    Explanation: The points (0,1) and (1,0) have a distance of 1 to their nearest pole.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles all cases by ensuring each point is reached in the shortest path from any pole.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The solution must be efficient to handle grids up to 2000x2000 in size. The presence of at least one pole is guaranteed, simplifying the nearest pole search.\nrequirement pool:\n- Efficiently calculate the sum of squared distances for large grids.\n- Ensure accuracy of results for all possible grid configurations.\n- Optimize the algorithm to reduce computation time.\n- Handle edge cases where poles are clustered or sparse.\n- Provide a user-friendly interface for input and output.\nWe will use a breadth-first search (BFS) approach to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it allows us to propagate the minimum distance from each pole to all other points in the grid. We will utilize a queue to manage the BFS and a 2D list to store the minimum squared distances for each point.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A two-dimensional array representing the city layout where each cell can either be empty or contain a telephone pole.\n    'Euclidean distance': The straight-line distance between two points in a plane, calculated using the formula \\((x_2 - x_1)^2 + (y_2 - y_1)^2\\).\n    'BFS (Breadth-First Search)': An algorithm for traversing or searching tree or graph data structures, used here to find the shortest path from telephone poles to other points.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This means we need to calculate the total of all squared distances from each point to its nearest telephone pole.\n    'nearest pole': This indicates that for each point, we need to find the closest telephone pole in terms of Euclidean distance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the grid dimensions and the grid itself.\n2. Initialize a 2D list to store the minimum squared distances for each point.\n3. Use a queue to perform BFS starting from all telephone poles simultaneously.\n4. For each point in the queue, calculate its squared distance to the nearest pole and update the minimum distance if a shorter path is found.\n5. Continue the BFS until all points have been processed.\n6. Sum up all the minimum squared distances and return the result.\n\n# [edge case]\n    Input: 0 0\n           1\n    Output: 0\n    Explanation: The grid is 1x1 with a single telephone pole, so the distance is zero.\n\n    Input: 1 1\n           11\n           11\n    Output: 0\n    Explanation: Every point is a telephone pole, so all distances are zero.\n\n    Input: 1 1\n           10\n           01\n    Output: 2\n    Explanation: The points (0,1) and (1,0) are each one unit away from their nearest pole, resulting in a total squared distance of 1 + 1 = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles all cases, including grids with minimal size or multiple poles.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The solution must be efficient to handle large grid sizes up to 2000x2000 and ensure accuracy across multiple test cases. The presence of at least one pole guarantees that every point has a nearest pole.\nrequirement pool:\n- Efficiently compute the sum of squared distances for large grids\n- Ensure accuracy of results for all test cases\n- Optimize algorithm for performance improvements\n- Provide a user-friendly interface for input and output\n- Include detailed documentation for developers\nWe will use a Breadth-First Search (BFS) algorithm to efficiently compute the nearest telephone pole for each grid point. This approach is suitable for large grids as it minimizes redundant calculations and ensures that each point is processed in optimal time. We will utilize the collections.deque for efficient queue operations in BFS.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: The Euclidean distance is a measure of the true straight line distance between two points in Euclidean space. In this requirement, it is used to calculate the distance between a grid point and the nearest telephone pole.\n\n    'grid'\n    Explanation: The grid represents the city plane where each cell can either contain a telephone pole (denoted by 1) or be empty (denoted by 0).\n\n# [phrase showing quantity relationship]\n    'nearest': This indicates that for each point on the grid, we need to find the closest telephone pole in terms of Euclidean distance.\n    Implementation: Use BFS to explore each grid point and calculate the distance to the nearest pole.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to create a grid representation.\n    2. Initialize a BFS queue with all telephone pole positions.\n    3. For each point in the grid, use BFS to find the nearest telephone pole and calculate the square of the Euclidean distance.\n    4. Sum all calculated distances for each grid point.\n    5. Return the total sum.\n\n# [edge case]\n    Input: \n    0 0\n    1\n    Output: \n    0\n    Explanation: The grid is minimal with only one point which is a telephone pole itself, so the distance is zero.\n\n    Input: \n    1 1\n    11\n    11\n    Output: \n    0\n    Explanation: All points are telephone poles, so each point's nearest pole is itself, resulting in zero distance.\n\n    Input: \n    1 1\n    10\n    00\n    Output: \n    2\n    Explanation: The point (1,1) has a nearest pole at (0,0) with a squared Euclidean distance of 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles all cases by calculating distances from existing poles efficiently.\n", "requirement analysis:\nThe requirement is to compute the sum of squared Euclidean distances from each grid point to the nearest telephone pole efficiently. The grid can be large, so the solution must be optimized for performance. The input format must be strictly followed, and the solution should handle multiple test cases accurately.\nrequirement pool:\n- Efficient computation of distances for large grids\n- Accurate handling of multiple test cases\n- Optimization for performance\n- Strict adherence to input/output format\n- User-friendly interface for input and output\nWe will use a breadth-first search (BFS) approach to efficiently compute the nearest telephone pole for each grid point. This approach is suitable for large grids as it avoids recalculating distances repeatedly and leverages the grid structure. We will utilize the collections.deque for efficient queue operations in BFS.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A structured representation of the city as a plane, where each cell can contain a telephone pole.\n    'Euclidean distance': The straight-line distance between two points in the plane, calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2.\n    'nearest pole': The closest telephone pole to a given point on the grid, which determines the value of S(x, y).\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This indicates that we need to calculate the total sum of squared distances from each grid point to its nearest telephone pole.\n    '0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m': Specifies the range of grid points to consider, covering all points within the grid dimensions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve grid dimensions and the grid itself.\n    2. Identify all positions of telephone poles in the grid.\n    3. Initialize a matrix to store the minimum squared distance for each grid point.\n    4. Use BFS starting from each telephone pole to compute the minimum squared distance to each grid point.\n    5. For each grid point, update its minimum squared distance if a closer pole is found during BFS traversal.\n    6. Sum all minimum squared distances stored in the matrix to get the final result.\n\n# [edge case]\n    Input: 0 0\n           1\n    Output: 0\n    Explanation: The grid is a single point with a telephone pole, so the distance is zero.\n\n    Input: 1 1\n           11\n           11\n    Output: 0\n    Explanation: Every point in the grid is a telephone pole, so all distances are zero.\n\n    Input: 1 1\n           10\n           01\n    Output: 2\n    Explanation: The points (0,1) and (1,0) are each one unit away from their nearest pole.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by ensuring that each point's distance is calculated correctly based on its nearest pole.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The solution must be efficient to handle grids up to 2000x2000 in size. The presence of at least one pole ensures that every point has a nearest pole.\nrequirement pool:\n- Efficiently calculate the sum of squared distances for large grids\n- Ensure accuracy for all test cases\n- Optimize the algorithm for performance\n- Handle edge cases with minimal poles\n- Provide clear documentation and code comments\nWe will use a Breadth-First Search (BFS) algorithm to efficiently calculate the nearest telephone pole for each point in the grid. This approach is suitable for large grids as it minimizes redundant calculations and ensures that each point is processed in a systematic manner. We will utilize the collections.deque for efficient queue operations in BFS.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A two-dimensional array representing the city layout, where each cell can either have a telephone pole or not.\n    'Euclidean distance': The straight-line distance between two points in a plane, calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2.\n    'Breadth-First Search (BFS)': An algorithm for traversing or searching tree or graph data structures, used here to find the nearest telephone pole efficiently.\n\n# [phrase showing quantity relationship]\n    'sum of all S(x, y)': This means we need to calculate the total of all squared distances from each point to its nearest telephone pole.\n    'nearest pole': This indicates finding the closest telephone pole to a given point, which is crucial for calculating S(x, y).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to create a grid representation of the city.\n    2. Initialize a matrix to store the minimum squared distances for each point.\n    3. Use BFS starting from all telephone poles simultaneously to calculate the minimum squared distance for each point in the grid.\n    4. For each point in the grid, update its distance if a closer pole is found during BFS traversal.\n    5. Sum all the minimum squared distances to get the final result.\n\n# [edge case]\n    Edge Case 1: A grid with only one telephone pole at one corner.\n    Input: \n    0 0\n    1\n    Expected Output: 0\n    Explanation: The only point is a telephone pole itself, so the distance is zero.\n\n    Edge Case 2: A grid with all cells having telephone poles.\n    Input:\n    1 1\n    11\n    11\n    Expected Output: 0\n    Explanation: Every point is a telephone pole, so all distances are zero.\n\n    Edge Case 3: A grid with maximum size and poles only at the corners.\n    Input:\n    1999 1999\n    (1 at (0,0) and (1999,1999), rest are 0s)\n    Expected Output: Calculated based on BFS traversal.\n    Explanation: The BFS will efficiently calculate distances from the corners.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by ensuring that each point's distance is calculated based on its nearest pole.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 4, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "add_1_sentence_at_end", "parent_index": 4}
