{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "prompt": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] made up entirely of zeros and ones. Note that in this problem, unlike others, the array indices start from zero. They are not indexed from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules:\n\n1. First, a new array a^{\u2192 d} is created as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.\n\nIt implies that the complete array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator.\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the conclusion of the process. If yes, also find the number of steps the process will take before it finishes. Ensure your solution efficiently handles cases where arrays are lengthy and the number of steps required is significant. Consider edge cases where the array might already be all zeros or contains long patterns that quickly stabilize.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "repair_prompt": ["You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] made up entirely of zeros and ones. Note that in this problem, unlike others, the array indices start from zero. They are not indexed from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules:\n\n1. First, a new array a^{\u2192 d} is created as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.\n\nIt implies that the complete array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator.\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the conclusion of the process. If yes, also find the number of steps the process will take before it finishes. Ensure your solution efficiently handles cases where arrays are lengthy and the number of steps required is significant. Consider edge cases where the array might already be all zeros or contains long patterns that quickly stabilize.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] made up entirely of zeros and ones. Note that in this problem, unlike others, the array indices start from zero. You should be aware that they are not indexed from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules:\n\n1. First, a new array a^{\u2192 d} is created as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.\n\nIt implies that the complete array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator.\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the conclusion of the process. If yes, also find the number of steps the process will take before it finishes. Ensure your solution efficiently handles cases where arrays are lengthy and the number of steps required is significant. Consider edge cases where the array might already be all zeros or contains long patterns that quickly stabilize.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] made up entirely of zeros and ones, and in this problem, unlike others, the array indices start from zero. In one step, the array a is replaced by another array of length n according to the following rules:\n\n1. First, a new array a^{\u2192 d} is created as a cyclic shift of the array a to the right by d cells, with its elements defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, representing a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}].\n\n2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator.\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing, and for a given array a, determine whether it will consist of only zeros at the conclusion of the process, and if yes, find the number of steps the process will take before it finishes. Ensure your solution efficiently handles cases where arrays are lengthy and the number of steps required is significant, considering edge cases where the array might already be all zeros or contains long patterns that quickly stabilize.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_array(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, each containing:\n            - n (int): The size of the array.\n            - d (int): The number of positions to cyclically shift the array.\n            - a (List[int]): The array of zeros and ones.\n\n    Returns:\n        List[int]: A list of integers where each integer is the number of steps required for the corresponding\n                   test case to make the array all zeros, or -1 if it cannot be done.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        seen_states = set()\n        \n        while True:\n            # Check if the array is all zeros\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n            \n            # Check for cycles\n            if tuple(a) in seen_states:\n                results.append(-1)\n                break\n            \n            # Record the current state\n            seen_states.add(tuple(a))\n            \n            # Perform the cyclic shift and logical AND operation\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Increment the step counter\n            steps += 1\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    # Process the test cases\n    results = process_array(t, test_cases)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps required to transform the array into all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): Array of zeros and ones.\n\n    Returns:\n        List[int]: List of results for each test case, where each result is the number of steps to reach all zeros,\n                   or -1 if it cannot be achieved.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n\n        seen_states = set()\n        steps = 0\n\n        while tuple(a) not in seen_states:\n            seen_states.add(tuple(a))\n            steps += 1\n\n            # Create cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n\n            # Perform logical AND\n            a = [a[i] & a_shifted[i] for i in range(n)]\n\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n        else:\n            results.append(-1)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n\n    results = process_test_cases(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef steps_to_all_zeros(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of steps required for each test case to transform the array into all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): Array of zeros and ones.\n\n    Returns:\n        List[int]: List of results for each test case, indicating the number of steps to reach all zeros,\n                   or -1 if the array stabilizes without becoming all zeros.\n    \"\"\"\n    results = []\n    for n, d, a in test_cases:\n        steps = 0\n        while any(a):\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            # Apply logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            # Check if the array has stabilized\n            if new_a == a:\n                results.append(-1)\n                break\n            a = new_a\n            steps += 1\n        else:\n            results.append(steps)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = steps_to_all_zeros(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case to determine the number of steps required for the array to become all zeros\n    or if it enters a cycle where it never stabilizes to all zeros.\n\n    Args:\n        test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, each containing:\n            - n (int): The size of the array.\n            - d (int): The cyclic shift offset.\n            - a (List[int]): The array of zeros and ones.\n\n    Returns:\n        List[int]: A list of results for each test case, where each result is the number of steps required\n        for the array to become all zeros, or -1 if it never stabilizes to all zeros.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n\n        seen_states = set()\n        step_count = 0\n\n        while tuple(a) not in seen_states:\n            seen_states.add(tuple(a))\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            step_count += 1\n\n            if all(x == 0 for x in a):\n                results.append(step_count)\n                break\n        else:\n            results.append(-1)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        d = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        test_cases.append((n, d, a))\n        index += 2 + n\n    \n    results = process_test_cases(test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_array(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): Array of zeros and ones.\n\n    Returns:\n        List[int]: List of results for each test case, where each result is the number of steps\n                   required for the array to become all zeros, or -1 if it never becomes all zeros.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n\n        seen_states = set()\n        steps = 0\n\n        while True:\n            current_state = tuple(a)\n            if current_state in seen_states:\n                results.append(-1)\n                break\n\n            seen_states.add(current_state)\n\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n\n            # Apply logical AND operation\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n\n    # Call the function and print results\n    results = process_array(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of integers (0s and 1s).\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the corresponding test case\n        to make the array all zeros, or -1 if the array stabilizes without becoming all zeros.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Create cyclically shifted array\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform element-wise logical AND\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array is all zeros\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            # Check if the array has stabilized\n            if new_a == a:\n                results.append(-1)\n                break\n            \n            # Update the array and increment step counter\n            a = new_a\n            steps += 1\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_test_cases(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_test_cases(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Processes each test case by performing cyclic shifts and logical AND operations\n    on the array until it stabilizes or becomes all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing n, d, and array a.\n\n    Returns:\n        List[int]: List of results for each test case, indicating the number of steps\n                   to reach an all-zero array or -1 if it never stabilizes.\n    \"\"\"\n    results = []\n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n        \n        steps = 0\n        while True:\n            steps += 1\n            # Perform cyclic shift\n            shifted_a = [a[(i + n - d) % n] for i in range(n)]\n            # Perform logical AND operation\n            new_a = [a[i] & shifted_a[i] for i in range(n)]\n            \n            if new_a == a:\n                results.append(-1)\n                break\n            \n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            a = new_a\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    # Call the function and print results\n    results = process_test_cases(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes multiple test cases to determine the number of steps required for an array to become all zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of integers (0s and 1s).\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the corresponding test case\n        to make the array consist of only zeros. If the array cannot become all zeros, returns -1 for that test case.\n    \"\"\"\n    results = []\n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            # Apply logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n            # Check if the array has stabilized\n            if new_a == a:\n                results.append(-1)\n                break\n            # Check if the array is all zeros\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            # Update the array for the next iteration\n            a = new_a\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_test_cases(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef process_test_case(n: int, d: int, a: List[int]) -> int:\n    \"\"\"Processes a single test case to determine the number of steps required\n    for the array to become all zeros or stabilize.\n\n    Args:\n        n (int): The size of the array.\n        d (int): The number of positions to cyclically shift the array.\n        a (List[int]): The array of zeros and ones.\n\n    Returns:\n        int: The number of steps required for the array to become all zeros,\n             or -1 if it stabilizes without becoming all zeros.\n    \"\"\"\n    steps = 0\n    while True:\n        # Perform cyclic shift\n        a_shifted = [a[(i + n - d) % n] for i in range(n)]\n        \n        # Perform logical AND operation\n        new_a = [a[i] & a_shifted[i] for i in range(n)]\n        \n        steps += 1\n        \n        # Check if the array is all zeros\n        if all(x == 0 for x in new_a):\n            return steps\n        \n        # Check if the array has stabilized\n        if new_a == a:\n            return -1\n        \n        # Update the array for the next iteration\n        a = new_a\n\ndef main():\n    \"\"\"Main function to handle input and output for multiple test cases.\"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        result = process_test_case(n, d, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef steps_to_all_zeros(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of steps required for each test case to transform the array into all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Number of positions to cyclically shift the array.\n            - a (List[int]): The array of zeros and ones.\n\n    Returns:\n        List[int]: List of results for each test case, where each result is the number of steps\n                   required to transform the array into all zeros, or -1 if it cannot be done.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n        \n        seen_states = set()\n        steps = 0\n        \n        while tuple(a) not in seen_states:\n            seen_states.add(tuple(a))\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n            \n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n        else:\n            results.append(-1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    # Call the function and print results\n    results = steps_to_all_zeros(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires an efficient algorithm to determine the number of steps needed for an array of zeros and ones to become all zeros after a series of cyclic shifts and logical AND operations. The solution must handle large arrays and multiple test cases efficiently, ensuring that edge cases are correctly addressed.\nrequirement pool:\n- Efficiently process arrays up to 10^6 in size.\n- Correctly determine the number of steps or if the process never results in all zeros.\n- Handle edge cases such as arrays that are already all zeros.\n- Provide clear and concise output for each test case.\n- Optimize for performance across multiple test cases.\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations until the array stabilizes or becomes all zeros. The function will efficiently handle large arrays using list operations and modular arithmetic. We will use Python's built-in capabilities to manage the cyclic shifts and logical operations without additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to rotating the elements of the array to the right by a specified number of positions, wrapping around the end of the array back to the beginning.\n\n    'logical \"AND\" operator'\n    Explanation: This is a bitwise operation that results in 1 if both operands are 1, and 0 otherwise. It is used here to combine elements of the original and shifted arrays.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array has a fixed length of n, which is important for determining the indices during cyclic shifts.\n\n    'd cells'\n    Explanation: The number of positions by which the array is cyclically shifted to the right.\n\n# [degree adverb]\n    'only zeros'\n    Explanation: The goal is to determine if the array can become entirely composed of zeros. This is a condition that must be checked after each transformation step.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and details for each test case.\n2. For each test case, perform the following:\n   - Initialize a counter for steps.\n   - While the array contains any 1s:\n     - Perform a cyclic shift of the array by d positions.\n     - Apply the logical \"AND\" operation between the original and shifted arrays.\n     - Increment the step counter.\n     - If the array becomes all zeros, record the number of steps and break.\n     - If a cycle is detected where the array does not change, return -1 for that test case.\n3. Output the results for each test case.\n\n# [edge case]\n    Test case with an already zero array:\n    Input: 1 1\n           0\n    Expected output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Test case with maximum shift:\n    Input: 3 3\n           1 0 1\n    Expected output: -1\n    Explanation: The shift equals the array length, so it will not change, resulting in no progress towards all zeros.\n\n    Test case with alternating pattern:\n    Input: 4 2\n           1 0 1 0\n    Expected output: -1\n    Explanation: The pattern will not change with a shift of 2, so it will never become all zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    \n```python\ndef process_test_cases(test_cases):\n    results = []\n    for n, d, a in test_cases:\n        steps = 0\n        seen_states = set()\n        while True:\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n            if tuple(a) in seen_states:\n                results.append(-1)\n                break\n            seen_states.add(tuple(a))\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n    return results\n\n# Example usage:\ntest_cases = [\n    (2, 1, [0, 1]),\n    (3, 2, [0, 1, 0]),\n    (5, 2, [1, 1, 0, 1, 0]),\n    (4, 2, [0, 1, 0, 1]),\n    (1, 1, [0])\n]\n\nprint(process_test_cases(test_cases))\n```\nThis code handles edge cases by checking if an array state has been seen before to detect cycles and prevent infinite loops.\n", "requirement analysis:\nThe requirements focus on processing binary arrays with cyclic shifts and logical operations. The solution must efficiently handle large arrays and edge cases, providing accurate results in terms of stabilization steps or indicating if stabilization is impossible.\nrequirement pool:\n- Efficiently process large arrays\n- Handle edge cases effectively\n- Provide accurate step counts\n- Ensure easy integration\n- Maintain clear output format\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array until it stabilizes or reaches a state where it cannot become all zeros. The function will efficiently handle large arrays by using modular arithmetic for cyclic shifts and will track changes to determine when the array stabilizes. We will use a simple loop to iterate through the steps and a set to track seen states to detect cycles.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to rotating the elements of the array to the right by a specified number of positions, wrapping around the end of the array to the beginning.\n\n    'logical \"AND\" operation'\n    Explanation: This is a bitwise operation where each bit of the output is 1 if the corresponding bits of both operands are 1, otherwise it is 0.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array has a fixed length of n, which is important for understanding how the cyclic shift operates.\n\n    'd cells'\n    Explanation: The number of positions by which the array is cyclically shifted to the right.\n\n# [degree adverb]\n    'only zeros'\n    Explanation: The goal is to determine if the array can be transformed into an array consisting entirely of zeros.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and details for each test case.\n2. For each test case, perform the following:\n   - Initialize the current array state and a step counter.\n   - Use a loop to perform cyclic shifts and logical AND operations:\n     - Compute the cyclically shifted array using modular arithmetic.\n     - Perform element-wise logical AND between the current array and its shifted version.\n     - Check if the resulting array is all zeros; if so, record the step count and break.\n     - If the array state repeats (indicating a cycle), break and return -1.\n3. Output the results for each test case.\n\n# [edge case]\n    Test Case 1: [0, 0, 0] with d = 1 = 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Test Case 2: [1, 0, 1] with d = 2 = -1\n    Explanation: The array will cycle through states without reaching all zeros.\n\n    Test Case 3: [1, 1, 1] with d = 1 = 2\n    Explanation: The array will become all zeros after two steps.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Check if the initial array is already all zeros and return 0 immediately.\n    - Use a set to track seen states to detect cycles and return -1 if a cycle is detected without reaching all zeros.\n\n```python\ndef process_test_cases(test_cases):\n    results = []\n    \n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n        \n        seen_states = set()\n        steps = 0\n        \n        while tuple(a) not in seen_states:\n            seen_states.add(tuple(a))\n            steps += 1\n            \n            # Create cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform logical AND\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n        else:\n            results.append(-1)\n    \n    return results\n\n# Example usage:\ntest_cases = [\n    (2, 1, [0, 1]),\n    (3, 2, [0, 1, 0]),\n    (5, 2, [1, 1, 0, 1, 0]),\n    (4, 2, [0, 1, 0, 1]),\n    (1, 1, [0])\n]\n\nprint(process_test_cases(test_cases))\n```\n\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the number of steps needed for an array of zeros and ones to become all zeros after a series of transformations. The solution must handle large arrays and multiple test cases efficiently, ensuring that edge cases are considered, such as arrays that never become all zeros.\nrequirement pool:\n- Efficiently handle large arrays up to 10^6 elements.\n- Correctly determine the number of steps for the array to become all zeros.\n- Return -1 if the array never becomes all zeros.\n- Handle multiple test cases in a single execution.\n- Ensure the solution is easy to understand and maintain.\nWe will implement a function that simulates the transformation process of the array. The function will cyclically shift the array and perform a logical AND operation until the array becomes all zeros or stabilizes. We will use efficient list operations to handle large arrays and ensure the solution is both fast and easy to maintain. The approach will involve checking for cycles to determine if the array will never become all zeros.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to rotating the elements of the array to the right by a specified number of positions, wrapping around the end of the array back to the beginning.\n\n    'logical \"AND\"'\n    Explanation: This is a bitwise operation where each element of the array is combined with the corresponding element of the shifted array, resulting in a new array where each element is the result of the AND operation.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array and its cyclic shift both have the same length, n, which is crucial for maintaining the structure during transformations.\n\n# [degree adverb]\n    'only zeros'\n    Explanation: The requirement is to determine if the array will consist entirely of zeros after a series of transformations. This implies checking if all elements are zero.\n\n# [code logic]\n    1. Initialize a counter for steps.\n    2. For each test case, perform the following:\n        - Read n and d.\n        - Initialize the array a.\n        - While the array contains any 1s:\n            - Perform a cyclic shift by d positions.\n            - Apply the logical AND operation between the original and shifted arrays.\n            - Increment the step counter.\n            - If the array stabilizes (no change after a step), break and return -1.\n        - If the array becomes all zeros, return the step count.\n\n# [edge case]\n    Case 1: n = 1, d = 1, a = [0]\n    Expected output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Case 2: n = 3, d = 3, a = [1, 0, 1]\n    Expected output: -1\n    Explanation: The cyclic shift will not change the array, and it will never become all zeros.\n\n    Case 3: n = 5, d = 1, a = [1, 1, 1, 1, 1]\n    Expected output: 4\n    Explanation: Each step reduces one element to zero until all are zero.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where arrays are already zeros or stabilize without becoming all zeros.\n    \n```python\ndef process_array(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, d, a = case\n        steps = 0\n        while any(a):\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            if new_a == a:\n                results.append(-1)\n                break\n            a = new_a\n            steps += 1\n        else:\n            results.append(steps)\n    return results\n```\n", "requirement analysis:\nThe requirements focus on processing binary arrays with cyclic shifts and logical operations until stabilization. The solution must efficiently handle large arrays and edge cases, providing clear output for each test case.\nrequirement pool:\n- Efficiently process arrays up to 10^6 elements\n- Handle edge cases where arrays stabilize quickly\n- Provide accurate step count for stabilization\n- Ensure logical operations are correctly implemented\n- Optimize for minimal computational resources\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array until it stabilizes. The function will efficiently handle large arrays by using a set to track previously seen states to detect cycles and avoid unnecessary computations. This approach ensures that we can determine if the array will eventually consist of only zeros or if it will enter a cycle where it never stabilizes to all zeros.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to the process of moving elements of the array to the right by a specified number of positions, wrapping around the end of the array to the beginning.\n\n    'logical \"AND\" operator'\n    Explanation: This is a bitwise operation where each element of the array is combined with the corresponding element of the shifted array, resulting in a new array where each element is the result of the logical AND operation.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array has a fixed length, and operations are performed on arrays of this length.\n\n# [degree adverb]\n    'only zeros'\n    Explanation: The requirement is to determine if the array will consist entirely of zeros after a series of operations.\n\n# [code logic]\n1. Initialize a counter for steps taken.\n2. For each test case, perform the following:\n   - Initialize a set to track seen states of the array.\n   - While the current state of the array has not been seen before:\n     - Add the current state to the set.\n     - Perform a cyclic shift on the array.\n     - Apply the logical AND operation between the original and shifted arrays.\n     - Increment the step counter.\n     - Check if the array consists only of zeros; if so, break and record the step count.\n   - If a cycle is detected (i.e., a state repeats), return -1 for that test case.\n\n# [edge case]\n    Test case with an already zero array:\n    1 1\n    0\n    Expected output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Test case with an array that never changes:\n    3 1\n    1 0 1\n    Expected output: -1\n    Explanation: The cyclic shift and AND operation will not change the array, resulting in a cycle.\n\n    Test case with maximum shift:\n    5 5\n    1 1 0 0 1\n    Expected output: -1\n    Explanation: A full shift results in no change, leading to a cycle.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if all(x == 0 for x in a):\n            return 0\n        seen_states = set()\n        while tuple(a) not in seen_states:\n            seen_states.add(tuple(a))\n            # Perform cyclic shift and AND operation\n            # Check for all zeros condition\n            # Increment step counter\n        return -1 if not all(x == 0 for x in a) else step_count\n", "requirement analysis:\nThe requirements focus on transforming an array through cyclic shifts and logical operations until stabilization. The challenge lies in efficiently handling large arrays and ensuring the process terminates correctly, especially in edge cases.\nrequirement pool:\n- Efficiently handle large arrays up to 10^6 elements\n- Ensure accurate results for all test cases\n- Optimize the number of computational steps\n- Provide clear examples and explanations\n- Scalability for future enhancements\nWe will implement a function that simulates the process of cyclically shifting the array and applying the logical AND operation until the array stabilizes or becomes all zeros. The function will efficiently handle large arrays by using a set to track previously seen states to detect cycles and avoid unnecessary computations. This approach ensures that we can determine if the array will eventually become all zeros or if it will stabilize with some ones remaining.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to the process of rotating the array elements to the right by a specified number of positions, wrapping around the end of the array back to the beginning.\n\n    'logical \"AND\"'\n    Explanation: This is a bitwise operation where each element of the array is combined with its corresponding element in the shifted array, resulting in a new array where each element is the result of the AND operation.\n\n# [phrase showing quantity relationship]\n    'only zeros'\n    Explanation: The requirement is to determine if the array will eventually consist entirely of zeros after applying the cyclic shift and AND operations repeatedly.\n\n# [degree adverb]\n    'first time'\n    Explanation: This indicates that we need to find the number of steps required for the array to become all zeros for the first time, if possible.\n\n# [code logic]\n    1. Initialize a counter to track the number of steps.\n    2. Use a set to store previously seen states of the array to detect cycles.\n    3. Perform cyclic shift and logical AND operations on the array.\n    4. Check if the array consists only of zeros; if so, return the step count.\n    5. If a cycle is detected (i.e., a state repeats), return -1.\n    6. Repeat until the array stabilizes or becomes all zeros.\n\n# [edge case]\n    Input: 1 1\n           0\n    Output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Input: 3 1\n           1 0 1\n    Output: -1\n    Explanation: The array will cycle between states without becoming all zeros.\n\n    Input: 4 4\n           1 1 1 1\n    Output: -1\n    Explanation: The cyclic shift will not change the array, and it will never become all zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if all(x == 0 for x in a):\n            return 0\n        seen_states = set()\n        while True:\n            if tuple(a) in seen_states:\n                return -1\n            seen_states.add(tuple(a))\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n            if all(x == 0 for x in a):\n                return steps\n", "requirement analysis:\nThe problem requires efficiently determining the number of steps needed for an array of zeros and ones to become all zeros after cyclic shifts and logical AND operations. The solution must handle large arrays and multiple test cases, ensuring that edge cases are addressed, such as arrays that do not change or are already zeros.\nrequirement pool:\n- Efficiently process arrays up to 10^6 in size\n- Correctly determine the number of steps or if the process never results in all zeros\n- Handle edge cases, such as arrays that are already all zeros\n- Provide clear and concise output for each test case\n- Optimize for both time and space complexity\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array until it stabilizes or becomes all zeros. The function will efficiently handle large arrays by using modular arithmetic for cyclic shifts and will track changes to determine when the process stabilizes. We will use Python's built-in list operations for simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to rotating the array elements to the right by a specified number of positions, wrapping around the end of the array back to the beginning.\n\n    'logical \"AND\" operator'\n    Explanation: This is a bitwise operation where each element of the array is combined with its corresponding element in the shifted array using the AND operation, resulting in a new array.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array has a fixed length of n, which is important for defining the cyclic shift and ensuring operations are performed correctly.\n\n# [degree adverb]\n    'only zeros'\n    Explanation: The requirement is to determine if the array will consist entirely of zeros after processing, which means no element should be non-zero.\n\n# [code logic]\n    - Initialize a counter for steps.\n    - For each test case, perform the following:\n      - While the array contains any 1s:\n        - Create a cyclically shifted version of the array using modular arithmetic.\n        - Perform element-wise logical AND between the original and shifted arrays.\n        - Increment the step counter.\n        - If the array stabilizes (no change), break and return -1.\n      - If the array becomes all zeros, return the step count.\n\n# [edge case]\n    Input: 1 1\n           0\n    Output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Input: 3 3\n           1 0 1\n    Output: -1\n    Explanation: The cyclic shift will result in no change, as each element will AND with itself, maintaining its value.\n\n    Input: 4 1\n           1 1 1 1\n    Output: 2\n    Explanation: After two steps, the array will become all zeros due to consecutive AND operations reducing all elements to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking for stabilization and zero conditions.\n", "requirement analysis:\nThe requirements focus on processing an array of binary values through cyclic shifts and logical operations until a stable state is reached. The solution must efficiently handle large arrays and multiple test cases, ensuring that the output is accurate and meets the specified conditions. Edge cases, such as arrays that do not change or are already zeros, must be considered.\nrequirement pool:\n- Efficiently process arrays up to 10^6 in size.\n- Correctly determine the number of steps to reach an all-zero array.\n- Return -1 if the array never becomes all zeros.\n- Optimize for quick processing of multiple test cases.\n- Provide clear documentation and examples.\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array until it stabilizes or becomes all zeros. The function will efficiently handle large arrays by using modular arithmetic for cyclic shifts and will track changes to determine when the process can stop. We will use Python's built-in list operations for simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves moving elements of an array to the right by a specified number of positions, with elements wrapping around to the beginning of the array.\n\n    'logical \"AND\" operator'\n    Explanation: The logical \"AND\" operator compares two binary values and returns 1 if both are 1, otherwise it returns 0.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array has a fixed length of n, which is important for determining the indices during cyclic shifts.\n\n# [degree adverb] \n    'only zeros'\n    Explanation: The process aims to transform the array such that all elements are zero. This is the condition for stopping the process and determining the number of steps taken.\n\n# [code logic]\n1. For each test case, read n and d.\n2. Initialize the array a with the given elements.\n3. Initialize a step counter to zero.\n4. While the array contains any 1s:\n   - Perform a cyclic shift of the array by d positions to create a new array.\n   - Perform an element-wise logical \"AND\" between the original and shifted arrays.\n   - Increment the step counter.\n   - If the array does not change after an iteration, break the loop and return -1.\n5. If the array becomes all zeros, return the step counter.\n\n# [edge case] \n    Case 1: n = 1, d = 1, a = [0] = 0\n    Explanation: The array is already all zeros, so no steps are needed. The expected output is 0.\n\n    Case 2: n = 3, d = 3, a = [1, 0, 1] = -1\n    Explanation: The cyclic shift will not change the array, and it will never become all zeros. The expected output is -1.\n\n    Case 3: n = 5, d = 2, a = [1, 0, 0, 0, 0] = 1\n    Explanation: After one step, the array becomes all zeros. The expected output is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already all zeros or does not change after a shift.\n    \n```python\ndef process_test_cases(test_cases):\n    results = []\n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n        \n        steps = 0\n        while True:\n            steps += 1\n            shifted_a = [a[(i + n - d) % n] for i in range(n)]\n            new_a = [a[i] & shifted_a[i] for i in range(n)]\n            \n            if new_a == a:\n                results.append(-1)\n                break\n            \n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            a = new_a\n    \n    return results\n```\nThis code handles edge cases by checking if the array is already all zeros at the start and by detecting when no changes occur after a shift.\n", "requirement analysis:\nThe requirements focus on processing binary arrays with cyclic shifts and logical operations until stabilization. The solution must efficiently handle large arrays and multiple test cases, ensuring that the process terminates correctly and outputs the number of steps or -1 if stabilization is not possible.\nrequirement pool:\n- Efficiently process arrays up to 10^6 elements\n- Handle multiple test cases up to 1000\n- Ensure correct cyclic shift and logical AND operations\n- Output the number of steps or -1 if stabilization is not possible\n- Optimize for edge cases where arrays stabilize quickly\nWe will implement a function that processes each test case independently, using efficient array manipulation techniques to handle cyclic shifts and logical operations. The function will iterate until the array stabilizes, ensuring it handles large arrays and multiple test cases efficiently. We will use Python's built-in list operations for cyclic shifts and logical operations, avoiding unnecessary complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to rotating the array elements to the right by a specified number of positions, wrapping around the end of the array back to the beginning.\n\n    'logical \"AND\" operator'\n    Explanation: This is a bitwise operation where each element of the array is replaced by the result of an AND operation between itself and the corresponding element in the cyclically shifted array.\n\n# [phrase showing quantity relationship]\n    'length n'\n    Explanation: The array has a fixed size of n elements, which is important for understanding how cyclic shifts are applied.\n\n# [degree adverb]\n    'only zeros'\n    Explanation: The requirement is to determine if the array will consist entirely of zeros after a series of transformations.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and details for each test case.\n2. For each test case, perform the following steps:\n   - Initialize the array and determine its size and cyclic shift offset.\n   - Implement a loop to apply cyclic shifts and logical AND operations until the array stabilizes or becomes all zeros.\n   - Track the number of steps taken and check if the array becomes all zeros.\n   - If the array stabilizes without becoming all zeros, return -1 for that test case.\n3. Output the number of steps for each test case.\n\n# [edge case]\n    Test case with an already zero array:\n    1 1\n    0\n    Expected output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Test case with no change after cyclic shift:\n    3 1\n    1 0 1\n    Expected output: -1\n    Explanation: The cyclic shift does not change the array, so it will never become all zeros.\n\n    Test case with maximum size and quick stabilization:\n    5 5\n    1 1 1 1 1\n    Expected output: 1\n    Explanation: After one step, all elements become zero due to AND operation with shifted array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where arrays are already zero or do not change after cyclic shifts.\n```python\ndef process_test_cases(test_cases):\n    results = []\n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n            if new_a == a:\n                results.append(-1)\n                break\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            a = new_a\n    return results\n\n# Example usage:\ntest_cases = [\n    (2, 1, [0, 1]),\n    (3, 2, [0, 1, 0]),\n    (5, 2, [1, 1, 0, 1, 0]),\n    (4, 2, [0, 1, 0, 1]),\n    (1, 1, [0])\n]\n\nprint(process_test_cases(test_cases))\n```\n", "requirement analysis:\nThe problem requires efficiently determining the number of steps needed for an array of zeros and ones to become all zeros after cyclic shifts and logical AND operations. The solution must handle large arrays and multiple test cases, ensuring that it can quickly determine if the array will never become all zeros.\nrequirement pool:\n- Efficiently handle large arrays up to 10^6 elements.\n- Correctly determine the number of steps for the array to become all zeros.\n- Identify cases where the array will never become all zeros.\n- Optimize the solution for performance and clarity.\n- Provide detailed output for debugging and analysis.\nWe will implement a function that processes each test case independently. The function will perform cyclic shifts and logical AND operations iteratively until the array becomes all zeros or stabilizes. We will use efficient list operations to handle large arrays and ensure the solution is optimized for performance and clarity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to the process of rotating the elements of the array to the right by a specified number of positions, wrapping around the end of the array back to the beginning.\n\n    'logical \"AND\" operator'\n    Explanation: This is a bitwise operation that results in 1 if both operands are 1, and 0 otherwise. It is used here to combine elements of the original array and the shifted array.\n\n# [phrase showing quantity relationship]\n    'length n': Refers to the size of the array, which is important for determining how many elements are involved in operations.\n    'd cells': Refers to the number of positions by which the array is cyclically shifted to the right.\n\n# [degree adverb]\n    'only zeros': Indicates that the final goal is for all elements in the array to be zero.\n    'significant': Implies that the solution must efficiently handle cases where many steps are required.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and details for each test case.\n2. For each test case:\n   - Initialize a counter for steps.\n   - Perform cyclic shifts and logical AND operations iteratively:\n     - Create a new array by cyclically shifting the original array by d positions.\n     - Replace each element in the original array with the result of a logical AND operation between itself and the corresponding element in the shifted array.\n     - Increment the step counter.\n     - Check if the array consists entirely of zeros; if so, record the number of steps and break out of the loop.\n     - If the array stabilizes without becoming all zeros, record -1.\n3. Output the results for each test case.\n\n# [edge case]\n    Test case with an already zero array:\n    1 1\n    0\n    Expected output: 0\n    Explanation: The array is already all zeros, so no steps are needed.\n\n    Test case with an array that stabilizes without becoming all zeros:\n    4 2\n    0 1 0 1\n    Expected output: -1\n    Explanation: The cyclic shift and AND operations do not change the array to all zeros.\n\n    Test case with maximum size and complex pattern:\n    10^6 1\n    (alternating pattern of 0s and 1s)\n    Expected output: Depends on pattern stabilization; could be significant or -1 if it never becomes all zeros.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where arrays are already all zeros or stabilize without becoming all zeros.\n```python\ndef process_test_cases(test_cases):\n    results = []\n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            if new_a == a:\n                results.append(-1)\n                break\n            a = new_a\n    return results\n\n# Example usage:\ntest_cases = [\n    (2, 1, [0, 1]),\n    (3, 2, [0, 1, 0]),\n    (5, 2, [1, 1, 0, 1, 0]),\n    (4, 2, [0, 1, 0, 1]),\n    (1, 1, [0])\n]\nprint(process_test_cases(test_cases))\n```\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the number of steps needed for an array of zeros and ones to become all zeros after cyclic shifts and logical AND operations. The solution must handle large arrays and multiple test cases, providing clear output for each case. Edge cases, such as arrays that never become all zeros, must be addressed.\nrequirement pool:\n- Efficiently handle arrays up to 10^6 elements.\n- Provide correct number of steps for array to become all zeros.\n- Handle edge cases where the array never becomes all zeros.\n- Ensure clear and concise output format.\n- Optimize for performance and clarity.\nWe will implement a function that simulates the process of cyclically shifting the array and performing the logical AND operation until the array becomes all zeros or stabilizes. The function will efficiently handle large arrays by using a set to track previously seen states to detect cycles. This approach ensures that we can quickly determine if the array will never become all zeros.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: This refers to the process of rotating the array elements to the right by a specified number of positions (d). The elements that are shifted out from the end of the array reappear at the beginning.\n\n    'logical AND'\n    Explanation: This is a bitwise operation where each bit of the output is 1 if the corresponding bits of both operands are 1, otherwise it is 0.\n\n# [phrase showing quantity relationship]\n    'length n': Refers to the size of the array, which is important for determining the indices during cyclic shifts.\n    'd cells': Indicates the number of positions by which the array is cyclically shifted to the right.\n\n# [degree adverb]\n    'only zeros': This indicates that the process should continue until all elements in the array are zero. It implies a complete transformation of the array to zeros.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and details for each test case.\n2. For each test case:\n   - Initialize a counter for steps.\n   - Use a set to track previously seen states of the array to detect cycles.\n   - While the array is not all zeros and has not stabilized:\n     - Perform a cyclic shift of the array by d positions.\n     - Apply the logical AND operation between the original and shifted arrays.\n     - Check if the new state of the array has been seen before (to detect cycles).\n     - Increment the step counter.\n   - If the array becomes all zeros, record the number of steps.\n   - If a cycle is detected without reaching all zeros, return -1 for that test case.\n\n# [edge case]\n    1. n = 1, d = 1, a = [0] = 0\n    Explanation: The array is already all zeros, so no steps are needed.\n    \n    2. n = 3, d = 1, a = [1, 0, 1] = -1\n    Explanation: The array will cycle through states without ever becoming all zeros due to alternating pattern.\n    \n    3. n = 4, d = 2, a = [1, 1, 0, 0] = 2\n    Explanation: The array will become all zeros after two steps.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where arrays might already be all zeros or contain patterns that quickly stabilize.\n    \n```python\ndef process_test_cases(test_cases):\n    results = []\n    for n, d, a in test_cases:\n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n        \n        seen_states = set()\n        steps = 0\n        while tuple(a) not in seen_states:\n            seen_states.add(tuple(a))\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n        else:\n            results.append(-1)\n    \n    return results\n```\nThis code efficiently handles each test case by tracking previously seen states and applying cyclic shifts and logical AND operations until the array becomes all zeros or stabilizes into a cycle.\n"], "scores": [], "pass_results": [false, false, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 895, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "rephrase_one", "parent_index": 504}
