{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, assisting his long-lost relative Indiana Jones, to locate a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. The tunnels are established following a specific arrangement. They are set in such a way that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the minimum sum of energy needed to take the secret treasure at room v. This calculation is done under the condition that they are initially at room u (1 \u2264 u, v \u2264 n).\n\nHelp them, so you can get a portion of the treasure! Write a program to efficiently handle both types of queries given the constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, assisting his long-lost relative Indiana Jones, to locate a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. The tunnels are established following a specific arrangement. They are set in such a way that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the minimum sum of energy needed to take the secret treasure at room v. This calculation is done under the condition that they are initially at room u (1 \u2264 u, v \u2264 n).\n\nHelp them, so you can get a portion of the treasure! Write a program to efficiently handle both types of queries given the constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, assisting his long-lost relative Indiana Jones, to locate a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. The tunnels are established following a specific arrangement. These tunnels are configured in such a manner that allows for movement between every pair of rooms. They are set in such a way that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the minimum sum of energy needed to take the secret treasure at room v. This calculation is done under the condition that they are initially at room u (1 \u2264 u, v \u2264 n).\n\nHelp them, so you can get a portion of the treasure! Write a program to efficiently handle both types of queries given the constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, assisting his long-lost relative Indiana Jones, to locate a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, established in a specific arrangement so that it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and to go from the x-th room to the y-th room, there must exist a tunnel between x and y, taking max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the minimum sum of energy needed to take the secret treasure at room v, under the condition that they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Write a program to efficiently handle both types of queries given the constraints.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at the given index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\nclass DFS:\n    \"\"\"Depth First Search to preprocess the tree for LCA queries.\"\"\"\n    \n    def __init__(self, n: int, tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [-1] * (n + 1)\n        self.build_tree(tunnels)\n    \n    def build_tree(self, tunnels: List[Tuple[int, int]]):\n        \"\"\"Builds the adjacency list from tunnels.\"\"\"\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.dfs(1, -1, 0)\n    \n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Performs DFS to set parent and depth.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n    \n    def lca(self, u: int, v: int) -> int:\n        \"\"\"Finds the Lowest Common Ancestor of u and v.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], dfs: DFS, segment_tree: SegmentTree) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    lca = dfs.lca(u, v)\n    path_energy = 0\n    current = u\n    while current != lca:\n        next_room = dfs.parent[current]\n        path_energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]),\n                           abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    current = v\n    while current != lca:\n        next_room = dfs.parent[current]\n        path_energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_room - 1]),\n                           abs(illusion_rates[current - 1] - illusion_rates[next_room - 1]))\n        current = next_room\n    return path_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    dfs = DFS(n, tunnels)\n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, dfs, segment_tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Performs Depth First Search to populate parent and depth lists.\"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_list, depth_list)\n\ndef preprocess_lca(n: int, tree: List[List[int]]) -> Tuple[List[int], List[int]]:\n    \"\"\"Preprocesses the tree to prepare for LCA queries.\"\"\"\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    dfs(1, -1, 0, tree, parent_list, depth_list)\n    return parent_list, depth_list\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth_list[u] < depth_list[v]:\n        u, v = v, u\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Calculates the energy cost between two nodes using their illusion rates.\"\"\"\n    ancestor = lca(u, v, parent_list, depth_list)\n    energy = 0\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent_list[u] - 1]),\n                      abs(illusion_rates[u - 1] - illusion_rates[parent_list[u] - 1]))\n        u = parent_list[u]\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v - 1] + illusion_rates[parent_list[v] - 1]),\n                      abs(illusion_rates[v - 1] - illusion_rates[parent_list[v] - 1]))\n        v = parent_list[v]\n    return energy\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    parent_list, depth_list = preprocess_lca(len(tree) - 1, tree)\n    return calculate_energy(u, v, illusion_rates, parent_list, depth_list)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Dict\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(start_room: int, end_room: int, illusion_rates: List[int], tree: Dict[int, List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from start_room to end_room.\"\"\"\n    def dfs(current_room: int, target_room: int, visited: set, current_energy: int) -> int:\n        if current_room == target_room:\n            return current_energy\n        \n        visited.add(current_room)\n        min_energy = float('inf')\n        \n        for neighbor in tree[current_room]:\n            if neighbor not in visited:\n                energy_cost = max(abs(illusion_rates[current_room - 1] + illusion_rates[neighbor - 1]),\n                                  abs(illusion_rates[current_room - 1] - illusion_rates[neighbor - 1]))\n                min_energy = min(min_energy, dfs(neighbor, target_room, visited, current_energy + energy_cost))\n        \n        visited.remove(current_room)\n        return min_energy\n    \n    return dfs(start_room, end_room, set(), 0)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = {i: [] for i in range(1, n + 1)}\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = calculate_min_energy(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef handle_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Handles queries to update illusion rates and calculate minimum energy required between rooms.\n\n    Args:\n        n (int): Number of rooms.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        tunnels (List[Tuple[int, int]]): List of tunnels connecting rooms.\n        queries (List[Tuple[int, int, int]]): List of queries to process.\n\n    Returns:\n        List[int]: Results for type 2 queries.\n    \"\"\"\n    # Initialize adjacency list for the tree\n    adjacency_list = [[] for _ in range(n + 1)]\n    for u, v in tunnels:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    # Function to perform DFS and calculate path energy\n    def dfs_energy(start: int, end: int) -> int:\n        visited = [False] * (n + 1)\n        stack = [(start, 0)]  # (current_room, current_energy)\n        while stack:\n            current_room, current_energy = stack.pop()\n            if current_room == end:\n                return current_energy\n            visited[current_room] = True\n            for neighbor in adjacency_list[current_room]:\n                if not visited[neighbor]:\n                    energy = max(abs(illusion_rates[current_room - 1] + illusion_rates[neighbor - 1]),\n                                 abs(illusion_rates[current_room - 1] - illusion_rates[neighbor - 1]))\n                    stack.append((neighbor, current_energy + energy))\n        return float('inf')  # Should not reach here if the tree is valid\n\n    results = []\n    for query in queries:\n        query_type, u, v = query\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u - 1] = v\n        elif query_type == 2:\n            # Calculate minimum energy from room u to room v\n            results.append(dfs_energy(u, v))\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = handle_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy_path(start_room: int, end_room: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy path from start_room to end_room.\"\"\"\n    if start_room == end_room:\n        return 0\n\n    # Build adjacency list for the tree\n    adjacency_list = [[] for _ in range(len(illusion_rates))]\n    for u, v in tunnels:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n\n    # Use DFS to find the path from start_room to end_room\n    def dfs(current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        if current == target:\n            return True\n        visited[current] = True\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                path.append(neighbor)\n                if dfs(neighbor, target, visited, path):\n                    return True\n                path.pop()\n        return False\n\n    visited = [False] * len(illusion_rates)\n    path = [start_room - 1]\n    dfs(start_room - 1, end_room - 1, visited, path)\n\n    # Calculate the energy cost for the path found\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i]]\n        a_y = illusion_rates[path[i + 1]]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    illusion_rates = list(map(int, data[2:n+2]))\n    tunnels = [tuple(map(int, data[i:i+2])) for i in range(n+2, n+2+(n-1)*2, 2)]\n    queries = [data[i:i+3] for i in range(n+2+(n-1)*2, len(data), 3)]\n\n    for query in queries:\n        if query[0] == '1':\n            update_illusion_rate(int(query[1]), int(query[2]), illusion_rates)\n        elif query[0] == '2':\n            result = calculate_min_energy_path(int(query[1]), int(query[2]), illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.subtree_size = [0] * (n + 1)\n        self.chain_head = [-1] * (n + 1)\n        self.chain_index = [-1] * (n + 1)\n        self.pos_in_base = [-1] * (n + 1)\n        self.base_array = []\n        self.segment_tree = []\n        self.chain_no = 0\n        self.ptr = 0\n\n    def dfs(self, current: int, parent: int):\n        self.parent[current] = parent\n        self.subtree_size[current] = 1\n        for neighbor in self.adj_list[current]:\n            if neighbor == parent:\n                continue\n            self.depth[neighbor] = self.depth[current] + 1\n            self.dfs(neighbor, current)\n            self.subtree_size[current] += self.subtree_size[neighbor]\n\n    def hld(self, current: int, parent: int):\n        if self.chain_head[self.chain_no] == -1:\n            self.chain_head[self.chain_no] = current\n        self.chain_index[current] = self.chain_no\n        self.pos_in_base[current] = self.ptr\n        self.base_array.append(self.illusion_rates[current - 1])\n        self.ptr += 1\n\n        special_child = -1\n        for neighbor in self.adj_list[current]:\n            if neighbor != parent:\n                if special_child == -1 or self.subtree_size[neighbor] > self.subtree_size[special_child]:\n                    special_child = neighbor\n\n        if special_child != -1:\n            self.hld(special_child, current)\n\n        for neighbor in self.adj_list[current]:\n            if neighbor != parent and neighbor != special_child:\n                self.chain_no += 1\n                self.hld(neighbor, current)\n\n    def build_segment_tree(self, start: int, end: int, node: int):\n        if start == end:\n            if start < len(self.base_array):\n                self.segment_tree[node] = self.base_array[start]\n            return\n        mid = (start + end) // 2\n        self.build_segment_tree(start, mid, 2 * node + 1)\n        self.build_segment_tree(mid + 1, end, 2 * node + 2)\n        self.segment_tree[node] = self.segment_tree[2 * node + 1] + self.segment_tree[2 * node + 2]\n\n    def update_segment_tree(self, start: int, end: int, node: int, idx: int, value: int):\n        if start == end:\n            self.segment_tree[node] = value\n            return\n        mid = (start + end) // 2\n        if idx <= mid:\n            self.update_segment_tree(start, mid, 2 * node + 1, idx, value)\n        else:\n            self.update_segment_tree(mid + 1, end, 2 * node + 2, idx, value)\n        self.segment_tree[node] = self.segment_tree[2 * node + 1] + self.segment_tree[2 * node + 2]\n\n    def query_segment_tree(self, start: int, end: int, node: int, L: int, R: int) -> int:\n        if start > R or end < L:\n            return 0\n        if start >= L and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_query = self.query_segment_tree(start, mid, 2 * node + 1, L, R)\n        right_query = self.query_segment_tree(mid + 1, end, 2 * node + 2, L, R)\n        return left_query + right_query\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        idx = self.pos_in_base[room]\n        self.update_segment_tree(0, self.ptr - 1, 0, idx, new_rate)\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        lca = self.find_lca(u, v)\n        return self.query_up(u, lca) + self.query_up(v, lca) - self.query_up(lca, lca)\n\n    def query_up(self, u: int, v: int) -> int:\n        if u == v:\n            return 0\n        uchain, vchain = self.chain_index[u], self.chain_index[v]\n        result = 0\n        while uchain != vchain:\n            uhead = self.chain_head[uchain]\n            result += self.query_segment_tree(0, self.ptr - 1, 0, self.pos_in_base[uhead], self.pos_in_base[u])\n            u = self.parent[uhead]\n            uchain = self.chain_index[u]\n        result += self.query_segment_tree(0, self.ptr - 1, 0, self.pos_in_base[v] + 1, self.pos_in_base[u])\n        return result\n\n    def find_lca(self, u: int, v: int) -> int:\n        while self.chain_index[u] != self.chain_index[v]:\n            if self.depth[self.chain_head[self.chain_index[u]]] < self.depth[self.chain_head[self.chain_index[v]]]:\n                v = self.parent[self.chain_head[self.chain_index[v]]]\n            else:\n                u = self.parent[self.chain_head[self.chain_index[u]]]\n        return u if self.depth[u] < self.depth[v] else v\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    tree.update_illusion_rate(room, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    return tree.calculate_min_energy(u, v)\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [input().split() for _ in range(q)]\n\n# Initialize the tree\ntree = Tree(n, illusion_rates, tunnels)\ntree.dfs(1, -1)\ntree.hld(1, -1)\ntree.segment_tree = [0] * (4 * n)\ntree.build_segment_tree(0, tree.ptr - 1, 0)\n\n# Output interface\nfor query in queries:\n    if query[0] == '1':\n        u, c = int(query[1]), int(query[2])\n        update_illusion_rate(u, c, illusion_rates)\n    elif query[0] == '2':\n        u, v = int(query[1]), int(query[2])\n        result = calculate_min_energy(u, v, illusion_rates, tunnels)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass MazeSolver:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        self.build_segment_tree(1, 1, n)\n        self.dfs(1, 0)\n\n    def dfs(self, node: int, parent: int):\n        self.parent[node] = parent\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self.depth[neighbor] = self.depth[node] + 1\n                self.dfs(neighbor, node)\n\n    def build_segment_tree(self, index: int, start: int, end: int):\n        if start == end:\n            self.segment_tree[index] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self.build_segment_tree(2 * index, start, mid)\n            self.build_segment_tree(2 * index + 1, mid + 1, end)\n            self.segment_tree[index] = self.segment_tree[2 * index] + self.segment_tree[2 * index + 1]\n\n    def update_segment_tree(self, index: int, start: int, end: int, pos: int, value: int):\n        if start == end:\n            self.segment_tree[index] = value\n        else:\n            mid = (start + end) // 2\n            if start <= pos <= mid:\n                self.update_segment_tree(2 * index, start, mid, pos, value)\n            else:\n                self.update_segment_tree(2 * index + 1, mid + 1, end, pos, value)\n            self.segment_tree[index] = self.segment_tree[2 * index] + self.segment_tree[2 * index + 1]\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room - 1] = new_rate\n        self.update_segment_tree(1, 1, self.n, room, new_rate)\n\n    def query_minimum_energy(self, u: int, v: int) -> int:\n        lca = self.find_lca(u, v)\n        energy = self.calculate_energy(u, lca) + self.calculate_energy(v, lca)\n        return energy\n\n    def find_lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def calculate_energy(self, u: int, ancestor: int) -> int:\n        energy = 0\n        while u != ancestor:\n            parent = self.parent[u]\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[parent - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[parent - 1]))\n            u = parent\n        return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    solver = MazeSolver(n, illusion_rates, tree)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            solver.update_illusion_rate(query[1], query[2])\n        elif query[0] == 2:\n            result = solver.query_minimum_energy(query[1], query[2])\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Perform Depth First Search to preprocess the tree.\"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of two nodes.\"\"\"\n    if depth_list[u] < depth_list[v]:\n        u, v = v, u\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Calculate the energy required to move from room u to room v.\"\"\"\n    ancestor = lca(u, v, parent_list, depth_list)\n    energy = 0\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent_list[u] - 1]),\n                      abs(illusion_rates[u - 1] - illusion_rates[parent_list[u] - 1]))\n        u = parent_list[u]\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v - 1] + illusion_rates[parent_list[v] - 1]),\n                      abs(illusion_rates[v - 1] - illusion_rates[parent_list[v] - 1]))\n        v = parent_list[v]\n    return energy\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    n = len(tree) - 1\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    dfs(1, -1, 0, tree, parent_list, depth_list)\n    return calculate_energy(u, v, illusion_rates, parent_list, depth_list)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    queries = [input().split() for _ in range(q)]\n\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room_index - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree_structure: Dict[int, List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    # Perform DFS to find the path from u to v\n    def dfs(current: int, target: int, visited: set, path: List[int]) -> List[int]:\n        if current == target:\n            return path\n        visited.add(current)\n        for neighbor in tree_structure[current]:\n            if neighbor not in visited:\n                result = dfs(neighbor, target, visited, path + [neighbor])\n                if result:\n                    return result\n        return []\n\n    path = dfs(u, v, set(), [u])\n    \n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n    \n    return total_energy\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree_structure = {}\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        if s not in tree_structure:\n            tree_structure[s] = []\n        if t not in tree_structure:\n            tree_structure[t] = []\n        tree_structure[s].append(t)\n        tree_structure[t].append(s)\n\n    queries = [input().strip() for _ in range(q)]\n\n    # Output interface\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            u, c = int(parts[1]), int(parts[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif parts[0] == '2':\n            u, v = int(parts[1]), int(parts[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree_structure)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to efficiently update and query illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]):\n    \"\"\"Performs DFS to calculate depth and parent information.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_list)\n    ancestor = lca(u, v, depth, parent_list)\n    \n    energy = 0\n    current = u\n    while current != ancestor:\n        next_node = parent_list[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_node - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[next_node - 1]))\n        current = next_node\n    \n    current = v\n    while current != ancestor:\n        next_node = parent_list[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_node - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[next_node - 1]))\n        current = next_node\n    \n    return energy\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            u, c = query[1], query[2]\n            update_illusion_rate(u, c, illusion_rates)\n            segment_tree.update(u - 1, c)\n        elif query[0] == 2:\n            u, v = query[1], query[2]\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating energy costs in a maze structured as a tree. The solution must be scalable to handle up to 100,000 rooms and queries, ensuring quick and accurate responses.\nrequirement pool:\n- Efficient query handling for illusion rate changes\n- Accurate energy calculation between rooms\n- User-friendly input and output interface\n- Scalability to handle large number of rooms and queries\n- Optimization for resource usage\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure of the maze, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures that both types of queries are handled in logarithmic time complexity, making it scalable for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this context, it means that the rooms and tunnels form a structure where there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated as max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum and the absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy needed to travel from room u to room v. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Use Depth First Search (DFS) to preprocess the tree for efficient Lowest Common Ancestor (LCA) queries, which will help in finding paths between any two rooms.\n4. Implement a Segment Tree or Binary Indexed Tree to handle updates to illusion rates efficiently.\n5. For type 1 queries, update the illusion rate of the specified room using the Segment Tree.\n6. For type 2 queries, use LCA to find the path from room u to room v and calculate the minimum energy required using preprocessed data and current illusion rates.\n\n# [edge case]\n    1 1 -3\n    Explanation: This query changes the illusion rate of room 1 to -3. The expected output is not directly related to this query but affects subsequent type 2 queries.\n\n    2 1 1 = 0\n    Explanation: When querying from a room to itself, no energy is required, so the expected output is 0.\n\n    2 1 6 = 24\n    Explanation: After changing the illusion rate of room 1 to -3, calculate the energy from room 1 to room 6 using updated rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree should handle updates and queries efficiently, including self-queries and path recalculations after updates.\n", "requirement analysis:\nThe main challenge is to efficiently handle both types of queries given the constraints of up to 100,000 rooms and queries. The solution must ensure quick updates to the illusion rates and accurate energy calculations for paths in the tree structure.\nrequirement pool:\n- Efficiently process type 1 queries to update illusion rates.\n- Accurately calculate the minimum energy for type 2 queries.\n- Optimize data structures to handle large input sizes.\n- Ensure the solution is scalable and performs well under maximum constraints.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. For type 1 queries, we will update the illusion rate in constant time. For type 2 queries, we will use LCA to find the path between two nodes and calculate the energy cost efficiently. We will use adjacency lists to represent the tree and segment trees to manage updates and queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. This structure is crucial for efficiently finding paths and handling queries.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms. It can be updated and queried.\n\n    'energy'\n    Explanation: Energy is calculated as max(|a_x + a_y|, |a_x - a_y|) when moving between rooms x and y. This is the cost of traveling through a tunnel.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the path with the least energy cost from room u to room v. This can be implemented by calculating energy costs for all possible paths and selecting the smallest one.\n\n# [code logic]\n    - Use adjacency lists to represent the tree structure.\n    - Implement DFS to traverse the tree and preprocess data for LCA.\n    - Use LCA to efficiently find paths between nodes for type 2 queries.\n    - Implement segment trees or similar data structures to handle updates and queries efficiently.\n    - For type 1 queries, update the illusion rate in constant time.\n    - For type 2 queries, calculate the energy cost using preprocessed LCA data.\n\n# [edge case]\n    1 1 -3\n    Explanation: This query changes the illusion rate of room 1 to -3. The expected output is not applicable as it's an update query.\n    \n    2 1 1 = 0\n    Explanation: When querying from a room to itself, no energy is needed, so the expected output is 0.\n    \n    2 n n = 0\n    Explanation: Similar to querying from a room to itself, querying from the last room to itself also requires no energy, so the expected output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic handles them by ensuring that querying from a room to itself results in zero energy cost.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries on a tree structure representing a maze. The key challenge is to ensure that both types of queries (updating illusion rates and calculating minimum energy) are processed quickly, even for the upper limit of input sizes. The solution must maintain accuracy in energy calculations and allow for dynamic updates to the maze's properties.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Accurately calculate the minimum energy required for type 2 queries.\n- Optimize data structures to handle up to 100,000 rooms and queries.\n- Ensure the solution is scalable and performs well under maximum constraints.\n- Provide clear and concise output for each query.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy required for type 2 queries efficiently. For type 1 queries, we will update the illusion rate directly in the list. We will utilize adjacency lists to represent the tree structure and handle queries using efficient traversal techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this context, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: Energy is calculated as max(|a_x + a_y|, |a_x - a_y|) when moving between two rooms x and y.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the max function and abs function.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the path with the least energy cost from room u to room v. This can be implemented using algorithms that find the shortest path, such as DFS or Dijkstra's algorithm.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Implement DFS to preprocess the tree and calculate paths for type 2 queries.\n    3. For type 1 queries, update the illusion rate directly in the list.\n    4. For type 2 queries, use the preprocessed data to efficiently calculate the minimum energy required.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires 0 energy.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 20\n    Explanation: The path from room 1 to room 3 goes through room 2, requiring max(|10 + (-10)|, |10 - (-10)|) = 20 energy.\n\n    Input: 4 1\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 15\n    Explanation: The path from room 1 to room 4 goes through rooms 2 and 3, requiring max(|-5 + (-5)|, |-5 - (-5)|) = 10 energy for each segment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and adjacency lists will handle these cases correctly.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating energy requirements between rooms. The solution must be robust enough to handle large input sizes and ensure quick response times for user queries.\nrequirement pool:\n- Efficient query handling for changing illusion rates\n- Accurate calculation of energy requirements between rooms\n- Scalability to handle large numbers of rooms and queries\n- Robustness to ensure the program handles edge cases\n- User-friendly interface for input and output\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy required between rooms efficiently. We will utilize adjacency lists to represent the tree structure and handle updates to illusion rates using a simple list update. For path queries, we will use a DFS-based approach to find the path and calculate the energy required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: Energy is calculated as max(|a_x + a_y|, |a_x - a_y|) when moving from room x to room y.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to reach the target room from the starting room. This involves finding the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Implement DFS to preprocess the tree and calculate paths.\n    3. For type 1 queries, update the illusion rate of the specified room.\n    4. For type 2 queries, use DFS to find the path from room u to room v and calculate the total energy using the given formula.\n    5. Output the result for each type 2 query.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: Direct path from room 1 to room 2 with energy max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: All rooms have zero illusion rate, so energy is zero regardless of path.\n\n    Case 3: Large illusion rates\n    Input:\n    ```\n    3 1\n    1000000000 -1000000000 1000000000\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    3000000000\n    ```\n    Explanation: Path from room 1 to room 3 via room 2 with large illusion rates results in high energy cost.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and adjacency lists will handle these cases correctly.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries on a tree structure representing a maze. The main challenge is to ensure that both types of queries (updating illusion rates and calculating minimum energy paths) are processed quickly, even for the upper limit of input sizes. The solution must be optimized for performance and scalability.\nrequirement pool:\n- Efficiently handle type 1 queries to update illusion rates.\n- Efficiently handle type 2 queries to calculate minimum energy paths.\n- Optimize data structures for fast query processing.\n- Ensure the solution is scalable to handle maximum input sizes.\n- Provide clear and concise output for each query.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy path using a combination of tree traversal and dynamic programming. This approach will efficiently handle both types of queries by maintaining an updated illusion rate and calculating the minimum energy path using precomputed values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost of moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated as max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to reach the target room from the starting room. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse input to construct the tree and store initial illusion rates.\n2. Use DFS to preprocess the tree and calculate necessary data for efficient query handling.\n3. For type 1 queries, update the illusion rate of the specified room.\n4. For type 2 queries, calculate the minimum energy path from room u to room v using precomputed data and dynamic programming techniques.\n\n# [edge case] \n    1. Query with u = v (e.g., 2 1 1) = 0\n    Explanation: If the starting and target rooms are the same, no movement is needed, so the energy cost is 0.\n    \n    2. All rooms have zero illusion rate (e.g., n = 3, a = [0, 0, 0], query = 2 1 3) = 0\n    Explanation: If all rooms have an illusion rate of zero, any path will have zero energy cost since max(|0 + 0|, |0 - 0|) = 0.\n\n    3. Maximum possible illusion rate change (e.g., n = 2, initial a = [10^9, -10^9], query = 1 1 -10^9 followed by 2 1 2) = 20^9\n    Explanation: The maximum change in illusion rate can lead to a maximum energy cost calculation.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where u = v.\n        if u == v:\n            return 0\n        (other code for handling queries)\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree-structured maze with dynamic updates to room properties and calculating path energies. The main challenge is to ensure that the solution can handle up to 100,000 rooms and queries efficiently, which suggests the need for advanced data structures and algorithms like segment trees or heavy-light decomposition.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy paths.\n- Ensure the solution handles edge cases and invalid inputs gracefully.\n- Optimize for performance to handle the maximum constraints.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Heavy-Light Decomposition (HLD) to efficiently handle the queries. DFS will help in traversing the tree structure, while HLD will allow us to decompose the tree into segments that can be managed using segment trees for fast updates and queries. This approach is suitable for handling large input sizes and dynamic updates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected acyclic graph. This allows traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one to update the illusion rate of a room and another to calculate the minimum energy required to move from one room to another.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves finding the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to move from the starting room to the target room. This involves calculating the path with the least energy consumption.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Implement DFS to traverse the tree and prepare for Heavy-Light Decomposition (HLD).\n    3. Use HLD to decompose the tree into manageable segments.\n    4. Implement segment trees to handle updates and queries efficiently.\n    5. For type 1 queries, update the illusion rate in the segment tree.\n    6. For type 2 queries, calculate the minimum energy using the segment tree and HLD path queries.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: With both rooms having an illusion rate of 0, moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Output: 2000000000\n    Explanation: The initial energy calculation involves large values due to high illusion rates, testing integer handling.\n\n    Input: 4 3\n           -1 -1 -1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 4 -10\n           2 1 4\n    Output: 6\n            Explanation: The initial query tests uniform negative values, while the update tests handling changes in illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, HLD, and segment trees will efficiently manage updates and queries, including edge cases involving large values or uniform rates.\n", "requirement analysis:\nThe main challenge is to efficiently handle both types of queries given the constraints of up to 100,000 rooms and queries. The solution must ensure quick updates to the illusion rates and fast computation of the minimum energy required for any given path. The tree structure of the maze allows for efficient traversal algorithms, which should be leveraged to optimize query responses.\nrequirement pool:\n- Efficiently handle up to 100,000 queries and rooms.\n- Accurately calculate the minimum energy required for any path.\n- Provide real-time updates to illusion rates.\n- Ensure the system is responsive and user-friendly.\n- Support visualization of the maze and paths.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to quickly find the minimum energy path between any two rooms. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze structure where each room is a node and each tunnel is an edge.\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented as `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb] \n    'minimum': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest one.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given tunnels.\n3. Preprocess the tree using DFS to prepare for LCA queries.\n4. Implement a Segment Tree to handle updates to illusion rates efficiently.\n5. For type 1 queries, update the illusion rate of the specified room.\n6. For type 2 queries, use LCA to find the path from room u to room v and calculate the minimum energy required using the preprocessed data and current illusion rates.\n\n# [edge case] \n    Edge Case 1: n = 2, q = 1, initial rates = [0, 0], query = \"2 1 2\"\n    Expected Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Edge Case 2: n = 3, q = 1, initial rates = [10^9, -10^9, 0], query = \"2 1 3\"\n    Expected Output: 10^9\n    Explanation: The path from room 1 to room 3 involves moving through room 2. The energy calculation will be dominated by the large absolute values.\n\n    Edge Case 3: n = 4, q = 2, initial rates = [1, -1, 1, -1], queries = [\"1 1 10^9\", \"2 1 4\"]\n    Expected Output: A large value due to the update in illusion rate making one of the paths have high energy.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently using a Segment Tree or similar data structure to ensure that changes in illusion rates are reflected in subsequent queries without recalculating from scratch. This involves implementing update and query operations on the Segment Tree.\n", "requirement analysis:\nThe main challenge is to efficiently handle both types of queries given the constraints of up to 100,000 rooms and queries. The solution must be optimized for both time and space complexity, ensuring that updates to the illusion rates are processed quickly and that the minimum energy path is calculated efficiently. The tree structure of the maze should be leveraged to optimize pathfinding.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy paths.\n- Optimize data structures for fast access and updates.\n- Ensure the solution handles edge cases and large inputs robustly.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary information for each node, and LCA will be used to find the minimum energy path between two nodes. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one to update the illusion rate of a room and another to calculate the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the energy calculation formula for moving between two rooms. It requires finding the maximum of the absolute values of the sum and difference of the illusion rates of two rooms.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to move from one room to another.\n\n# [code logic]\n    1. Parse the input to construct the tree structure using adjacency lists.\n    2. Preprocess the tree using DFS to calculate necessary information for each node, such as depth and parent.\n    3. Implement LCA to efficiently find the path between two nodes.\n    4. Use a Segment Tree to handle updates to the illusion rates efficiently.\n    5. For type 2 queries, calculate the energy required using the preprocessed information and LCA.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: Direct calculation using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All rooms have zero illusion rate\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: All calculations result in zero energy since all illusion rates are zero.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate, max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle these scenarios.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 queries and rooms, ensuring quick updates to illusion rates and accurate calculations of energy requirements. The solution should be robust enough to handle large input sizes and provide reliable outputs for type 2 queries.\nrequirement pool:\n- Efficient query handling for up to 100,000 queries\n- Accurate calculation of energy requirements between rooms\n- Quick updates to room illusion rates\n- Robust handling of large input sizes\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to find paths between rooms, while the Segment Tree will allow us to update and query the illusion rates quickly. This approach ensures that both types of queries are handled in logarithmic time complexity, making it suitable for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing traversal between any pair of rooms. This implies a connected acyclic graph.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented by calculating the total energy for all possible paths and selecting the smallest one.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to traverse the tree and calculate paths between rooms.\n    4. Use a Segment Tree to efficiently update and query illusion rates.\n    5. For type 1 queries, update the illusion rate of a specified room.\n    6. For type 2 queries, calculate the minimum energy required to travel from one room to another using DFS and Segment Tree.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: 10\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: 0\n    Explanation: Since all illusion rates are zero, the energy required for any path is zero.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output: Calculation based on updated rates.\n    Explanation: After changing the illusion rate of room 1, recalculate energy for path from room 1 to room 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle these scenarios by recalculating paths and updating rates as needed.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating energy requirements in a maze structured as a tree. The solution must be robust enough to handle large input sizes and ensure quick response times for user queries.\nrequirement pool:\n- Efficient query handling for changing illusion rates\n- Accurate calculation of energy requirements\n- Robust handling of large input sizes\n- Quick response times for user queries\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to find the minimum energy path between two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes.\n    'illusion rate': This is a value associated with each room that affects the energy calculation when moving between rooms.\n    'queries': There are two types of queries: updating the illusion rate of a room and calculating the minimum energy needed to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'minimum': In the context of the second type of query, it refers to finding the least amount of energy required to move from one room to another. This can be implemented using algorithms that find the shortest path, such as Dijkstra's algorithm or BFS in unweighted graphs.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Preprocess the tree using DFS to calculate necessary paths and prepare for LCA queries.\n    3. Implement a Segment Tree to efficiently update illusion rates.\n    4. For type 1 queries, update the illusion rate in the Segment Tree.\n    5. For type 2 queries, use LCA to find the path between two rooms and calculate the minimum energy using preprocessed data.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Output: 20\n    Explanation: The path is 1 \u2192 2 \u2192 3, with energies max(|10 + (-10)|, |10 - (-10)|) = 20 and max(|-10 + 10|, |-10 - 10|) = 20.\n\n    Input: 4 1\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Output: 0\n    Explanation: All rooms have the same illusion rate, so moving between them requires no energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and LCA will naturally handle these scenarios correctly.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 951, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "expand_one2two", "parent_index": 568}
