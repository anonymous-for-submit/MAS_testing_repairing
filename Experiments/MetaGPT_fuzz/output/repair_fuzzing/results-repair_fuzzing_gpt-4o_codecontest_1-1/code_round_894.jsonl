{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure the solution efficiently handles large values of n and k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure the solution efficiently handles large values of n and k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. This means that you can express the number using powers of n only, with each power being used at most once in the sum. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure the solution efficiently handles large values of n and k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n, which is exemplified by the number 17 being special for n = 4 as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure the solution efficiently handles large values of n and k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k //= 2\n        results.append(special_number)\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Call the function and print results\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 0\n        while k > 0:\n            if k & 1:  # Check if the least significant bit is 1\n                special_number = (special_number + pow(n, power, MOD)) % MOD\n            k >>= 1  # Right shift k to process the next bit\n            power += 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            k //= n\n            power = (power * n) % MOD\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        base_n_representation = k - 1\n        power = 1\n        \n        while base_n_representation > 0:\n            if base_n_representation % n != 0:\n                special_number = (special_number + power) % MOD\n            base_n_representation //= n\n            power = (power * n) % MOD\n        \n        # Add the contribution of the least significant bit (2^0)\n        special_number = (special_number + 1) % MOD\n        results.append(special_number)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport itertools\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing n and k for each test case.\n\n    Returns:\n        List[int]: List of k-th special numbers modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Generate powers of n\n        powers = [n**i for i in range(32)]  # Assuming 32-bit integer for practical purposes\n        \n        # Generate all combinations of these powers\n        special_numbers = set()\n        for r in range(1, len(powers) + 1):\n            for combo in itertools.combinations(powers, r):\n                special_numbers.add(sum(combo))\n        \n        # Sort the special numbers\n        sorted_special_numbers = sorted(special_numbers)\n        \n        # Retrieve the k-th special number modulo MOD\n        results.append(sorted_special_numbers[k-1] % MOD)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Call the function and print results\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            k //= n\n            power = (power * n) % MOD\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers where each integer is the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of n. The k-th special number\n    is the k-th number in the sequence of special numbers when sorted in\n    increasing order.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    MODULO = 10**9 + 7\n    results = []\n\n    for n, k in test_cases:\n        # Convert k-1 to binary to determine which powers of n to sum\n        binary_representation = bin(k - 1)[2:]  # Get binary representation of k-1\n        special_number = 0\n        power = 1  # Start with n^0\n\n        # Iterate over each bit in the binary representation\n        for bit in reversed(binary_representation):\n            if bit == '1':\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO  # Move to the next power of n\n\n        results.append(special_number)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    num_test_cases = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(num_test_cases)]\n\n    # Output interface\n    results = find_kth_special_number(num_test_cases, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        result = compute_kth_special_number(n, k)\n        results.append(result)\n    return results\n\ndef compute_kth_special_number(n: int, k: int) -> int:\n    \"\"\"Compute the k-th special number for a given n.\n\n    Args:\n        n: The base number for powers.\n        k: The index of the special number to find.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    special_number = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            special_number = (special_number + power) % MODULO\n        power = (power * n) % MODULO\n        k //= 2\n    return special_number\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, and output the result modulo 10^9+7. The challenge lies in efficiently computing the k-th number without generating all previous numbers.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for edge cases\nWe will use a binary representation approach to efficiently compute the k-th special number. The idea is to treat the number k as a binary number and interpret each bit as a power of n. This allows us to directly compute the k-th special number without generating all previous numbers. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure efficiency and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its binary representation.\n    3. Interpret each bit in the binary representation as a power of n.\n    4. Compute the sum of these powers to find the k-th special number.\n    5. Return the result modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: (large number modulo 10^9+7)\n    Explanation: This tests the efficiency and correctness of handling large values for k.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles all cases by using binary representation and modular arithmetic.\n", "requirement analysis:\nThe task requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be computed modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficiently compute the k-th special number for large n and k.\n- Ensure the solution handles up to 10,000 test cases.\n- Implement modulo operation to manage large outputs.\n- Optimize the algorithm for speed and accuracy.\n- Provide clear and concise output format.\nWe will use a binary representation approach to solve this problem. The k-th special number can be derived by interpreting k as a binary number and using the positions of the '1's in the binary representation to determine which powers of n to sum. This approach is efficient because it directly maps the binary representation of k to the sum of distinct powers of n, ensuring that we can handle large values of n and k efficiently. We will use Python's built-in capabilities for handling large integers and perform modulo operations to manage large outputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0, 1, 2, ...).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its binary representation.\n    3. Initialize a variable to store the special number.\n    4. Iterate over each bit in the binary representation of k:\n        - If the bit is '1', add n raised to the power of the bit's position to the special number.\n    5. Perform modulo operation with 10^9+7 on the resulting special number.\n    6. Output the result for each test case.\n\n# [edge case]\n    For n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    For n = 10^9, k = 1\n    Expected output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    For n = 2, k = 10^9\n    Expected output: A large number modulo 10^9+7\n    Explanation: This tests the efficiency and correctness of handling large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles large values of n and k using binary representation and modulo operations.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle large values efficiently and return results modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handling large values of n and k\n- Accurate modulo operation\n- Responsive input handling\n- User-friendly output format\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and perform modulo operations to ensure results fit within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that a special number is formed by adding distinct powers of n, such as n^0, n^1, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order': This indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Convert k to its base-n representation. This representation will help determine which powers of n are included in the k-th special number.\n3. Calculate the k-th special number by summing the powers of n indicated by the base-n representation of k.\n4. Apply modulo 10^9+7 to the result to ensure it fits within the required constraints.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1, which is n^0.\n\n    Test case: (n=10^9, k=1) = 1\n    Explanation: Even for very large n, the first special number is still 1.\n\n    Test case: (n=2, k=10^9) = <calculated value>\n    Explanation: This tests the upper limit of k and ensures that the solution handles large values efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its base-n representation inherently handles these cases by correctly identifying which powers of n are included in the k-th special number.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must efficiently handle large values of n and k, and output the result modulo 10^9+7. The challenge lies in efficiently computing the sequence of special numbers and ensuring the solution is scalable for large inputs.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Optimize for performance\n- Ensure accuracy of results\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k well. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure performance and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n, with each power being used at most once.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that each special number is formed by adding distinct powers of n, such as n^0, n^1, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order': This indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k-1 to its base-n representation. This is because the sequence is zero-indexed in terms of powers.\n3. Interpret this base-n representation as a sum of powers of n to get the k-th special number.\n4. Compute the result modulo 10^9+7 to handle large numbers.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case 1: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Test case 2: (n=2, k=2) = 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Test case 3: (n=10^9, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k-1 to base-n and interpreting it as a sum of powers naturally handles these cases.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must efficiently handle large values of n and k, and output the result modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handling large values of n and k\n- Output formatting and correctness\n- Modular arithmetic for large numbers\n- User-friendly input/output handling\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities for handling large integers and modular arithmetic to efficiently compute the k-th special number. The itertools library will be used to generate combinations of powers of n.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n, with each power used at most once.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is used only once. In code, this can be implemented by iterating over combinations of powers of n and summing them.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that the k-th special number is the k-th smallest number in this sorted sequence.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the values of n and k for each test case.\n2. For each test case, generate special numbers using combinations of powers of n.\n3. Sort these numbers in increasing order.\n4. Retrieve the k-th special number from the sorted list.\n5. Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: (large number modulo 10^9+7)\n    Explanation: This tests the efficiency and correctness of handling large values for k.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large values of n and k.\n    - Use efficient algorithms to generate combinations and handle large integers.\n    - Implement modular arithmetic to ensure results fit within constraints.\n\n```python\nimport itertools\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    # Generate powers of n\n    powers = [n**i for i in range(32)]  # Assuming 32-bit integer for practical purposes\n    \n    # Generate all combinations of these powers\n    special_numbers = set()\n    for r in range(1, len(powers) + 1):\n        for combo in itertools.combinations(powers, r):\n            special_numbers.add(sum(combo))\n    \n    # Sort the special numbers\n    sorted_special_numbers = sorted(special_numbers)\n    \n    # Return the k-th special number modulo MOD\n    return sorted_special_numbers[k-1] % MOD\n\n# Example usage:\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(find_kth_special_number(n, k))\n```\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently and return results modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handling large values of n and k\n- Accurate modulo operation\n- Responsive input handling\n- User-friendly output format\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach efficiently handles large values of n and k. We will use Python's built-in capabilities for handling large integers and perform modulo operations to ensure results fit within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n, with each power being used at most once.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that each special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc., without repeating any power in the sum.\n\n# [degree adverb]\n    'increasing order': This indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Convert k to its base-n representation. This representation will guide which powers of n to sum to form the k-th special number.\n3. Calculate the k-th special number by summing the powers of n indicated by the base-n representation.\n4. Apply modulo 10^9+7 to the result to ensure it fits within the required constraints.\n5. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1 = 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 2: n = 10^9, k = 1 = 1\n    Explanation: Even for very large n, the first special number is still 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Explanation: This tests the efficiency of handling large k values. The expected output would be a large number modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its base-n representation and summing the corresponding powers of n inherently handles all edge cases, including very large values of n and k.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, and the result should be given modulo 10^9+7. The challenge lies in efficiently generating and sorting these special numbers to find the k-th one.\nrequirement pool:\n- Efficient algorithm to compute k-th special number.\n- Handle large input values for n and k.\n- Output results modulo 10^9+7.\n- Support multiple test cases.\n- Optimize for time and space complexity.\nWe will use a mathematical approach to generate special numbers by considering the binary representation of k. Each bit in the binary representation corresponds to a power of n, which allows us to efficiently compute the k-th special number. We will use Python's built-in capabilities to handle large integers and apply modulo operation to ensure results are within the required range.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, 17 is special for n = 4 because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    - Convert k to its binary representation.\n    - Each bit in the binary representation corresponds to a power of n.\n    - Calculate the sum of n raised to the power of each bit position where the bit is set (i.e., equals 1).\n    - Apply modulo operation with 10^9+7 to ensure the result is within the required range.\n    - Repeat the above steps for each test case.\n\n# [edge case]\n    For n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n = 2 is simply 2^0 = 1.\n\n    For n = 10^9, k = 1\n    Expected output: 1\n    Explanation: Even for large n, the first special number is always n^0 = 1.\n\n    For n = 2, k = 10^9\n    Expected output: A large number modulo 10^9+7\n    Explanation: This tests the efficiency and correctness of handling large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modulo operation efficiently handles all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n efficiently, ensuring the solution can handle large values of n and k. The output must be modulo 10^9+7 to manage large numbers. The solution should be optimized for performance across multiple test cases.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Optimize performance for multiple test cases\n- Ensure accurate sorting of special numbers\nWe will use a mathematical approach to compute the k-th special number efficiently. The key is to represent the number as a sum of distinct powers of n. We will leverage the properties of binary representation to determine which powers of n to include in the sum. Python's built-in capabilities for handling large integers and modular arithmetic will be utilized to ensure performance and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, 17 is special for n = 4 because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that the number is formed by adding distinct powers of n, such as n^0, n^1, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order': This indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use a loop to determine which powers of n to include in the sum to form the k-th special number.\n3. Convert k to its binary representation. Each bit in the binary representation indicates whether a corresponding power of n should be included in the sum.\n4. Calculate the sum of these powers of n.\n5. Since the result can be large, take the result modulo 10^9+7.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1, which is n^0.\n\n    Test case: (n=10^9, k=1) = 1\n    Explanation: Even for large n, the first special number is always 1.\n\n    Test case: (n=2, k=10^9) = (result modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the solution handles large values efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of using binary representation inherently handles all cases, including edge cases, by determining which powers of n to include in the sum.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases with n and k as large as 10^9, and output results modulo 10^9+7. The challenge lies in efficiently computing these numbers without generating the entire sequence.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Optimize for time complexity\n- Optimize for space complexity\nWe will use a mathematical approach to compute the k-th special number directly using binary representation of k. Each bit in the binary representation of k corresponds to a power of n, which allows us to efficiently compute the special number without generating the entire sequence. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure efficiency and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, 17 is special for n = 4 because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k-1 to its binary representation. This is because the binary representation will help us determine which powers of n to sum.\n3. Initialize a variable to store the special number.\n4. Iterate over each bit in the binary representation of k-1:\n   - If the bit is set (i.e., it is 1), add the corresponding power of n to the special number.\n5. Take the result modulo 10^9+7 to handle large numbers.\n6. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: Even for very large n, the first special number is always 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the efficiency and correctness of handling large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modular arithmetic inherently handles these cases efficiently.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must efficiently handle large values of n and k, and output the result modulo 10^9+7. The challenge lies in efficiently computing the sequence and ensuring the solution is scalable for large inputs.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Ensure solution scalability\n- Provide clear input/output format\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities to handle large integers and efficiently compute powers. The solution will iterate over possible combinations of powers of n to find the k-th special number, ensuring results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use the binary representation of numbers to determine which powers of n to include in the sum to form special numbers.\n3. Iterate through numbers, converting each to its binary form, and use the binary digits to decide which powers of n to sum.\n4. Keep track of the count of special numbers generated.\n5. Once the k-th special number is found, compute it modulo 10^9+7 and store the result.\n6. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: Computation should be efficient enough to handle large k without timeouts.\n    Explanation: The algorithm should efficiently compute large indices without iterating through all possible numbers.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modular arithmetic efficiently handles large values of n and k.\n"], "scores": [], "pass_results": [false, false, false, true, true, true, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 894, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "add_1_sentence_at_end", "parent_index": 539}
